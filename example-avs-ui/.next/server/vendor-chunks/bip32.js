"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bip32";
exports.ids = ["vendor-chunks/bip32"];
exports.modules = {

/***/ "(ssr)/./node_modules/bip32/src/bip32.js":
/*!*****************************************!*\
  !*** ./node_modules/bip32/src/bip32.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst crypto = __webpack_require__(/*! ./crypto */ \"(ssr)/./node_modules/bip32/src/crypto.js\");\nconst bs58check = __webpack_require__(/*! bs58check */ \"(ssr)/./node_modules/bs58check/index.js\");\nconst ecc = __webpack_require__(/*! tiny-secp256k1 */ \"(ssr)/./node_modules/tiny-secp256k1/index.js\");\nconst typeforce = __webpack_require__(/*! typeforce */ \"(ssr)/./node_modules/typeforce/index.js\");\nconst wif = __webpack_require__(/*! wif */ \"(ssr)/./node_modules/wif/index.js\");\nconst UINT256_TYPE = typeforce.BufferN(32);\nconst NETWORK_TYPE = typeforce.compile({\n    wif: typeforce.UInt8,\n    bip32: {\n        public: typeforce.UInt32,\n        private: typeforce.UInt32,\n    },\n});\nconst BITCOIN = {\n    messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n    bech32: 'bc',\n    bip32: {\n        public: 0x0488b21e,\n        private: 0x0488ade4,\n    },\n    pubKeyHash: 0x00,\n    scriptHash: 0x05,\n    wif: 0x80,\n};\nconst HIGHEST_BIT = 0x80000000;\nconst UINT31_MAX = Math.pow(2, 31) - 1;\nfunction BIP32Path(value) {\n    return (typeforce.String(value) && value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/) !== null);\n}\nfunction UInt31(value) {\n    return typeforce.UInt32(value) && value <= UINT31_MAX;\n}\nclass BIP32 {\n    constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0x00000000) {\n        this.__D = __D;\n        this.__Q = __Q;\n        this.chainCode = chainCode;\n        this.network = network;\n        this.__DEPTH = __DEPTH;\n        this.__INDEX = __INDEX;\n        this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;\n        typeforce(NETWORK_TYPE, network);\n        this.lowR = false;\n    }\n    get depth() {\n        return this.__DEPTH;\n    }\n    get index() {\n        return this.__INDEX;\n    }\n    get parentFingerprint() {\n        return this.__PARENT_FINGERPRINT;\n    }\n    get publicKey() {\n        if (this.__Q === undefined)\n            this.__Q = ecc.pointFromScalar(this.__D, true);\n        return this.__Q;\n    }\n    get privateKey() {\n        return this.__D;\n    }\n    get identifier() {\n        return crypto.hash160(this.publicKey);\n    }\n    get fingerprint() {\n        return this.identifier.slice(0, 4);\n    }\n    get compressed() {\n        return true;\n    }\n    // Private === not neutered\n    // Public === neutered\n    isNeutered() {\n        return this.__D === undefined;\n    }\n    neutered() {\n        return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);\n    }\n    toBase58() {\n        const network = this.network;\n        const version = !this.isNeutered()\n            ? network.bip32.private\n            : network.bip32.public;\n        const buffer = Buffer.allocUnsafe(78);\n        // 4 bytes: version bytes\n        buffer.writeUInt32BE(version, 0);\n        // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n        buffer.writeUInt8(this.depth, 4);\n        // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n        buffer.writeUInt32BE(this.parentFingerprint, 5);\n        // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n        // This is encoded in big endian. (0x00000000 if master key)\n        buffer.writeUInt32BE(this.index, 9);\n        // 32 bytes: the chain code\n        this.chainCode.copy(buffer, 13);\n        // 33 bytes: the public key or private key data\n        if (!this.isNeutered()) {\n            // 0x00 + k for private keys\n            buffer.writeUInt8(0, 45);\n            this.privateKey.copy(buffer, 46);\n            // 33 bytes: the public key\n        }\n        else {\n            // X9.62 encoding for public keys\n            this.publicKey.copy(buffer, 45);\n        }\n        return bs58check.encode(buffer);\n    }\n    toWIF() {\n        if (!this.privateKey)\n            throw new TypeError('Missing private key');\n        return wif.encode(this.network.wif, this.privateKey, true);\n    }\n    // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\n    derive(index) {\n        typeforce(typeforce.UInt32, index);\n        const isHardened = index >= HIGHEST_BIT;\n        const data = Buffer.allocUnsafe(37);\n        // Hardened child\n        if (isHardened) {\n            if (this.isNeutered())\n                throw new TypeError('Missing private key for hardened child key');\n            // data = 0x00 || ser256(kpar) || ser32(index)\n            data[0] = 0x00;\n            this.privateKey.copy(data, 1);\n            data.writeUInt32BE(index, 33);\n            // Normal child\n        }\n        else {\n            // data = serP(point(kpar)) || ser32(index)\n            //      = serP(Kpar) || ser32(index)\n            this.publicKey.copy(data, 0);\n            data.writeUInt32BE(index, 33);\n        }\n        const I = crypto.hmacSHA512(this.chainCode, data);\n        const IL = I.slice(0, 32);\n        const IR = I.slice(32);\n        // if parse256(IL) >= n, proceed with the next value for i\n        if (!ecc.isPrivate(IL))\n            return this.derive(index + 1);\n        // Private parent key -> private child key\n        let hd;\n        if (!this.isNeutered()) {\n            // ki = parse256(IL) + kpar (mod n)\n            const ki = ecc.privateAdd(this.privateKey, IL);\n            // In case ki == 0, proceed with the next value for i\n            if (ki == null)\n                return this.derive(index + 1);\n            hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n            // Public parent key -> public child key\n        }\n        else {\n            // Ki = point(parse256(IL)) + Kpar\n            //    = G*IL + Kpar\n            const Ki = ecc.pointAddScalar(this.publicKey, IL, true);\n            // In case Ki is the point at infinity, proceed with the next value for i\n            if (Ki === null)\n                return this.derive(index + 1);\n            hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n        }\n        return hd;\n    }\n    deriveHardened(index) {\n        typeforce(UInt31, index);\n        // Only derives hardened private keys by default\n        return this.derive(index + HIGHEST_BIT);\n    }\n    derivePath(path) {\n        typeforce(BIP32Path, path);\n        let splitPath = path.split('/');\n        if (splitPath[0] === 'm') {\n            if (this.parentFingerprint)\n                throw new TypeError('Expected master, got child');\n            splitPath = splitPath.slice(1);\n        }\n        return splitPath.reduce((prevHd, indexStr) => {\n            let index;\n            if (indexStr.slice(-1) === `'`) {\n                index = parseInt(indexStr.slice(0, -1), 10);\n                return prevHd.deriveHardened(index);\n            }\n            else {\n                index = parseInt(indexStr, 10);\n                return prevHd.derive(index);\n            }\n        }, this);\n    }\n    sign(hash, lowR) {\n        if (!this.privateKey)\n            throw new Error('Missing private key');\n        if (lowR === undefined)\n            lowR = this.lowR;\n        if (lowR === false) {\n            return ecc.sign(hash, this.privateKey);\n        }\n        else {\n            let sig = ecc.sign(hash, this.privateKey);\n            const extraData = Buffer.alloc(32, 0);\n            let counter = 0;\n            // if first try is lowR, skip the loop\n            // for second try and on, add extra entropy counting up\n            while (sig[0] > 0x7f) {\n                counter++;\n                extraData.writeUIntLE(counter, 0, 6);\n                sig = ecc.signWithEntropy(hash, this.privateKey, extraData);\n            }\n            return sig;\n        }\n    }\n    verify(hash, signature) {\n        return ecc.verify(hash, this.publicKey, signature);\n    }\n}\nfunction fromBase58(inString, network) {\n    const buffer = bs58check.decode(inString);\n    if (buffer.length !== 78)\n        throw new TypeError('Invalid buffer length');\n    network = network || BITCOIN;\n    // 4 bytes: version bytes\n    const version = buffer.readUInt32BE(0);\n    if (version !== network.bip32.private && version !== network.bip32.public)\n        throw new TypeError('Invalid network version');\n    // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n    const depth = buffer[4];\n    // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n    const parentFingerprint = buffer.readUInt32BE(5);\n    if (depth === 0) {\n        if (parentFingerprint !== 0x00000000)\n            throw new TypeError('Invalid parent fingerprint');\n    }\n    // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n    // This is encoded in MSB order. (0x00000000 if master key)\n    const index = buffer.readUInt32BE(9);\n    if (depth === 0 && index !== 0)\n        throw new TypeError('Invalid index');\n    // 32 bytes: the chain code\n    const chainCode = buffer.slice(13, 45);\n    let hd;\n    // 33 bytes: private key data (0x00 + k)\n    if (version === network.bip32.private) {\n        if (buffer.readUInt8(45) !== 0x00)\n            throw new TypeError('Invalid private key');\n        const k = buffer.slice(46, 78);\n        hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint);\n        // 33 bytes: public key data (0x02 + X or 0x03 + X)\n    }\n    else {\n        const X = buffer.slice(45, 78);\n        hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);\n    }\n    return hd;\n}\nexports.fromBase58 = fromBase58;\nfunction fromPrivateKey(privateKey, chainCode, network) {\n    return fromPrivateKeyLocal(privateKey, chainCode, network);\n}\nexports.fromPrivateKey = fromPrivateKey;\nfunction fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {\n    typeforce({\n        privateKey: UINT256_TYPE,\n        chainCode: UINT256_TYPE,\n    }, { privateKey, chainCode });\n    network = network || BITCOIN;\n    if (!ecc.isPrivate(privateKey))\n        throw new TypeError('Private key not in range [1, n)');\n    return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);\n}\nfunction fromPublicKey(publicKey, chainCode, network) {\n    return fromPublicKeyLocal(publicKey, chainCode, network);\n}\nexports.fromPublicKey = fromPublicKey;\nfunction fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {\n    typeforce({\n        publicKey: typeforce.BufferN(33),\n        chainCode: UINT256_TYPE,\n    }, { publicKey, chainCode });\n    network = network || BITCOIN;\n    // verify the X coordinate is a point on the curve\n    if (!ecc.isPoint(publicKey))\n        throw new TypeError('Point is not on the curve');\n    return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);\n}\nfunction fromSeed(seed, network) {\n    typeforce(typeforce.Buffer, seed);\n    if (seed.length < 16)\n        throw new TypeError('Seed should be at least 128 bits');\n    if (seed.length > 64)\n        throw new TypeError('Seed should be at most 512 bits');\n    network = network || BITCOIN;\n    const I = crypto.hmacSHA512(Buffer.from('Bitcoin seed', 'utf8'), seed);\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32);\n    return fromPrivateKey(IL, IR, network);\n}\nexports.fromSeed = fromSeed;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmlwMzIvc3JjL2JpcDMyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsbUJBQU8sQ0FBQywwREFBVTtBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQywwREFBVztBQUNyQyxZQUFZLG1CQUFPLENBQUMsb0VBQWdCO0FBQ3BDLGtCQUFrQixtQkFBTyxDQUFDLDBEQUFXO0FBQ3JDLFlBQVksbUJBQU8sQ0FBQyw4Q0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSSx1QkFBdUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSSxzQkFBc0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvYmlwMzIvc3JjL2JpcDMyLmpzPzhhYjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKFwiLi9jcnlwdG9cIik7XG5jb25zdCBiczU4Y2hlY2sgPSByZXF1aXJlKCdiczU4Y2hlY2snKTtcbmNvbnN0IGVjYyA9IHJlcXVpcmUoJ3Rpbnktc2VjcDI1NmsxJyk7XG5jb25zdCB0eXBlZm9yY2UgPSByZXF1aXJlKCd0eXBlZm9yY2UnKTtcbmNvbnN0IHdpZiA9IHJlcXVpcmUoJ3dpZicpO1xuY29uc3QgVUlOVDI1Nl9UWVBFID0gdHlwZWZvcmNlLkJ1ZmZlck4oMzIpO1xuY29uc3QgTkVUV09SS19UWVBFID0gdHlwZWZvcmNlLmNvbXBpbGUoe1xuICAgIHdpZjogdHlwZWZvcmNlLlVJbnQ4LFxuICAgIGJpcDMyOiB7XG4gICAgICAgIHB1YmxpYzogdHlwZWZvcmNlLlVJbnQzMixcbiAgICAgICAgcHJpdmF0ZTogdHlwZWZvcmNlLlVJbnQzMixcbiAgICB9LFxufSk7XG5jb25zdCBCSVRDT0lOID0ge1xuICAgIG1lc3NhZ2VQcmVmaXg6ICdcXHgxOEJpdGNvaW4gU2lnbmVkIE1lc3NhZ2U6XFxuJyxcbiAgICBiZWNoMzI6ICdiYycsXG4gICAgYmlwMzI6IHtcbiAgICAgICAgcHVibGljOiAweDA0ODhiMjFlLFxuICAgICAgICBwcml2YXRlOiAweDA0ODhhZGU0LFxuICAgIH0sXG4gICAgcHViS2V5SGFzaDogMHgwMCxcbiAgICBzY3JpcHRIYXNoOiAweDA1LFxuICAgIHdpZjogMHg4MCxcbn07XG5jb25zdCBISUdIRVNUX0JJVCA9IDB4ODAwMDAwMDA7XG5jb25zdCBVSU5UMzFfTUFYID0gTWF0aC5wb3coMiwgMzEpIC0gMTtcbmZ1bmN0aW9uIEJJUDMyUGF0aCh2YWx1ZSkge1xuICAgIHJldHVybiAodHlwZWZvcmNlLlN0cmluZyh2YWx1ZSkgJiYgdmFsdWUubWF0Y2goL14obVxcLyk/KFxcZCsnP1xcLykqXFxkKyc/JC8pICE9PSBudWxsKTtcbn1cbmZ1bmN0aW9uIFVJbnQzMSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlZm9yY2UuVUludDMyKHZhbHVlKSAmJiB2YWx1ZSA8PSBVSU5UMzFfTUFYO1xufVxuY2xhc3MgQklQMzIge1xuICAgIGNvbnN0cnVjdG9yKF9fRCwgX19RLCBjaGFpbkNvZGUsIG5ldHdvcmssIF9fREVQVEggPSAwLCBfX0lOREVYID0gMCwgX19QQVJFTlRfRklOR0VSUFJJTlQgPSAweDAwMDAwMDAwKSB7XG4gICAgICAgIHRoaXMuX19EID0gX19EO1xuICAgICAgICB0aGlzLl9fUSA9IF9fUTtcbiAgICAgICAgdGhpcy5jaGFpbkNvZGUgPSBjaGFpbkNvZGU7XG4gICAgICAgIHRoaXMubmV0d29yayA9IG5ldHdvcms7XG4gICAgICAgIHRoaXMuX19ERVBUSCA9IF9fREVQVEg7XG4gICAgICAgIHRoaXMuX19JTkRFWCA9IF9fSU5ERVg7XG4gICAgICAgIHRoaXMuX19QQVJFTlRfRklOR0VSUFJJTlQgPSBfX1BBUkVOVF9GSU5HRVJQUklOVDtcbiAgICAgICAgdHlwZWZvcmNlKE5FVFdPUktfVFlQRSwgbmV0d29yayk7XG4gICAgICAgIHRoaXMubG93UiA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZGVwdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fREVQVEg7XG4gICAgfVxuICAgIGdldCBpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19JTkRFWDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudEZpbmdlcnByaW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX1BBUkVOVF9GSU5HRVJQUklOVDtcbiAgICB9XG4gICAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX19RID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLl9fUSA9IGVjYy5wb2ludEZyb21TY2FsYXIodGhpcy5fX0QsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fX1E7XG4gICAgfVxuICAgIGdldCBwcml2YXRlS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX0Q7XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmhhc2gxNjAodGhpcy5wdWJsaWNLZXkpO1xuICAgIH1cbiAgICBnZXQgZmluZ2VycHJpbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkZW50aWZpZXIuc2xpY2UoMCwgNCk7XG4gICAgfVxuICAgIGdldCBjb21wcmVzc2VkKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gUHJpdmF0ZSA9PT0gbm90IG5ldXRlcmVkXG4gICAgLy8gUHVibGljID09PSBuZXV0ZXJlZFxuICAgIGlzTmV1dGVyZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fRCA9PT0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBuZXV0ZXJlZCgpIHtcbiAgICAgICAgcmV0dXJuIGZyb21QdWJsaWNLZXlMb2NhbCh0aGlzLnB1YmxpY0tleSwgdGhpcy5jaGFpbkNvZGUsIHRoaXMubmV0d29yaywgdGhpcy5kZXB0aCwgdGhpcy5pbmRleCwgdGhpcy5wYXJlbnRGaW5nZXJwcmludCk7XG4gICAgfVxuICAgIHRvQmFzZTU4KCkge1xuICAgICAgICBjb25zdCBuZXR3b3JrID0gdGhpcy5uZXR3b3JrO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gIXRoaXMuaXNOZXV0ZXJlZCgpXG4gICAgICAgICAgICA/IG5ldHdvcmsuYmlwMzIucHJpdmF0ZVxuICAgICAgICAgICAgOiBuZXR3b3JrLmJpcDMyLnB1YmxpYztcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDc4KTtcbiAgICAgICAgLy8gNCBieXRlczogdmVyc2lvbiBieXRlc1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJCRSh2ZXJzaW9uLCAwKTtcbiAgICAgICAgLy8gMSBieXRlOiBkZXB0aDogMHgwMCBmb3IgbWFzdGVyIG5vZGVzLCAweDAxIGZvciBsZXZlbC0xIGRlc2NlbmRhbnRzLCAuLi4uXG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQ4KHRoaXMuZGVwdGgsIDQpO1xuICAgICAgICAvLyA0IGJ5dGVzOiB0aGUgZmluZ2VycHJpbnQgb2YgdGhlIHBhcmVudCdzIGtleSAoMHgwMDAwMDAwMCBpZiBtYXN0ZXIga2V5KVxuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJCRSh0aGlzLnBhcmVudEZpbmdlcnByaW50LCA1KTtcbiAgICAgICAgLy8gNCBieXRlczogY2hpbGQgbnVtYmVyLiBUaGlzIGlzIHRoZSBudW1iZXIgaSBpbiB4aSA9IHhwYXIvaSwgd2l0aCB4aSB0aGUga2V5IGJlaW5nIHNlcmlhbGl6ZWQuXG4gICAgICAgIC8vIFRoaXMgaXMgZW5jb2RlZCBpbiBiaWcgZW5kaWFuLiAoMHgwMDAwMDAwMCBpZiBtYXN0ZXIga2V5KVxuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJCRSh0aGlzLmluZGV4LCA5KTtcbiAgICAgICAgLy8gMzIgYnl0ZXM6IHRoZSBjaGFpbiBjb2RlXG4gICAgICAgIHRoaXMuY2hhaW5Db2RlLmNvcHkoYnVmZmVyLCAxMyk7XG4gICAgICAgIC8vIDMzIGJ5dGVzOiB0aGUgcHVibGljIGtleSBvciBwcml2YXRlIGtleSBkYXRhXG4gICAgICAgIGlmICghdGhpcy5pc05ldXRlcmVkKCkpIHtcbiAgICAgICAgICAgIC8vIDB4MDAgKyBrIGZvciBwcml2YXRlIGtleXNcbiAgICAgICAgICAgIGJ1ZmZlci53cml0ZVVJbnQ4KDAsIDQ1KTtcbiAgICAgICAgICAgIHRoaXMucHJpdmF0ZUtleS5jb3B5KGJ1ZmZlciwgNDYpO1xuICAgICAgICAgICAgLy8gMzMgYnl0ZXM6IHRoZSBwdWJsaWMga2V5XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBYOS42MiBlbmNvZGluZyBmb3IgcHVibGljIGtleXNcbiAgICAgICAgICAgIHRoaXMucHVibGljS2V5LmNvcHkoYnVmZmVyLCA0NSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJzNThjaGVjay5lbmNvZGUoYnVmZmVyKTtcbiAgICB9XG4gICAgdG9XSUYoKSB7XG4gICAgICAgIGlmICghdGhpcy5wcml2YXRlS2V5KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBwcml2YXRlIGtleScpO1xuICAgICAgICByZXR1cm4gd2lmLmVuY29kZSh0aGlzLm5ldHdvcmsud2lmLCB0aGlzLnByaXZhdGVLZXksIHRydWUpO1xuICAgIH1cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDMyLm1lZGlhd2lraSNjaGlsZC1rZXktZGVyaXZhdGlvbi1ja2QtZnVuY3Rpb25zXG4gICAgZGVyaXZlKGluZGV4KSB7XG4gICAgICAgIHR5cGVmb3JjZSh0eXBlZm9yY2UuVUludDMyLCBpbmRleCk7XG4gICAgICAgIGNvbnN0IGlzSGFyZGVuZWQgPSBpbmRleCA+PSBISUdIRVNUX0JJVDtcbiAgICAgICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgzNyk7XG4gICAgICAgIC8vIEhhcmRlbmVkIGNoaWxkXG4gICAgICAgIGlmIChpc0hhcmRlbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc05ldXRlcmVkKCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBwcml2YXRlIGtleSBmb3IgaGFyZGVuZWQgY2hpbGQga2V5Jyk7XG4gICAgICAgICAgICAvLyBkYXRhID0gMHgwMCB8fCBzZXIyNTYoa3BhcikgfHwgc2VyMzIoaW5kZXgpXG4gICAgICAgICAgICBkYXRhWzBdID0gMHgwMDtcbiAgICAgICAgICAgIHRoaXMucHJpdmF0ZUtleS5jb3B5KGRhdGEsIDEpO1xuICAgICAgICAgICAgZGF0YS53cml0ZVVJbnQzMkJFKGluZGV4LCAzMyk7XG4gICAgICAgICAgICAvLyBOb3JtYWwgY2hpbGRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRhdGEgPSBzZXJQKHBvaW50KGtwYXIpKSB8fCBzZXIzMihpbmRleClcbiAgICAgICAgICAgIC8vICAgICAgPSBzZXJQKEtwYXIpIHx8IHNlcjMyKGluZGV4KVxuICAgICAgICAgICAgdGhpcy5wdWJsaWNLZXkuY29weShkYXRhLCAwKTtcbiAgICAgICAgICAgIGRhdGEud3JpdGVVSW50MzJCRShpbmRleCwgMzMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IEkgPSBjcnlwdG8uaG1hY1NIQTUxMih0aGlzLmNoYWluQ29kZSwgZGF0YSk7XG4gICAgICAgIGNvbnN0IElMID0gSS5zbGljZSgwLCAzMik7XG4gICAgICAgIGNvbnN0IElSID0gSS5zbGljZSgzMik7XG4gICAgICAgIC8vIGlmIHBhcnNlMjU2KElMKSA+PSBuLCBwcm9jZWVkIHdpdGggdGhlIG5leHQgdmFsdWUgZm9yIGlcbiAgICAgICAgaWYgKCFlY2MuaXNQcml2YXRlKElMKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlcml2ZShpbmRleCArIDEpO1xuICAgICAgICAvLyBQcml2YXRlIHBhcmVudCBrZXkgLT4gcHJpdmF0ZSBjaGlsZCBrZXlcbiAgICAgICAgbGV0IGhkO1xuICAgICAgICBpZiAoIXRoaXMuaXNOZXV0ZXJlZCgpKSB7XG4gICAgICAgICAgICAvLyBraSA9IHBhcnNlMjU2KElMKSArIGtwYXIgKG1vZCBuKVxuICAgICAgICAgICAgY29uc3Qga2kgPSBlY2MucHJpdmF0ZUFkZCh0aGlzLnByaXZhdGVLZXksIElMKTtcbiAgICAgICAgICAgIC8vIEluIGNhc2Uga2kgPT0gMCwgcHJvY2VlZCB3aXRoIHRoZSBuZXh0IHZhbHVlIGZvciBpXG4gICAgICAgICAgICBpZiAoa2kgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZXJpdmUoaW5kZXggKyAxKTtcbiAgICAgICAgICAgIGhkID0gZnJvbVByaXZhdGVLZXlMb2NhbChraSwgSVIsIHRoaXMubmV0d29yaywgdGhpcy5kZXB0aCArIDEsIGluZGV4LCB0aGlzLmZpbmdlcnByaW50LnJlYWRVSW50MzJCRSgwKSk7XG4gICAgICAgICAgICAvLyBQdWJsaWMgcGFyZW50IGtleSAtPiBwdWJsaWMgY2hpbGQga2V5XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBLaSA9IHBvaW50KHBhcnNlMjU2KElMKSkgKyBLcGFyXG4gICAgICAgICAgICAvLyAgICA9IEcqSUwgKyBLcGFyXG4gICAgICAgICAgICBjb25zdCBLaSA9IGVjYy5wb2ludEFkZFNjYWxhcih0aGlzLnB1YmxpY0tleSwgSUwsIHRydWUpO1xuICAgICAgICAgICAgLy8gSW4gY2FzZSBLaSBpcyB0aGUgcG9pbnQgYXQgaW5maW5pdHksIHByb2NlZWQgd2l0aCB0aGUgbmV4dCB2YWx1ZSBmb3IgaVxuICAgICAgICAgICAgaWYgKEtpID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlcml2ZShpbmRleCArIDEpO1xuICAgICAgICAgICAgaGQgPSBmcm9tUHVibGljS2V5TG9jYWwoS2ksIElSLCB0aGlzLm5ldHdvcmssIHRoaXMuZGVwdGggKyAxLCBpbmRleCwgdGhpcy5maW5nZXJwcmludC5yZWFkVUludDMyQkUoMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZDtcbiAgICB9XG4gICAgZGVyaXZlSGFyZGVuZWQoaW5kZXgpIHtcbiAgICAgICAgdHlwZWZvcmNlKFVJbnQzMSwgaW5kZXgpO1xuICAgICAgICAvLyBPbmx5IGRlcml2ZXMgaGFyZGVuZWQgcHJpdmF0ZSBrZXlzIGJ5IGRlZmF1bHRcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVyaXZlKGluZGV4ICsgSElHSEVTVF9CSVQpO1xuICAgIH1cbiAgICBkZXJpdmVQYXRoKHBhdGgpIHtcbiAgICAgICAgdHlwZWZvcmNlKEJJUDMyUGF0aCwgcGF0aCk7XG4gICAgICAgIGxldCBzcGxpdFBhdGggPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgICAgIGlmIChzcGxpdFBhdGhbMF0gPT09ICdtJykge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50RmluZ2VycHJpbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgbWFzdGVyLCBnb3QgY2hpbGQnKTtcbiAgICAgICAgICAgIHNwbGl0UGF0aCA9IHNwbGl0UGF0aC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXRQYXRoLnJlZHVjZSgocHJldkhkLCBpbmRleFN0cikgPT4ge1xuICAgICAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICAgICAgaWYgKGluZGV4U3RyLnNsaWNlKC0xKSA9PT0gYCdgKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBwYXJzZUludChpbmRleFN0ci5zbGljZSgwLCAtMSksIDEwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldkhkLmRlcml2ZUhhcmRlbmVkKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gcGFyc2VJbnQoaW5kZXhTdHIsIDEwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldkhkLmRlcml2ZShpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICBzaWduKGhhc2gsIGxvd1IpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByaXZhdGVLZXkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgaWYgKGxvd1IgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGxvd1IgPSB0aGlzLmxvd1I7XG4gICAgICAgIGlmIChsb3dSID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVjYy5zaWduKGhhc2gsIHRoaXMucHJpdmF0ZUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgc2lnID0gZWNjLnNpZ24oaGFzaCwgdGhpcy5wcml2YXRlS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhRGF0YSA9IEJ1ZmZlci5hbGxvYygzMiwgMCk7XG4gICAgICAgICAgICBsZXQgY291bnRlciA9IDA7XG4gICAgICAgICAgICAvLyBpZiBmaXJzdCB0cnkgaXMgbG93Uiwgc2tpcCB0aGUgbG9vcFxuICAgICAgICAgICAgLy8gZm9yIHNlY29uZCB0cnkgYW5kIG9uLCBhZGQgZXh0cmEgZW50cm9weSBjb3VudGluZyB1cFxuICAgICAgICAgICAgd2hpbGUgKHNpZ1swXSA+IDB4N2YpIHtcbiAgICAgICAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgICAgICAgICAgZXh0cmFEYXRhLndyaXRlVUludExFKGNvdW50ZXIsIDAsIDYpO1xuICAgICAgICAgICAgICAgIHNpZyA9IGVjYy5zaWduV2l0aEVudHJvcHkoaGFzaCwgdGhpcy5wcml2YXRlS2V5LCBleHRyYURhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpZztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2ZXJpZnkoaGFzaCwgc2lnbmF0dXJlKSB7XG4gICAgICAgIHJldHVybiBlY2MudmVyaWZ5KGhhc2gsIHRoaXMucHVibGljS2V5LCBzaWduYXR1cmUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZyb21CYXNlNTgoaW5TdHJpbmcsIG5ldHdvcmspIHtcbiAgICBjb25zdCBidWZmZXIgPSBiczU4Y2hlY2suZGVjb2RlKGluU3RyaW5nKTtcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCAhPT0gNzgpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgYnVmZmVyIGxlbmd0aCcpO1xuICAgIG5ldHdvcmsgPSBuZXR3b3JrIHx8IEJJVENPSU47XG4gICAgLy8gNCBieXRlczogdmVyc2lvbiBieXRlc1xuICAgIGNvbnN0IHZlcnNpb24gPSBidWZmZXIucmVhZFVJbnQzMkJFKDApO1xuICAgIGlmICh2ZXJzaW9uICE9PSBuZXR3b3JrLmJpcDMyLnByaXZhdGUgJiYgdmVyc2lvbiAhPT0gbmV0d29yay5iaXAzMi5wdWJsaWMpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbmV0d29yayB2ZXJzaW9uJyk7XG4gICAgLy8gMSBieXRlOiBkZXB0aDogMHgwMCBmb3IgbWFzdGVyIG5vZGVzLCAweDAxIGZvciBsZXZlbC0xIGRlc2NlbmRhbnRzLCAuLi5cbiAgICBjb25zdCBkZXB0aCA9IGJ1ZmZlcls0XTtcbiAgICAvLyA0IGJ5dGVzOiB0aGUgZmluZ2VycHJpbnQgb2YgdGhlIHBhcmVudCdzIGtleSAoMHgwMDAwMDAwMCBpZiBtYXN0ZXIga2V5KVxuICAgIGNvbnN0IHBhcmVudEZpbmdlcnByaW50ID0gYnVmZmVyLnJlYWRVSW50MzJCRSg1KTtcbiAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgICAgaWYgKHBhcmVudEZpbmdlcnByaW50ICE9PSAweDAwMDAwMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwYXJlbnQgZmluZ2VycHJpbnQnKTtcbiAgICB9XG4gICAgLy8gNCBieXRlczogY2hpbGQgbnVtYmVyLiBUaGlzIGlzIHRoZSBudW1iZXIgaSBpbiB4aSA9IHhwYXIvaSwgd2l0aCB4aSB0aGUga2V5IGJlaW5nIHNlcmlhbGl6ZWQuXG4gICAgLy8gVGhpcyBpcyBlbmNvZGVkIGluIE1TQiBvcmRlci4gKDB4MDAwMDAwMDAgaWYgbWFzdGVyIGtleSlcbiAgICBjb25zdCBpbmRleCA9IGJ1ZmZlci5yZWFkVUludDMyQkUoOSk7XG4gICAgaWYgKGRlcHRoID09PSAwICYmIGluZGV4ICE9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGluZGV4Jyk7XG4gICAgLy8gMzIgYnl0ZXM6IHRoZSBjaGFpbiBjb2RlXG4gICAgY29uc3QgY2hhaW5Db2RlID0gYnVmZmVyLnNsaWNlKDEzLCA0NSk7XG4gICAgbGV0IGhkO1xuICAgIC8vIDMzIGJ5dGVzOiBwcml2YXRlIGtleSBkYXRhICgweDAwICsgaylcbiAgICBpZiAodmVyc2lvbiA9PT0gbmV0d29yay5iaXAzMi5wcml2YXRlKSB7XG4gICAgICAgIGlmIChidWZmZXIucmVhZFVJbnQ4KDQ1KSAhPT0gMHgwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgY29uc3QgayA9IGJ1ZmZlci5zbGljZSg0NiwgNzgpO1xuICAgICAgICBoZCA9IGZyb21Qcml2YXRlS2V5TG9jYWwoaywgY2hhaW5Db2RlLCBuZXR3b3JrLCBkZXB0aCwgaW5kZXgsIHBhcmVudEZpbmdlcnByaW50KTtcbiAgICAgICAgLy8gMzMgYnl0ZXM6IHB1YmxpYyBrZXkgZGF0YSAoMHgwMiArIFggb3IgMHgwMyArIFgpXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBYID0gYnVmZmVyLnNsaWNlKDQ1LCA3OCk7XG4gICAgICAgIGhkID0gZnJvbVB1YmxpY0tleUxvY2FsKFgsIGNoYWluQ29kZSwgbmV0d29yaywgZGVwdGgsIGluZGV4LCBwYXJlbnRGaW5nZXJwcmludCk7XG4gICAgfVxuICAgIHJldHVybiBoZDtcbn1cbmV4cG9ydHMuZnJvbUJhc2U1OCA9IGZyb21CYXNlNTg7XG5mdW5jdGlvbiBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5LCBjaGFpbkNvZGUsIG5ldHdvcmspIHtcbiAgICByZXR1cm4gZnJvbVByaXZhdGVLZXlMb2NhbChwcml2YXRlS2V5LCBjaGFpbkNvZGUsIG5ldHdvcmspO1xufVxuZXhwb3J0cy5mcm9tUHJpdmF0ZUtleSA9IGZyb21Qcml2YXRlS2V5O1xuZnVuY3Rpb24gZnJvbVByaXZhdGVLZXlMb2NhbChwcml2YXRlS2V5LCBjaGFpbkNvZGUsIG5ldHdvcmssIGRlcHRoLCBpbmRleCwgcGFyZW50RmluZ2VycHJpbnQpIHtcbiAgICB0eXBlZm9yY2Uoe1xuICAgICAgICBwcml2YXRlS2V5OiBVSU5UMjU2X1RZUEUsXG4gICAgICAgIGNoYWluQ29kZTogVUlOVDI1Nl9UWVBFLFxuICAgIH0sIHsgcHJpdmF0ZUtleSwgY2hhaW5Db2RlIH0pO1xuICAgIG5ldHdvcmsgPSBuZXR3b3JrIHx8IEJJVENPSU47XG4gICAgaWYgKCFlY2MuaXNQcml2YXRlKHByaXZhdGVLZXkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcml2YXRlIGtleSBub3QgaW4gcmFuZ2UgWzEsIG4pJyk7XG4gICAgcmV0dXJuIG5ldyBCSVAzMihwcml2YXRlS2V5LCB1bmRlZmluZWQsIGNoYWluQ29kZSwgbmV0d29yaywgZGVwdGgsIGluZGV4LCBwYXJlbnRGaW5nZXJwcmludCk7XG59XG5mdW5jdGlvbiBmcm9tUHVibGljS2V5KHB1YmxpY0tleSwgY2hhaW5Db2RlLCBuZXR3b3JrKSB7XG4gICAgcmV0dXJuIGZyb21QdWJsaWNLZXlMb2NhbChwdWJsaWNLZXksIGNoYWluQ29kZSwgbmV0d29yayk7XG59XG5leHBvcnRzLmZyb21QdWJsaWNLZXkgPSBmcm9tUHVibGljS2V5O1xuZnVuY3Rpb24gZnJvbVB1YmxpY0tleUxvY2FsKHB1YmxpY0tleSwgY2hhaW5Db2RlLCBuZXR3b3JrLCBkZXB0aCwgaW5kZXgsIHBhcmVudEZpbmdlcnByaW50KSB7XG4gICAgdHlwZWZvcmNlKHtcbiAgICAgICAgcHVibGljS2V5OiB0eXBlZm9yY2UuQnVmZmVyTigzMyksXG4gICAgICAgIGNoYWluQ29kZTogVUlOVDI1Nl9UWVBFLFxuICAgIH0sIHsgcHVibGljS2V5LCBjaGFpbkNvZGUgfSk7XG4gICAgbmV0d29yayA9IG5ldHdvcmsgfHwgQklUQ09JTjtcbiAgICAvLyB2ZXJpZnkgdGhlIFggY29vcmRpbmF0ZSBpcyBhIHBvaW50IG9uIHRoZSBjdXJ2ZVxuICAgIGlmICghZWNjLmlzUG9pbnQocHVibGljS2V5KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUG9pbnQgaXMgbm90IG9uIHRoZSBjdXJ2ZScpO1xuICAgIHJldHVybiBuZXcgQklQMzIodW5kZWZpbmVkLCBwdWJsaWNLZXksIGNoYWluQ29kZSwgbmV0d29yaywgZGVwdGgsIGluZGV4LCBwYXJlbnRGaW5nZXJwcmludCk7XG59XG5mdW5jdGlvbiBmcm9tU2VlZChzZWVkLCBuZXR3b3JrKSB7XG4gICAgdHlwZWZvcmNlKHR5cGVmb3JjZS5CdWZmZXIsIHNlZWQpO1xuICAgIGlmIChzZWVkLmxlbmd0aCA8IDE2KVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTZWVkIHNob3VsZCBiZSBhdCBsZWFzdCAxMjggYml0cycpO1xuICAgIGlmIChzZWVkLmxlbmd0aCA+IDY0KVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTZWVkIHNob3VsZCBiZSBhdCBtb3N0IDUxMiBiaXRzJyk7XG4gICAgbmV0d29yayA9IG5ldHdvcmsgfHwgQklUQ09JTjtcbiAgICBjb25zdCBJID0gY3J5cHRvLmhtYWNTSEE1MTIoQnVmZmVyLmZyb20oJ0JpdGNvaW4gc2VlZCcsICd1dGY4JyksIHNlZWQpO1xuICAgIGNvbnN0IElMID0gSS5zbGljZSgwLCAzMik7XG4gICAgY29uc3QgSVIgPSBJLnNsaWNlKDMyKTtcbiAgICByZXR1cm4gZnJvbVByaXZhdGVLZXkoSUwsIElSLCBuZXR3b3JrKTtcbn1cbmV4cG9ydHMuZnJvbVNlZWQgPSBmcm9tU2VlZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bip32/src/bip32.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bip32/src/crypto.js":
/*!******************************************!*\
  !*** ./node_modules/bip32/src/crypto.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst createHash = __webpack_require__(/*! create-hash */ \"(ssr)/./node_modules/create-hash/index.js\");\nconst createHmac = __webpack_require__(/*! create-hmac */ \"(ssr)/./node_modules/create-hmac/index.js\");\nfunction hash160(buffer) {\n    const sha256Hash = createHash('sha256')\n        .update(buffer)\n        .digest();\n    try {\n        return createHash('rmd160')\n            .update(sha256Hash)\n            .digest();\n    }\n    catch (err) {\n        return createHash('ripemd160')\n            .update(sha256Hash)\n            .digest();\n    }\n}\nexports.hash160 = hash160;\nfunction hmacSHA512(key, data) {\n    return createHmac('sha512', key)\n        .update(data)\n        .digest();\n}\nexports.hmacSHA512 = hmacSHA512;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmlwMzIvc3JjL2NyeXB0by5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsbUJBQU8sQ0FBQyw4REFBYTtBQUN4QyxtQkFBbUIsbUJBQU8sQ0FBQyw4REFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL2JpcDMyL3NyYy9jcnlwdG8uanM/ZTFmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpO1xuY29uc3QgY3JlYXRlSG1hYyA9IHJlcXVpcmUoJ2NyZWF0ZS1obWFjJyk7XG5mdW5jdGlvbiBoYXNoMTYwKGJ1ZmZlcikge1xuICAgIGNvbnN0IHNoYTI1Nkhhc2ggPSBjcmVhdGVIYXNoKCdzaGEyNTYnKVxuICAgICAgICAudXBkYXRlKGJ1ZmZlcilcbiAgICAgICAgLmRpZ2VzdCgpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVIYXNoKCdybWQxNjAnKVxuICAgICAgICAgICAgLnVwZGF0ZShzaGEyNTZIYXNoKVxuICAgICAgICAgICAgLmRpZ2VzdCgpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVIYXNoKCdyaXBlbWQxNjAnKVxuICAgICAgICAgICAgLnVwZGF0ZShzaGEyNTZIYXNoKVxuICAgICAgICAgICAgLmRpZ2VzdCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuaGFzaDE2MCA9IGhhc2gxNjA7XG5mdW5jdGlvbiBobWFjU0hBNTEyKGtleSwgZGF0YSkge1xuICAgIHJldHVybiBjcmVhdGVIbWFjKCdzaGE1MTInLCBrZXkpXG4gICAgICAgIC51cGRhdGUoZGF0YSlcbiAgICAgICAgLmRpZ2VzdCgpO1xufVxuZXhwb3J0cy5obWFjU0hBNTEyID0gaG1hY1NIQTUxMjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bip32/src/crypto.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/bip32/src/index.js":
/*!*****************************************!*\
  !*** ./node_modules/bip32/src/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar bip32_1 = __webpack_require__(/*! ./bip32 */ \"(ssr)/./node_modules/bip32/src/bip32.js\");\nexports.fromSeed = bip32_1.fromSeed;\nexports.fromBase58 = bip32_1.fromBase58;\nexports.fromPublicKey = bip32_1.fromPublicKey;\nexports.fromPrivateKey = bip32_1.fromPrivateKey;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYmlwMzIvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsbUJBQU8sQ0FBQyx3REFBUztBQUMvQixnQkFBZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCLHFCQUFxQjtBQUNyQixzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9iaXAzMi9zcmMvaW5kZXguanM/N2E3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBiaXAzMl8xID0gcmVxdWlyZShcIi4vYmlwMzJcIik7XG5leHBvcnRzLmZyb21TZWVkID0gYmlwMzJfMS5mcm9tU2VlZDtcbmV4cG9ydHMuZnJvbUJhc2U1OCA9IGJpcDMyXzEuZnJvbUJhc2U1ODtcbmV4cG9ydHMuZnJvbVB1YmxpY0tleSA9IGJpcDMyXzEuZnJvbVB1YmxpY0tleTtcbmV4cG9ydHMuZnJvbVByaXZhdGVLZXkgPSBiaXAzMl8xLmZyb21Qcml2YXRlS2V5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bip32/src/index.js\n");

/***/ })

};
;