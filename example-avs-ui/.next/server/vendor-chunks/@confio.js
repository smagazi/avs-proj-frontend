"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@confio";
exports.ids = ["vendor-chunks/@confio"];
exports.modules = {

/***/ "(ssr)/./node_modules/@confio/ics23/build/compress.js":
/*!******************************************************!*\
  !*** ./node_modules/@confio/ics23/build/compress.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decompress = exports.compress = void 0;\nconst codecimpl_1 = __webpack_require__(/*! ./generated/codecimpl */ \"(ssr)/./node_modules/@confio/ics23/build/generated/codecimpl.js\");\nfunction compress(proof) {\n    if (!proof.batch) {\n        return proof;\n    }\n    return { compressed: compressBatch(proof.batch) };\n}\nexports.compress = compress;\nfunction decompress(proof) {\n    if (!proof.compressed) {\n        return proof;\n    }\n    return { batch: decompressBatch(proof.compressed) };\n}\nexports.decompress = decompress;\nfunction compressBatch(proof) {\n    const centries = [];\n    const lookup = [];\n    const registry = new Map();\n    for (const entry of proof.entries) {\n        if (entry.exist) {\n            const centry = { exist: compressExist(entry.exist, lookup, registry) };\n            centries.push(centry);\n        }\n        else if (entry.nonexist) {\n            const non = entry.nonexist;\n            const centry = {\n                nonexist: {\n                    key: non.key,\n                    left: compressExist(non.left, lookup, registry),\n                    right: compressExist(non.right, lookup, registry),\n                },\n            };\n            centries.push(centry);\n        }\n        else {\n            throw new Error(\"Unexpected batch entry during compress\");\n        }\n    }\n    return {\n        entries: centries,\n        lookupInners: lookup,\n    };\n}\nfunction compressExist(exist, lookup, registry) {\n    if (!exist) {\n        return undefined;\n    }\n    const path = exist.path.map((inner) => {\n        const sig = codecimpl_1.ics23.InnerOp.encode(inner).finish();\n        let idx = registry.get(sig);\n        if (idx === undefined) {\n            idx = lookup.length;\n            lookup.push(inner);\n            registry.set(sig, idx);\n        }\n        return idx;\n    });\n    return {\n        key: exist.key,\n        value: exist.value,\n        leaf: exist.leaf,\n        path,\n    };\n}\nfunction decompressBatch(proof) {\n    const lookup = proof.lookupInners;\n    const entries = proof.entries.map((comp) => {\n        if (comp.exist) {\n            return { exist: decompressExist(comp.exist, lookup) };\n        }\n        else if (comp.nonexist) {\n            const non = comp.nonexist;\n            return {\n                nonexist: {\n                    key: non.key,\n                    left: decompressExist(non.left, lookup),\n                    right: decompressExist(non.right, lookup),\n                },\n            };\n        }\n        else {\n            throw new Error(\"Unexpected batch entry during compress\");\n        }\n    });\n    return {\n        entries,\n    };\n}\nfunction decompressExist(exist, lookup) {\n    if (!exist) {\n        return undefined;\n    }\n    const { key, value, leaf, path } = exist;\n    const newPath = (path || []).map((idx) => lookup[idx]);\n    return { key, value, leaf, path: newPath };\n}\n//# sourceMappingURL=compress.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbmZpby9pY3MyMy9idWlsZC9jb21wcmVzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxnQkFBZ0I7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsOEZBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0EsYUFBYTtBQUNiO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9AY29uZmlvL2ljczIzL2J1aWxkL2NvbXByZXNzLmpzP2ExNDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29tcHJlc3MgPSBleHBvcnRzLmNvbXByZXNzID0gdm9pZCAwO1xuY29uc3QgY29kZWNpbXBsXzEgPSByZXF1aXJlKFwiLi9nZW5lcmF0ZWQvY29kZWNpbXBsXCIpO1xuZnVuY3Rpb24gY29tcHJlc3MocHJvb2YpIHtcbiAgICBpZiAoIXByb29mLmJhdGNoKSB7XG4gICAgICAgIHJldHVybiBwcm9vZjtcbiAgICB9XG4gICAgcmV0dXJuIHsgY29tcHJlc3NlZDogY29tcHJlc3NCYXRjaChwcm9vZi5iYXRjaCkgfTtcbn1cbmV4cG9ydHMuY29tcHJlc3MgPSBjb21wcmVzcztcbmZ1bmN0aW9uIGRlY29tcHJlc3MocHJvb2YpIHtcbiAgICBpZiAoIXByb29mLmNvbXByZXNzZWQpIHtcbiAgICAgICAgcmV0dXJuIHByb29mO1xuICAgIH1cbiAgICByZXR1cm4geyBiYXRjaDogZGVjb21wcmVzc0JhdGNoKHByb29mLmNvbXByZXNzZWQpIH07XG59XG5leHBvcnRzLmRlY29tcHJlc3MgPSBkZWNvbXByZXNzO1xuZnVuY3Rpb24gY29tcHJlc3NCYXRjaChwcm9vZikge1xuICAgIGNvbnN0IGNlbnRyaWVzID0gW107XG4gICAgY29uc3QgbG9va3VwID0gW107XG4gICAgY29uc3QgcmVnaXN0cnkgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBwcm9vZi5lbnRyaWVzKSB7XG4gICAgICAgIGlmIChlbnRyeS5leGlzdCkge1xuICAgICAgICAgICAgY29uc3QgY2VudHJ5ID0geyBleGlzdDogY29tcHJlc3NFeGlzdChlbnRyeS5leGlzdCwgbG9va3VwLCByZWdpc3RyeSkgfTtcbiAgICAgICAgICAgIGNlbnRyaWVzLnB1c2goY2VudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbnRyeS5ub25leGlzdCkge1xuICAgICAgICAgICAgY29uc3Qgbm9uID0gZW50cnkubm9uZXhpc3Q7XG4gICAgICAgICAgICBjb25zdCBjZW50cnkgPSB7XG4gICAgICAgICAgICAgICAgbm9uZXhpc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiBub24ua2V5LFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBjb21wcmVzc0V4aXN0KG5vbi5sZWZ0LCBsb29rdXAsIHJlZ2lzdHJ5KSxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGNvbXByZXNzRXhpc3Qobm9uLnJpZ2h0LCBsb29rdXAsIHJlZ2lzdHJ5KSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNlbnRyaWVzLnB1c2goY2VudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgYmF0Y2ggZW50cnkgZHVyaW5nIGNvbXByZXNzXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVudHJpZXM6IGNlbnRyaWVzLFxuICAgICAgICBsb29rdXBJbm5lcnM6IGxvb2t1cCxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHJlc3NFeGlzdChleGlzdCwgbG9va3VwLCByZWdpc3RyeSkge1xuICAgIGlmICghZXhpc3QpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IGV4aXN0LnBhdGgubWFwKChpbm5lcikgPT4ge1xuICAgICAgICBjb25zdCBzaWcgPSBjb2RlY2ltcGxfMS5pY3MyMy5Jbm5lck9wLmVuY29kZShpbm5lcikuZmluaXNoKCk7XG4gICAgICAgIGxldCBpZHggPSByZWdpc3RyeS5nZXQoc2lnKTtcbiAgICAgICAgaWYgKGlkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZHggPSBsb29rdXAubGVuZ3RoO1xuICAgICAgICAgICAgbG9va3VwLnB1c2goaW5uZXIpO1xuICAgICAgICAgICAgcmVnaXN0cnkuc2V0KHNpZywgaWR4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWR4O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleTogZXhpc3Qua2V5LFxuICAgICAgICB2YWx1ZTogZXhpc3QudmFsdWUsXG4gICAgICAgIGxlYWY6IGV4aXN0LmxlYWYsXG4gICAgICAgIHBhdGgsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRlY29tcHJlc3NCYXRjaChwcm9vZikge1xuICAgIGNvbnN0IGxvb2t1cCA9IHByb29mLmxvb2t1cElubmVycztcbiAgICBjb25zdCBlbnRyaWVzID0gcHJvb2YuZW50cmllcy5tYXAoKGNvbXApID0+IHtcbiAgICAgICAgaWYgKGNvbXAuZXhpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGV4aXN0OiBkZWNvbXByZXNzRXhpc3QoY29tcC5leGlzdCwgbG9va3VwKSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXAubm9uZXhpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vbiA9IGNvbXAubm9uZXhpc3Q7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5vbmV4aXN0OiB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogbm9uLmtleSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZGVjb21wcmVzc0V4aXN0KG5vbi5sZWZ0LCBsb29rdXApLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogZGVjb21wcmVzc0V4aXN0KG5vbi5yaWdodCwgbG9va3VwKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgYmF0Y2ggZW50cnkgZHVyaW5nIGNvbXByZXNzXCIpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW50cmllcyxcbiAgICB9O1xufVxuZnVuY3Rpb24gZGVjb21wcmVzc0V4aXN0KGV4aXN0LCBsb29rdXApIHtcbiAgICBpZiAoIWV4aXN0KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHsga2V5LCB2YWx1ZSwgbGVhZiwgcGF0aCB9ID0gZXhpc3Q7XG4gICAgY29uc3QgbmV3UGF0aCA9IChwYXRoIHx8IFtdKS5tYXAoKGlkeCkgPT4gbG9va3VwW2lkeF0pO1xuICAgIHJldHVybiB7IGtleSwgdmFsdWUsIGxlYWYsIHBhdGg6IG5ld1BhdGggfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXByZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@confio/ics23/build/compress.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@confio/ics23/build/generated/codecimpl.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@confio/ics23/build/generated/codecimpl.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\n\nvar $protobuf = __webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\");\n\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.ics23 = (function() {\n\n    /**\n     * Namespace ics23.\n     * @exports ics23\n     * @namespace\n     */\n    var ics23 = {};\n\n    /**\n     * HashOp enum.\n     * @name ics23.HashOp\n     * @enum {string}\n     * @property {number} NO_HASH=0 NO_HASH value\n     * @property {number} SHA256=1 SHA256 value\n     * @property {number} SHA512=2 SHA512 value\n     * @property {number} KECCAK=3 KECCAK value\n     * @property {number} RIPEMD160=4 RIPEMD160 value\n     * @property {number} BITCOIN=5 BITCOIN value\n     * @property {number} SHA512_256=6 SHA512_256 value\n     */\n    ics23.HashOp = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"NO_HASH\"] = 0;\n        values[valuesById[1] = \"SHA256\"] = 1;\n        values[valuesById[2] = \"SHA512\"] = 2;\n        values[valuesById[3] = \"KECCAK\"] = 3;\n        values[valuesById[4] = \"RIPEMD160\"] = 4;\n        values[valuesById[5] = \"BITCOIN\"] = 5;\n        values[valuesById[6] = \"SHA512_256\"] = 6;\n        return values;\n    })();\n\n    /**\n     * LengthOp defines how to process the key and value of the LeafOp\n     * to include length information. After encoding the length with the given\n     * algorithm, the length will be prepended to the key and value bytes.\n     * (Each one with it's own encoded length)\n     * @name ics23.LengthOp\n     * @enum {string}\n     * @property {number} NO_PREFIX=0 NO_PREFIX value\n     * @property {number} VAR_PROTO=1 VAR_PROTO value\n     * @property {number} VAR_RLP=2 VAR_RLP value\n     * @property {number} FIXED32_BIG=3 FIXED32_BIG value\n     * @property {number} FIXED32_LITTLE=4 FIXED32_LITTLE value\n     * @property {number} FIXED64_BIG=5 FIXED64_BIG value\n     * @property {number} FIXED64_LITTLE=6 FIXED64_LITTLE value\n     * @property {number} REQUIRE_32_BYTES=7 REQUIRE_32_BYTES value\n     * @property {number} REQUIRE_64_BYTES=8 REQUIRE_64_BYTES value\n     */\n    ics23.LengthOp = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"NO_PREFIX\"] = 0;\n        values[valuesById[1] = \"VAR_PROTO\"] = 1;\n        values[valuesById[2] = \"VAR_RLP\"] = 2;\n        values[valuesById[3] = \"FIXED32_BIG\"] = 3;\n        values[valuesById[4] = \"FIXED32_LITTLE\"] = 4;\n        values[valuesById[5] = \"FIXED64_BIG\"] = 5;\n        values[valuesById[6] = \"FIXED64_LITTLE\"] = 6;\n        values[valuesById[7] = \"REQUIRE_32_BYTES\"] = 7;\n        values[valuesById[8] = \"REQUIRE_64_BYTES\"] = 8;\n        return values;\n    })();\n\n    ics23.ExistenceProof = (function() {\n\n        /**\n         * Properties of an ExistenceProof.\n         * @memberof ics23\n         * @interface IExistenceProof\n         * @property {Uint8Array|null} [key] ExistenceProof key\n         * @property {Uint8Array|null} [value] ExistenceProof value\n         * @property {ics23.ILeafOp|null} [leaf] ExistenceProof leaf\n         * @property {Array.<ics23.IInnerOp>|null} [path] ExistenceProof path\n         */\n\n        /**\n         * Constructs a new ExistenceProof.\n         * @memberof ics23\n         * @classdesc ExistenceProof takes a key and a value and a set of steps to perform on it.\n         * The result of peforming all these steps will provide a \"root hash\", which can\n         * be compared to the value in a header.\n         * \n         * Since it is computationally infeasible to produce a hash collission for any of the used\n         * cryptographic hash functions, if someone can provide a series of operations to transform\n         * a given key and value into a root hash that matches some trusted root, these key and values\n         * must be in the referenced merkle tree.\n         * \n         * The only possible issue is maliablity in LeafOp, such as providing extra prefix data,\n         * which should be controlled by a spec. Eg. with lengthOp as NONE,\n         * prefix = FOO, key = BAR, value = CHOICE\n         * and\n         * prefix = F, key = OOBAR, value = CHOICE\n         * would produce the same value.\n         * \n         * With LengthOp this is tricker but not impossible. Which is why the \"leafPrefixEqual\" field\n         * in the ProofSpec is valuable to prevent this mutability. And why all trees should\n         * length-prefix the data before hashing it.\n         * @implements IExistenceProof\n         * @constructor\n         * @param {ics23.IExistenceProof=} [properties] Properties to set\n         */\n        function ExistenceProof(properties) {\n            this.path = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * ExistenceProof value.\n         * @member {Uint8Array} value\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.value = $util.newBuffer([]);\n\n        /**\n         * ExistenceProof leaf.\n         * @member {ics23.ILeafOp|null|undefined} leaf\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.leaf = null;\n\n        /**\n         * ExistenceProof path.\n         * @member {Array.<ics23.IInnerOp>} path\n         * @memberof ics23.ExistenceProof\n         * @instance\n         */\n        ExistenceProof.prototype.path = $util.emptyArray;\n\n        /**\n         * Creates a new ExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.IExistenceProof=} [properties] Properties to set\n         * @returns {ics23.ExistenceProof} ExistenceProof instance\n         */\n        ExistenceProof.create = function create(properties) {\n            return new ExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified ExistenceProof message. Does not implicitly {@link ics23.ExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.IExistenceProof} message ExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                $root.ics23.LeafOp.encode(message.leaf, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.path != null && message.path.length)\n                for (var i = 0; i < message.path.length; ++i)\n                    $root.ics23.InnerOp.encode(message.path[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified ExistenceProof message, length delimited. Does not implicitly {@link ics23.ExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.IExistenceProof} message ExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an ExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.ExistenceProof} ExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.ExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.value = reader.bytes();\n                    break;\n                case 3:\n                    message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    if (!(message.path && message.path.length))\n                        message.path = [];\n                    message.path.push($root.ics23.InnerOp.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an ExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.ExistenceProof} ExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an ExistenceProof message.\n         * @function verify\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        ExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value)))\n                    return \"value: buffer expected\";\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\")) {\n                var error = $root.ics23.LeafOp.verify(message.leaf);\n                if (error)\n                    return \"leaf.\" + error;\n            }\n            if (message.path != null && message.hasOwnProperty(\"path\")) {\n                if (!Array.isArray(message.path))\n                    return \"path: array expected\";\n                for (var i = 0; i < message.path.length; ++i) {\n                    var error = $root.ics23.InnerOp.verify(message.path[i]);\n                    if (error)\n                        return \"path.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates an ExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.ExistenceProof} ExistenceProof\n         */\n        ExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.ExistenceProof)\n                return object;\n            var message = new $root.ics23.ExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.value != null)\n                if (typeof object.value === \"string\")\n                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);\n                else if (object.value.length)\n                    message.value = object.value;\n            if (object.leaf != null) {\n                if (typeof object.leaf !== \"object\")\n                    throw TypeError(\".ics23.ExistenceProof.leaf: object expected\");\n                message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);\n            }\n            if (object.path) {\n                if (!Array.isArray(object.path))\n                    throw TypeError(\".ics23.ExistenceProof.path: array expected\");\n                message.path = [];\n                for (var i = 0; i < object.path.length; ++i) {\n                    if (typeof object.path[i] !== \"object\")\n                        throw TypeError(\".ics23.ExistenceProof.path: object expected\");\n                    message.path[i] = $root.ics23.InnerOp.fromObject(object.path[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an ExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.ExistenceProof\n         * @static\n         * @param {ics23.ExistenceProof} message ExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        ExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.path = [];\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                if (options.bytes === String)\n                    object.value = \"\";\n                else {\n                    object.value = [];\n                    if (options.bytes !== Array)\n                        object.value = $util.newBuffer(object.value);\n                }\n                object.leaf = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);\n            if (message.path && message.path.length) {\n                object.path = [];\n                for (var j = 0; j < message.path.length; ++j)\n                    object.path[j] = $root.ics23.InnerOp.toObject(message.path[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this ExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.ExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        ExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ExistenceProof;\n    })();\n\n    ics23.NonExistenceProof = (function() {\n\n        /**\n         * Properties of a NonExistenceProof.\n         * @memberof ics23\n         * @interface INonExistenceProof\n         * @property {Uint8Array|null} [key] NonExistenceProof key\n         * @property {ics23.IExistenceProof|null} [left] NonExistenceProof left\n         * @property {ics23.IExistenceProof|null} [right] NonExistenceProof right\n         */\n\n        /**\n         * Constructs a new NonExistenceProof.\n         * @memberof ics23\n         * @classdesc Represents a NonExistenceProof.\n         * @implements INonExistenceProof\n         * @constructor\n         * @param {ics23.INonExistenceProof=} [properties] Properties to set\n         */\n        function NonExistenceProof(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * NonExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         */\n        NonExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * NonExistenceProof left.\n         * @member {ics23.IExistenceProof|null|undefined} left\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         */\n        NonExistenceProof.prototype.left = null;\n\n        /**\n         * NonExistenceProof right.\n         * @member {ics23.IExistenceProof|null|undefined} right\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         */\n        NonExistenceProof.prototype.right = null;\n\n        /**\n         * Creates a new NonExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.INonExistenceProof=} [properties] Properties to set\n         * @returns {ics23.NonExistenceProof} NonExistenceProof instance\n         */\n        NonExistenceProof.create = function create(properties) {\n            return new NonExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified NonExistenceProof message. Does not implicitly {@link ics23.NonExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.INonExistenceProof} message NonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        NonExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                $root.ics23.ExistenceProof.encode(message.left, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                $root.ics23.ExistenceProof.encode(message.right, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified NonExistenceProof message, length delimited. Does not implicitly {@link ics23.NonExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.INonExistenceProof} message NonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        NonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a NonExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.NonExistenceProof} NonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        NonExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.NonExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.left = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.right = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a NonExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.NonExistenceProof} NonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        NonExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a NonExistenceProof message.\n         * @function verify\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        NonExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.left != null && message.hasOwnProperty(\"left\")) {\n                var error = $root.ics23.ExistenceProof.verify(message.left);\n                if (error)\n                    return \"left.\" + error;\n            }\n            if (message.right != null && message.hasOwnProperty(\"right\")) {\n                var error = $root.ics23.ExistenceProof.verify(message.right);\n                if (error)\n                    return \"right.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a NonExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.NonExistenceProof} NonExistenceProof\n         */\n        NonExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.NonExistenceProof)\n                return object;\n            var message = new $root.ics23.NonExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.left != null) {\n                if (typeof object.left !== \"object\")\n                    throw TypeError(\".ics23.NonExistenceProof.left: object expected\");\n                message.left = $root.ics23.ExistenceProof.fromObject(object.left);\n            }\n            if (object.right != null) {\n                if (typeof object.right !== \"object\")\n                    throw TypeError(\".ics23.NonExistenceProof.right: object expected\");\n                message.right = $root.ics23.ExistenceProof.fromObject(object.right);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a NonExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.NonExistenceProof\n         * @static\n         * @param {ics23.NonExistenceProof} message NonExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        NonExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                object.left = null;\n                object.right = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                object.left = $root.ics23.ExistenceProof.toObject(message.left, options);\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                object.right = $root.ics23.ExistenceProof.toObject(message.right, options);\n            return object;\n        };\n\n        /**\n         * Converts this NonExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.NonExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        NonExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return NonExistenceProof;\n    })();\n\n    ics23.CommitmentProof = (function() {\n\n        /**\n         * Properties of a CommitmentProof.\n         * @memberof ics23\n         * @interface ICommitmentProof\n         * @property {ics23.IExistenceProof|null} [exist] CommitmentProof exist\n         * @property {ics23.INonExistenceProof|null} [nonexist] CommitmentProof nonexist\n         * @property {ics23.IBatchProof|null} [batch] CommitmentProof batch\n         * @property {ics23.ICompressedBatchProof|null} [compressed] CommitmentProof compressed\n         */\n\n        /**\n         * Constructs a new CommitmentProof.\n         * @memberof ics23\n         * @classdesc Represents a CommitmentProof.\n         * @implements ICommitmentProof\n         * @constructor\n         * @param {ics23.ICommitmentProof=} [properties] Properties to set\n         */\n        function CommitmentProof(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CommitmentProof exist.\n         * @member {ics23.IExistenceProof|null|undefined} exist\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.exist = null;\n\n        /**\n         * CommitmentProof nonexist.\n         * @member {ics23.INonExistenceProof|null|undefined} nonexist\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.nonexist = null;\n\n        /**\n         * CommitmentProof batch.\n         * @member {ics23.IBatchProof|null|undefined} batch\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.batch = null;\n\n        /**\n         * CommitmentProof compressed.\n         * @member {ics23.ICompressedBatchProof|null|undefined} compressed\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        CommitmentProof.prototype.compressed = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * CommitmentProof proof.\n         * @member {\"exist\"|\"nonexist\"|\"batch\"|\"compressed\"|undefined} proof\n         * @memberof ics23.CommitmentProof\n         * @instance\n         */\n        Object.defineProperty(CommitmentProof.prototype, \"proof\", {\n            get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\", \"batch\", \"compressed\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new CommitmentProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.ICommitmentProof=} [properties] Properties to set\n         * @returns {ics23.CommitmentProof} CommitmentProof instance\n         */\n        CommitmentProof.create = function create(properties) {\n            return new CommitmentProof(properties);\n        };\n\n        /**\n         * Encodes the specified CommitmentProof message. Does not implicitly {@link ics23.CommitmentProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.ICommitmentProof} message CommitmentProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CommitmentProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.exist != null && message.hasOwnProperty(\"exist\"))\n                $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\"))\n                $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.batch != null && message.hasOwnProperty(\"batch\"))\n                $root.ics23.BatchProof.encode(message.batch, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.compressed != null && message.hasOwnProperty(\"compressed\"))\n                $root.ics23.CompressedBatchProof.encode(message.compressed, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CommitmentProof message, length delimited. Does not implicitly {@link ics23.CommitmentProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.ICommitmentProof} message CommitmentProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CommitmentProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CommitmentProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CommitmentProof} CommitmentProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CommitmentProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CommitmentProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.batch = $root.ics23.BatchProof.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.compressed = $root.ics23.CompressedBatchProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CommitmentProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CommitmentProof} CommitmentProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CommitmentProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CommitmentProof message.\n         * @function verify\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CommitmentProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.ExistenceProof.verify(message.exist);\n                    if (error)\n                        return \"exist.\" + error;\n                }\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.NonExistenceProof.verify(message.nonexist);\n                    if (error)\n                        return \"nonexist.\" + error;\n                }\n            }\n            if (message.batch != null && message.hasOwnProperty(\"batch\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.BatchProof.verify(message.batch);\n                    if (error)\n                        return \"batch.\" + error;\n                }\n            }\n            if (message.compressed != null && message.hasOwnProperty(\"compressed\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.CompressedBatchProof.verify(message.compressed);\n                    if (error)\n                        return \"compressed.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CommitmentProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CommitmentProof} CommitmentProof\n         */\n        CommitmentProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CommitmentProof)\n                return object;\n            var message = new $root.ics23.CommitmentProof();\n            if (object.exist != null) {\n                if (typeof object.exist !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.exist: object expected\");\n                message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);\n            }\n            if (object.nonexist != null) {\n                if (typeof object.nonexist !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.nonexist: object expected\");\n                message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);\n            }\n            if (object.batch != null) {\n                if (typeof object.batch !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.batch: object expected\");\n                message.batch = $root.ics23.BatchProof.fromObject(object.batch);\n            }\n            if (object.compressed != null) {\n                if (typeof object.compressed !== \"object\")\n                    throw TypeError(\".ics23.CommitmentProof.compressed: object expected\");\n                message.compressed = $root.ics23.CompressedBatchProof.fromObject(object.compressed);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CommitmentProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CommitmentProof\n         * @static\n         * @param {ics23.CommitmentProof} message CommitmentProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CommitmentProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);\n                if (options.oneofs)\n                    object.proof = \"exist\";\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);\n                if (options.oneofs)\n                    object.proof = \"nonexist\";\n            }\n            if (message.batch != null && message.hasOwnProperty(\"batch\")) {\n                object.batch = $root.ics23.BatchProof.toObject(message.batch, options);\n                if (options.oneofs)\n                    object.proof = \"batch\";\n            }\n            if (message.compressed != null && message.hasOwnProperty(\"compressed\")) {\n                object.compressed = $root.ics23.CompressedBatchProof.toObject(message.compressed, options);\n                if (options.oneofs)\n                    object.proof = \"compressed\";\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CommitmentProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CommitmentProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CommitmentProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CommitmentProof;\n    })();\n\n    ics23.LeafOp = (function() {\n\n        /**\n         * Properties of a LeafOp.\n         * @memberof ics23\n         * @interface ILeafOp\n         * @property {ics23.HashOp|null} [hash] LeafOp hash\n         * @property {ics23.HashOp|null} [prehashKey] LeafOp prehashKey\n         * @property {ics23.HashOp|null} [prehashValue] LeafOp prehashValue\n         * @property {ics23.LengthOp|null} [length] LeafOp length\n         * @property {Uint8Array|null} [prefix] LeafOp prefix\n         */\n\n        /**\n         * Constructs a new LeafOp.\n         * @memberof ics23\n         * @classdesc LeafOp represents the raw key-value data we wish to prove, and\n         * must be flexible to represent the internal transformation from\n         * the original key-value pairs into the basis hash, for many existing\n         * merkle trees.\n         * \n         * key and value are passed in. So that the signature of this operation is:\n         * leafOp(key, value) -> output\n         * \n         * To process this, first prehash the keys and values if needed (ANY means no hash in this case):\n         * hkey = prehashKey(key)\n         * hvalue = prehashValue(value)\n         * \n         * Then combine the bytes, and hash it\n         * output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)\n         * @implements ILeafOp\n         * @constructor\n         * @param {ics23.ILeafOp=} [properties] Properties to set\n         */\n        function LeafOp(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * LeafOp hash.\n         * @member {ics23.HashOp} hash\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.hash = 0;\n\n        /**\n         * LeafOp prehashKey.\n         * @member {ics23.HashOp} prehashKey\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.prehashKey = 0;\n\n        /**\n         * LeafOp prehashValue.\n         * @member {ics23.HashOp} prehashValue\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.prehashValue = 0;\n\n        /**\n         * LeafOp length.\n         * @member {ics23.LengthOp} length\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.length = 0;\n\n        /**\n         * LeafOp prefix.\n         * @member {Uint8Array} prefix\n         * @memberof ics23.LeafOp\n         * @instance\n         */\n        LeafOp.prototype.prefix = $util.newBuffer([]);\n\n        /**\n         * Creates a new LeafOp instance using the specified properties.\n         * @function create\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.ILeafOp=} [properties] Properties to set\n         * @returns {ics23.LeafOp} LeafOp instance\n         */\n        LeafOp.create = function create(properties) {\n            return new LeafOp(properties);\n        };\n\n        /**\n         * Encodes the specified LeafOp message. Does not implicitly {@link ics23.LeafOp.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.ILeafOp} message LeafOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LeafOp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hash);\n            if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.prehashKey);\n            if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.prehashValue);\n            if (message.length != null && message.hasOwnProperty(\"length\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.length);\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.prefix);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified LeafOp message, length delimited. Does not implicitly {@link ics23.LeafOp.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.ILeafOp} message LeafOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        LeafOp.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a LeafOp message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.LeafOp} LeafOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LeafOp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.LeafOp();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.hash = reader.int32();\n                    break;\n                case 2:\n                    message.prehashKey = reader.int32();\n                    break;\n                case 3:\n                    message.prehashValue = reader.int32();\n                    break;\n                case 4:\n                    message.length = reader.int32();\n                    break;\n                case 5:\n                    message.prefix = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a LeafOp message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.LeafOp} LeafOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        LeafOp.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a LeafOp message.\n         * @function verify\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        LeafOp.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                switch (message.hash) {\n                default:\n                    return \"hash: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\"))\n                switch (message.prehashKey) {\n                default:\n                    return \"prehashKey: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\"))\n                switch (message.prehashValue) {\n                default:\n                    return \"prehashValue: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.length != null && message.hasOwnProperty(\"length\"))\n                switch (message.length) {\n                default:\n                    return \"length: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                case 7:\n                case 8:\n                    break;\n                }\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                if (!(message.prefix && typeof message.prefix.length === \"number\" || $util.isString(message.prefix)))\n                    return \"prefix: buffer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a LeafOp message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.LeafOp} LeafOp\n         */\n        LeafOp.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.LeafOp)\n                return object;\n            var message = new $root.ics23.LeafOp();\n            switch (object.hash) {\n            case \"NO_HASH\":\n            case 0:\n                message.hash = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.hash = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.hash = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.hash = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.hash = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.hash = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.hash = 6;\n                break;\n            }\n            switch (object.prehashKey) {\n            case \"NO_HASH\":\n            case 0:\n                message.prehashKey = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.prehashKey = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.prehashKey = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.prehashKey = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.prehashKey = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.prehashKey = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.prehashKey = 6;\n                break;\n            }\n            switch (object.prehashValue) {\n            case \"NO_HASH\":\n            case 0:\n                message.prehashValue = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.prehashValue = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.prehashValue = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.prehashValue = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.prehashValue = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.prehashValue = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.prehashValue = 6;\n                break;\n            }\n            switch (object.length) {\n            case \"NO_PREFIX\":\n            case 0:\n                message.length = 0;\n                break;\n            case \"VAR_PROTO\":\n            case 1:\n                message.length = 1;\n                break;\n            case \"VAR_RLP\":\n            case 2:\n                message.length = 2;\n                break;\n            case \"FIXED32_BIG\":\n            case 3:\n                message.length = 3;\n                break;\n            case \"FIXED32_LITTLE\":\n            case 4:\n                message.length = 4;\n                break;\n            case \"FIXED64_BIG\":\n            case 5:\n                message.length = 5;\n                break;\n            case \"FIXED64_LITTLE\":\n            case 6:\n                message.length = 6;\n                break;\n            case \"REQUIRE_32_BYTES\":\n            case 7:\n                message.length = 7;\n                break;\n            case \"REQUIRE_64_BYTES\":\n            case 8:\n                message.length = 8;\n                break;\n            }\n            if (object.prefix != null)\n                if (typeof object.prefix === \"string\")\n                    $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);\n                else if (object.prefix.length)\n                    message.prefix = object.prefix;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a LeafOp message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.LeafOp\n         * @static\n         * @param {ics23.LeafOp} message LeafOp\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        LeafOp.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.hash = options.enums === String ? \"NO_HASH\" : 0;\n                object.prehashKey = options.enums === String ? \"NO_HASH\" : 0;\n                object.prehashValue = options.enums === String ? \"NO_HASH\" : 0;\n                object.length = options.enums === String ? \"NO_PREFIX\" : 0;\n                if (options.bytes === String)\n                    object.prefix = \"\";\n                else {\n                    object.prefix = [];\n                    if (options.bytes !== Array)\n                        object.prefix = $util.newBuffer(object.prefix);\n                }\n            }\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n            if (message.prehashKey != null && message.hasOwnProperty(\"prehashKey\"))\n                object.prehashKey = options.enums === String ? $root.ics23.HashOp[message.prehashKey] : message.prehashKey;\n            if (message.prehashValue != null && message.hasOwnProperty(\"prehashValue\"))\n                object.prehashValue = options.enums === String ? $root.ics23.HashOp[message.prehashValue] : message.prehashValue;\n            if (message.length != null && message.hasOwnProperty(\"length\"))\n                object.length = options.enums === String ? $root.ics23.LengthOp[message.length] : message.length;\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;\n            return object;\n        };\n\n        /**\n         * Converts this LeafOp to JSON.\n         * @function toJSON\n         * @memberof ics23.LeafOp\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        LeafOp.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return LeafOp;\n    })();\n\n    ics23.InnerOp = (function() {\n\n        /**\n         * Properties of an InnerOp.\n         * @memberof ics23\n         * @interface IInnerOp\n         * @property {ics23.HashOp|null} [hash] InnerOp hash\n         * @property {Uint8Array|null} [prefix] InnerOp prefix\n         * @property {Uint8Array|null} [suffix] InnerOp suffix\n         */\n\n        /**\n         * Constructs a new InnerOp.\n         * @memberof ics23\n         * @classdesc InnerOp represents a merkle-proof step that is not a leaf.\n         * It represents concatenating two children and hashing them to provide the next result.\n         * \n         * The result of the previous step is passed in, so the signature of this op is:\n         * innerOp(child) -> output\n         * \n         * The result of applying InnerOp should be:\n         * output = op.hash(op.prefix || child || op.suffix)\n         * \n         * where the || operator is concatenation of binary data,\n         * and child is the result of hashing all the tree below this step.\n         * \n         * Any special data, like prepending child with the length, or prepending the entire operation with\n         * some value to differentiate from leaf nodes, should be included in prefix and suffix.\n         * If either of prefix or suffix is empty, we just treat it as an empty string\n         * @implements IInnerOp\n         * @constructor\n         * @param {ics23.IInnerOp=} [properties] Properties to set\n         */\n        function InnerOp(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * InnerOp hash.\n         * @member {ics23.HashOp} hash\n         * @memberof ics23.InnerOp\n         * @instance\n         */\n        InnerOp.prototype.hash = 0;\n\n        /**\n         * InnerOp prefix.\n         * @member {Uint8Array} prefix\n         * @memberof ics23.InnerOp\n         * @instance\n         */\n        InnerOp.prototype.prefix = $util.newBuffer([]);\n\n        /**\n         * InnerOp suffix.\n         * @member {Uint8Array} suffix\n         * @memberof ics23.InnerOp\n         * @instance\n         */\n        InnerOp.prototype.suffix = $util.newBuffer([]);\n\n        /**\n         * Creates a new InnerOp instance using the specified properties.\n         * @function create\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.IInnerOp=} [properties] Properties to set\n         * @returns {ics23.InnerOp} InnerOp instance\n         */\n        InnerOp.create = function create(properties) {\n            return new InnerOp(properties);\n        };\n\n        /**\n         * Encodes the specified InnerOp message. Does not implicitly {@link ics23.InnerOp.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.IInnerOp} message InnerOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerOp.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hash);\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.prefix);\n            if (message.suffix != null && message.hasOwnProperty(\"suffix\"))\n                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.suffix);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified InnerOp message, length delimited. Does not implicitly {@link ics23.InnerOp.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.IInnerOp} message InnerOp message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerOp.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an InnerOp message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.InnerOp} InnerOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerOp.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.InnerOp();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.hash = reader.int32();\n                    break;\n                case 2:\n                    message.prefix = reader.bytes();\n                    break;\n                case 3:\n                    message.suffix = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an InnerOp message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.InnerOp} InnerOp\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerOp.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an InnerOp message.\n         * @function verify\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        InnerOp.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                switch (message.hash) {\n                default:\n                    return \"hash: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                if (!(message.prefix && typeof message.prefix.length === \"number\" || $util.isString(message.prefix)))\n                    return \"prefix: buffer expected\";\n            if (message.suffix != null && message.hasOwnProperty(\"suffix\"))\n                if (!(message.suffix && typeof message.suffix.length === \"number\" || $util.isString(message.suffix)))\n                    return \"suffix: buffer expected\";\n            return null;\n        };\n\n        /**\n         * Creates an InnerOp message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.InnerOp} InnerOp\n         */\n        InnerOp.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.InnerOp)\n                return object;\n            var message = new $root.ics23.InnerOp();\n            switch (object.hash) {\n            case \"NO_HASH\":\n            case 0:\n                message.hash = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.hash = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.hash = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.hash = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.hash = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.hash = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.hash = 6;\n                break;\n            }\n            if (object.prefix != null)\n                if (typeof object.prefix === \"string\")\n                    $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);\n                else if (object.prefix.length)\n                    message.prefix = object.prefix;\n            if (object.suffix != null)\n                if (typeof object.suffix === \"string\")\n                    $util.base64.decode(object.suffix, message.suffix = $util.newBuffer($util.base64.length(object.suffix)), 0);\n                else if (object.suffix.length)\n                    message.suffix = object.suffix;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an InnerOp message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.InnerOp\n         * @static\n         * @param {ics23.InnerOp} message InnerOp\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        InnerOp.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.hash = options.enums === String ? \"NO_HASH\" : 0;\n                if (options.bytes === String)\n                    object.prefix = \"\";\n                else {\n                    object.prefix = [];\n                    if (options.bytes !== Array)\n                        object.prefix = $util.newBuffer(object.prefix);\n                }\n                if (options.bytes === String)\n                    object.suffix = \"\";\n                else {\n                    object.suffix = [];\n                    if (options.bytes !== Array)\n                        object.suffix = $util.newBuffer(object.suffix);\n                }\n            }\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n            if (message.prefix != null && message.hasOwnProperty(\"prefix\"))\n                object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;\n            if (message.suffix != null && message.hasOwnProperty(\"suffix\"))\n                object.suffix = options.bytes === String ? $util.base64.encode(message.suffix, 0, message.suffix.length) : options.bytes === Array ? Array.prototype.slice.call(message.suffix) : message.suffix;\n            return object;\n        };\n\n        /**\n         * Converts this InnerOp to JSON.\n         * @function toJSON\n         * @memberof ics23.InnerOp\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        InnerOp.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return InnerOp;\n    })();\n\n    ics23.ProofSpec = (function() {\n\n        /**\n         * Properties of a ProofSpec.\n         * @memberof ics23\n         * @interface IProofSpec\n         * @property {ics23.ILeafOp|null} [leafSpec] ProofSpec leafSpec\n         * @property {ics23.IInnerSpec|null} [innerSpec] ProofSpec innerSpec\n         * @property {number|null} [maxDepth] ProofSpec maxDepth\n         * @property {number|null} [minDepth] ProofSpec minDepth\n         */\n\n        /**\n         * Constructs a new ProofSpec.\n         * @memberof ics23\n         * @classdesc ProofSpec defines what the expected parameters are for a given proof type.\n         * This can be stored in the client and used to validate any incoming proofs.\n         * \n         * verify(ProofSpec, Proof) -> Proof | Error\n         * \n         * As demonstrated in tests, if we don't fix the algorithm used to calculate the\n         * LeafHash for a given tree, there are many possible key-value pairs that can\n         * generate a given hash (by interpretting the preimage differently).\n         * We need this for proper security, requires client knows a priori what\n         * tree format server uses. But not in code, rather a configuration object.\n         * @implements IProofSpec\n         * @constructor\n         * @param {ics23.IProofSpec=} [properties] Properties to set\n         */\n        function ProofSpec(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * ProofSpec leafSpec.\n         * @member {ics23.ILeafOp|null|undefined} leafSpec\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.leafSpec = null;\n\n        /**\n         * ProofSpec innerSpec.\n         * @member {ics23.IInnerSpec|null|undefined} innerSpec\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.innerSpec = null;\n\n        /**\n         * ProofSpec maxDepth.\n         * @member {number} maxDepth\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.maxDepth = 0;\n\n        /**\n         * ProofSpec minDepth.\n         * @member {number} minDepth\n         * @memberof ics23.ProofSpec\n         * @instance\n         */\n        ProofSpec.prototype.minDepth = 0;\n\n        /**\n         * Creates a new ProofSpec instance using the specified properties.\n         * @function create\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.IProofSpec=} [properties] Properties to set\n         * @returns {ics23.ProofSpec} ProofSpec instance\n         */\n        ProofSpec.create = function create(properties) {\n            return new ProofSpec(properties);\n        };\n\n        /**\n         * Encodes the specified ProofSpec message. Does not implicitly {@link ics23.ProofSpec.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.IProofSpec} message ProofSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ProofSpec.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\"))\n                $root.ics23.LeafOp.encode(message.leafSpec, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\"))\n                $root.ics23.InnerSpec.encode(message.innerSpec, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.maxDepth);\n            if (message.minDepth != null && message.hasOwnProperty(\"minDepth\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.minDepth);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified ProofSpec message, length delimited. Does not implicitly {@link ics23.ProofSpec.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.IProofSpec} message ProofSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        ProofSpec.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a ProofSpec message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.ProofSpec} ProofSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ProofSpec.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.ProofSpec();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.leafSpec = $root.ics23.LeafOp.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.innerSpec = $root.ics23.InnerSpec.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.maxDepth = reader.int32();\n                    break;\n                case 4:\n                    message.minDepth = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a ProofSpec message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.ProofSpec} ProofSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ProofSpec.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a ProofSpec message.\n         * @function verify\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        ProofSpec.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\")) {\n                var error = $root.ics23.LeafOp.verify(message.leafSpec);\n                if (error)\n                    return \"leafSpec.\" + error;\n            }\n            if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\")) {\n                var error = $root.ics23.InnerSpec.verify(message.innerSpec);\n                if (error)\n                    return \"innerSpec.\" + error;\n            }\n            if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\"))\n                if (!$util.isInteger(message.maxDepth))\n                    return \"maxDepth: integer expected\";\n            if (message.minDepth != null && message.hasOwnProperty(\"minDepth\"))\n                if (!$util.isInteger(message.minDepth))\n                    return \"minDepth: integer expected\";\n            return null;\n        };\n\n        /**\n         * Creates a ProofSpec message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.ProofSpec} ProofSpec\n         */\n        ProofSpec.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.ProofSpec)\n                return object;\n            var message = new $root.ics23.ProofSpec();\n            if (object.leafSpec != null) {\n                if (typeof object.leafSpec !== \"object\")\n                    throw TypeError(\".ics23.ProofSpec.leafSpec: object expected\");\n                message.leafSpec = $root.ics23.LeafOp.fromObject(object.leafSpec);\n            }\n            if (object.innerSpec != null) {\n                if (typeof object.innerSpec !== \"object\")\n                    throw TypeError(\".ics23.ProofSpec.innerSpec: object expected\");\n                message.innerSpec = $root.ics23.InnerSpec.fromObject(object.innerSpec);\n            }\n            if (object.maxDepth != null)\n                message.maxDepth = object.maxDepth | 0;\n            if (object.minDepth != null)\n                message.minDepth = object.minDepth | 0;\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a ProofSpec message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.ProofSpec\n         * @static\n         * @param {ics23.ProofSpec} message ProofSpec\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        ProofSpec.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                object.leafSpec = null;\n                object.innerSpec = null;\n                object.maxDepth = 0;\n                object.minDepth = 0;\n            }\n            if (message.leafSpec != null && message.hasOwnProperty(\"leafSpec\"))\n                object.leafSpec = $root.ics23.LeafOp.toObject(message.leafSpec, options);\n            if (message.innerSpec != null && message.hasOwnProperty(\"innerSpec\"))\n                object.innerSpec = $root.ics23.InnerSpec.toObject(message.innerSpec, options);\n            if (message.maxDepth != null && message.hasOwnProperty(\"maxDepth\"))\n                object.maxDepth = message.maxDepth;\n            if (message.minDepth != null && message.hasOwnProperty(\"minDepth\"))\n                object.minDepth = message.minDepth;\n            return object;\n        };\n\n        /**\n         * Converts this ProofSpec to JSON.\n         * @function toJSON\n         * @memberof ics23.ProofSpec\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        ProofSpec.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return ProofSpec;\n    })();\n\n    ics23.InnerSpec = (function() {\n\n        /**\n         * Properties of an InnerSpec.\n         * @memberof ics23\n         * @interface IInnerSpec\n         * @property {Array.<number>|null} [childOrder] InnerSpec childOrder\n         * @property {number|null} [childSize] InnerSpec childSize\n         * @property {number|null} [minPrefixLength] InnerSpec minPrefixLength\n         * @property {number|null} [maxPrefixLength] InnerSpec maxPrefixLength\n         * @property {Uint8Array|null} [emptyChild] InnerSpec emptyChild\n         * @property {ics23.HashOp|null} [hash] InnerSpec hash\n         */\n\n        /**\n         * Constructs a new InnerSpec.\n         * @memberof ics23\n         * @classdesc Represents an InnerSpec.\n         * @implements IInnerSpec\n         * @constructor\n         * @param {ics23.IInnerSpec=} [properties] Properties to set\n         */\n        function InnerSpec(properties) {\n            this.childOrder = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * InnerSpec childOrder.\n         * @member {Array.<number>} childOrder\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.childOrder = $util.emptyArray;\n\n        /**\n         * InnerSpec childSize.\n         * @member {number} childSize\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.childSize = 0;\n\n        /**\n         * InnerSpec minPrefixLength.\n         * @member {number} minPrefixLength\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.minPrefixLength = 0;\n\n        /**\n         * InnerSpec maxPrefixLength.\n         * @member {number} maxPrefixLength\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.maxPrefixLength = 0;\n\n        /**\n         * InnerSpec emptyChild.\n         * @member {Uint8Array} emptyChild\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.emptyChild = $util.newBuffer([]);\n\n        /**\n         * InnerSpec hash.\n         * @member {ics23.HashOp} hash\n         * @memberof ics23.InnerSpec\n         * @instance\n         */\n        InnerSpec.prototype.hash = 0;\n\n        /**\n         * Creates a new InnerSpec instance using the specified properties.\n         * @function create\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.IInnerSpec=} [properties] Properties to set\n         * @returns {ics23.InnerSpec} InnerSpec instance\n         */\n        InnerSpec.create = function create(properties) {\n            return new InnerSpec(properties);\n        };\n\n        /**\n         * Encodes the specified InnerSpec message. Does not implicitly {@link ics23.InnerSpec.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.IInnerSpec} message InnerSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerSpec.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.childOrder != null && message.childOrder.length) {\n                writer.uint32(/* id 1, wireType 2 =*/10).fork();\n                for (var i = 0; i < message.childOrder.length; ++i)\n                    writer.int32(message.childOrder[i]);\n                writer.ldelim();\n            }\n            if (message.childSize != null && message.hasOwnProperty(\"childSize\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.childSize);\n            if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.minPrefixLength);\n            if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.maxPrefixLength);\n            if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\"))\n                writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.emptyChild);\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.hash);\n            return writer;\n        };\n\n        /**\n         * Encodes the specified InnerSpec message, length delimited. Does not implicitly {@link ics23.InnerSpec.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.IInnerSpec} message InnerSpec message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        InnerSpec.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes an InnerSpec message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.InnerSpec} InnerSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerSpec.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.InnerSpec();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.childOrder && message.childOrder.length))\n                        message.childOrder = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.childOrder.push(reader.int32());\n                    } else\n                        message.childOrder.push(reader.int32());\n                    break;\n                case 2:\n                    message.childSize = reader.int32();\n                    break;\n                case 3:\n                    message.minPrefixLength = reader.int32();\n                    break;\n                case 4:\n                    message.maxPrefixLength = reader.int32();\n                    break;\n                case 5:\n                    message.emptyChild = reader.bytes();\n                    break;\n                case 6:\n                    message.hash = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes an InnerSpec message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.InnerSpec} InnerSpec\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        InnerSpec.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies an InnerSpec message.\n         * @function verify\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        InnerSpec.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.childOrder != null && message.hasOwnProperty(\"childOrder\")) {\n                if (!Array.isArray(message.childOrder))\n                    return \"childOrder: array expected\";\n                for (var i = 0; i < message.childOrder.length; ++i)\n                    if (!$util.isInteger(message.childOrder[i]))\n                        return \"childOrder: integer[] expected\";\n            }\n            if (message.childSize != null && message.hasOwnProperty(\"childSize\"))\n                if (!$util.isInteger(message.childSize))\n                    return \"childSize: integer expected\";\n            if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\"))\n                if (!$util.isInteger(message.minPrefixLength))\n                    return \"minPrefixLength: integer expected\";\n            if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\"))\n                if (!$util.isInteger(message.maxPrefixLength))\n                    return \"maxPrefixLength: integer expected\";\n            if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\"))\n                if (!(message.emptyChild && typeof message.emptyChild.length === \"number\" || $util.isString(message.emptyChild)))\n                    return \"emptyChild: buffer expected\";\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                switch (message.hash) {\n                default:\n                    return \"hash: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                    break;\n                }\n            return null;\n        };\n\n        /**\n         * Creates an InnerSpec message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.InnerSpec} InnerSpec\n         */\n        InnerSpec.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.InnerSpec)\n                return object;\n            var message = new $root.ics23.InnerSpec();\n            if (object.childOrder) {\n                if (!Array.isArray(object.childOrder))\n                    throw TypeError(\".ics23.InnerSpec.childOrder: array expected\");\n                message.childOrder = [];\n                for (var i = 0; i < object.childOrder.length; ++i)\n                    message.childOrder[i] = object.childOrder[i] | 0;\n            }\n            if (object.childSize != null)\n                message.childSize = object.childSize | 0;\n            if (object.minPrefixLength != null)\n                message.minPrefixLength = object.minPrefixLength | 0;\n            if (object.maxPrefixLength != null)\n                message.maxPrefixLength = object.maxPrefixLength | 0;\n            if (object.emptyChild != null)\n                if (typeof object.emptyChild === \"string\")\n                    $util.base64.decode(object.emptyChild, message.emptyChild = $util.newBuffer($util.base64.length(object.emptyChild)), 0);\n                else if (object.emptyChild.length)\n                    message.emptyChild = object.emptyChild;\n            switch (object.hash) {\n            case \"NO_HASH\":\n            case 0:\n                message.hash = 0;\n                break;\n            case \"SHA256\":\n            case 1:\n                message.hash = 1;\n                break;\n            case \"SHA512\":\n            case 2:\n                message.hash = 2;\n                break;\n            case \"KECCAK\":\n            case 3:\n                message.hash = 3;\n                break;\n            case \"RIPEMD160\":\n            case 4:\n                message.hash = 4;\n                break;\n            case \"BITCOIN\":\n            case 5:\n                message.hash = 5;\n                break;\n            case \"SHA512_256\":\n            case 6:\n                message.hash = 6;\n                break;\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from an InnerSpec message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.InnerSpec\n         * @static\n         * @param {ics23.InnerSpec} message InnerSpec\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        InnerSpec.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.childOrder = [];\n            if (options.defaults) {\n                object.childSize = 0;\n                object.minPrefixLength = 0;\n                object.maxPrefixLength = 0;\n                if (options.bytes === String)\n                    object.emptyChild = \"\";\n                else {\n                    object.emptyChild = [];\n                    if (options.bytes !== Array)\n                        object.emptyChild = $util.newBuffer(object.emptyChild);\n                }\n                object.hash = options.enums === String ? \"NO_HASH\" : 0;\n            }\n            if (message.childOrder && message.childOrder.length) {\n                object.childOrder = [];\n                for (var j = 0; j < message.childOrder.length; ++j)\n                    object.childOrder[j] = message.childOrder[j];\n            }\n            if (message.childSize != null && message.hasOwnProperty(\"childSize\"))\n                object.childSize = message.childSize;\n            if (message.minPrefixLength != null && message.hasOwnProperty(\"minPrefixLength\"))\n                object.minPrefixLength = message.minPrefixLength;\n            if (message.maxPrefixLength != null && message.hasOwnProperty(\"maxPrefixLength\"))\n                object.maxPrefixLength = message.maxPrefixLength;\n            if (message.emptyChild != null && message.hasOwnProperty(\"emptyChild\"))\n                object.emptyChild = options.bytes === String ? $util.base64.encode(message.emptyChild, 0, message.emptyChild.length) : options.bytes === Array ? Array.prototype.slice.call(message.emptyChild) : message.emptyChild;\n            if (message.hash != null && message.hasOwnProperty(\"hash\"))\n                object.hash = options.enums === String ? $root.ics23.HashOp[message.hash] : message.hash;\n            return object;\n        };\n\n        /**\n         * Converts this InnerSpec to JSON.\n         * @function toJSON\n         * @memberof ics23.InnerSpec\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        InnerSpec.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return InnerSpec;\n    })();\n\n    ics23.BatchProof = (function() {\n\n        /**\n         * Properties of a BatchProof.\n         * @memberof ics23\n         * @interface IBatchProof\n         * @property {Array.<ics23.IBatchEntry>|null} [entries] BatchProof entries\n         */\n\n        /**\n         * Constructs a new BatchProof.\n         * @memberof ics23\n         * @classdesc Represents a BatchProof.\n         * @implements IBatchProof\n         * @constructor\n         * @param {ics23.IBatchProof=} [properties] Properties to set\n         */\n        function BatchProof(properties) {\n            this.entries = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BatchProof entries.\n         * @member {Array.<ics23.IBatchEntry>} entries\n         * @memberof ics23.BatchProof\n         * @instance\n         */\n        BatchProof.prototype.entries = $util.emptyArray;\n\n        /**\n         * Creates a new BatchProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.IBatchProof=} [properties] Properties to set\n         * @returns {ics23.BatchProof} BatchProof instance\n         */\n        BatchProof.create = function create(properties) {\n            return new BatchProof(properties);\n        };\n\n        /**\n         * Encodes the specified BatchProof message. Does not implicitly {@link ics23.BatchProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.IBatchProof} message BatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.entries != null && message.entries.length)\n                for (var i = 0; i < message.entries.length; ++i)\n                    $root.ics23.BatchEntry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BatchProof message, length delimited. Does not implicitly {@link ics23.BatchProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.IBatchProof} message BatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BatchProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.BatchProof} BatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.BatchProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.entries && message.entries.length))\n                        message.entries = [];\n                    message.entries.push($root.ics23.BatchEntry.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BatchProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.BatchProof} BatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BatchProof message.\n         * @function verify\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BatchProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.entries != null && message.hasOwnProperty(\"entries\")) {\n                if (!Array.isArray(message.entries))\n                    return \"entries: array expected\";\n                for (var i = 0; i < message.entries.length; ++i) {\n                    var error = $root.ics23.BatchEntry.verify(message.entries[i]);\n                    if (error)\n                        return \"entries.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a BatchProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.BatchProof} BatchProof\n         */\n        BatchProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.BatchProof)\n                return object;\n            var message = new $root.ics23.BatchProof();\n            if (object.entries) {\n                if (!Array.isArray(object.entries))\n                    throw TypeError(\".ics23.BatchProof.entries: array expected\");\n                message.entries = [];\n                for (var i = 0; i < object.entries.length; ++i) {\n                    if (typeof object.entries[i] !== \"object\")\n                        throw TypeError(\".ics23.BatchProof.entries: object expected\");\n                    message.entries[i] = $root.ics23.BatchEntry.fromObject(object.entries[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BatchProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.BatchProof\n         * @static\n         * @param {ics23.BatchProof} message BatchProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BatchProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.entries = [];\n            if (message.entries && message.entries.length) {\n                object.entries = [];\n                for (var j = 0; j < message.entries.length; ++j)\n                    object.entries[j] = $root.ics23.BatchEntry.toObject(message.entries[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this BatchProof to JSON.\n         * @function toJSON\n         * @memberof ics23.BatchProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BatchProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BatchProof;\n    })();\n\n    ics23.BatchEntry = (function() {\n\n        /**\n         * Properties of a BatchEntry.\n         * @memberof ics23\n         * @interface IBatchEntry\n         * @property {ics23.IExistenceProof|null} [exist] BatchEntry exist\n         * @property {ics23.INonExistenceProof|null} [nonexist] BatchEntry nonexist\n         */\n\n        /**\n         * Constructs a new BatchEntry.\n         * @memberof ics23\n         * @classdesc Represents a BatchEntry.\n         * @implements IBatchEntry\n         * @constructor\n         * @param {ics23.IBatchEntry=} [properties] Properties to set\n         */\n        function BatchEntry(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * BatchEntry exist.\n         * @member {ics23.IExistenceProof|null|undefined} exist\n         * @memberof ics23.BatchEntry\n         * @instance\n         */\n        BatchEntry.prototype.exist = null;\n\n        /**\n         * BatchEntry nonexist.\n         * @member {ics23.INonExistenceProof|null|undefined} nonexist\n         * @memberof ics23.BatchEntry\n         * @instance\n         */\n        BatchEntry.prototype.nonexist = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * BatchEntry proof.\n         * @member {\"exist\"|\"nonexist\"|undefined} proof\n         * @memberof ics23.BatchEntry\n         * @instance\n         */\n        Object.defineProperty(BatchEntry.prototype, \"proof\", {\n            get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new BatchEntry instance using the specified properties.\n         * @function create\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.IBatchEntry=} [properties] Properties to set\n         * @returns {ics23.BatchEntry} BatchEntry instance\n         */\n        BatchEntry.create = function create(properties) {\n            return new BatchEntry(properties);\n        };\n\n        /**\n         * Encodes the specified BatchEntry message. Does not implicitly {@link ics23.BatchEntry.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.IBatchEntry} message BatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchEntry.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.exist != null && message.hasOwnProperty(\"exist\"))\n                $root.ics23.ExistenceProof.encode(message.exist, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\"))\n                $root.ics23.NonExistenceProof.encode(message.nonexist, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified BatchEntry message, length delimited. Does not implicitly {@link ics23.BatchEntry.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.IBatchEntry} message BatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        BatchEntry.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a BatchEntry message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.BatchEntry} BatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchEntry.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.BatchEntry();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.exist = $root.ics23.ExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.nonexist = $root.ics23.NonExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a BatchEntry message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.BatchEntry} BatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        BatchEntry.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a BatchEntry message.\n         * @function verify\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        BatchEntry.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.ExistenceProof.verify(message.exist);\n                    if (error)\n                        return \"exist.\" + error;\n                }\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.NonExistenceProof.verify(message.nonexist);\n                    if (error)\n                        return \"nonexist.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a BatchEntry message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.BatchEntry} BatchEntry\n         */\n        BatchEntry.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.BatchEntry)\n                return object;\n            var message = new $root.ics23.BatchEntry();\n            if (object.exist != null) {\n                if (typeof object.exist !== \"object\")\n                    throw TypeError(\".ics23.BatchEntry.exist: object expected\");\n                message.exist = $root.ics23.ExistenceProof.fromObject(object.exist);\n            }\n            if (object.nonexist != null) {\n                if (typeof object.nonexist !== \"object\")\n                    throw TypeError(\".ics23.BatchEntry.nonexist: object expected\");\n                message.nonexist = $root.ics23.NonExistenceProof.fromObject(object.nonexist);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a BatchEntry message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.BatchEntry\n         * @static\n         * @param {ics23.BatchEntry} message BatchEntry\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        BatchEntry.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                object.exist = $root.ics23.ExistenceProof.toObject(message.exist, options);\n                if (options.oneofs)\n                    object.proof = \"exist\";\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                object.nonexist = $root.ics23.NonExistenceProof.toObject(message.nonexist, options);\n                if (options.oneofs)\n                    object.proof = \"nonexist\";\n            }\n            return object;\n        };\n\n        /**\n         * Converts this BatchEntry to JSON.\n         * @function toJSON\n         * @memberof ics23.BatchEntry\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        BatchEntry.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return BatchEntry;\n    })();\n\n    ics23.CompressedBatchProof = (function() {\n\n        /**\n         * Properties of a CompressedBatchProof.\n         * @memberof ics23\n         * @interface ICompressedBatchProof\n         * @property {Array.<ics23.ICompressedBatchEntry>|null} [entries] CompressedBatchProof entries\n         * @property {Array.<ics23.IInnerOp>|null} [lookupInners] CompressedBatchProof lookupInners\n         */\n\n        /**\n         * Constructs a new CompressedBatchProof.\n         * @memberof ics23\n         * @classdesc Represents a CompressedBatchProof.\n         * @implements ICompressedBatchProof\n         * @constructor\n         * @param {ics23.ICompressedBatchProof=} [properties] Properties to set\n         */\n        function CompressedBatchProof(properties) {\n            this.entries = [];\n            this.lookupInners = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedBatchProof entries.\n         * @member {Array.<ics23.ICompressedBatchEntry>} entries\n         * @memberof ics23.CompressedBatchProof\n         * @instance\n         */\n        CompressedBatchProof.prototype.entries = $util.emptyArray;\n\n        /**\n         * CompressedBatchProof lookupInners.\n         * @member {Array.<ics23.IInnerOp>} lookupInners\n         * @memberof ics23.CompressedBatchProof\n         * @instance\n         */\n        CompressedBatchProof.prototype.lookupInners = $util.emptyArray;\n\n        /**\n         * Creates a new CompressedBatchProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.ICompressedBatchProof=} [properties] Properties to set\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof instance\n         */\n        CompressedBatchProof.create = function create(properties) {\n            return new CompressedBatchProof(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedBatchProof message. Does not implicitly {@link ics23.CompressedBatchProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.ICompressedBatchProof} message CompressedBatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.entries != null && message.entries.length)\n                for (var i = 0; i < message.entries.length; ++i)\n                    $root.ics23.CompressedBatchEntry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.lookupInners != null && message.lookupInners.length)\n                for (var i = 0; i < message.lookupInners.length; ++i)\n                    $root.ics23.InnerOp.encode(message.lookupInners[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedBatchProof message, length delimited. Does not implicitly {@link ics23.CompressedBatchProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.ICompressedBatchProof} message CompressedBatchProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedBatchProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    if (!(message.entries && message.entries.length))\n                        message.entries = [];\n                    message.entries.push($root.ics23.CompressedBatchEntry.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    if (!(message.lookupInners && message.lookupInners.length))\n                        message.lookupInners = [];\n                    message.lookupInners.push($root.ics23.InnerOp.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedBatchProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedBatchProof message.\n         * @function verify\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedBatchProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.entries != null && message.hasOwnProperty(\"entries\")) {\n                if (!Array.isArray(message.entries))\n                    return \"entries: array expected\";\n                for (var i = 0; i < message.entries.length; ++i) {\n                    var error = $root.ics23.CompressedBatchEntry.verify(message.entries[i]);\n                    if (error)\n                        return \"entries.\" + error;\n                }\n            }\n            if (message.lookupInners != null && message.hasOwnProperty(\"lookupInners\")) {\n                if (!Array.isArray(message.lookupInners))\n                    return \"lookupInners: array expected\";\n                for (var i = 0; i < message.lookupInners.length; ++i) {\n                    var error = $root.ics23.InnerOp.verify(message.lookupInners[i]);\n                    if (error)\n                        return \"lookupInners.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedBatchProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedBatchProof} CompressedBatchProof\n         */\n        CompressedBatchProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedBatchProof)\n                return object;\n            var message = new $root.ics23.CompressedBatchProof();\n            if (object.entries) {\n                if (!Array.isArray(object.entries))\n                    throw TypeError(\".ics23.CompressedBatchProof.entries: array expected\");\n                message.entries = [];\n                for (var i = 0; i < object.entries.length; ++i) {\n                    if (typeof object.entries[i] !== \"object\")\n                        throw TypeError(\".ics23.CompressedBatchProof.entries: object expected\");\n                    message.entries[i] = $root.ics23.CompressedBatchEntry.fromObject(object.entries[i]);\n                }\n            }\n            if (object.lookupInners) {\n                if (!Array.isArray(object.lookupInners))\n                    throw TypeError(\".ics23.CompressedBatchProof.lookupInners: array expected\");\n                message.lookupInners = [];\n                for (var i = 0; i < object.lookupInners.length; ++i) {\n                    if (typeof object.lookupInners[i] !== \"object\")\n                        throw TypeError(\".ics23.CompressedBatchProof.lookupInners: object expected\");\n                    message.lookupInners[i] = $root.ics23.InnerOp.fromObject(object.lookupInners[i]);\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedBatchProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedBatchProof\n         * @static\n         * @param {ics23.CompressedBatchProof} message CompressedBatchProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedBatchProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults) {\n                object.entries = [];\n                object.lookupInners = [];\n            }\n            if (message.entries && message.entries.length) {\n                object.entries = [];\n                for (var j = 0; j < message.entries.length; ++j)\n                    object.entries[j] = $root.ics23.CompressedBatchEntry.toObject(message.entries[j], options);\n            }\n            if (message.lookupInners && message.lookupInners.length) {\n                object.lookupInners = [];\n                for (var j = 0; j < message.lookupInners.length; ++j)\n                    object.lookupInners[j] = $root.ics23.InnerOp.toObject(message.lookupInners[j], options);\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CompressedBatchProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedBatchProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedBatchProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedBatchProof;\n    })();\n\n    ics23.CompressedBatchEntry = (function() {\n\n        /**\n         * Properties of a CompressedBatchEntry.\n         * @memberof ics23\n         * @interface ICompressedBatchEntry\n         * @property {ics23.ICompressedExistenceProof|null} [exist] CompressedBatchEntry exist\n         * @property {ics23.ICompressedNonExistenceProof|null} [nonexist] CompressedBatchEntry nonexist\n         */\n\n        /**\n         * Constructs a new CompressedBatchEntry.\n         * @memberof ics23\n         * @classdesc Represents a CompressedBatchEntry.\n         * @implements ICompressedBatchEntry\n         * @constructor\n         * @param {ics23.ICompressedBatchEntry=} [properties] Properties to set\n         */\n        function CompressedBatchEntry(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedBatchEntry exist.\n         * @member {ics23.ICompressedExistenceProof|null|undefined} exist\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         */\n        CompressedBatchEntry.prototype.exist = null;\n\n        /**\n         * CompressedBatchEntry nonexist.\n         * @member {ics23.ICompressedNonExistenceProof|null|undefined} nonexist\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         */\n        CompressedBatchEntry.prototype.nonexist = null;\n\n        // OneOf field names bound to virtual getters and setters\n        var $oneOfFields;\n\n        /**\n         * CompressedBatchEntry proof.\n         * @member {\"exist\"|\"nonexist\"|undefined} proof\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         */\n        Object.defineProperty(CompressedBatchEntry.prototype, \"proof\", {\n            get: $util.oneOfGetter($oneOfFields = [\"exist\", \"nonexist\"]),\n            set: $util.oneOfSetter($oneOfFields)\n        });\n\n        /**\n         * Creates a new CompressedBatchEntry instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.ICompressedBatchEntry=} [properties] Properties to set\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry instance\n         */\n        CompressedBatchEntry.create = function create(properties) {\n            return new CompressedBatchEntry(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedBatchEntry message. Does not implicitly {@link ics23.CompressedBatchEntry.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.ICompressedBatchEntry} message CompressedBatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchEntry.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.exist != null && message.hasOwnProperty(\"exist\"))\n                $root.ics23.CompressedExistenceProof.encode(message.exist, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\"))\n                $root.ics23.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedBatchEntry message, length delimited. Does not implicitly {@link ics23.CompressedBatchEntry.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.ICompressedBatchEntry} message CompressedBatchEntry message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedBatchEntry.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedBatchEntry message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchEntry.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedBatchEntry();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.exist = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.nonexist = $root.ics23.CompressedNonExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedBatchEntry message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedBatchEntry.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedBatchEntry message.\n         * @function verify\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedBatchEntry.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            var properties = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.CompressedExistenceProof.verify(message.exist);\n                    if (error)\n                        return \"exist.\" + error;\n                }\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                if (properties.proof === 1)\n                    return \"proof: multiple values\";\n                properties.proof = 1;\n                {\n                    var error = $root.ics23.CompressedNonExistenceProof.verify(message.nonexist);\n                    if (error)\n                        return \"nonexist.\" + error;\n                }\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedBatchEntry message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedBatchEntry} CompressedBatchEntry\n         */\n        CompressedBatchEntry.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedBatchEntry)\n                return object;\n            var message = new $root.ics23.CompressedBatchEntry();\n            if (object.exist != null) {\n                if (typeof object.exist !== \"object\")\n                    throw TypeError(\".ics23.CompressedBatchEntry.exist: object expected\");\n                message.exist = $root.ics23.CompressedExistenceProof.fromObject(object.exist);\n            }\n            if (object.nonexist != null) {\n                if (typeof object.nonexist !== \"object\")\n                    throw TypeError(\".ics23.CompressedBatchEntry.nonexist: object expected\");\n                message.nonexist = $root.ics23.CompressedNonExistenceProof.fromObject(object.nonexist);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedBatchEntry message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedBatchEntry\n         * @static\n         * @param {ics23.CompressedBatchEntry} message CompressedBatchEntry\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedBatchEntry.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (message.exist != null && message.hasOwnProperty(\"exist\")) {\n                object.exist = $root.ics23.CompressedExistenceProof.toObject(message.exist, options);\n                if (options.oneofs)\n                    object.proof = \"exist\";\n            }\n            if (message.nonexist != null && message.hasOwnProperty(\"nonexist\")) {\n                object.nonexist = $root.ics23.CompressedNonExistenceProof.toObject(message.nonexist, options);\n                if (options.oneofs)\n                    object.proof = \"nonexist\";\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CompressedBatchEntry to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedBatchEntry\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedBatchEntry.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedBatchEntry;\n    })();\n\n    ics23.CompressedExistenceProof = (function() {\n\n        /**\n         * Properties of a CompressedExistenceProof.\n         * @memberof ics23\n         * @interface ICompressedExistenceProof\n         * @property {Uint8Array|null} [key] CompressedExistenceProof key\n         * @property {Uint8Array|null} [value] CompressedExistenceProof value\n         * @property {ics23.ILeafOp|null} [leaf] CompressedExistenceProof leaf\n         * @property {Array.<number>|null} [path] CompressedExistenceProof path\n         */\n\n        /**\n         * Constructs a new CompressedExistenceProof.\n         * @memberof ics23\n         * @classdesc Represents a CompressedExistenceProof.\n         * @implements ICompressedExistenceProof\n         * @constructor\n         * @param {ics23.ICompressedExistenceProof=} [properties] Properties to set\n         */\n        function CompressedExistenceProof(properties) {\n            this.path = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * CompressedExistenceProof value.\n         * @member {Uint8Array} value\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.value = $util.newBuffer([]);\n\n        /**\n         * CompressedExistenceProof leaf.\n         * @member {ics23.ILeafOp|null|undefined} leaf\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.leaf = null;\n\n        /**\n         * CompressedExistenceProof path.\n         * @member {Array.<number>} path\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         */\n        CompressedExistenceProof.prototype.path = $util.emptyArray;\n\n        /**\n         * Creates a new CompressedExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.ICompressedExistenceProof=} [properties] Properties to set\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof instance\n         */\n        CompressedExistenceProof.create = function create(properties) {\n            return new CompressedExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedExistenceProof message. Does not implicitly {@link ics23.CompressedExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.ICompressedExistenceProof} message CompressedExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                $root.ics23.LeafOp.encode(message.leaf, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            if (message.path != null && message.path.length) {\n                writer.uint32(/* id 4, wireType 2 =*/34).fork();\n                for (var i = 0; i < message.path.length; ++i)\n                    writer.int32(message.path[i]);\n                writer.ldelim();\n            }\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedExistenceProof message, length delimited. Does not implicitly {@link ics23.CompressedExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.ICompressedExistenceProof} message CompressedExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.value = reader.bytes();\n                    break;\n                case 3:\n                    message.leaf = $root.ics23.LeafOp.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    if (!(message.path && message.path.length))\n                        message.path = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.path.push(reader.int32());\n                    } else\n                        message.path.push(reader.int32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedExistenceProof message.\n         * @function verify\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                if (!(message.value && typeof message.value.length === \"number\" || $util.isString(message.value)))\n                    return \"value: buffer expected\";\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\")) {\n                var error = $root.ics23.LeafOp.verify(message.leaf);\n                if (error)\n                    return \"leaf.\" + error;\n            }\n            if (message.path != null && message.hasOwnProperty(\"path\")) {\n                if (!Array.isArray(message.path))\n                    return \"path: array expected\";\n                for (var i = 0; i < message.path.length; ++i)\n                    if (!$util.isInteger(message.path[i]))\n                        return \"path: integer[] expected\";\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedExistenceProof} CompressedExistenceProof\n         */\n        CompressedExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedExistenceProof)\n                return object;\n            var message = new $root.ics23.CompressedExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.value != null)\n                if (typeof object.value === \"string\")\n                    $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);\n                else if (object.value.length)\n                    message.value = object.value;\n            if (object.leaf != null) {\n                if (typeof object.leaf !== \"object\")\n                    throw TypeError(\".ics23.CompressedExistenceProof.leaf: object expected\");\n                message.leaf = $root.ics23.LeafOp.fromObject(object.leaf);\n            }\n            if (object.path) {\n                if (!Array.isArray(object.path))\n                    throw TypeError(\".ics23.CompressedExistenceProof.path: array expected\");\n                message.path = [];\n                for (var i = 0; i < object.path.length; ++i)\n                    message.path[i] = object.path[i] | 0;\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedExistenceProof\n         * @static\n         * @param {ics23.CompressedExistenceProof} message CompressedExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.arrays || options.defaults)\n                object.path = [];\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                if (options.bytes === String)\n                    object.value = \"\";\n                else {\n                    object.value = [];\n                    if (options.bytes !== Array)\n                        object.value = $util.newBuffer(object.value);\n                }\n                object.leaf = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.value != null && message.hasOwnProperty(\"value\"))\n                object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;\n            if (message.leaf != null && message.hasOwnProperty(\"leaf\"))\n                object.leaf = $root.ics23.LeafOp.toObject(message.leaf, options);\n            if (message.path && message.path.length) {\n                object.path = [];\n                for (var j = 0; j < message.path.length; ++j)\n                    object.path[j] = message.path[j];\n            }\n            return object;\n        };\n\n        /**\n         * Converts this CompressedExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedExistenceProof;\n    })();\n\n    ics23.CompressedNonExistenceProof = (function() {\n\n        /**\n         * Properties of a CompressedNonExistenceProof.\n         * @memberof ics23\n         * @interface ICompressedNonExistenceProof\n         * @property {Uint8Array|null} [key] CompressedNonExistenceProof key\n         * @property {ics23.ICompressedExistenceProof|null} [left] CompressedNonExistenceProof left\n         * @property {ics23.ICompressedExistenceProof|null} [right] CompressedNonExistenceProof right\n         */\n\n        /**\n         * Constructs a new CompressedNonExistenceProof.\n         * @memberof ics23\n         * @classdesc Represents a CompressedNonExistenceProof.\n         * @implements ICompressedNonExistenceProof\n         * @constructor\n         * @param {ics23.ICompressedNonExistenceProof=} [properties] Properties to set\n         */\n        function CompressedNonExistenceProof(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n\n        /**\n         * CompressedNonExistenceProof key.\n         * @member {Uint8Array} key\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         */\n        CompressedNonExistenceProof.prototype.key = $util.newBuffer([]);\n\n        /**\n         * CompressedNonExistenceProof left.\n         * @member {ics23.ICompressedExistenceProof|null|undefined} left\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         */\n        CompressedNonExistenceProof.prototype.left = null;\n\n        /**\n         * CompressedNonExistenceProof right.\n         * @member {ics23.ICompressedExistenceProof|null|undefined} right\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         */\n        CompressedNonExistenceProof.prototype.right = null;\n\n        /**\n         * Creates a new CompressedNonExistenceProof instance using the specified properties.\n         * @function create\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.ICompressedNonExistenceProof=} [properties] Properties to set\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof instance\n         */\n        CompressedNonExistenceProof.create = function create(properties) {\n            return new CompressedNonExistenceProof(properties);\n        };\n\n        /**\n         * Encodes the specified CompressedNonExistenceProof message. Does not implicitly {@link ics23.CompressedNonExistenceProof.verify|verify} messages.\n         * @function encode\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.ICompressedNonExistenceProof} message CompressedNonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedNonExistenceProof.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.key);\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                $root.ics23.CompressedExistenceProof.encode(message.left, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                $root.ics23.CompressedExistenceProof.encode(message.right, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n            return writer;\n        };\n\n        /**\n         * Encodes the specified CompressedNonExistenceProof message, length delimited. Does not implicitly {@link ics23.CompressedNonExistenceProof.verify|verify} messages.\n         * @function encodeDelimited\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.ICompressedNonExistenceProof} message CompressedNonExistenceProof message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        CompressedNonExistenceProof.encodeDelimited = function encodeDelimited(message, writer) {\n            return this.encode(message, writer).ldelim();\n        };\n\n        /**\n         * Decodes a CompressedNonExistenceProof message from the specified reader or buffer.\n         * @function decode\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedNonExistenceProof.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.ics23.CompressedNonExistenceProof();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.left = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.right = $root.ics23.CompressedExistenceProof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n\n        /**\n         * Decodes a CompressedNonExistenceProof message from the specified reader or buffer, length delimited.\n         * @function decodeDelimited\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CompressedNonExistenceProof.decodeDelimited = function decodeDelimited(reader) {\n            if (!(reader instanceof $Reader))\n                reader = new $Reader(reader);\n            return this.decode(reader, reader.uint32());\n        };\n\n        /**\n         * Verifies a CompressedNonExistenceProof message.\n         * @function verify\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {Object.<string,*>} message Plain object to verify\n         * @returns {string|null} `null` if valid, otherwise the reason why it is not\n         */\n        CompressedNonExistenceProof.verify = function verify(message) {\n            if (typeof message !== \"object\" || message === null)\n                return \"object expected\";\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                if (!(message.key && typeof message.key.length === \"number\" || $util.isString(message.key)))\n                    return \"key: buffer expected\";\n            if (message.left != null && message.hasOwnProperty(\"left\")) {\n                var error = $root.ics23.CompressedExistenceProof.verify(message.left);\n                if (error)\n                    return \"left.\" + error;\n            }\n            if (message.right != null && message.hasOwnProperty(\"right\")) {\n                var error = $root.ics23.CompressedExistenceProof.verify(message.right);\n                if (error)\n                    return \"right.\" + error;\n            }\n            return null;\n        };\n\n        /**\n         * Creates a CompressedNonExistenceProof message from a plain object. Also converts values to their respective internal types.\n         * @function fromObject\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {Object.<string,*>} object Plain object\n         * @returns {ics23.CompressedNonExistenceProof} CompressedNonExistenceProof\n         */\n        CompressedNonExistenceProof.fromObject = function fromObject(object) {\n            if (object instanceof $root.ics23.CompressedNonExistenceProof)\n                return object;\n            var message = new $root.ics23.CompressedNonExistenceProof();\n            if (object.key != null)\n                if (typeof object.key === \"string\")\n                    $util.base64.decode(object.key, message.key = $util.newBuffer($util.base64.length(object.key)), 0);\n                else if (object.key.length)\n                    message.key = object.key;\n            if (object.left != null) {\n                if (typeof object.left !== \"object\")\n                    throw TypeError(\".ics23.CompressedNonExistenceProof.left: object expected\");\n                message.left = $root.ics23.CompressedExistenceProof.fromObject(object.left);\n            }\n            if (object.right != null) {\n                if (typeof object.right !== \"object\")\n                    throw TypeError(\".ics23.CompressedNonExistenceProof.right: object expected\");\n                message.right = $root.ics23.CompressedExistenceProof.fromObject(object.right);\n            }\n            return message;\n        };\n\n        /**\n         * Creates a plain object from a CompressedNonExistenceProof message. Also converts values to other types if specified.\n         * @function toObject\n         * @memberof ics23.CompressedNonExistenceProof\n         * @static\n         * @param {ics23.CompressedNonExistenceProof} message CompressedNonExistenceProof\n         * @param {$protobuf.IConversionOptions} [options] Conversion options\n         * @returns {Object.<string,*>} Plain object\n         */\n        CompressedNonExistenceProof.toObject = function toObject(message, options) {\n            if (!options)\n                options = {};\n            var object = {};\n            if (options.defaults) {\n                if (options.bytes === String)\n                    object.key = \"\";\n                else {\n                    object.key = [];\n                    if (options.bytes !== Array)\n                        object.key = $util.newBuffer(object.key);\n                }\n                object.left = null;\n                object.right = null;\n            }\n            if (message.key != null && message.hasOwnProperty(\"key\"))\n                object.key = options.bytes === String ? $util.base64.encode(message.key, 0, message.key.length) : options.bytes === Array ? Array.prototype.slice.call(message.key) : message.key;\n            if (message.left != null && message.hasOwnProperty(\"left\"))\n                object.left = $root.ics23.CompressedExistenceProof.toObject(message.left, options);\n            if (message.right != null && message.hasOwnProperty(\"right\"))\n                object.right = $root.ics23.CompressedExistenceProof.toObject(message.right, options);\n            return object;\n        };\n\n        /**\n         * Converts this CompressedNonExistenceProof to JSON.\n         * @function toJSON\n         * @memberof ics23.CompressedNonExistenceProof\n         * @instance\n         * @returns {Object.<string,*>} JSON object\n         */\n        CompressedNonExistenceProof.prototype.toJSON = function toJSON() {\n            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n        };\n\n        return CompressedNonExistenceProof;\n    })();\n\n    return ics23;\n})();\n\nmodule.exports = $root;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbmZpby9pY3MyMy9idWlsZC9nZW5lcmF0ZWQvY29kZWNpbXBsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQW9COztBQUU1QztBQUNBOztBQUVBO0FBQ0EsMEVBQTBFOztBQUUxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QyxzQkFBc0IsaUJBQWlCO0FBQ3ZDLHNCQUFzQixvQkFBb0I7QUFDMUMsc0JBQXNCLDZCQUE2QjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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azovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0Bjb25maW8vaWNzMjMvYnVpbGQvZ2VuZXJhdGVkL2NvZGVjaW1wbC5qcz83Njk2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qZXNsaW50LWRpc2FibGUgYmxvY2stc2NvcGVkLXZhciwgaWQtbGVuZ3RoLCBuby1jb250cm9sLXJlZ2V4LCBuby1tYWdpYy1udW1iZXJzLCBuby1wcm90b3R5cGUtYnVpbHRpbnMsIG5vLXJlZGVjbGFyZSwgbm8tc2hhZG93LCBuby12YXIsIHNvcnQtdmFycyovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICRwcm90b2J1ZiA9IHJlcXVpcmUoXCJwcm90b2J1ZmpzL21pbmltYWxcIik7XG5cbi8vIENvbW1vbiBhbGlhc2VzXG52YXIgJFJlYWRlciA9ICRwcm90b2J1Zi5SZWFkZXIsICRXcml0ZXIgPSAkcHJvdG9idWYuV3JpdGVyLCAkdXRpbCA9ICRwcm90b2J1Zi51dGlsO1xuXG4vLyBFeHBvcnRlZCByb290IG5hbWVzcGFjZVxudmFyICRyb290ID0gJHByb3RvYnVmLnJvb3RzW1wiZGVmYXVsdFwiXSB8fCAoJHByb3RvYnVmLnJvb3RzW1wiZGVmYXVsdFwiXSA9IHt9KTtcblxuJHJvb3QuaWNzMjMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBOYW1lc3BhY2UgaWNzMjMuXG4gICAgICogQGV4cG9ydHMgaWNzMjNcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICovXG4gICAgdmFyIGljczIzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBIYXNoT3AgZW51bS5cbiAgICAgKiBAbmFtZSBpY3MyMy5IYXNoT3BcbiAgICAgKiBAZW51bSB7c3RyaW5nfVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBOT19IQVNIPTAgTk9fSEFTSCB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBTSEEyNTY9MSBTSEEyNTYgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gU0hBNTEyPTIgU0hBNTEyIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEtFQ0NBSz0zIEtFQ0NBSyB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBSSVBFTUQxNjA9NCBSSVBFTUQxNjAgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gQklUQ09JTj01IEJJVENPSU4gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gU0hBNTEyXzI1Nj02IFNIQTUxMl8yNTYgdmFsdWVcbiAgICAgKi9cbiAgICBpY3MyMy5IYXNoT3AgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzBdID0gXCJOT19IQVNIXCJdID0gMDtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMV0gPSBcIlNIQTI1NlwiXSA9IDE7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzJdID0gXCJTSEE1MTJcIl0gPSAyO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFszXSA9IFwiS0VDQ0FLXCJdID0gMztcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNF0gPSBcIlJJUEVNRDE2MFwiXSA9IDQ7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzVdID0gXCJCSVRDT0lOXCJdID0gNTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNl0gPSBcIlNIQTUxMl8yNTZcIl0gPSA2O1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH0pKCk7XG5cbiAgICAvKipcbiAgICAgKiBMZW5ndGhPcCBkZWZpbmVzIGhvdyB0byBwcm9jZXNzIHRoZSBrZXkgYW5kIHZhbHVlIG9mIHRoZSBMZWFmT3BcbiAgICAgKiB0byBpbmNsdWRlIGxlbmd0aCBpbmZvcm1hdGlvbi4gQWZ0ZXIgZW5jb2RpbmcgdGhlIGxlbmd0aCB3aXRoIHRoZSBnaXZlblxuICAgICAqIGFsZ29yaXRobSwgdGhlIGxlbmd0aCB3aWxsIGJlIHByZXBlbmRlZCB0byB0aGUga2V5IGFuZCB2YWx1ZSBieXRlcy5cbiAgICAgKiAoRWFjaCBvbmUgd2l0aCBpdCdzIG93biBlbmNvZGVkIGxlbmd0aClcbiAgICAgKiBAbmFtZSBpY3MyMy5MZW5ndGhPcFxuICAgICAqIEBlbnVtIHtzdHJpbmd9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IE5PX1BSRUZJWD0wIE5PX1BSRUZJWCB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBWQVJfUFJPVE89MSBWQVJfUFJPVE8gdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gVkFSX1JMUD0yIFZBUl9STFAgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRklYRUQzMl9CSUc9MyBGSVhFRDMyX0JJRyB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBGSVhFRDMyX0xJVFRMRT00IEZJWEVEMzJfTElUVExFIHZhbHVlXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEZJWEVENjRfQklHPTUgRklYRUQ2NF9CSUcgdmFsdWVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gRklYRUQ2NF9MSVRUTEU9NiBGSVhFRDY0X0xJVFRMRSB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBSRVFVSVJFXzMyX0JZVEVTPTcgUkVRVUlSRV8zMl9CWVRFUyB2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBSRVFVSVJFXzY0X0JZVEVTPTggUkVRVUlSRV82NF9CWVRFUyB2YWx1ZVxuICAgICAqL1xuICAgIGljczIzLkxlbmd0aE9wID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWVzQnlJZCA9IHt9LCB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHZhbHVlc0J5SWQpO1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFswXSA9IFwiTk9fUFJFRklYXCJdID0gMDtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMV0gPSBcIlZBUl9QUk9UT1wiXSA9IDE7XG4gICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzJdID0gXCJWQVJfUkxQXCJdID0gMjtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbM10gPSBcIkZJWEVEMzJfQklHXCJdID0gMztcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNF0gPSBcIkZJWEVEMzJfTElUVExFXCJdID0gNDtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNV0gPSBcIkZJWEVENjRfQklHXCJdID0gNTtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbNl0gPSBcIkZJWEVENjRfTElUVExFXCJdID0gNjtcbiAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbN10gPSBcIlJFUVVJUkVfMzJfQllURVNcIl0gPSA3O1xuICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFs4XSA9IFwiUkVRVUlSRV82NF9CWVRFU1wiXSA9IDg7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfSkoKTtcblxuICAgIGljczIzLkV4aXN0ZW5jZVByb29mID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGFuIEV4aXN0ZW5jZVByb29mLlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjNcbiAgICAgICAgICogQGludGVyZmFjZSBJRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fG51bGx9IFtrZXldIEV4aXN0ZW5jZVByb29mIGtleVxuICAgICAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl8bnVsbH0gW3ZhbHVlXSBFeGlzdGVuY2VQcm9vZiB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge2ljczIzLklMZWFmT3B8bnVsbH0gW2xlYWZdIEV4aXN0ZW5jZVByb29mIGxlYWZcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48aWNzMjMuSUlubmVyT3A+fG51bGx9IFtwYXRoXSBFeGlzdGVuY2VQcm9vZiBwYXRoXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEV4aXN0ZW5jZVByb29mLlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjNcbiAgICAgICAgICogQGNsYXNzZGVzYyBFeGlzdGVuY2VQcm9vZiB0YWtlcyBhIGtleSBhbmQgYSB2YWx1ZSBhbmQgYSBzZXQgb2Ygc3RlcHMgdG8gcGVyZm9ybSBvbiBpdC5cbiAgICAgICAgICogVGhlIHJlc3VsdCBvZiBwZWZvcm1pbmcgYWxsIHRoZXNlIHN0ZXBzIHdpbGwgcHJvdmlkZSBhIFwicm9vdCBoYXNoXCIsIHdoaWNoIGNhblxuICAgICAgICAgKiBiZSBjb21wYXJlZCB0byB0aGUgdmFsdWUgaW4gYSBoZWFkZXIuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBTaW5jZSBpdCBpcyBjb21wdXRhdGlvbmFsbHkgaW5mZWFzaWJsZSB0byBwcm9kdWNlIGEgaGFzaCBjb2xsaXNzaW9uIGZvciBhbnkgb2YgdGhlIHVzZWRcbiAgICAgICAgICogY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9ucywgaWYgc29tZW9uZSBjYW4gcHJvdmlkZSBhIHNlcmllcyBvZiBvcGVyYXRpb25zIHRvIHRyYW5zZm9ybVxuICAgICAgICAgKiBhIGdpdmVuIGtleSBhbmQgdmFsdWUgaW50byBhIHJvb3QgaGFzaCB0aGF0IG1hdGNoZXMgc29tZSB0cnVzdGVkIHJvb3QsIHRoZXNlIGtleSBhbmQgdmFsdWVzXG4gICAgICAgICAqIG11c3QgYmUgaW4gdGhlIHJlZmVyZW5jZWQgbWVya2xlIHRyZWUuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBUaGUgb25seSBwb3NzaWJsZSBpc3N1ZSBpcyBtYWxpYWJsaXR5IGluIExlYWZPcCwgc3VjaCBhcyBwcm92aWRpbmcgZXh0cmEgcHJlZml4IGRhdGEsXG4gICAgICAgICAqIHdoaWNoIHNob3VsZCBiZSBjb250cm9sbGVkIGJ5IGEgc3BlYy4gRWcuIHdpdGggbGVuZ3RoT3AgYXMgTk9ORSxcbiAgICAgICAgICogcHJlZml4ID0gRk9PLCBrZXkgPSBCQVIsIHZhbHVlID0gQ0hPSUNFXG4gICAgICAgICAqIGFuZFxuICAgICAgICAgKiBwcmVmaXggPSBGLCBrZXkgPSBPT0JBUiwgdmFsdWUgPSBDSE9JQ0VcbiAgICAgICAgICogd291bGQgcHJvZHVjZSB0aGUgc2FtZSB2YWx1ZS5cbiAgICAgICAgICogXG4gICAgICAgICAqIFdpdGggTGVuZ3RoT3AgdGhpcyBpcyB0cmlja2VyIGJ1dCBub3QgaW1wb3NzaWJsZS4gV2hpY2ggaXMgd2h5IHRoZSBcImxlYWZQcmVmaXhFcXVhbFwiIGZpZWxkXG4gICAgICAgICAqIGluIHRoZSBQcm9vZlNwZWMgaXMgdmFsdWFibGUgdG8gcHJldmVudCB0aGlzIG11dGFiaWxpdHkuIEFuZCB3aHkgYWxsIHRyZWVzIHNob3VsZFxuICAgICAgICAgKiBsZW5ndGgtcHJlZml4IHRoZSBkYXRhIGJlZm9yZSBoYXNoaW5nIGl0LlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUV4aXN0ZW5jZVByb29mPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBFeGlzdGVuY2VQcm9vZihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLnBhdGggPSBbXTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRXhpc3RlbmNlUHJvb2Yga2V5LlxuICAgICAgICAgKiBAbWVtYmVyIHtVaW50OEFycmF5fSBrZXlcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgRXhpc3RlbmNlUHJvb2YucHJvdG90eXBlLmtleSA9ICR1dGlsLm5ld0J1ZmZlcihbXSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4aXN0ZW5jZVByb29mIHZhbHVlLlxuICAgICAgICAgKiBAbWVtYmVyIHtVaW50OEFycmF5fSB2YWx1ZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBFeGlzdGVuY2VQcm9vZi5wcm90b3R5cGUudmFsdWUgPSAkdXRpbC5uZXdCdWZmZXIoW10pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeGlzdGVuY2VQcm9vZiBsZWFmLlxuICAgICAgICAgKiBAbWVtYmVyIHtpY3MyMy5JTGVhZk9wfG51bGx8dW5kZWZpbmVkfSBsZWFmXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEV4aXN0ZW5jZVByb29mLnByb3RvdHlwZS5sZWFmID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXhpc3RlbmNlUHJvb2YgcGF0aC5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPGljczIzLklJbm5lck9wPn0gcGF0aFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBFeGlzdGVuY2VQcm9vZi5wcm90b3R5cGUucGF0aCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgRXhpc3RlbmNlUHJvb2YgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUV4aXN0ZW5jZVByb29mPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5FeGlzdGVuY2VQcm9vZn0gRXhpc3RlbmNlUHJvb2YgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEV4aXN0ZW5jZVByb29mLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV4aXN0ZW5jZVByb29mKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgRXhpc3RlbmNlUHJvb2YgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgaWNzMjMuRXhpc3RlbmNlUHJvb2YudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JRXhpc3RlbmNlUHJvb2Z9IG1lc3NhZ2UgRXhpc3RlbmNlUHJvb2YgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBFeGlzdGVuY2VQcm9vZi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uua2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLmJ5dGVzKG1lc3NhZ2Uua2V5KTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuYnl0ZXMobWVzc2FnZS52YWx1ZSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5sZWFmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxlYWZcIikpXG4gICAgICAgICAgICAgICAgJHJvb3QuaWNzMjMuTGVhZk9wLmVuY29kZShtZXNzYWdlLmxlYWYsIHdyaXRlci51aW50MzIoLyogaWQgMywgd2lyZVR5cGUgMiA9Ki8yNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnBhdGggIT0gbnVsbCAmJiBtZXNzYWdlLnBhdGgubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5wYXRoLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5pY3MyMy5Jbm5lck9wLmVuY29kZShtZXNzYWdlLnBhdGhbaV0sIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki8zNCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBFeGlzdGVuY2VQcm9vZiBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBpY3MyMy5FeGlzdGVuY2VQcm9vZi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklFeGlzdGVuY2VQcm9vZn0gbWVzc2FnZSBFeGlzdGVuY2VQcm9vZiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIEV4aXN0ZW5jZVByb29mLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGFuIEV4aXN0ZW5jZVByb29mIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5FeGlzdGVuY2VQcm9vZn0gRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBFeGlzdGVuY2VQcm9vZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5pY3MyMy5FeGlzdGVuY2VQcm9vZigpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxlYWYgPSAkcm9vdC5pY3MyMy5MZWFmT3AuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnBhdGggJiYgbWVzc2FnZS5wYXRoLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhdGggPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXRoLnB1c2goJHJvb3QuaWNzMjMuSW5uZXJPcC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhbiBFeGlzdGVuY2VQcm9vZiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuRXhpc3RlbmNlUHJvb2Z9IEV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgRXhpc3RlbmNlUHJvb2YuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGFuIEV4aXN0ZW5jZVByb29mIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBFeGlzdGVuY2VQcm9vZi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5rZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwia2V5XCIpKVxuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uua2V5ICYmIHR5cGVvZiBtZXNzYWdlLmtleS5sZW5ndGggPT09IFwibnVtYmVyXCIgfHwgJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5rZXkpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwia2V5OiBidWZmZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKVxuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudmFsdWUgJiYgdHlwZW9mIG1lc3NhZ2UudmFsdWUubGVuZ3RoID09PSBcIm51bWJlclwiIHx8ICR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UudmFsdWUpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidmFsdWU6IGJ1ZmZlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubGVhZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsZWFmXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuaWNzMjMuTGVhZk9wLnZlcmlmeShtZXNzYWdlLmxlYWYpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibGVhZi5cIiArIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucGF0aCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwYXRoXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UucGF0aCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInBhdGg6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLnBhdGgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuaWNzMjMuSW5uZXJPcC52ZXJpZnkobWVzc2FnZS5wYXRoW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicGF0aC5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGFuIEV4aXN0ZW5jZVByb29mIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuRXhpc3RlbmNlUHJvb2Z9IEV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqL1xuICAgICAgICBFeGlzdGVuY2VQcm9vZi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5pY3MyMy5FeGlzdGVuY2VQcm9vZilcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuaWNzMjMuRXhpc3RlbmNlUHJvb2YoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3Qua2V5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Qua2V5ID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKG9iamVjdC5rZXksIG1lc3NhZ2Uua2V5ID0gJHV0aWwubmV3QnVmZmVyKCR1dGlsLmJhc2U2NC5sZW5ndGgob2JqZWN0LmtleSkpLCAwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmplY3Qua2V5Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXkgPSBvYmplY3Qua2V5O1xuICAgICAgICAgICAgaWYgKG9iamVjdC52YWx1ZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnZhbHVlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKG9iamVjdC52YWx1ZSwgbWVzc2FnZS52YWx1ZSA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC52YWx1ZSkpLCAwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmplY3QudmFsdWUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlID0gb2JqZWN0LnZhbHVlO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5sZWFmICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5sZWFmICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuaWNzMjMuRXhpc3RlbmNlUHJvb2YubGVhZjogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubGVhZiA9ICRyb290LmljczIzLkxlYWZPcC5mcm9tT2JqZWN0KG9iamVjdC5sZWFmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QucGF0aCkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QucGF0aCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5pY3MyMy5FeGlzdGVuY2VQcm9vZi5wYXRoOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnBhdGggPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5wYXRoLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LnBhdGhbaV0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuaWNzMjMuRXhpc3RlbmNlUHJvb2YucGF0aDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhdGhbaV0gPSAkcm9vdC5pY3MyMy5Jbm5lck9wLmZyb21PYmplY3Qob2JqZWN0LnBhdGhbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYW4gRXhpc3RlbmNlUHJvb2YgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5FeGlzdGVuY2VQcm9vZn0gbWVzc2FnZSBFeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIEV4aXN0ZW5jZVByb29mLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFycmF5cyB8fCBvcHRpb25zLmRlZmF1bHRzKVxuICAgICAgICAgICAgICAgIG9iamVjdC5wYXRoID0gW107XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5rZXkgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3Qua2V5ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzICE9PSBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5rZXkgPSAkdXRpbC5uZXdCdWZmZXIob2JqZWN0LmtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyAhPT0gQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSAkdXRpbC5uZXdCdWZmZXIob2JqZWN0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqZWN0LmxlYWYgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uua2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3Qua2V5ID0gb3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nID8gJHV0aWwuYmFzZTY0LmVuY29kZShtZXNzYWdlLmtleSwgMCwgbWVzc2FnZS5rZXkubGVuZ3RoKSA6IG9wdGlvbnMuYnl0ZXMgPT09IEFycmF5ID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobWVzc2FnZS5rZXkpIDogbWVzc2FnZS5rZXk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QudmFsdWUgPSBvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcgPyAkdXRpbC5iYXNlNjQuZW5jb2RlKG1lc3NhZ2UudmFsdWUsIDAsIG1lc3NhZ2UudmFsdWUubGVuZ3RoKSA6IG9wdGlvbnMuYnl0ZXMgPT09IEFycmF5ID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobWVzc2FnZS52YWx1ZSkgOiBtZXNzYWdlLnZhbHVlO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubGVhZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsZWFmXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5sZWFmID0gJHJvb3QuaWNzMjMuTGVhZk9wLnRvT2JqZWN0KG1lc3NhZ2UubGVhZiwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wYXRoICYmIG1lc3NhZ2UucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QucGF0aCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5wYXRoLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QucGF0aFtqXSA9ICRyb290LmljczIzLklubmVyT3AudG9PYmplY3QobWVzc2FnZS5wYXRoW2pdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgRXhpc3RlbmNlUHJvb2YgdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIEV4aXN0ZW5jZVByb29mLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gRXhpc3RlbmNlUHJvb2Y7XG4gICAgfSkoKTtcblxuICAgIGljczIzLk5vbkV4aXN0ZW5jZVByb29mID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgTm9uRXhpc3RlbmNlUHJvb2YuXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyM1xuICAgICAgICAgKiBAaW50ZXJmYWNlIElOb25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl8bnVsbH0gW2tleV0gTm9uRXhpc3RlbmNlUHJvb2Yga2V5XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7aWNzMjMuSUV4aXN0ZW5jZVByb29mfG51bGx9IFtsZWZ0XSBOb25FeGlzdGVuY2VQcm9vZiBsZWZ0XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7aWNzMjMuSUV4aXN0ZW5jZVByb29mfG51bGx9IFtyaWdodF0gTm9uRXhpc3RlbmNlUHJvb2YgcmlnaHRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTm9uRXhpc3RlbmNlUHJvb2YuXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyM1xuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBOb25FeGlzdGVuY2VQcm9vZi5cbiAgICAgICAgICogQGltcGxlbWVudHMgSU5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklOb25FeGlzdGVuY2VQcm9vZj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gTm9uRXhpc3RlbmNlUHJvb2YocHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb25FeGlzdGVuY2VQcm9vZiBrZXkuXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQ4QXJyYXl9IGtleVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBOb25FeGlzdGVuY2VQcm9vZi5wcm90b3R5cGUua2V5ID0gJHV0aWwubmV3QnVmZmVyKFtdKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uRXhpc3RlbmNlUHJvb2YgbGVmdC5cbiAgICAgICAgICogQG1lbWJlciB7aWNzMjMuSUV4aXN0ZW5jZVByb29mfG51bGx8dW5kZWZpbmVkfSBsZWZ0XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Ob25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE5vbkV4aXN0ZW5jZVByb29mLnByb3RvdHlwZS5sZWZ0ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uRXhpc3RlbmNlUHJvb2YgcmlnaHQuXG4gICAgICAgICAqIEBtZW1iZXIge2ljczIzLklFeGlzdGVuY2VQcm9vZnxudWxsfHVuZGVmaW5lZH0gcmlnaHRcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLk5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTm9uRXhpc3RlbmNlUHJvb2YucHJvdG90eXBlLnJpZ2h0ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBOb25FeGlzdGVuY2VQcm9vZiBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLk5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JTm9uRXhpc3RlbmNlUHJvb2Y9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLk5vbkV4aXN0ZW5jZVByb29mfSBOb25FeGlzdGVuY2VQcm9vZiBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTm9uRXhpc3RlbmNlUHJvb2YuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9uRXhpc3RlbmNlUHJvb2YocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBOb25FeGlzdGVuY2VQcm9vZiBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBpY3MyMy5Ob25FeGlzdGVuY2VQcm9vZi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklOb25FeGlzdGVuY2VQcm9vZn0gbWVzc2FnZSBOb25FeGlzdGVuY2VQcm9vZiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIE5vbkV4aXN0ZW5jZVByb29mLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5rZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwia2V5XCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuYnl0ZXMobWVzc2FnZS5rZXkpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubGVmdCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsZWZ0XCIpKVxuICAgICAgICAgICAgICAgICRyb290LmljczIzLkV4aXN0ZW5jZVByb29mLmVuY29kZShtZXNzYWdlLmxlZnQsIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnJpZ2h0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInJpZ2h0XCIpKVxuICAgICAgICAgICAgICAgICRyb290LmljczIzLkV4aXN0ZW5jZVByb29mLmVuY29kZShtZXNzYWdlLnJpZ2h0LCB3cml0ZXIudWludDMyKC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgTm9uRXhpc3RlbmNlUHJvb2YgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgaWNzMjMuTm9uRXhpc3RlbmNlUHJvb2YudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLk5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JTm9uRXhpc3RlbmNlUHJvb2Z9IG1lc3NhZ2UgTm9uRXhpc3RlbmNlUHJvb2YgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBOb25FeGlzdGVuY2VQcm9vZi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIE5vbkV4aXN0ZW5jZVByb29mIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLk5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Ob25FeGlzdGVuY2VQcm9vZn0gTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBOb25FeGlzdGVuY2VQcm9vZi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5pY3MyMy5Ob25FeGlzdGVuY2VQcm9vZigpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGVmdCA9ICRyb290LmljczIzLkV4aXN0ZW5jZVByb29mLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yaWdodCA9ICRyb290LmljczIzLkV4aXN0ZW5jZVByb29mLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBOb25FeGlzdGVuY2VQcm9vZiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Ob25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuTm9uRXhpc3RlbmNlUHJvb2Z9IE5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgTm9uRXhpc3RlbmNlUHJvb2YuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgTm9uRXhpc3RlbmNlUHJvb2YgbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIE5vbkV4aXN0ZW5jZVByb29mLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJrZXlcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5rZXkgJiYgdHlwZW9mIG1lc3NhZ2Uua2V5Lmxlbmd0aCA9PT0gXCJudW1iZXJcIiB8fCAkdXRpbC5pc1N0cmluZyhtZXNzYWdlLmtleSkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJrZXk6IGJ1ZmZlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubGVmdCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsZWZ0XCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuaWNzMjMuRXhpc3RlbmNlUHJvb2YudmVyaWZ5KG1lc3NhZ2UubGVmdCk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJsZWZ0LlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5yaWdodCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJyaWdodFwiKSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmljczIzLkV4aXN0ZW5jZVByb29mLnZlcmlmeShtZXNzYWdlLnJpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInJpZ2h0LlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIE5vbkV4aXN0ZW5jZVByb29mIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLk5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuTm9uRXhpc3RlbmNlUHJvb2Z9IE5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqL1xuICAgICAgICBOb25FeGlzdGVuY2VQcm9vZi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5pY3MyMy5Ob25FeGlzdGVuY2VQcm9vZilcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuaWNzMjMuTm9uRXhpc3RlbmNlUHJvb2YoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3Qua2V5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Qua2V5ID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKG9iamVjdC5rZXksIG1lc3NhZ2Uua2V5ID0gJHV0aWwubmV3QnVmZmVyKCR1dGlsLmJhc2U2NC5sZW5ndGgob2JqZWN0LmtleSkpLCAwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmplY3Qua2V5Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXkgPSBvYmplY3Qua2V5O1xuICAgICAgICAgICAgaWYgKG9iamVjdC5sZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5sZWZ0ICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuaWNzMjMuTm9uRXhpc3RlbmNlUHJvb2YubGVmdDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubGVmdCA9ICRyb290LmljczIzLkV4aXN0ZW5jZVByb29mLmZyb21PYmplY3Qob2JqZWN0LmxlZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5yaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QucmlnaHQgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5pY3MyMy5Ob25FeGlzdGVuY2VQcm9vZi5yaWdodDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UucmlnaHQgPSAkcm9vdC5pY3MyMy5FeGlzdGVuY2VQcm9vZi5mcm9tT2JqZWN0KG9iamVjdC5yaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgTm9uRXhpc3RlbmNlUHJvb2YgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLk5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5Ob25FeGlzdGVuY2VQcm9vZn0gbWVzc2FnZSBOb25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIE5vbkV4aXN0ZW5jZVByb29mLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZylcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmtleSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5rZXkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgIT09IEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmtleSA9ICR1dGlsLm5ld0J1ZmZlcihvYmplY3Qua2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqZWN0LmxlZnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIG9iamVjdC5yaWdodCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5rZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwia2V5XCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5rZXkgPSBvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcgPyAkdXRpbC5iYXNlNjQuZW5jb2RlKG1lc3NhZ2Uua2V5LCAwLCBtZXNzYWdlLmtleS5sZW5ndGgpIDogb3B0aW9ucy5ieXRlcyA9PT0gQXJyYXkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLmtleSkgOiBtZXNzYWdlLmtleTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmxlZnQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibGVmdFwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QubGVmdCA9ICRyb290LmljczIzLkV4aXN0ZW5jZVByb29mLnRvT2JqZWN0KG1lc3NhZ2UubGVmdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5yaWdodCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJyaWdodFwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QucmlnaHQgPSAkcm9vdC5pY3MyMy5FeGlzdGVuY2VQcm9vZi50b09iamVjdChtZXNzYWdlLnJpZ2h0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgTm9uRXhpc3RlbmNlUHJvb2YgdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIE5vbkV4aXN0ZW5jZVByb29mLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gTm9uRXhpc3RlbmNlUHJvb2Y7XG4gICAgfSkoKTtcblxuICAgIGljczIzLkNvbW1pdG1lbnRQcm9vZiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIENvbW1pdG1lbnRQcm9vZi5cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzXG4gICAgICAgICAqIEBpbnRlcmZhY2UgSUNvbW1pdG1lbnRQcm9vZlxuICAgICAgICAgKiBAcHJvcGVydHkge2ljczIzLklFeGlzdGVuY2VQcm9vZnxudWxsfSBbZXhpc3RdIENvbW1pdG1lbnRQcm9vZiBleGlzdFxuICAgICAgICAgKiBAcHJvcGVydHkge2ljczIzLklOb25FeGlzdGVuY2VQcm9vZnxudWxsfSBbbm9uZXhpc3RdIENvbW1pdG1lbnRQcm9vZiBub25leGlzdFxuICAgICAgICAgKiBAcHJvcGVydHkge2ljczIzLklCYXRjaFByb29mfG51bGx9IFtiYXRjaF0gQ29tbWl0bWVudFByb29mIGJhdGNoXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7aWNzMjMuSUNvbXByZXNzZWRCYXRjaFByb29mfG51bGx9IFtjb21wcmVzc2VkXSBDb21taXRtZW50UHJvb2YgY29tcHJlc3NlZFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBDb21taXRtZW50UHJvb2YuXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyM1xuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBDb21taXRtZW50UHJvb2YuXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElDb21taXRtZW50UHJvb2ZcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUNvbW1pdG1lbnRQcm9vZj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQ29tbWl0bWVudFByb29mKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tbWl0bWVudFByb29mIGV4aXN0LlxuICAgICAgICAgKiBAbWVtYmVyIHtpY3MyMy5JRXhpc3RlbmNlUHJvb2Z8bnVsbHx1bmRlZmluZWR9IGV4aXN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21taXRtZW50UHJvb2ZcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBDb21taXRtZW50UHJvb2YucHJvdG90eXBlLmV4aXN0ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tbWl0bWVudFByb29mIG5vbmV4aXN0LlxuICAgICAgICAgKiBAbWVtYmVyIHtpY3MyMy5JTm9uRXhpc3RlbmNlUHJvb2Z8bnVsbHx1bmRlZmluZWR9IG5vbmV4aXN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21taXRtZW50UHJvb2ZcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBDb21taXRtZW50UHJvb2YucHJvdG90eXBlLm5vbmV4aXN0ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tbWl0bWVudFByb29mIGJhdGNoLlxuICAgICAgICAgKiBAbWVtYmVyIHtpY3MyMy5JQmF0Y2hQcm9vZnxudWxsfHVuZGVmaW5lZH0gYmF0Y2hcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbW1pdG1lbnRQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIENvbW1pdG1lbnRQcm9vZi5wcm90b3R5cGUuYmF0Y2ggPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21taXRtZW50UHJvb2YgY29tcHJlc3NlZC5cbiAgICAgICAgICogQG1lbWJlciB7aWNzMjMuSUNvbXByZXNzZWRCYXRjaFByb29mfG51bGx8dW5kZWZpbmVkfSBjb21wcmVzc2VkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21taXRtZW50UHJvb2ZcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBDb21taXRtZW50UHJvb2YucHJvdG90eXBlLmNvbXByZXNzZWQgPSBudWxsO1xuXG4gICAgICAgIC8vIE9uZU9mIGZpZWxkIG5hbWVzIGJvdW5kIHRvIHZpcnR1YWwgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICAgICAgICB2YXIgJG9uZU9mRmllbGRzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21taXRtZW50UHJvb2YgcHJvb2YuXG4gICAgICAgICAqIEBtZW1iZXIge1wiZXhpc3RcInxcIm5vbmV4aXN0XCJ8XCJiYXRjaFwifFwiY29tcHJlc3NlZFwifHVuZGVmaW5lZH0gcHJvb2ZcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbW1pdG1lbnRQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21taXRtZW50UHJvb2YucHJvdG90eXBlLCBcInByb29mXCIsIHtcbiAgICAgICAgICAgIGdldDogJHV0aWwub25lT2ZHZXR0ZXIoJG9uZU9mRmllbGRzID0gW1wiZXhpc3RcIiwgXCJub25leGlzdFwiLCBcImJhdGNoXCIsIFwiY29tcHJlc3NlZFwiXSksXG4gICAgICAgICAgICBzZXQ6ICR1dGlsLm9uZU9mU2V0dGVyKCRvbmVPZkZpZWxkcylcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgQ29tbWl0bWVudFByb29mIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tbWl0bWVudFByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQ29tbWl0bWVudFByb29mPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Db21taXRtZW50UHJvb2Z9IENvbW1pdG1lbnRQcm9vZiBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQ29tbWl0bWVudFByb29mLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbW1pdG1lbnRQcm9vZihwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIENvbW1pdG1lbnRQcm9vZiBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBpY3MyMy5Db21taXRtZW50UHJvb2YudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbW1pdG1lbnRQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUNvbW1pdG1lbnRQcm9vZn0gbWVzc2FnZSBDb21taXRtZW50UHJvb2YgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBDb21taXRtZW50UHJvb2YuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmV4aXN0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImV4aXN0XCIpKVxuICAgICAgICAgICAgICAgICRyb290LmljczIzLkV4aXN0ZW5jZVByb29mLmVuY29kZShtZXNzYWdlLmV4aXN0LCB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ub25leGlzdCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJub25leGlzdFwiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5pY3MyMy5Ob25FeGlzdGVuY2VQcm9vZi5lbmNvZGUobWVzc2FnZS5ub25leGlzdCwgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuYmF0Y2ggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYmF0Y2hcIikpXG4gICAgICAgICAgICAgICAgJHJvb3QuaWNzMjMuQmF0Y2hQcm9vZi5lbmNvZGUobWVzc2FnZS5iYXRjaCwgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAyID0qLzI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuY29tcHJlc3NlZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjb21wcmVzc2VkXCIpKVxuICAgICAgICAgICAgICAgICRyb290LmljczIzLkNvbXByZXNzZWRCYXRjaFByb29mLmVuY29kZShtZXNzYWdlLmNvbXByZXNzZWQsIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki8zNCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBDb21taXRtZW50UHJvb2YgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgaWNzMjMuQ29tbWl0bWVudFByb29mLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21taXRtZW50UHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklDb21taXRtZW50UHJvb2Z9IG1lc3NhZ2UgQ29tbWl0bWVudFByb29mIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgQ29tbWl0bWVudFByb29mLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgQ29tbWl0bWVudFByb29mIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbW1pdG1lbnRQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuQ29tbWl0bWVudFByb29mfSBDb21taXRtZW50UHJvb2ZcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBDb21taXRtZW50UHJvb2YuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuaWNzMjMuQ29tbWl0bWVudFByb29mKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXhpc3QgPSAkcm9vdC5pY3MyMy5FeGlzdGVuY2VQcm9vZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uubm9uZXhpc3QgPSAkcm9vdC5pY3MyMy5Ob25FeGlzdGVuY2VQcm9vZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYmF0Y2ggPSAkcm9vdC5pY3MyMy5CYXRjaFByb29mLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb21wcmVzc2VkID0gJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEJhdGNoUHJvb2YuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIENvbW1pdG1lbnRQcm9vZiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21taXRtZW50UHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkNvbW1pdG1lbnRQcm9vZn0gQ29tbWl0bWVudFByb29mXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgQ29tbWl0bWVudFByb29mLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIENvbW1pdG1lbnRQcm9vZiBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21taXRtZW50UHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIENvbW1pdG1lbnRQcm9vZi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXhpc3QgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZXhpc3RcIikpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnByb29mID0gMTtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmljczIzLkV4aXN0ZW5jZVByb29mLnZlcmlmeShtZXNzYWdlLmV4aXN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZXhpc3QuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ub25leGlzdCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJub25leGlzdFwiKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLnByb29mID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwcm9vZjogbXVsdGlwbGUgdmFsdWVzXCI7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5wcm9vZiA9IDE7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5pY3MyMy5Ob25FeGlzdGVuY2VQcm9vZi52ZXJpZnkobWVzc2FnZS5ub25leGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm5vbmV4aXN0LlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuYmF0Y2ggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYmF0Y2hcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5wcm9vZiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicHJvb2Y6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHJvb2YgPSAxO1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuaWNzMjMuQmF0Y2hQcm9vZi52ZXJpZnkobWVzc2FnZS5iYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJhdGNoLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuY29tcHJlc3NlZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjb21wcmVzc2VkXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMucHJvb2YgPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInByb29mOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnByb29mID0gMTtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmljczIzLkNvbXByZXNzZWRCYXRjaFByb29mLnZlcmlmeShtZXNzYWdlLmNvbXByZXNzZWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb21wcmVzc2VkLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBDb21taXRtZW50UHJvb2YgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tbWl0bWVudFByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuQ29tbWl0bWVudFByb29mfSBDb21taXRtZW50UHJvb2ZcbiAgICAgICAgICovXG4gICAgICAgIENvbW1pdG1lbnRQcm9vZi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5pY3MyMy5Db21taXRtZW50UHJvb2YpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmljczIzLkNvbW1pdG1lbnRQcm9vZigpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5leGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZXhpc3QgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5pY3MyMy5Db21taXRtZW50UHJvb2YuZXhpc3Q6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmV4aXN0ID0gJHJvb3QuaWNzMjMuRXhpc3RlbmNlUHJvb2YuZnJvbU9iamVjdChvYmplY3QuZXhpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5ub25leGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Qubm9uZXhpc3QgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5pY3MyMy5Db21taXRtZW50UHJvb2Yubm9uZXhpc3Q6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm5vbmV4aXN0ID0gJHJvb3QuaWNzMjMuTm9uRXhpc3RlbmNlUHJvb2YuZnJvbU9iamVjdChvYmplY3Qubm9uZXhpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5iYXRjaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuYmF0Y2ggIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5pY3MyMy5Db21taXRtZW50UHJvb2YuYmF0Y2g6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmJhdGNoID0gJHJvb3QuaWNzMjMuQmF0Y2hQcm9vZi5mcm9tT2JqZWN0KG9iamVjdC5iYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqZWN0LmNvbXByZXNzZWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmNvbXByZXNzZWQgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5pY3MyMy5Db21taXRtZW50UHJvb2YuY29tcHJlc3NlZDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29tcHJlc3NlZCA9ICRyb290LmljczIzLkNvbXByZXNzZWRCYXRjaFByb29mLmZyb21PYmplY3Qob2JqZWN0LmNvbXByZXNzZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIENvbW1pdG1lbnRQcm9vZiBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tbWl0bWVudFByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5Db21taXRtZW50UHJvb2Z9IG1lc3NhZ2UgQ29tbWl0bWVudFByb29mXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgQ29tbWl0bWVudFByb29mLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmV4aXN0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImV4aXN0XCIpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmV4aXN0ID0gJHJvb3QuaWNzMjMuRXhpc3RlbmNlUHJvb2YudG9PYmplY3QobWVzc2FnZS5leGlzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QucHJvb2YgPSBcImV4aXN0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ub25leGlzdCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJub25leGlzdFwiKSkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5ub25leGlzdCA9ICRyb290LmljczIzLk5vbkV4aXN0ZW5jZVByb29mLnRvT2JqZWN0KG1lc3NhZ2Uubm9uZXhpc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnByb29mID0gXCJub25leGlzdFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuYmF0Y2ggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYmF0Y2hcIikpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuYmF0Y2ggPSAkcm9vdC5pY3MyMy5CYXRjaFByb29mLnRvT2JqZWN0KG1lc3NhZ2UuYmF0Y2gsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnByb29mID0gXCJiYXRjaFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuY29tcHJlc3NlZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjb21wcmVzc2VkXCIpKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmNvbXByZXNzZWQgPSAkcm9vdC5pY3MyMy5Db21wcmVzc2VkQmF0Y2hQcm9vZi50b09iamVjdChtZXNzYWdlLmNvbXByZXNzZWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnByb29mID0gXCJjb21wcmVzc2VkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIENvbW1pdG1lbnRQcm9vZiB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21taXRtZW50UHJvb2ZcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIENvbW1pdG1lbnRQcm9vZi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIENvbW1pdG1lbnRQcm9vZjtcbiAgICB9KSgpO1xuXG4gICAgaWNzMjMuTGVhZk9wID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgTGVhZk9wLlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjNcbiAgICAgICAgICogQGludGVyZmFjZSBJTGVhZk9wXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7aWNzMjMuSGFzaE9wfG51bGx9IFtoYXNoXSBMZWFmT3AgaGFzaFxuICAgICAgICAgKiBAcHJvcGVydHkge2ljczIzLkhhc2hPcHxudWxsfSBbcHJlaGFzaEtleV0gTGVhZk9wIHByZWhhc2hLZXlcbiAgICAgICAgICogQHByb3BlcnR5IHtpY3MyMy5IYXNoT3B8bnVsbH0gW3ByZWhhc2hWYWx1ZV0gTGVhZk9wIHByZWhhc2hWYWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge2ljczIzLkxlbmd0aE9wfG51bGx9IFtsZW5ndGhdIExlYWZPcCBsZW5ndGhcbiAgICAgICAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fG51bGx9IFtwcmVmaXhdIExlYWZPcCBwcmVmaXhcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTGVhZk9wLlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjNcbiAgICAgICAgICogQGNsYXNzZGVzYyBMZWFmT3AgcmVwcmVzZW50cyB0aGUgcmF3IGtleS12YWx1ZSBkYXRhIHdlIHdpc2ggdG8gcHJvdmUsIGFuZFxuICAgICAgICAgKiBtdXN0IGJlIGZsZXhpYmxlIHRvIHJlcHJlc2VudCB0aGUgaW50ZXJuYWwgdHJhbnNmb3JtYXRpb24gZnJvbVxuICAgICAgICAgKiB0aGUgb3JpZ2luYWwga2V5LXZhbHVlIHBhaXJzIGludG8gdGhlIGJhc2lzIGhhc2gsIGZvciBtYW55IGV4aXN0aW5nXG4gICAgICAgICAqIG1lcmtsZSB0cmVlcy5cbiAgICAgICAgICogXG4gICAgICAgICAqIGtleSBhbmQgdmFsdWUgYXJlIHBhc3NlZCBpbi4gU28gdGhhdCB0aGUgc2lnbmF0dXJlIG9mIHRoaXMgb3BlcmF0aW9uIGlzOlxuICAgICAgICAgKiBsZWFmT3Aoa2V5LCB2YWx1ZSkgLT4gb3V0cHV0XG4gICAgICAgICAqIFxuICAgICAgICAgKiBUbyBwcm9jZXNzIHRoaXMsIGZpcnN0IHByZWhhc2ggdGhlIGtleXMgYW5kIHZhbHVlcyBpZiBuZWVkZWQgKEFOWSBtZWFucyBubyBoYXNoIGluIHRoaXMgY2FzZSk6XG4gICAgICAgICAqIGhrZXkgPSBwcmVoYXNoS2V5KGtleSlcbiAgICAgICAgICogaHZhbHVlID0gcHJlaGFzaFZhbHVlKHZhbHVlKVxuICAgICAgICAgKiBcbiAgICAgICAgICogVGhlbiBjb21iaW5lIHRoZSBieXRlcywgYW5kIGhhc2ggaXRcbiAgICAgICAgICogb3V0cHV0ID0gaGFzaChwcmVmaXggfHwgbGVuZ3RoKGhrZXkpIHx8IGhrZXkgfHwgbGVuZ3RoKGh2YWx1ZSkgfHwgaHZhbHVlKVxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJTGVhZk9wXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklMZWFmT3A9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIExlYWZPcChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExlYWZPcCBoYXNoLlxuICAgICAgICAgKiBAbWVtYmVyIHtpY3MyMy5IYXNoT3B9IGhhc2hcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkxlYWZPcFxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIExlYWZPcC5wcm90b3R5cGUuaGFzaCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExlYWZPcCBwcmVoYXNoS2V5LlxuICAgICAgICAgKiBAbWVtYmVyIHtpY3MyMy5IYXNoT3B9IHByZWhhc2hLZXlcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkxlYWZPcFxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIExlYWZPcC5wcm90b3R5cGUucHJlaGFzaEtleSA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExlYWZPcCBwcmVoYXNoVmFsdWUuXG4gICAgICAgICAqIEBtZW1iZXIge2ljczIzLkhhc2hPcH0gcHJlaGFzaFZhbHVlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5MZWFmT3BcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBMZWFmT3AucHJvdG90eXBlLnByZWhhc2hWYWx1ZSA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExlYWZPcCBsZW5ndGguXG4gICAgICAgICAqIEBtZW1iZXIge2ljczIzLkxlbmd0aE9wfSBsZW5ndGhcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkxlYWZPcFxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIExlYWZPcC5wcm90b3R5cGUubGVuZ3RoID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTGVhZk9wIHByZWZpeC5cbiAgICAgICAgICogQG1lbWJlciB7VWludDhBcnJheX0gcHJlZml4XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5MZWFmT3BcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBMZWFmT3AucHJvdG90eXBlLnByZWZpeCA9ICR1dGlsLm5ld0J1ZmZlcihbXSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgTGVhZk9wIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuTGVhZk9wXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JTGVhZk9wPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5MZWFmT3B9IExlYWZPcCBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgTGVhZk9wLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExlYWZPcChwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIExlYWZPcCBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBpY3MyMy5MZWFmT3AudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkxlYWZPcFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUxlYWZPcH0gbWVzc2FnZSBMZWFmT3AgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBMZWFmT3AuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmhhc2ggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaGFzaFwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovOCkuaW50MzIobWVzc2FnZS5oYXNoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnByZWhhc2hLZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicHJlaGFzaEtleVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDAgPSovMTYpLmludDMyKG1lc3NhZ2UucHJlaGFzaEtleSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wcmVoYXNoVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicHJlaGFzaFZhbHVlXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMywgd2lyZVR5cGUgMCA9Ki8yNCkuaW50MzIobWVzc2FnZS5wcmVoYXNoVmFsdWUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubGVuZ3RoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxlbmd0aFwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDQsIHdpcmVUeXBlIDAgPSovMzIpLmludDMyKG1lc3NhZ2UubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnByZWZpeCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcmVmaXhcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA1LCB3aXJlVHlwZSAyID0qLzQyKS5ieXRlcyhtZXNzYWdlLnByZWZpeCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgTGVhZk9wIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIGljczIzLkxlYWZPcC52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuTGVhZk9wXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JTGVhZk9wfSBtZXNzYWdlIExlYWZPcCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIExlYWZPcC5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIExlYWZPcCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5MZWFmT3BcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkxlYWZPcH0gTGVhZk9wXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgTGVhZk9wLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmljczIzLkxlYWZPcCgpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmhhc2ggPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByZWhhc2hLZXkgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByZWhhc2hWYWx1ZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGVuZ3RoID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcmVmaXggPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIExlYWZPcCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5MZWFmT3BcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkxlYWZPcH0gTGVhZk9wXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgTGVhZk9wLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIExlYWZPcCBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5MZWFmT3BcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIExlYWZPcC52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5oYXNoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImhhc2hcIikpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLmhhc2gpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJoYXNoOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wcmVoYXNoS2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInByZWhhc2hLZXlcIikpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLnByZWhhc2hLZXkpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwcmVoYXNoS2V5OiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wcmVoYXNoVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicHJlaGFzaFZhbHVlXCIpKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS5wcmVoYXNoVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwcmVoYXNoVmFsdWU6IGVudW0gdmFsdWUgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmxlbmd0aCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsZW5ndGhcIikpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxlbmd0aDogZW51bSB2YWx1ZSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wcmVmaXggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicHJlZml4XCIpKVxuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UucHJlZml4ICYmIHR5cGVvZiBtZXNzYWdlLnByZWZpeC5sZW5ndGggPT09IFwibnVtYmVyXCIgfHwgJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5wcmVmaXgpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicHJlZml4OiBidWZmZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgTGVhZk9wIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkxlYWZPcFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkxlYWZPcH0gTGVhZk9wXG4gICAgICAgICAqL1xuICAgICAgICBMZWFmT3AuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuaWNzMjMuTGVhZk9wKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5pY3MyMy5MZWFmT3AoKTtcbiAgICAgICAgICAgIHN3aXRjaCAob2JqZWN0Lmhhc2gpIHtcbiAgICAgICAgICAgIGNhc2UgXCJOT19IQVNIXCI6XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5oYXNoID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTSEEyNTZcIjpcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmhhc2ggPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNIQTUxMlwiOlxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGFzaCA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiS0VDQ0FLXCI6XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5oYXNoID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJSSVBFTUQxNjBcIjpcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmhhc2ggPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkJJVENPSU5cIjpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmhhc2ggPSA1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNIQTUxMl8yNTZcIjpcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmhhc2ggPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChvYmplY3QucHJlaGFzaEtleSkge1xuICAgICAgICAgICAgY2FzZSBcIk5PX0hBU0hcIjpcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnByZWhhc2hLZXkgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNIQTI1NlwiOlxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJlaGFzaEtleSA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiU0hBNTEyXCI6XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5wcmVoYXNoS2V5ID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJLRUNDQUtcIjpcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnByZWhhc2hLZXkgPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlJJUEVNRDE2MFwiOlxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJlaGFzaEtleSA9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQklUQ09JTlwiOlxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJlaGFzaEtleSA9IDU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiU0hBNTEyXzI1NlwiOlxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJlaGFzaEtleSA9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKG9iamVjdC5wcmVoYXNoVmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJOT19IQVNIXCI6XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5wcmVoYXNoVmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNIQTI1NlwiOlxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJlaGFzaFZhbHVlID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTSEE1MTJcIjpcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnByZWhhc2hWYWx1ZSA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiS0VDQ0FLXCI6XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5wcmVoYXNoVmFsdWUgPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlJJUEVNRDE2MFwiOlxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJlaGFzaFZhbHVlID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJCSVRDT0lOXCI6XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5wcmVoYXNoVmFsdWUgPSA1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNIQTUxMl8yNTZcIjpcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnByZWhhc2hWYWx1ZSA9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKG9iamVjdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgXCJOT19QUkVGSVhcIjpcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiVkFSX1BST1RPXCI6XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5sZW5ndGggPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlZBUl9STFBcIjpcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmxlbmd0aCA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRklYRUQzMl9CSUdcIjpcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmxlbmd0aCA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRklYRUQzMl9MSVRUTEVcIjpcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmxlbmd0aCA9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRklYRUQ2NF9CSUdcIjpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmxlbmd0aCA9IDU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRklYRUQ2NF9MSVRUTEVcIjpcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmxlbmd0aCA9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUkVRVUlSRV8zMl9CWVRFU1wiOlxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UubGVuZ3RoID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJSRVFVSVJFXzY0X0JZVEVTXCI6XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5sZW5ndGggPSA4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5wcmVmaXggIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5wcmVmaXggPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICR1dGlsLmJhc2U2NC5kZWNvZGUob2JqZWN0LnByZWZpeCwgbWVzc2FnZS5wcmVmaXggPSAkdXRpbC5uZXdCdWZmZXIoJHV0aWwuYmFzZTY0Lmxlbmd0aChvYmplY3QucHJlZml4KSksIDApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdC5wcmVmaXgubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByZWZpeCA9IG9iamVjdC5wcmVmaXg7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgTGVhZk9wIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5MZWFmT3BcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLkxlYWZPcH0gbWVzc2FnZSBMZWFmT3BcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBMZWFmT3AudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuaGFzaCA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/IFwiTk9fSEFTSFwiIDogMDtcbiAgICAgICAgICAgICAgICBvYmplY3QucHJlaGFzaEtleSA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/IFwiTk9fSEFTSFwiIDogMDtcbiAgICAgICAgICAgICAgICBvYmplY3QucHJlaGFzaFZhbHVlID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gXCJOT19IQVNIXCIgOiAwO1xuICAgICAgICAgICAgICAgIG9iamVjdC5sZW5ndGggPSBvcHRpb25zLmVudW1zID09PSBTdHJpbmcgPyBcIk5PX1BSRUZJWFwiIDogMDtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QucHJlZml4ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnByZWZpeCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyAhPT0gQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QucHJlZml4ID0gJHV0aWwubmV3QnVmZmVyKG9iamVjdC5wcmVmaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmhhc2ggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaGFzaFwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuaGFzaCA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/ICRyb290LmljczIzLkhhc2hPcFttZXNzYWdlLmhhc2hdIDogbWVzc2FnZS5oYXNoO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucHJlaGFzaEtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcmVoYXNoS2V5XCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5wcmVoYXNoS2V5ID0gb3B0aW9ucy5lbnVtcyA9PT0gU3RyaW5nID8gJHJvb3QuaWNzMjMuSGFzaE9wW21lc3NhZ2UucHJlaGFzaEtleV0gOiBtZXNzYWdlLnByZWhhc2hLZXk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wcmVoYXNoVmFsdWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicHJlaGFzaFZhbHVlXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5wcmVoYXNoVmFsdWUgPSBvcHRpb25zLmVudW1zID09PSBTdHJpbmcgPyAkcm9vdC5pY3MyMy5IYXNoT3BbbWVzc2FnZS5wcmVoYXNoVmFsdWVdIDogbWVzc2FnZS5wcmVoYXNoVmFsdWU7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5sZW5ndGggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibGVuZ3RoXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5sZW5ndGggPSBvcHRpb25zLmVudW1zID09PSBTdHJpbmcgPyAkcm9vdC5pY3MyMy5MZW5ndGhPcFttZXNzYWdlLmxlbmd0aF0gOiBtZXNzYWdlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnByZWZpeCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJwcmVmaXhcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnByZWZpeCA9IG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZyA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobWVzc2FnZS5wcmVmaXgsIDAsIG1lc3NhZ2UucHJlZml4Lmxlbmd0aCkgOiBvcHRpb25zLmJ5dGVzID09PSBBcnJheSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG1lc3NhZ2UucHJlZml4KSA6IG1lc3NhZ2UucHJlZml4O1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBMZWFmT3AgdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuTGVhZk9wXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBMZWFmT3AucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBMZWFmT3A7XG4gICAgfSkoKTtcblxuICAgIGljczIzLklubmVyT3AgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYW4gSW5uZXJPcC5cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzXG4gICAgICAgICAqIEBpbnRlcmZhY2UgSUlubmVyT3BcbiAgICAgICAgICogQHByb3BlcnR5IHtpY3MyMy5IYXNoT3B8bnVsbH0gW2hhc2hdIElubmVyT3AgaGFzaFxuICAgICAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl8bnVsbH0gW3ByZWZpeF0gSW5uZXJPcCBwcmVmaXhcbiAgICAgICAgICogQHByb3BlcnR5IHtVaW50OEFycmF5fG51bGx9IFtzdWZmaXhdIElubmVyT3Agc3VmZml4XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IElubmVyT3AuXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyM1xuICAgICAgICAgKiBAY2xhc3NkZXNjIElubmVyT3AgcmVwcmVzZW50cyBhIG1lcmtsZS1wcm9vZiBzdGVwIHRoYXQgaXMgbm90IGEgbGVhZi5cbiAgICAgICAgICogSXQgcmVwcmVzZW50cyBjb25jYXRlbmF0aW5nIHR3byBjaGlsZHJlbiBhbmQgaGFzaGluZyB0aGVtIHRvIHByb3ZpZGUgdGhlIG5leHQgcmVzdWx0LlxuICAgICAgICAgKiBcbiAgICAgICAgICogVGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXMgc3RlcCBpcyBwYXNzZWQgaW4sIHNvIHRoZSBzaWduYXR1cmUgb2YgdGhpcyBvcCBpczpcbiAgICAgICAgICogaW5uZXJPcChjaGlsZCkgLT4gb3V0cHV0XG4gICAgICAgICAqIFxuICAgICAgICAgKiBUaGUgcmVzdWx0IG9mIGFwcGx5aW5nIElubmVyT3Agc2hvdWxkIGJlOlxuICAgICAgICAgKiBvdXRwdXQgPSBvcC5oYXNoKG9wLnByZWZpeCB8fCBjaGlsZCB8fCBvcC5zdWZmaXgpXG4gICAgICAgICAqIFxuICAgICAgICAgKiB3aGVyZSB0aGUgfHwgb3BlcmF0b3IgaXMgY29uY2F0ZW5hdGlvbiBvZiBiaW5hcnkgZGF0YSxcbiAgICAgICAgICogYW5kIGNoaWxkIGlzIHRoZSByZXN1bHQgb2YgaGFzaGluZyBhbGwgdGhlIHRyZWUgYmVsb3cgdGhpcyBzdGVwLlxuICAgICAgICAgKiBcbiAgICAgICAgICogQW55IHNwZWNpYWwgZGF0YSwgbGlrZSBwcmVwZW5kaW5nIGNoaWxkIHdpdGggdGhlIGxlbmd0aCwgb3IgcHJlcGVuZGluZyB0aGUgZW50aXJlIG9wZXJhdGlvbiB3aXRoXG4gICAgICAgICAqIHNvbWUgdmFsdWUgdG8gZGlmZmVyZW50aWF0ZSBmcm9tIGxlYWYgbm9kZXMsIHNob3VsZCBiZSBpbmNsdWRlZCBpbiBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAgICAgICogSWYgZWl0aGVyIG9mIHByZWZpeCBvciBzdWZmaXggaXMgZW1wdHksIHdlIGp1c3QgdHJlYXQgaXQgYXMgYW4gZW1wdHkgc3RyaW5nXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElJbm5lck9wXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklJbm5lck9wPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBJbm5lck9wKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5uZXJPcCBoYXNoLlxuICAgICAgICAgKiBAbWVtYmVyIHtpY3MyMy5IYXNoT3B9IGhhc2hcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLklubmVyT3BcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBJbm5lck9wLnByb3RvdHlwZS5oYXNoID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5uZXJPcCBwcmVmaXguXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQ4QXJyYXl9IHByZWZpeFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuSW5uZXJPcFxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIElubmVyT3AucHJvdG90eXBlLnByZWZpeCA9ICR1dGlsLm5ld0J1ZmZlcihbXSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElubmVyT3Agc3VmZml4LlxuICAgICAgICAgKiBAbWVtYmVyIHtVaW50OEFycmF5fSBzdWZmaXhcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLklubmVyT3BcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBJbm5lck9wLnByb3RvdHlwZS5zdWZmaXggPSAkdXRpbC5uZXdCdWZmZXIoW10pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IElubmVyT3AgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Jbm5lck9wXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JSW5uZXJPcD19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuSW5uZXJPcH0gSW5uZXJPcCBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgSW5uZXJPcC5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbm5lck9wKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgSW5uZXJPcCBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBpY3MyMy5Jbm5lck9wLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Jbm5lck9wXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JSW5uZXJPcH0gbWVzc2FnZSBJbm5lck9wIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgSW5uZXJPcC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaGFzaCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJoYXNoXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki84KS5pbnQzMihtZXNzYWdlLmhhc2gpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucHJlZml4ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInByZWZpeFwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLmJ5dGVzKG1lc3NhZ2UucHJlZml4KTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN1ZmZpeCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzdWZmaXhcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAyID0qLzI2KS5ieXRlcyhtZXNzYWdlLnN1ZmZpeCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgSW5uZXJPcCBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBpY3MyMy5Jbm5lck9wLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Jbm5lck9wXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JSW5uZXJPcH0gbWVzc2FnZSBJbm5lck9wIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgSW5uZXJPcC5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhbiBJbm5lck9wIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLklubmVyT3BcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLklubmVyT3B9IElubmVyT3BcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBJbm5lck9wLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmljczIzLklubmVyT3AoKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5oYXNoID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcmVmaXggPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN1ZmZpeCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGFuIElubmVyT3AgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuSW5uZXJPcFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuSW5uZXJPcH0gSW5uZXJPcFxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIElubmVyT3AuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGFuIElubmVyT3AgbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuSW5uZXJPcFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgSW5uZXJPcC52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5oYXNoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImhhc2hcIikpXG4gICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLmhhc2gpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJoYXNoOiBlbnVtIHZhbHVlIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wcmVmaXggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicHJlZml4XCIpKVxuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UucHJlZml4ICYmIHR5cGVvZiBtZXNzYWdlLnByZWZpeC5sZW5ndGggPT09IFwibnVtYmVyXCIgfHwgJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5wcmVmaXgpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicHJlZml4OiBidWZmZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN1ZmZpeCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJzdWZmaXhcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5zdWZmaXggJiYgdHlwZW9mIG1lc3NhZ2Uuc3VmZml4Lmxlbmd0aCA9PT0gXCJudW1iZXJcIiB8fCAkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnN1ZmZpeCkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdWZmaXg6IGJ1ZmZlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gSW5uZXJPcCBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Jbm5lck9wXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuSW5uZXJPcH0gSW5uZXJPcFxuICAgICAgICAgKi9cbiAgICAgICAgSW5uZXJPcC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5pY3MyMy5Jbm5lck9wKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5pY3MyMy5Jbm5lck9wKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKG9iamVjdC5oYXNoKSB7XG4gICAgICAgICAgICBjYXNlIFwiTk9fSEFTSFwiOlxuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGFzaCA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiU0hBMjU2XCI6XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5oYXNoID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTSEE1MTJcIjpcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmhhc2ggPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIktFQ0NBS1wiOlxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGFzaCA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiUklQRU1EMTYwXCI6XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5oYXNoID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJCSVRDT0lOXCI6XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5oYXNoID0gNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTSEE1MTJfMjU2XCI6XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5oYXNoID0gNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3QucHJlZml4ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QucHJlZml4ID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICAkdXRpbC5iYXNlNjQuZGVjb2RlKG9iamVjdC5wcmVmaXgsIG1lc3NhZ2UucHJlZml4ID0gJHV0aWwubmV3QnVmZmVyKCR1dGlsLmJhc2U2NC5sZW5ndGgob2JqZWN0LnByZWZpeCkpLCAwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmplY3QucHJlZml4Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcmVmaXggPSBvYmplY3QucHJlZml4O1xuICAgICAgICAgICAgaWYgKG9iamVjdC5zdWZmaXggIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5zdWZmaXggPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICR1dGlsLmJhc2U2NC5kZWNvZGUob2JqZWN0LnN1ZmZpeCwgbWVzc2FnZS5zdWZmaXggPSAkdXRpbC5uZXdCdWZmZXIoJHV0aWwuYmFzZTY0Lmxlbmd0aChvYmplY3Quc3VmZml4KSksIDApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iamVjdC5zdWZmaXgubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN1ZmZpeCA9IG9iamVjdC5zdWZmaXg7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGFuIElubmVyT3AgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLklubmVyT3BcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklubmVyT3B9IG1lc3NhZ2UgSW5uZXJPcFxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIElubmVyT3AudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuaGFzaCA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/IFwiTk9fSEFTSFwiIDogMDtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QucHJlZml4ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnByZWZpeCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyAhPT0gQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3QucHJlZml4ID0gJHV0aWwubmV3QnVmZmVyKG9iamVjdC5wcmVmaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3Quc3VmZml4ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnN1ZmZpeCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyAhPT0gQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Quc3VmZml4ID0gJHV0aWwubmV3QnVmZmVyKG9iamVjdC5zdWZmaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmhhc2ggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaGFzaFwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuaGFzaCA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/ICRyb290LmljczIzLkhhc2hPcFttZXNzYWdlLmhhc2hdIDogbWVzc2FnZS5oYXNoO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucHJlZml4ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInByZWZpeFwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QucHJlZml4ID0gb3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nID8gJHV0aWwuYmFzZTY0LmVuY29kZShtZXNzYWdlLnByZWZpeCwgMCwgbWVzc2FnZS5wcmVmaXgubGVuZ3RoKSA6IG9wdGlvbnMuYnl0ZXMgPT09IEFycmF5ID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobWVzc2FnZS5wcmVmaXgpIDogbWVzc2FnZS5wcmVmaXg7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5zdWZmaXggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwic3VmZml4XCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5zdWZmaXggPSBvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcgPyAkdXRpbC5iYXNlNjQuZW5jb2RlKG1lc3NhZ2Uuc3VmZml4LCAwLCBtZXNzYWdlLnN1ZmZpeC5sZW5ndGgpIDogb3B0aW9ucy5ieXRlcyA9PT0gQXJyYXkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLnN1ZmZpeCkgOiBtZXNzYWdlLnN1ZmZpeDtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgSW5uZXJPcCB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Jbm5lck9wXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBJbm5lck9wLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gSW5uZXJPcDtcbiAgICB9KSgpO1xuXG4gICAgaWNzMjMuUHJvb2ZTcGVjID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgUHJvb2ZTcGVjLlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjNcbiAgICAgICAgICogQGludGVyZmFjZSBJUHJvb2ZTcGVjXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7aWNzMjMuSUxlYWZPcHxudWxsfSBbbGVhZlNwZWNdIFByb29mU3BlYyBsZWFmU3BlY1xuICAgICAgICAgKiBAcHJvcGVydHkge2ljczIzLklJbm5lclNwZWN8bnVsbH0gW2lubmVyU3BlY10gUHJvb2ZTcGVjIGlubmVyU3BlY1xuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbbWF4RGVwdGhdIFByb29mU3BlYyBtYXhEZXB0aFxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbbWluRGVwdGhdIFByb29mU3BlYyBtaW5EZXB0aFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBQcm9vZlNwZWMuXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyM1xuICAgICAgICAgKiBAY2xhc3NkZXNjIFByb29mU3BlYyBkZWZpbmVzIHdoYXQgdGhlIGV4cGVjdGVkIHBhcmFtZXRlcnMgYXJlIGZvciBhIGdpdmVuIHByb29mIHR5cGUuXG4gICAgICAgICAqIFRoaXMgY2FuIGJlIHN0b3JlZCBpbiB0aGUgY2xpZW50IGFuZCB1c2VkIHRvIHZhbGlkYXRlIGFueSBpbmNvbWluZyBwcm9vZnMuXG4gICAgICAgICAqIFxuICAgICAgICAgKiB2ZXJpZnkoUHJvb2ZTcGVjLCBQcm9vZikgLT4gUHJvb2YgfCBFcnJvclxuICAgICAgICAgKiBcbiAgICAgICAgICogQXMgZGVtb25zdHJhdGVkIGluIHRlc3RzLCBpZiB3ZSBkb24ndCBmaXggdGhlIGFsZ29yaXRobSB1c2VkIHRvIGNhbGN1bGF0ZSB0aGVcbiAgICAgICAgICogTGVhZkhhc2ggZm9yIGEgZ2l2ZW4gdHJlZSwgdGhlcmUgYXJlIG1hbnkgcG9zc2libGUga2V5LXZhbHVlIHBhaXJzIHRoYXQgY2FuXG4gICAgICAgICAqIGdlbmVyYXRlIGEgZ2l2ZW4gaGFzaCAoYnkgaW50ZXJwcmV0dGluZyB0aGUgcHJlaW1hZ2UgZGlmZmVyZW50bHkpLlxuICAgICAgICAgKiBXZSBuZWVkIHRoaXMgZm9yIHByb3BlciBzZWN1cml0eSwgcmVxdWlyZXMgY2xpZW50IGtub3dzIGEgcHJpb3JpIHdoYXRcbiAgICAgICAgICogdHJlZSBmb3JtYXQgc2VydmVyIHVzZXMuIEJ1dCBub3QgaW4gY29kZSwgcmF0aGVyIGEgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElQcm9vZlNwZWNcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSVByb29mU3BlYz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gUHJvb2ZTcGVjKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvb2ZTcGVjIGxlYWZTcGVjLlxuICAgICAgICAgKiBAbWVtYmVyIHtpY3MyMy5JTGVhZk9wfG51bGx8dW5kZWZpbmVkfSBsZWFmU3BlY1xuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuUHJvb2ZTcGVjXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgUHJvb2ZTcGVjLnByb3RvdHlwZS5sZWFmU3BlYyA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb29mU3BlYyBpbm5lclNwZWMuXG4gICAgICAgICAqIEBtZW1iZXIge2ljczIzLklJbm5lclNwZWN8bnVsbHx1bmRlZmluZWR9IGlubmVyU3BlY1xuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuUHJvb2ZTcGVjXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgUHJvb2ZTcGVjLnByb3RvdHlwZS5pbm5lclNwZWMgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9vZlNwZWMgbWF4RGVwdGguXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gbWF4RGVwdGhcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLlByb29mU3BlY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFByb29mU3BlYy5wcm90b3R5cGUubWF4RGVwdGggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9vZlNwZWMgbWluRGVwdGguXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gbWluRGVwdGhcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLlByb29mU3BlY1xuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFByb29mU3BlYy5wcm90b3R5cGUubWluRGVwdGggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFByb29mU3BlYyBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLlByb29mU3BlY1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSVByb29mU3BlYz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuUHJvb2ZTcGVjfSBQcm9vZlNwZWMgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFByb29mU3BlYy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9vZlNwZWMocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBQcm9vZlNwZWMgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgaWNzMjMuUHJvb2ZTcGVjLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Qcm9vZlNwZWNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklQcm9vZlNwZWN9IG1lc3NhZ2UgUHJvb2ZTcGVjIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgUHJvb2ZTcGVjLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5sZWFmU3BlYyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsZWFmU3BlY1wiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5pY3MyMy5MZWFmT3AuZW5jb2RlKG1lc3NhZ2UubGVhZlNwZWMsIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmlubmVyU3BlYyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpbm5lclNwZWNcIikpXG4gICAgICAgICAgICAgICAgJHJvb3QuaWNzMjMuSW5uZXJTcGVjLmVuY29kZShtZXNzYWdlLmlubmVyU3BlYywgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF4RGVwdGggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibWF4RGVwdGhcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAwID0qLzI0KS5pbnQzMihtZXNzYWdlLm1heERlcHRoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1pbkRlcHRoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm1pbkRlcHRoXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMCA9Ki8zMikuaW50MzIobWVzc2FnZS5taW5EZXB0aCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgUHJvb2ZTcGVjIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIGljczIzLlByb29mU3BlYy52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuUHJvb2ZTcGVjXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JUHJvb2ZTcGVjfSBtZXNzYWdlIFByb29mU3BlYyBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIFByb29mU3BlYy5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFByb29mU3BlYyBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Qcm9vZlNwZWNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLlByb29mU3BlY30gUHJvb2ZTcGVjXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgUHJvb2ZTcGVjLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmljczIzLlByb29mU3BlYygpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxlYWZTcGVjID0gJHJvb3QuaWNzMjMuTGVhZk9wLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbm5lclNwZWMgPSAkcm9vdC5pY3MyMy5Jbm5lclNwZWMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1heERlcHRoID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5taW5EZXB0aCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgUHJvb2ZTcGVjIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLlByb29mU3BlY1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuUHJvb2ZTcGVjfSBQcm9vZlNwZWNcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBQcm9vZlNwZWMuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgUHJvb2ZTcGVjIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLlByb29mU3BlY1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgUHJvb2ZTcGVjLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmxlYWZTcGVjICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxlYWZTcGVjXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuaWNzMjMuTGVhZk9wLnZlcmlmeShtZXNzYWdlLmxlYWZTcGVjKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxlYWZTcGVjLlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbm5lclNwZWMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaW5uZXJTcGVjXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuaWNzMjMuSW5uZXJTcGVjLnZlcmlmeShtZXNzYWdlLmlubmVyU3BlYyk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpbm5lclNwZWMuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1heERlcHRoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm1heERlcHRoXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UubWF4RGVwdGgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJtYXhEZXB0aDogaW50ZWdlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWluRGVwdGggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibWluRGVwdGhcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5taW5EZXB0aCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm1pbkRlcHRoOiBpbnRlZ2VyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIFByb29mU3BlYyBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Qcm9vZlNwZWNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Qcm9vZlNwZWN9IFByb29mU3BlY1xuICAgICAgICAgKi9cbiAgICAgICAgUHJvb2ZTcGVjLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmljczIzLlByb29mU3BlYylcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuaWNzMjMuUHJvb2ZTcGVjKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmxlYWZTcGVjICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5sZWFmU3BlYyAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmljczIzLlByb29mU3BlYy5sZWFmU3BlYzogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubGVhZlNwZWMgPSAkcm9vdC5pY3MyMy5MZWFmT3AuZnJvbU9iamVjdChvYmplY3QubGVhZlNwZWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5pbm5lclNwZWMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmlubmVyU3BlYyAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmljczIzLlByb29mU3BlYy5pbm5lclNwZWM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmlubmVyU3BlYyA9ICRyb290LmljczIzLklubmVyU3BlYy5mcm9tT2JqZWN0KG9iamVjdC5pbm5lclNwZWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5tYXhEZXB0aCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UubWF4RGVwdGggPSBvYmplY3QubWF4RGVwdGggfCAwO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5taW5EZXB0aCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UubWluRGVwdGggPSBvYmplY3QubWluRGVwdGggfCAwO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIFByb29mU3BlYyBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuUHJvb2ZTcGVjXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5Qcm9vZlNwZWN9IG1lc3NhZ2UgUHJvb2ZTcGVjXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgUHJvb2ZTcGVjLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmxlYWZTcGVjID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvYmplY3QuaW5uZXJTcGVjID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvYmplY3QubWF4RGVwdGggPSAwO1xuICAgICAgICAgICAgICAgIG9iamVjdC5taW5EZXB0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5sZWFmU3BlYyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsZWFmU3BlY1wiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QubGVhZlNwZWMgPSAkcm9vdC5pY3MyMy5MZWFmT3AudG9PYmplY3QobWVzc2FnZS5sZWFmU3BlYywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5pbm5lclNwZWMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaW5uZXJTcGVjXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5pbm5lclNwZWMgPSAkcm9vdC5pY3MyMy5Jbm5lclNwZWMudG9PYmplY3QobWVzc2FnZS5pbm5lclNwZWMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWF4RGVwdGggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibWF4RGVwdGhcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0Lm1heERlcHRoID0gbWVzc2FnZS5tYXhEZXB0aDtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1pbkRlcHRoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm1pbkRlcHRoXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5taW5EZXB0aCA9IG1lc3NhZ2UubWluRGVwdGg7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFByb29mU3BlYyB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Qcm9vZlNwZWNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFByb29mU3BlYy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIFByb29mU3BlYztcbiAgICB9KSgpO1xuXG4gICAgaWNzMjMuSW5uZXJTcGVjID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGFuIElubmVyU3BlYy5cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzXG4gICAgICAgICAqIEBpbnRlcmZhY2UgSUlubmVyU3BlY1xuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fG51bGx9IFtjaGlsZE9yZGVyXSBJbm5lclNwZWMgY2hpbGRPcmRlclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbY2hpbGRTaXplXSBJbm5lclNwZWMgY2hpbGRTaXplXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFttaW5QcmVmaXhMZW5ndGhdIElubmVyU3BlYyBtaW5QcmVmaXhMZW5ndGhcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW21heFByZWZpeExlbmd0aF0gSW5uZXJTcGVjIG1heFByZWZpeExlbmd0aFxuICAgICAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl8bnVsbH0gW2VtcHR5Q2hpbGRdIElubmVyU3BlYyBlbXB0eUNoaWxkXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7aWNzMjMuSGFzaE9wfG51bGx9IFtoYXNoXSBJbm5lclNwZWMgaGFzaFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBJbm5lclNwZWMuXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyM1xuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYW4gSW5uZXJTcGVjLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJSW5uZXJTcGVjXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklJbm5lclNwZWM9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIElubmVyU3BlYyhwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkT3JkZXIgPSBbXTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5uZXJTcGVjIGNoaWxkT3JkZXIuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBjaGlsZE9yZGVyXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Jbm5lclNwZWNcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBJbm5lclNwZWMucHJvdG90eXBlLmNoaWxkT3JkZXIgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbm5lclNwZWMgY2hpbGRTaXplLlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGNoaWxkU2l6ZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuSW5uZXJTcGVjXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgSW5uZXJTcGVjLnByb3RvdHlwZS5jaGlsZFNpemUgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbm5lclNwZWMgbWluUHJlZml4TGVuZ3RoLlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IG1pblByZWZpeExlbmd0aFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuSW5uZXJTcGVjXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgSW5uZXJTcGVjLnByb3RvdHlwZS5taW5QcmVmaXhMZW5ndGggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbm5lclNwZWMgbWF4UHJlZml4TGVuZ3RoLlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IG1heFByZWZpeExlbmd0aFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuSW5uZXJTcGVjXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgSW5uZXJTcGVjLnByb3RvdHlwZS5tYXhQcmVmaXhMZW5ndGggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbm5lclNwZWMgZW1wdHlDaGlsZC5cbiAgICAgICAgICogQG1lbWJlciB7VWludDhBcnJheX0gZW1wdHlDaGlsZFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuSW5uZXJTcGVjXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgSW5uZXJTcGVjLnByb3RvdHlwZS5lbXB0eUNoaWxkID0gJHV0aWwubmV3QnVmZmVyKFtdKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5uZXJTcGVjIGhhc2guXG4gICAgICAgICAqIEBtZW1iZXIge2ljczIzLkhhc2hPcH0gaGFzaFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuSW5uZXJTcGVjXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgSW5uZXJTcGVjLnByb3RvdHlwZS5oYXNoID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBJbm5lclNwZWMgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Jbm5lclNwZWNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklJbm5lclNwZWM9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLklubmVyU3BlY30gSW5uZXJTcGVjIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBJbm5lclNwZWMuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5uZXJTcGVjKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgSW5uZXJTcGVjIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIGljczIzLklubmVyU3BlYy52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuSW5uZXJTcGVjXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JSW5uZXJTcGVjfSBtZXNzYWdlIElubmVyU3BlYyBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIElubmVyU3BlYy5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuY2hpbGRPcmRlciAhPSBudWxsICYmIG1lc3NhZ2UuY2hpbGRPcmRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLmZvcmsoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuY2hpbGRPcmRlci5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLmludDMyKG1lc3NhZ2UuY2hpbGRPcmRlcltpXSk7XG4gICAgICAgICAgICAgICAgd3JpdGVyLmxkZWxpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuY2hpbGRTaXplICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImNoaWxkU2l6ZVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDAgPSovMTYpLmludDMyKG1lc3NhZ2UuY2hpbGRTaXplKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1pblByZWZpeExlbmd0aCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtaW5QcmVmaXhMZW5ndGhcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAwID0qLzI0KS5pbnQzMihtZXNzYWdlLm1pblByZWZpeExlbmd0aCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXhQcmVmaXhMZW5ndGggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibWF4UHJlZml4TGVuZ3RoXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMCA9Ki8zMikuaW50MzIobWVzc2FnZS5tYXhQcmVmaXhMZW5ndGgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZW1wdHlDaGlsZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJlbXB0eUNoaWxkXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNSwgd2lyZVR5cGUgMiA9Ki80MikuYnl0ZXMobWVzc2FnZS5lbXB0eUNoaWxkKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmhhc2ggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaGFzaFwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDYsIHdpcmVUeXBlIDAgPSovNDgpLmludDMyKG1lc3NhZ2UuaGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgSW5uZXJTcGVjIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIGljczIzLklubmVyU3BlYy52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuSW5uZXJTcGVjXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JSW5uZXJTcGVjfSBtZXNzYWdlIElubmVyU3BlYyBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIElubmVyU3BlYy5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhbiBJbm5lclNwZWMgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuSW5uZXJTcGVjXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Jbm5lclNwZWN9IElubmVyU3BlY1xuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIElubmVyU3BlYy5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5pY3MyMy5Jbm5lclNwZWMoKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5jaGlsZE9yZGVyICYmIG1lc3NhZ2UuY2hpbGRPcmRlci5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jaGlsZE9yZGVyID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNoaWxkT3JkZXIucHVzaChyZWFkZXIuaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jaGlsZE9yZGVyLnB1c2gocmVhZGVyLmludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2hpbGRTaXplID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5taW5QcmVmaXhMZW5ndGggPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1heFByZWZpeExlbmd0aCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZW1wdHlDaGlsZCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGFzaCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGFuIElubmVyU3BlYyBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Jbm5lclNwZWNcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge2ljczIzLklubmVyU3BlY30gSW5uZXJTcGVjXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgSW5uZXJTcGVjLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhbiBJbm5lclNwZWMgbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuSW5uZXJTcGVjXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBJbm5lclNwZWMudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuY2hpbGRPcmRlciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjaGlsZE9yZGVyXCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UuY2hpbGRPcmRlcikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNoaWxkT3JkZXI6IGFycmF5IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmNoaWxkT3JkZXIubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuY2hpbGRPcmRlcltpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjaGlsZE9yZGVyOiBpbnRlZ2VyW10gZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmNoaWxkU2l6ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjaGlsZFNpemVcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5jaGlsZFNpemUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjaGlsZFNpemU6IGludGVnZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1pblByZWZpeExlbmd0aCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtaW5QcmVmaXhMZW5ndGhcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5taW5QcmVmaXhMZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJtaW5QcmVmaXhMZW5ndGg6IGludGVnZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1heFByZWZpeExlbmd0aCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJtYXhQcmVmaXhMZW5ndGhcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5tYXhQcmVmaXhMZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJtYXhQcmVmaXhMZW5ndGg6IGludGVnZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmVtcHR5Q2hpbGQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZW1wdHlDaGlsZFwiKSlcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmVtcHR5Q2hpbGQgJiYgdHlwZW9mIG1lc3NhZ2UuZW1wdHlDaGlsZC5sZW5ndGggPT09IFwibnVtYmVyXCIgfHwgJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5lbXB0eUNoaWxkKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImVtcHR5Q2hpbGQ6IGJ1ZmZlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuaGFzaCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJoYXNoXCIpKVxuICAgICAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS5oYXNoKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaGFzaDogZW51bSB2YWx1ZSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gSW5uZXJTcGVjIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLklubmVyU3BlY1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLklubmVyU3BlY30gSW5uZXJTcGVjXG4gICAgICAgICAqL1xuICAgICAgICBJbm5lclNwZWMuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuaWNzMjMuSW5uZXJTcGVjKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5pY3MyMy5Jbm5lclNwZWMoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuY2hpbGRPcmRlcikge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuY2hpbGRPcmRlcikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5pY3MyMy5Jbm5lclNwZWMuY2hpbGRPcmRlcjogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5jaGlsZE9yZGVyID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuY2hpbGRPcmRlci5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jaGlsZE9yZGVyW2ldID0gb2JqZWN0LmNoaWxkT3JkZXJbaV0gfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5jaGlsZFNpemUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmNoaWxkU2l6ZSA9IG9iamVjdC5jaGlsZFNpemUgfCAwO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5taW5QcmVmaXhMZW5ndGggIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm1pblByZWZpeExlbmd0aCA9IG9iamVjdC5taW5QcmVmaXhMZW5ndGggfCAwO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5tYXhQcmVmaXhMZW5ndGggIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm1heFByZWZpeExlbmd0aCA9IG9iamVjdC5tYXhQcmVmaXhMZW5ndGggfCAwO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5lbXB0eUNoaWxkICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZW1wdHlDaGlsZCA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgJHV0aWwuYmFzZTY0LmRlY29kZShvYmplY3QuZW1wdHlDaGlsZCwgbWVzc2FnZS5lbXB0eUNoaWxkID0gJHV0aWwubmV3QnVmZmVyKCR1dGlsLmJhc2U2NC5sZW5ndGgob2JqZWN0LmVtcHR5Q2hpbGQpKSwgMCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqZWN0LmVtcHR5Q2hpbGQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmVtcHR5Q2hpbGQgPSBvYmplY3QuZW1wdHlDaGlsZDtcbiAgICAgICAgICAgIHN3aXRjaCAob2JqZWN0Lmhhc2gpIHtcbiAgICAgICAgICAgIGNhc2UgXCJOT19IQVNIXCI6XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5oYXNoID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTSEEyNTZcIjpcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmhhc2ggPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNIQTUxMlwiOlxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGFzaCA9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiS0VDQ0FLXCI6XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5oYXNoID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJSSVBFTUQxNjBcIjpcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmhhc2ggPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkJJVENPSU5cIjpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmhhc2ggPSA1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNIQTUxMl8yNTZcIjpcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmhhc2ggPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhbiBJbm5lclNwZWMgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLklubmVyU3BlY1xuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSW5uZXJTcGVjfSBtZXNzYWdlIElubmVyU3BlY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIElubmVyU3BlYy50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgICAgICBvYmplY3QuY2hpbGRPcmRlciA9IFtdO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuY2hpbGRTaXplID0gMDtcbiAgICAgICAgICAgICAgICBvYmplY3QubWluUHJlZml4TGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBvYmplY3QubWF4UHJlZml4TGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuZW1wdHlDaGlsZCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5lbXB0eUNoaWxkID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzICE9PSBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5lbXB0eUNoaWxkID0gJHV0aWwubmV3QnVmZmVyKG9iamVjdC5lbXB0eUNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqZWN0Lmhhc2ggPSBvcHRpb25zLmVudW1zID09PSBTdHJpbmcgPyBcIk5PX0hBU0hcIiA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5jaGlsZE9yZGVyICYmIG1lc3NhZ2UuY2hpbGRPcmRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuY2hpbGRPcmRlciA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWVzc2FnZS5jaGlsZE9yZGVyLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuY2hpbGRPcmRlcltqXSA9IG1lc3NhZ2UuY2hpbGRPcmRlcltqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmNoaWxkU2l6ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJjaGlsZFNpemVcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmNoaWxkU2l6ZSA9IG1lc3NhZ2UuY2hpbGRTaXplO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubWluUHJlZml4TGVuZ3RoICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm1pblByZWZpeExlbmd0aFwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QubWluUHJlZml4TGVuZ3RoID0gbWVzc2FnZS5taW5QcmVmaXhMZW5ndGg7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5tYXhQcmVmaXhMZW5ndGggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibWF4UHJlZml4TGVuZ3RoXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5tYXhQcmVmaXhMZW5ndGggPSBtZXNzYWdlLm1heFByZWZpeExlbmd0aDtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmVtcHR5Q2hpbGQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZW1wdHlDaGlsZFwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuZW1wdHlDaGlsZCA9IG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZyA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobWVzc2FnZS5lbXB0eUNoaWxkLCAwLCBtZXNzYWdlLmVtcHR5Q2hpbGQubGVuZ3RoKSA6IG9wdGlvbnMuYnl0ZXMgPT09IEFycmF5ID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobWVzc2FnZS5lbXB0eUNoaWxkKSA6IG1lc3NhZ2UuZW1wdHlDaGlsZDtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmhhc2ggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiaGFzaFwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuaGFzaCA9IG9wdGlvbnMuZW51bXMgPT09IFN0cmluZyA/ICRyb290LmljczIzLkhhc2hPcFttZXNzYWdlLmhhc2hdIDogbWVzc2FnZS5oYXNoO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBJbm5lclNwZWMgdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuSW5uZXJTcGVjXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBJbm5lclNwZWMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBJbm5lclNwZWM7XG4gICAgfSkoKTtcblxuICAgIGljczIzLkJhdGNoUHJvb2YgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBCYXRjaFByb29mLlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjNcbiAgICAgICAgICogQGludGVyZmFjZSBJQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxpY3MyMy5JQmF0Y2hFbnRyeT58bnVsbH0gW2VudHJpZXNdIEJhdGNoUHJvb2YgZW50cmllc1xuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBCYXRjaFByb29mLlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjNcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgQmF0Y2hQcm9vZi5cbiAgICAgICAgICogQGltcGxlbWVudHMgSUJhdGNoUHJvb2ZcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUJhdGNoUHJvb2Y9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEJhdGNoUHJvb2YocHJvcGVydGllcykge1xuICAgICAgICAgICAgdGhpcy5lbnRyaWVzID0gW107XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhdGNoUHJvb2YgZW50cmllcy5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPGljczIzLklCYXRjaEVudHJ5Pn0gZW50cmllc1xuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEJhdGNoUHJvb2YucHJvdG90eXBlLmVudHJpZXMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IEJhdGNoUHJvb2YgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5CYXRjaFByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQmF0Y2hQcm9vZj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuQmF0Y2hQcm9vZn0gQmF0Y2hQcm9vZiBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQmF0Y2hQcm9vZi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCYXRjaFByb29mKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQmF0Y2hQcm9vZiBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBpY3MyMy5CYXRjaFByb29mLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5CYXRjaFByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQmF0Y2hQcm9vZn0gbWVzc2FnZSBCYXRjaFByb29mIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgQmF0Y2hQcm9vZi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZW50cmllcyAhPSBudWxsICYmIG1lc3NhZ2UuZW50cmllcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmVudHJpZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290LmljczIzLkJhdGNoRW50cnkuZW5jb2RlKG1lc3NhZ2UuZW50cmllc1tpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEJhdGNoUHJvb2YgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgaWNzMjMuQmF0Y2hQcm9vZi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUJhdGNoUHJvb2Z9IG1lc3NhZ2UgQmF0Y2hQcm9vZiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIEJhdGNoUHJvb2YuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBCYXRjaFByb29mIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkJhdGNoUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkJhdGNoUHJvb2Z9IEJhdGNoUHJvb2ZcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBCYXRjaFByb29mLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmljczIzLkJhdGNoUHJvb2YoKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5lbnRyaWVzICYmIG1lc3NhZ2UuZW50cmllcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbnRyaWVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZW50cmllcy5wdXNoKCRyb290LmljczIzLkJhdGNoRW50cnkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBCYXRjaFByb29mIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkJhdGNoUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkJhdGNoUHJvb2Z9IEJhdGNoUHJvb2ZcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBCYXRjaFByb29mLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIEJhdGNoUHJvb2YgbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgQmF0Y2hQcm9vZi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5lbnRyaWVzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImVudHJpZXNcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZS5lbnRyaWVzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiZW50cmllczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UuZW50cmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAkcm9vdC5pY3MyMy5CYXRjaEVudHJ5LnZlcmlmeShtZXNzYWdlLmVudHJpZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJlbnRyaWVzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBCYXRjaFByb29mIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkJhdGNoUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5CYXRjaFByb29mfSBCYXRjaFByb29mXG4gICAgICAgICAqL1xuICAgICAgICBCYXRjaFByb29mLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmljczIzLkJhdGNoUHJvb2YpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmljczIzLkJhdGNoUHJvb2YoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuZW50cmllcykge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QuZW50cmllcykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5pY3MyMy5CYXRjaFByb29mLmVudHJpZXM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZW50cmllcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqZWN0LmVudHJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZW50cmllc1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5pY3MyMy5CYXRjaFByb29mLmVudHJpZXM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbnRyaWVzW2ldID0gJHJvb3QuaWNzMjMuQmF0Y2hFbnRyeS5mcm9tT2JqZWN0KG9iamVjdC5lbnRyaWVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgQmF0Y2hQcm9vZiBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuQmF0Y2hQcm9vZn0gbWVzc2FnZSBCYXRjaFByb29mXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgQmF0Y2hQcm9vZi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cylcbiAgICAgICAgICAgICAgICBvYmplY3QuZW50cmllcyA9IFtdO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZW50cmllcyAmJiBtZXNzYWdlLmVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuZW50cmllcy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmVudHJpZXNbal0gPSAkcm9vdC5pY3MyMy5CYXRjaEVudHJ5LnRvT2JqZWN0KG1lc3NhZ2UuZW50cmllc1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIEJhdGNoUHJvb2YgdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgQmF0Y2hQcm9vZi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIEJhdGNoUHJvb2Y7XG4gICAgfSkoKTtcblxuICAgIGljczIzLkJhdGNoRW50cnkgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBCYXRjaEVudHJ5LlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjNcbiAgICAgICAgICogQGludGVyZmFjZSBJQmF0Y2hFbnRyeVxuICAgICAgICAgKiBAcHJvcGVydHkge2ljczIzLklFeGlzdGVuY2VQcm9vZnxudWxsfSBbZXhpc3RdIEJhdGNoRW50cnkgZXhpc3RcbiAgICAgICAgICogQHByb3BlcnR5IHtpY3MyMy5JTm9uRXhpc3RlbmNlUHJvb2Z8bnVsbH0gW25vbmV4aXN0XSBCYXRjaEVudHJ5IG5vbmV4aXN0XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEJhdGNoRW50cnkuXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyM1xuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBCYXRjaEVudHJ5LlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJQmF0Y2hFbnRyeVxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQmF0Y2hFbnRyeT19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQmF0Y2hFbnRyeShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhdGNoRW50cnkgZXhpc3QuXG4gICAgICAgICAqIEBtZW1iZXIge2ljczIzLklFeGlzdGVuY2VQcm9vZnxudWxsfHVuZGVmaW5lZH0gZXhpc3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkJhdGNoRW50cnlcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBCYXRjaEVudHJ5LnByb3RvdHlwZS5leGlzdCA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhdGNoRW50cnkgbm9uZXhpc3QuXG4gICAgICAgICAqIEBtZW1iZXIge2ljczIzLklOb25FeGlzdGVuY2VQcm9vZnxudWxsfHVuZGVmaW5lZH0gbm9uZXhpc3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkJhdGNoRW50cnlcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBCYXRjaEVudHJ5LnByb3RvdHlwZS5ub25leGlzdCA9IG51bGw7XG5cbiAgICAgICAgLy8gT25lT2YgZmllbGQgbmFtZXMgYm91bmQgdG8gdmlydHVhbCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gICAgICAgIHZhciAkb25lT2ZGaWVsZHM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhdGNoRW50cnkgcHJvb2YuXG4gICAgICAgICAqIEBtZW1iZXIge1wiZXhpc3RcInxcIm5vbmV4aXN0XCJ8dW5kZWZpbmVkfSBwcm9vZlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQmF0Y2hFbnRyeVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXRjaEVudHJ5LnByb3RvdHlwZSwgXCJwcm9vZlwiLCB7XG4gICAgICAgICAgICBnZXQ6ICR1dGlsLm9uZU9mR2V0dGVyKCRvbmVPZkZpZWxkcyA9IFtcImV4aXN0XCIsIFwibm9uZXhpc3RcIl0pLFxuICAgICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IEJhdGNoRW50cnkgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5CYXRjaEVudHJ5XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQmF0Y2hFbnRyeT19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuQmF0Y2hFbnRyeX0gQmF0Y2hFbnRyeSBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQmF0Y2hFbnRyeS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCYXRjaEVudHJ5KHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQmF0Y2hFbnRyeSBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBpY3MyMy5CYXRjaEVudHJ5LnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5CYXRjaEVudHJ5XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQmF0Y2hFbnRyeX0gbWVzc2FnZSBCYXRjaEVudHJ5IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgQmF0Y2hFbnRyeS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXhpc3QgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZXhpc3RcIikpXG4gICAgICAgICAgICAgICAgJHJvb3QuaWNzMjMuRXhpc3RlbmNlUHJvb2YuZW5jb2RlKG1lc3NhZ2UuZXhpc3QsIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5vbmV4aXN0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5vbmV4aXN0XCIpKVxuICAgICAgICAgICAgICAgICRyb290LmljczIzLk5vbkV4aXN0ZW5jZVByb29mLmVuY29kZShtZXNzYWdlLm5vbmV4aXN0LCB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQmF0Y2hFbnRyeSBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBpY3MyMy5CYXRjaEVudHJ5LnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5CYXRjaEVudHJ5XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQmF0Y2hFbnRyeX0gbWVzc2FnZSBCYXRjaEVudHJ5IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgQmF0Y2hFbnRyeS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIEJhdGNoRW50cnkgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQmF0Y2hFbnRyeVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuQmF0Y2hFbnRyeX0gQmF0Y2hFbnRyeVxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIEJhdGNoRW50cnkuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuaWNzMjMuQmF0Y2hFbnRyeSgpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV4aXN0ID0gJHJvb3QuaWNzMjMuRXhpc3RlbmNlUHJvb2YuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5vbmV4aXN0ID0gJHJvb3QuaWNzMjMuTm9uRXhpc3RlbmNlUHJvb2YuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIEJhdGNoRW50cnkgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQmF0Y2hFbnRyeVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuQmF0Y2hFbnRyeX0gQmF0Y2hFbnRyeVxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIEJhdGNoRW50cnkuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgQmF0Y2hFbnRyeSBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5CYXRjaEVudHJ5XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBCYXRjaEVudHJ5LnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5leGlzdCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJleGlzdFwiKSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHJvb2YgPSAxO1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuaWNzMjMuRXhpc3RlbmNlUHJvb2YudmVyaWZ5KG1lc3NhZ2UuZXhpc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJleGlzdC5cIiArIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm5vbmV4aXN0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm5vbmV4aXN0XCIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMucHJvb2YgPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInByb29mOiBtdWx0aXBsZSB2YWx1ZXNcIjtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnByb29mID0gMTtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmljczIzLk5vbkV4aXN0ZW5jZVByb29mLnZlcmlmeShtZXNzYWdlLm5vbmV4aXN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibm9uZXhpc3QuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIEJhdGNoRW50cnkgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQmF0Y2hFbnRyeVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkJhdGNoRW50cnl9IEJhdGNoRW50cnlcbiAgICAgICAgICovXG4gICAgICAgIEJhdGNoRW50cnkuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuaWNzMjMuQmF0Y2hFbnRyeSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuaWNzMjMuQmF0Y2hFbnRyeSgpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5leGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QuZXhpc3QgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5pY3MyMy5CYXRjaEVudHJ5LmV4aXN0OiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5leGlzdCA9ICRyb290LmljczIzLkV4aXN0ZW5jZVByb29mLmZyb21PYmplY3Qob2JqZWN0LmV4aXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3Qubm9uZXhpc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Lm5vbmV4aXN0ICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuaWNzMjMuQmF0Y2hFbnRyeS5ub25leGlzdDogb2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2Uubm9uZXhpc3QgPSAkcm9vdC5pY3MyMy5Ob25FeGlzdGVuY2VQcm9vZi5mcm9tT2JqZWN0KG9iamVjdC5ub25leGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgQmF0Y2hFbnRyeSBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQmF0Y2hFbnRyeVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuQmF0Y2hFbnRyeX0gbWVzc2FnZSBCYXRjaEVudHJ5XG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgQmF0Y2hFbnRyeS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5leGlzdCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJleGlzdFwiKSkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5leGlzdCA9ICRyb290LmljczIzLkV4aXN0ZW5jZVByb29mLnRvT2JqZWN0KG1lc3NhZ2UuZXhpc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9uZW9mcylcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnByb29mID0gXCJleGlzdFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uubm9uZXhpc3QgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibm9uZXhpc3RcIikpIHtcbiAgICAgICAgICAgICAgICBvYmplY3Qubm9uZXhpc3QgPSAkcm9vdC5pY3MyMy5Ob25FeGlzdGVuY2VQcm9vZi50b09iamVjdChtZXNzYWdlLm5vbmV4aXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5wcm9vZiA9IFwibm9uZXhpc3RcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgQmF0Y2hFbnRyeSB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5CYXRjaEVudHJ5XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBCYXRjaEVudHJ5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gQmF0Y2hFbnRyeTtcbiAgICB9KSgpO1xuXG4gICAgaWNzMjMuQ29tcHJlc3NlZEJhdGNoUHJvb2YgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBDb21wcmVzc2VkQmF0Y2hQcm9vZi5cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzXG4gICAgICAgICAqIEBpbnRlcmZhY2UgSUNvbXByZXNzZWRCYXRjaFByb29mXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPGljczIzLklDb21wcmVzc2VkQmF0Y2hFbnRyeT58bnVsbH0gW2VudHJpZXNdIENvbXByZXNzZWRCYXRjaFByb29mIGVudHJpZXNcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48aWNzMjMuSUlubmVyT3A+fG51bGx9IFtsb29rdXBJbm5lcnNdIENvbXByZXNzZWRCYXRjaFByb29mIGxvb2t1cElubmVyc1xuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBDb21wcmVzc2VkQmF0Y2hQcm9vZi5cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIENvbXByZXNzZWRCYXRjaFByb29mLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJQ29tcHJlc3NlZEJhdGNoUHJvb2ZcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUNvbXByZXNzZWRCYXRjaFByb29mPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBDb21wcmVzc2VkQmF0Y2hQcm9vZihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLmVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMubG9va3VwSW5uZXJzID0gW107XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXByZXNzZWRCYXRjaFByb29mIGVudHJpZXMuXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxpY3MyMy5JQ29tcHJlc3NlZEJhdGNoRW50cnk+fSBlbnRyaWVzXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRCYXRjaFByb29mLnByb3RvdHlwZS5lbnRyaWVzID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcHJlc3NlZEJhdGNoUHJvb2YgbG9va3VwSW5uZXJzLlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48aWNzMjMuSUlubmVyT3A+fSBsb29rdXBJbm5lcnNcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRCYXRjaFByb29mXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEJhdGNoUHJvb2YucHJvdG90eXBlLmxvb2t1cElubmVycyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgQ29tcHJlc3NlZEJhdGNoUHJvb2YgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUNvbXByZXNzZWRCYXRjaFByb29mPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Db21wcmVzc2VkQmF0Y2hQcm9vZn0gQ29tcHJlc3NlZEJhdGNoUHJvb2YgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRCYXRjaFByb29mLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXByZXNzZWRCYXRjaFByb29mKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQ29tcHJlc3NlZEJhdGNoUHJvb2YgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgaWNzMjMuQ29tcHJlc3NlZEJhdGNoUHJvb2YudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRCYXRjaFByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQ29tcHJlc3NlZEJhdGNoUHJvb2Z9IG1lc3NhZ2UgQ29tcHJlc3NlZEJhdGNoUHJvb2YgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkQmF0Y2hQcm9vZi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZW50cmllcyAhPSBudWxsICYmIG1lc3NhZ2UuZW50cmllcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmVudHJpZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICRyb290LmljczIzLkNvbXByZXNzZWRCYXRjaEVudHJ5LmVuY29kZShtZXNzYWdlLmVudHJpZXNbaV0sIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmxvb2t1cElubmVycyAhPSBudWxsICYmIG1lc3NhZ2UubG9va3VwSW5uZXJzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UubG9va3VwSW5uZXJzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAkcm9vdC5pY3MyMy5Jbm5lck9wLmVuY29kZShtZXNzYWdlLmxvb2t1cElubmVyc1tpXSwgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIENvbXByZXNzZWRCYXRjaFByb29mIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIGljczIzLkNvbXByZXNzZWRCYXRjaFByb29mLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUNvbXByZXNzZWRCYXRjaFByb29mfSBtZXNzYWdlIENvbXByZXNzZWRCYXRjaFByb29mIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEJhdGNoUHJvb2YuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBDb21wcmVzc2VkQmF0Y2hQcm9vZiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuQ29tcHJlc3NlZEJhdGNoUHJvb2Z9IENvbXByZXNzZWRCYXRjaFByb29mXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEJhdGNoUHJvb2YuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEJhdGNoUHJvb2YoKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5lbnRyaWVzICYmIG1lc3NhZ2UuZW50cmllcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbnRyaWVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZW50cmllcy5wdXNoKCRyb290LmljczIzLkNvbXByZXNzZWRCYXRjaEVudHJ5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UubG9va3VwSW5uZXJzICYmIG1lc3NhZ2UubG9va3VwSW5uZXJzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxvb2t1cElubmVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxvb2t1cElubmVycy5wdXNoKCRyb290LmljczIzLklubmVyT3AuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBDb21wcmVzc2VkQmF0Y2hQcm9vZiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuQ29tcHJlc3NlZEJhdGNoUHJvb2Z9IENvbXByZXNzZWRCYXRjaFByb29mXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEJhdGNoUHJvb2YuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgQ29tcHJlc3NlZEJhdGNoUHJvb2YgbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEJhdGNoUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRCYXRjaFByb29mLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmVudHJpZXMgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZW50cmllc1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmVudHJpZXMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJlbnRyaWVzOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5lbnRyaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmljczIzLkNvbXByZXNzZWRCYXRjaEVudHJ5LnZlcmlmeShtZXNzYWdlLmVudHJpZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJlbnRyaWVzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubG9va3VwSW5uZXJzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxvb2t1cElubmVyc1wiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLmxvb2t1cElubmVycykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxvb2t1cElubmVyczogYXJyYXkgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UubG9va3VwSW5uZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmljczIzLklubmVyT3AudmVyaWZ5KG1lc3NhZ2UubG9va3VwSW5uZXJzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibG9va3VwSW5uZXJzLlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBDb21wcmVzc2VkQmF0Y2hQcm9vZiBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkNvbXByZXNzZWRCYXRjaFByb29mfSBDb21wcmVzc2VkQmF0Y2hQcm9vZlxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEJhdGNoUHJvb2YuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEJhdGNoUHJvb2YpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290LmljczIzLkNvbXByZXNzZWRCYXRjaFByb29mKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0LmVudHJpZXMpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuaWNzMjMuQ29tcHJlc3NlZEJhdGNoUHJvb2YuZW50cmllczogYXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5lbnRyaWVzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QuZW50cmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5lbnRyaWVzW2ldICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmljczIzLkNvbXByZXNzZWRCYXRjaFByb29mLmVudHJpZXM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbnRyaWVzW2ldID0gJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnkuZnJvbU9iamVjdChvYmplY3QuZW50cmllc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5sb29rdXBJbm5lcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqZWN0Lmxvb2t1cElubmVycykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5pY3MyMy5Db21wcmVzc2VkQmF0Y2hQcm9vZi5sb29rdXBJbm5lcnM6IGFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UubG9va3VwSW5uZXJzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3QubG9va3VwSW5uZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Lmxvb2t1cElubmVyc1tpXSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5pY3MyMy5Db21wcmVzc2VkQmF0Y2hQcm9vZi5sb29rdXBJbm5lcnM6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5sb29rdXBJbm5lcnNbaV0gPSAkcm9vdC5pY3MyMy5Jbm5lck9wLmZyb21PYmplY3Qob2JqZWN0Lmxvb2t1cElubmVyc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIENvbXByZXNzZWRCYXRjaFByb29mIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkQmF0Y2hQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuQ29tcHJlc3NlZEJhdGNoUHJvb2Z9IG1lc3NhZ2UgQ29tcHJlc3NlZEJhdGNoUHJvb2ZcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkQmF0Y2hQcm9vZi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hcnJheXMgfHwgb3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5lbnRyaWVzID0gW107XG4gICAgICAgICAgICAgICAgb2JqZWN0Lmxvb2t1cElubmVycyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZW50cmllcyAmJiBtZXNzYWdlLmVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LmVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UuZW50cmllcy5sZW5ndGg7ICsrailcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmVudHJpZXNbal0gPSAkcm9vdC5pY3MyMy5Db21wcmVzc2VkQmF0Y2hFbnRyeS50b09iamVjdChtZXNzYWdlLmVudHJpZXNbal0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubG9va3VwSW5uZXJzICYmIG1lc3NhZ2UubG9va3VwSW5uZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5sb29rdXBJbm5lcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1lc3NhZ2UubG9va3VwSW5uZXJzLmxlbmd0aDsgKytqKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QubG9va3VwSW5uZXJzW2pdID0gJHJvb3QuaWNzMjMuSW5uZXJPcC50b09iamVjdChtZXNzYWdlLmxvb2t1cElubmVyc1tqXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIENvbXByZXNzZWRCYXRjaFByb29mIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRCYXRjaFByb29mXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkQmF0Y2hQcm9vZi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIENvbXByZXNzZWRCYXRjaFByb29mO1xuICAgIH0pKCk7XG5cbiAgICBpY3MyMy5Db21wcmVzc2VkQmF0Y2hFbnRyeSA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIENvbXByZXNzZWRCYXRjaEVudHJ5LlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjNcbiAgICAgICAgICogQGludGVyZmFjZSBJQ29tcHJlc3NlZEJhdGNoRW50cnlcbiAgICAgICAgICogQHByb3BlcnR5IHtpY3MyMy5JQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mfG51bGx9IFtleGlzdF0gQ29tcHJlc3NlZEJhdGNoRW50cnkgZXhpc3RcbiAgICAgICAgICogQHByb3BlcnR5IHtpY3MyMy5JQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mfG51bGx9IFtub25leGlzdF0gQ29tcHJlc3NlZEJhdGNoRW50cnkgbm9uZXhpc3RcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgQ29tcHJlc3NlZEJhdGNoRW50cnkuXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyM1xuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBDb21wcmVzc2VkQmF0Y2hFbnRyeS5cbiAgICAgICAgICogQGltcGxlbWVudHMgSUNvbXByZXNzZWRCYXRjaEVudHJ5XG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklDb21wcmVzc2VkQmF0Y2hFbnRyeT19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQ29tcHJlc3NlZEJhdGNoRW50cnkocHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wcmVzc2VkQmF0Y2hFbnRyeSBleGlzdC5cbiAgICAgICAgICogQG1lbWJlciB7aWNzMjMuSUNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZnxudWxsfHVuZGVmaW5lZH0gZXhpc3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRCYXRjaEVudHJ5XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEJhdGNoRW50cnkucHJvdG90eXBlLmV4aXN0ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcHJlc3NlZEJhdGNoRW50cnkgbm9uZXhpc3QuXG4gICAgICAgICAqIEBtZW1iZXIge2ljczIzLklDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2Z8bnVsbHx1bmRlZmluZWR9IG5vbmV4aXN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkQmF0Y2hFbnRyeVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRCYXRjaEVudHJ5LnByb3RvdHlwZS5ub25leGlzdCA9IG51bGw7XG5cbiAgICAgICAgLy8gT25lT2YgZmllbGQgbmFtZXMgYm91bmQgdG8gdmlydHVhbCBnZXR0ZXJzIGFuZCBzZXR0ZXJzXG4gICAgICAgIHZhciAkb25lT2ZGaWVsZHM7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXByZXNzZWRCYXRjaEVudHJ5IHByb29mLlxuICAgICAgICAgKiBAbWVtYmVyIHtcImV4aXN0XCJ8XCJub25leGlzdFwifHVuZGVmaW5lZH0gcHJvb2ZcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRCYXRjaEVudHJ5XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXByZXNzZWRCYXRjaEVudHJ5LnByb3RvdHlwZSwgXCJwcm9vZlwiLCB7XG4gICAgICAgICAgICBnZXQ6ICR1dGlsLm9uZU9mR2V0dGVyKCRvbmVPZkZpZWxkcyA9IFtcImV4aXN0XCIsIFwibm9uZXhpc3RcIl0pLFxuICAgICAgICAgICAgc2V0OiAkdXRpbC5vbmVPZlNldHRlcigkb25lT2ZGaWVsZHMpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IENvbXByZXNzZWRCYXRjaEVudHJ5IGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnlcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklDb21wcmVzc2VkQmF0Y2hFbnRyeT19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnl9IENvbXByZXNzZWRCYXRjaEVudHJ5IGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkQmF0Y2hFbnRyeS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wcmVzc2VkQmF0Y2hFbnRyeShwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIENvbXByZXNzZWRCYXRjaEVudHJ5IG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIGljczIzLkNvbXByZXNzZWRCYXRjaEVudHJ5LnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkQmF0Y2hFbnRyeVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUNvbXByZXNzZWRCYXRjaEVudHJ5fSBtZXNzYWdlIENvbXByZXNzZWRCYXRjaEVudHJ5IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEJhdGNoRW50cnkuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmV4aXN0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImV4aXN0XCIpKVxuICAgICAgICAgICAgICAgICRyb290LmljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi5lbmNvZGUobWVzc2FnZS5leGlzdCwgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uubm9uZXhpc3QgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibm9uZXhpc3RcIikpXG4gICAgICAgICAgICAgICAgJHJvb3QuaWNzMjMuQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mLmVuY29kZShtZXNzYWdlLm5vbmV4aXN0LCB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQ29tcHJlc3NlZEJhdGNoRW50cnkgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgaWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnkudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRCYXRjaEVudHJ5XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQ29tcHJlc3NlZEJhdGNoRW50cnl9IG1lc3NhZ2UgQ29tcHJlc3NlZEJhdGNoRW50cnkgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkQmF0Y2hFbnRyeS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIENvbXByZXNzZWRCYXRjaEVudHJ5IG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRCYXRjaEVudHJ5XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Db21wcmVzc2VkQmF0Y2hFbnRyeX0gQ29tcHJlc3NlZEJhdGNoRW50cnlcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkQmF0Y2hFbnRyeS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5pY3MyMy5Db21wcmVzc2VkQmF0Y2hFbnRyeSgpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV4aXN0ID0gJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ub25leGlzdCA9ICRyb290LmljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgQ29tcHJlc3NlZEJhdGNoRW50cnkgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnlcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkNvbXByZXNzZWRCYXRjaEVudHJ5fSBDb21wcmVzc2VkQmF0Y2hFbnRyeVxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRCYXRjaEVudHJ5LmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIENvbXByZXNzZWRCYXRjaEVudHJ5IG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRCYXRjaEVudHJ5XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkQmF0Y2hFbnRyeS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXhpc3QgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZXhpc3RcIikpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnByb29mID0gMTtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi52ZXJpZnkobWVzc2FnZS5leGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImV4aXN0LlwiICsgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uubm9uZXhpc3QgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibm9uZXhpc3RcIikpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5wcm9vZiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicHJvb2Y6IG11bHRpcGxlIHZhbHVlc1wiO1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMucHJvb2YgPSAxO1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuaWNzMjMuQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mLnZlcmlmeShtZXNzYWdlLm5vbmV4aXN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibm9uZXhpc3QuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIENvbXByZXNzZWRCYXRjaEVudHJ5IG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRCYXRjaEVudHJ5XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7aWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnl9IENvbXByZXNzZWRCYXRjaEVudHJ5XG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkQmF0Y2hFbnRyeS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5pY3MyMy5Db21wcmVzc2VkQmF0Y2hFbnRyeSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnkoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuZXhpc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmV4aXN0ICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuaWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnkuZXhpc3Q6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmV4aXN0ID0gJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLmZyb21PYmplY3Qob2JqZWN0LmV4aXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmplY3Qubm9uZXhpc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Lm5vbmV4aXN0ICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCIuaWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnkubm9uZXhpc3Q6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLm5vbmV4aXN0ID0gJHJvb3QuaWNzMjMuQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mLmZyb21PYmplY3Qob2JqZWN0Lm5vbmV4aXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBDb21wcmVzc2VkQmF0Y2hFbnRyeSBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnlcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLkNvbXByZXNzZWRCYXRjaEVudHJ5fSBtZXNzYWdlIENvbXByZXNzZWRCYXRjaEVudHJ5XG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEJhdGNoRW50cnkudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZXhpc3QgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZXhpc3RcIikpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuZXhpc3QgPSAkcm9vdC5pY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2YudG9PYmplY3QobWVzc2FnZS5leGlzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25lb2ZzKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QucHJvb2YgPSBcImV4aXN0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5ub25leGlzdCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJub25leGlzdFwiKSkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5ub25leGlzdCA9ICRyb290LmljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZi50b09iamVjdChtZXNzYWdlLm5vbmV4aXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbmVvZnMpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5wcm9vZiA9IFwibm9uZXhpc3RcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgQ29tcHJlc3NlZEJhdGNoRW50cnkgdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEJhdGNoRW50cnlcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRCYXRjaEVudHJ5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gQ29tcHJlc3NlZEJhdGNoRW50cnk7XG4gICAgfSkoKTtcblxuICAgIGljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi5cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzXG4gICAgICAgICAqIEBpbnRlcmZhY2UgSUNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl8bnVsbH0gW2tleV0gQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mIGtleVxuICAgICAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl8bnVsbH0gW3ZhbHVlXSBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YgdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtpY3MyMy5JTGVhZk9wfG51bGx9IFtsZWFmXSBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YgbGVhZlxuICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fG51bGx9IFtwYXRoXSBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YgcGF0aFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YuXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyM1xuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YuXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IFtdO1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2Yga2V5LlxuICAgICAgICAgKiBAbWVtYmVyIHtVaW50OEFycmF5fSBrZXlcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi5wcm90b3R5cGUua2V5ID0gJHV0aWwubmV3QnVmZmVyKFtdKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mIHZhbHVlLlxuICAgICAgICAgKiBAbWVtYmVyIHtVaW50OEFycmF5fSB2YWx1ZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLnByb3RvdHlwZS52YWx1ZSA9ICR1dGlsLm5ld0J1ZmZlcihbXSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZiBsZWFmLlxuICAgICAgICAgKiBAbWVtYmVyIHtpY3MyMy5JTGVhZk9wfG51bGx8dW5kZWZpbmVkfSBsZWFmXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YucHJvdG90eXBlLmxlYWYgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YgcGF0aC5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcj59IHBhdGhcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi5wcm90b3R5cGUucGF0aCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2Z9IENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZiBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZihwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZiBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBpY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2YudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZn0gbWVzc2FnZSBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmtleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJrZXlcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5ieXRlcyhtZXNzYWdlLmtleSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLmJ5dGVzKG1lc3NhZ2UudmFsdWUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UubGVhZiAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJsZWFmXCIpKVxuICAgICAgICAgICAgICAgICRyb290LmljczIzLkxlYWZPcC5lbmNvZGUobWVzc2FnZS5sZWFmLCB3cml0ZXIudWludDMyKC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5wYXRoICE9IG51bGwgJiYgbWVzc2FnZS5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgNCwgd2lyZVR5cGUgMiA9Ki8zNCkuZm9yaygpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5wYXRoLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuaW50MzIobWVzc2FnZS5wYXRoW2ldKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIubGRlbGltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIGljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mfSBtZXNzYWdlIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZn0gQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZigpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxlYWYgPSAkcm9vdC5pY3MyMy5MZWFmT3AuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnBhdGggJiYgbWVzc2FnZS5wYXRoLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhdGggPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGF0aC5wdXNoKHJlYWRlci5pbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhdGgucHVzaChyZWFkZXIuaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2Z9IENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YgbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uua2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmtleSAmJiB0eXBlb2YgbWVzc2FnZS5rZXkubGVuZ3RoID09PSBcIm51bWJlclwiIHx8ICR1dGlsLmlzU3RyaW5nKG1lc3NhZ2Uua2V5KSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImtleTogYnVmZmVyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS52YWx1ZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ2YWx1ZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnZhbHVlICYmIHR5cGVvZiBtZXNzYWdlLnZhbHVlLmxlbmd0aCA9PT0gXCJudW1iZXJcIiB8fCAkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnZhbHVlKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInZhbHVlOiBidWZmZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmxlYWYgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibGVhZlwiKSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmljczIzLkxlYWZPcC52ZXJpZnkobWVzc2FnZS5sZWFmKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxlYWYuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnBhdGggIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicGF0aFwiKSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlLnBhdGgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwYXRoOiBhcnJheSBleHBlY3RlZFwiO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZS5wYXRoLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnBhdGhbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwicGF0aDogaW50ZWdlcltdIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZiBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2Z9IENvbXByZXNzZWRFeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZilcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmtleSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmtleSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgJHV0aWwuYmFzZTY0LmRlY29kZShvYmplY3Qua2V5LCBtZXNzYWdlLmtleSA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC5rZXkpKSwgMCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqZWN0LmtleS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5ID0gb2JqZWN0LmtleTtcbiAgICAgICAgICAgIGlmIChvYmplY3QudmFsdWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdC52YWx1ZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgJHV0aWwuYmFzZTY0LmRlY29kZShvYmplY3QudmFsdWUsIG1lc3NhZ2UudmFsdWUgPSAkdXRpbC5uZXdCdWZmZXIoJHV0aWwuYmFzZTY0Lmxlbmd0aChvYmplY3QudmFsdWUpKSwgMCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqZWN0LnZhbHVlLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWx1ZSA9IG9iamVjdC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChvYmplY3QubGVhZiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QubGVhZiAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi5sZWFmOiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5sZWFmID0gJHJvb3QuaWNzMjMuTGVhZk9wLmZyb21PYmplY3Qob2JqZWN0LmxlYWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdC5wYXRoKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi5wYXRoOiBhcnJheSBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnBhdGggPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5wYXRoLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhdGhbaV0gPSBvYmplY3QucGF0aFtpXSB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZn0gbWVzc2FnZSBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlzIHx8IG9wdGlvbnMuZGVmYXVsdHMpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnBhdGggPSBbXTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZylcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmtleSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5rZXkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgIT09IEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmtleSA9ICR1dGlsLm5ld0J1ZmZlcihvYmplY3Qua2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZylcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LnZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzICE9PSBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9ICR1dGlsLm5ld0J1ZmZlcihvYmplY3QudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3QubGVhZiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5rZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwia2V5XCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5rZXkgPSBvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcgPyAkdXRpbC5iYXNlNjQuZW5jb2RlKG1lc3NhZ2Uua2V5LCAwLCBtZXNzYWdlLmtleS5sZW5ndGgpIDogb3B0aW9ucy5ieXRlcyA9PT0gQXJyYXkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLmtleSkgOiBtZXNzYWdlLmtleTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC52YWx1ZSA9IG9wdGlvbnMuYnl0ZXMgPT09IFN0cmluZyA/ICR1dGlsLmJhc2U2NC5lbmNvZGUobWVzc2FnZS52YWx1ZSwgMCwgbWVzc2FnZS52YWx1ZS5sZW5ndGgpIDogb3B0aW9ucy5ieXRlcyA9PT0gQXJyYXkgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLnZhbHVlKSA6IG1lc3NhZ2UudmFsdWU7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5sZWFmICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxlYWZcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmxlYWYgPSAkcm9vdC5pY3MyMy5MZWFmT3AudG9PYmplY3QobWVzc2FnZS5sZWFmLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnBhdGggJiYgbWVzc2FnZS5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9iamVjdC5wYXRoID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLnBhdGgubGVuZ3RoOyArK2opXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5wYXRoW2pdID0gbWVzc2FnZS5wYXRoW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YgdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2YucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2Y7XG4gICAgfSkoKTtcblxuICAgIGljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZi5cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzXG4gICAgICAgICAqIEBpbnRlcmZhY2UgSUNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl8bnVsbH0gW2tleV0gQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mIGtleVxuICAgICAgICAgKiBAcHJvcGVydHkge2ljczIzLklDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2Z8bnVsbH0gW2xlZnRdIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZiBsZWZ0XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7aWNzMjMuSUNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZnxudWxsfSBbcmlnaHRdIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZiByaWdodFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YuXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyM1xuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YuXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuSUNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mIGtleS5cbiAgICAgICAgICogQG1lbWJlciB7VWludDhBcnJheX0ga2V5XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YucHJvdG90eXBlLmtleSA9ICR1dGlsLm5ld0J1ZmZlcihbXSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZiBsZWZ0LlxuICAgICAgICAgKiBAbWVtYmVyIHtpY3MyMy5JQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mfG51bGx8dW5kZWZpbmVkfSBsZWZ0XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YucHJvdG90eXBlLmxlZnQgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YgcmlnaHQuXG4gICAgICAgICAqIEBtZW1iZXIge2ljczIzLklDb21wcmVzc2VkRXhpc3RlbmNlUHJvb2Z8bnVsbHx1bmRlZmluZWR9IHJpZ2h0XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YucHJvdG90eXBlLnJpZ2h0ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge2ljczIzLklDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2Y9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZn0gQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIGljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mfSBtZXNzYWdlIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uua2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLmJ5dGVzKG1lc3NhZ2Uua2V5KTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmxlZnQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibGVmdFwiKSlcbiAgICAgICAgICAgICAgICAkcm9vdC5pY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2YuZW5jb2RlKG1lc3NhZ2UubGVmdCwgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UucmlnaHQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwicmlnaHRcIikpXG4gICAgICAgICAgICAgICAgJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLmVuY29kZShtZXNzYWdlLnJpZ2h0LCB3cml0ZXIudWludDMyKC8qIGlkIDMsIHdpcmVUeXBlIDIgPSovMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIGljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgaWNzMjMuQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtpY3MyMy5JQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mfSBtZXNzYWdlIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZn0gQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LmljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZigpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGVmdCA9ICRyb290LmljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmlnaHQgPSAkcm9vdC5pY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2YuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge2ljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZn0gQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZiBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5rZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwia2V5XCIpKVxuICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uua2V5ICYmIHR5cGVvZiBtZXNzYWdlLmtleS5sZW5ndGggPT09IFwibnVtYmVyXCIgfHwgJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5rZXkpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwia2V5OiBidWZmZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLmxlZnQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwibGVmdFwiKSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvciA9ICRyb290LmljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi52ZXJpZnkobWVzc2FnZS5sZWZ0KTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImxlZnQuXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnJpZ2h0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInJpZ2h0XCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0gJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLnZlcmlmeShtZXNzYWdlLnJpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInJpZ2h0LlwiICsgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZiBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBpY3MyMy5Db21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2ZcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtpY3MyMy5Db21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2Z9IENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290LmljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZilcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QuaWNzMjMuQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmtleSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0LmtleSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgJHV0aWwuYmFzZTY0LmRlY29kZShvYmplY3Qua2V5LCBtZXNzYWdlLmtleSA9ICR1dGlsLm5ld0J1ZmZlcigkdXRpbC5iYXNlNjQubGVuZ3RoKG9iamVjdC5rZXkpKSwgMCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqZWN0LmtleS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5ID0gb2JqZWN0LmtleTtcbiAgICAgICAgICAgIGlmIChvYmplY3QubGVmdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QubGVmdCAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiLmljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZi5sZWZ0OiBvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5sZWZ0ID0gJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLmZyb21PYmplY3Qob2JqZWN0LmxlZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdC5yaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QucmlnaHQgIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIi5pY3MyMy5Db21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YucmlnaHQ6IG9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnJpZ2h0ID0gJHJvb3QuaWNzMjMuQ29tcHJlc3NlZEV4aXN0ZW5jZVByb29mLmZyb21PYmplY3Qob2JqZWN0LnJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBDb21wcmVzc2VkTm9uRXhpc3RlbmNlUHJvb2YgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7aWNzMjMuQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mfSBtZXNzYWdlIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIENvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzID09PSBTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5rZXkgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3Qua2V5ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmJ5dGVzICE9PSBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdC5rZXkgPSAkdXRpbC5uZXdCdWZmZXIob2JqZWN0LmtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9iamVjdC5sZWZ0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvYmplY3QucmlnaHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uua2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3Qua2V5ID0gb3B0aW9ucy5ieXRlcyA9PT0gU3RyaW5nID8gJHV0aWwuYmFzZTY0LmVuY29kZShtZXNzYWdlLmtleSwgMCwgbWVzc2FnZS5rZXkubGVuZ3RoKSA6IG9wdGlvbnMuYnl0ZXMgPT09IEFycmF5ID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobWVzc2FnZS5rZXkpIDogbWVzc2FnZS5rZXk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5sZWZ0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImxlZnRcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LmxlZnQgPSAkcm9vdC5pY3MyMy5Db21wcmVzc2VkRXhpc3RlbmNlUHJvb2YudG9PYmplY3QobWVzc2FnZS5sZWZ0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnJpZ2h0ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInJpZ2h0XCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5yaWdodCA9ICRyb290LmljczIzLkNvbXByZXNzZWRFeGlzdGVuY2VQcm9vZi50b09iamVjdChtZXNzYWdlLnJpZ2h0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIGljczIzLkNvbXByZXNzZWROb25FeGlzdGVuY2VQcm9vZlxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gQ29tcHJlc3NlZE5vbkV4aXN0ZW5jZVByb29mO1xuICAgIH0pKCk7XG5cbiAgICByZXR1cm4gaWNzMjM7XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICRyb290O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@confio/ics23/build/generated/codecimpl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@confio/ics23/build/ics23.js":
/*!***************************************************!*\
  !*** ./node_modules/@confio/ics23/build/ics23.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.batchVerifyNonMembership = exports.batchVerifyMembership = exports.verifyNonMembership = exports.verifyMembership = void 0;\nconst compress_1 = __webpack_require__(/*! ./compress */ \"(ssr)/./node_modules/@confio/ics23/build/compress.js\");\nconst proofs_1 = __webpack_require__(/*! ./proofs */ \"(ssr)/./node_modules/@confio/ics23/build/proofs.js\");\nconst specs_1 = __webpack_require__(/*! ./specs */ \"(ssr)/./node_modules/@confio/ics23/build/specs.js\");\n/*\nThis implements the client side functions as specified in\nhttps://github.com/cosmos/ics/tree/master/spec/ics-023-vector-commitments\n\nIn particular:\n\n  // Assumes ExistenceProof\n  type verifyMembership = (root: CommitmentRoot, proof: CommitmentProof, key: Key, value: Value) => boolean\n\n  // Assumes NonExistenceProof\n  type verifyNonMembership = (root: CommitmentRoot, proof: CommitmentProof, key: Key) => boolean\n\n  // Assumes BatchProof - required ExistenceProofs may be a subset of all items proven\n  type batchVerifyMembership = (root: CommitmentRoot, proof: CommitmentProof, items: Map<Key, Value>) => boolean\n\n  // Assumes BatchProof - required NonExistenceProofs may be a subset of all items proven\n  type batchVerifyNonMembership = (root: CommitmentRoot, proof: CommitmentProof, keys: Set<Key>) => boolean\n\nWe make an adjustment to accept a Spec to ensure the provided proof is in the format of the expected merkle store.\nThis can avoid an range of attacks on fake preimages, as we need to be careful on how to map key, value -> leaf\nand determine neighbors\n*/\n/**\n * verifyMembership ensures proof is (contains) a valid existence proof for the given\n */\nfunction verifyMembership(proof, spec, root, key, value) {\n    const norm = (0, compress_1.decompress)(proof);\n    const exist = getExistForKey(norm, key);\n    if (!exist) {\n        return false;\n    }\n    try {\n        (0, proofs_1.verifyExistence)(exist, spec, root, key, value);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexports.verifyMembership = verifyMembership;\n/**\n * verifyNonMembership ensures proof is (contains) a valid non-existence proof for the given key\n */\nfunction verifyNonMembership(proof, spec, root, key) {\n    const norm = (0, compress_1.decompress)(proof);\n    const nonexist = getNonExistForKey(norm, key);\n    if (!nonexist) {\n        return false;\n    }\n    try {\n        (0, proofs_1.verifyNonExistence)(nonexist, spec, root, key);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nexports.verifyNonMembership = verifyNonMembership;\n/**\n * batchVerifyMembership ensures proof is (contains) a valid existence proof for the given\n */\nfunction batchVerifyMembership(proof, spec, root, items) {\n    const norm = (0, compress_1.decompress)(proof);\n    for (const [key, value] of items.entries()) {\n        if (!verifyMembership(norm, spec, root, key, value)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.batchVerifyMembership = batchVerifyMembership;\n/**\n * batchVerifyNonMembership ensures proof is (contains) a valid existence proof for the given\n */\nfunction batchVerifyNonMembership(proof, spec, root, keys) {\n    const norm = (0, compress_1.decompress)(proof);\n    for (const key of keys) {\n        if (!verifyNonMembership(norm, spec, root, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.batchVerifyNonMembership = batchVerifyNonMembership;\nfunction getExistForKey(proof, key) {\n    const match = (p) => !!p && (0, specs_1.bytesEqual)(key, p.key);\n    if (match(proof.exist)) {\n        return proof.exist;\n    }\n    else if (proof.batch) {\n        return proof.batch.entries.map((x) => x.exist || null).find(match);\n    }\n    return undefined;\n}\nfunction getNonExistForKey(proof, key) {\n    const match = (p) => {\n        return (!!p &&\n            (!p.left || (0, specs_1.bytesBefore)(p.left.key, key)) &&\n            (!p.right || (0, specs_1.bytesBefore)(key, p.right.key)));\n    };\n    if (match(proof.nonexist)) {\n        return proof.nonexist;\n    }\n    else if (proof.batch) {\n        return proof.batch.entries.map((x) => x.nonexist || null).find(match);\n    }\n    return undefined;\n}\n//# sourceMappingURL=ics23.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbmZpby9pY3MyMy9idWlsZC9pY3MyMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRyw2QkFBNkIsR0FBRywyQkFBMkIsR0FBRyx3QkFBd0I7QUFDekgsbUJBQW1CLG1CQUFPLENBQUMsd0VBQVk7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsb0VBQVU7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsa0VBQVM7QUFDakM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0Bjb25maW8vaWNzMjMvYnVpbGQvaWNzMjMuanM/OWI2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmF0Y2hWZXJpZnlOb25NZW1iZXJzaGlwID0gZXhwb3J0cy5iYXRjaFZlcmlmeU1lbWJlcnNoaXAgPSBleHBvcnRzLnZlcmlmeU5vbk1lbWJlcnNoaXAgPSBleHBvcnRzLnZlcmlmeU1lbWJlcnNoaXAgPSB2b2lkIDA7XG5jb25zdCBjb21wcmVzc18xID0gcmVxdWlyZShcIi4vY29tcHJlc3NcIik7XG5jb25zdCBwcm9vZnNfMSA9IHJlcXVpcmUoXCIuL3Byb29mc1wiKTtcbmNvbnN0IHNwZWNzXzEgPSByZXF1aXJlKFwiLi9zcGVjc1wiKTtcbi8qXG5UaGlzIGltcGxlbWVudHMgdGhlIGNsaWVudCBzaWRlIGZ1bmN0aW9ucyBhcyBzcGVjaWZpZWQgaW5cbmh0dHBzOi8vZ2l0aHViLmNvbS9jb3Ntb3MvaWNzL3RyZWUvbWFzdGVyL3NwZWMvaWNzLTAyMy12ZWN0b3ItY29tbWl0bWVudHNcblxuSW4gcGFydGljdWxhcjpcblxuICAvLyBBc3N1bWVzIEV4aXN0ZW5jZVByb29mXG4gIHR5cGUgdmVyaWZ5TWVtYmVyc2hpcCA9IChyb290OiBDb21taXRtZW50Um9vdCwgcHJvb2Y6IENvbW1pdG1lbnRQcm9vZiwga2V5OiBLZXksIHZhbHVlOiBWYWx1ZSkgPT4gYm9vbGVhblxuXG4gIC8vIEFzc3VtZXMgTm9uRXhpc3RlbmNlUHJvb2ZcbiAgdHlwZSB2ZXJpZnlOb25NZW1iZXJzaGlwID0gKHJvb3Q6IENvbW1pdG1lbnRSb290LCBwcm9vZjogQ29tbWl0bWVudFByb29mLCBrZXk6IEtleSkgPT4gYm9vbGVhblxuXG4gIC8vIEFzc3VtZXMgQmF0Y2hQcm9vZiAtIHJlcXVpcmVkIEV4aXN0ZW5jZVByb29mcyBtYXkgYmUgYSBzdWJzZXQgb2YgYWxsIGl0ZW1zIHByb3ZlblxuICB0eXBlIGJhdGNoVmVyaWZ5TWVtYmVyc2hpcCA9IChyb290OiBDb21taXRtZW50Um9vdCwgcHJvb2Y6IENvbW1pdG1lbnRQcm9vZiwgaXRlbXM6IE1hcDxLZXksIFZhbHVlPikgPT4gYm9vbGVhblxuXG4gIC8vIEFzc3VtZXMgQmF0Y2hQcm9vZiAtIHJlcXVpcmVkIE5vbkV4aXN0ZW5jZVByb29mcyBtYXkgYmUgYSBzdWJzZXQgb2YgYWxsIGl0ZW1zIHByb3ZlblxuICB0eXBlIGJhdGNoVmVyaWZ5Tm9uTWVtYmVyc2hpcCA9IChyb290OiBDb21taXRtZW50Um9vdCwgcHJvb2Y6IENvbW1pdG1lbnRQcm9vZiwga2V5czogU2V0PEtleT4pID0+IGJvb2xlYW5cblxuV2UgbWFrZSBhbiBhZGp1c3RtZW50IHRvIGFjY2VwdCBhIFNwZWMgdG8gZW5zdXJlIHRoZSBwcm92aWRlZCBwcm9vZiBpcyBpbiB0aGUgZm9ybWF0IG9mIHRoZSBleHBlY3RlZCBtZXJrbGUgc3RvcmUuXG5UaGlzIGNhbiBhdm9pZCBhbiByYW5nZSBvZiBhdHRhY2tzIG9uIGZha2UgcHJlaW1hZ2VzLCBhcyB3ZSBuZWVkIHRvIGJlIGNhcmVmdWwgb24gaG93IHRvIG1hcCBrZXksIHZhbHVlIC0+IGxlYWZcbmFuZCBkZXRlcm1pbmUgbmVpZ2hib3JzXG4qL1xuLyoqXG4gKiB2ZXJpZnlNZW1iZXJzaGlwIGVuc3VyZXMgcHJvb2YgaXMgKGNvbnRhaW5zKSBhIHZhbGlkIGV4aXN0ZW5jZSBwcm9vZiBmb3IgdGhlIGdpdmVuXG4gKi9cbmZ1bmN0aW9uIHZlcmlmeU1lbWJlcnNoaXAocHJvb2YsIHNwZWMsIHJvb3QsIGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBub3JtID0gKDAsIGNvbXByZXNzXzEuZGVjb21wcmVzcykocHJvb2YpO1xuICAgIGNvbnN0IGV4aXN0ID0gZ2V0RXhpc3RGb3JLZXkobm9ybSwga2V5KTtcbiAgICBpZiAoIWV4aXN0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgKDAsIHByb29mc18xLnZlcmlmeUV4aXN0ZW5jZSkoZXhpc3QsIHNwZWMsIHJvb3QsIGtleSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLnZlcmlmeU1lbWJlcnNoaXAgPSB2ZXJpZnlNZW1iZXJzaGlwO1xuLyoqXG4gKiB2ZXJpZnlOb25NZW1iZXJzaGlwIGVuc3VyZXMgcHJvb2YgaXMgKGNvbnRhaW5zKSBhIHZhbGlkIG5vbi1leGlzdGVuY2UgcHJvb2YgZm9yIHRoZSBnaXZlbiBrZXlcbiAqL1xuZnVuY3Rpb24gdmVyaWZ5Tm9uTWVtYmVyc2hpcChwcm9vZiwgc3BlYywgcm9vdCwga2V5KSB7XG4gICAgY29uc3Qgbm9ybSA9ICgwLCBjb21wcmVzc18xLmRlY29tcHJlc3MpKHByb29mKTtcbiAgICBjb25zdCBub25leGlzdCA9IGdldE5vbkV4aXN0Rm9yS2V5KG5vcm0sIGtleSk7XG4gICAgaWYgKCFub25leGlzdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgICgwLCBwcm9vZnNfMS52ZXJpZnlOb25FeGlzdGVuY2UpKG5vbmV4aXN0LCBzcGVjLCByb290LCBrZXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLnZlcmlmeU5vbk1lbWJlcnNoaXAgPSB2ZXJpZnlOb25NZW1iZXJzaGlwO1xuLyoqXG4gKiBiYXRjaFZlcmlmeU1lbWJlcnNoaXAgZW5zdXJlcyBwcm9vZiBpcyAoY29udGFpbnMpIGEgdmFsaWQgZXhpc3RlbmNlIHByb29mIGZvciB0aGUgZ2l2ZW5cbiAqL1xuZnVuY3Rpb24gYmF0Y2hWZXJpZnlNZW1iZXJzaGlwKHByb29mLCBzcGVjLCByb290LCBpdGVtcykge1xuICAgIGNvbnN0IG5vcm0gPSAoMCwgY29tcHJlc3NfMS5kZWNvbXByZXNzKShwcm9vZik7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgaXRlbXMuZW50cmllcygpKSB7XG4gICAgICAgIGlmICghdmVyaWZ5TWVtYmVyc2hpcChub3JtLCBzcGVjLCByb290LCBrZXksIHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5iYXRjaFZlcmlmeU1lbWJlcnNoaXAgPSBiYXRjaFZlcmlmeU1lbWJlcnNoaXA7XG4vKipcbiAqIGJhdGNoVmVyaWZ5Tm9uTWVtYmVyc2hpcCBlbnN1cmVzIHByb29mIGlzIChjb250YWlucykgYSB2YWxpZCBleGlzdGVuY2UgcHJvb2YgZm9yIHRoZSBnaXZlblxuICovXG5mdW5jdGlvbiBiYXRjaFZlcmlmeU5vbk1lbWJlcnNoaXAocHJvb2YsIHNwZWMsIHJvb3QsIGtleXMpIHtcbiAgICBjb25zdCBub3JtID0gKDAsIGNvbXByZXNzXzEuZGVjb21wcmVzcykocHJvb2YpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgaWYgKCF2ZXJpZnlOb25NZW1iZXJzaGlwKG5vcm0sIHNwZWMsIHJvb3QsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuYmF0Y2hWZXJpZnlOb25NZW1iZXJzaGlwID0gYmF0Y2hWZXJpZnlOb25NZW1iZXJzaGlwO1xuZnVuY3Rpb24gZ2V0RXhpc3RGb3JLZXkocHJvb2YsIGtleSkge1xuICAgIGNvbnN0IG1hdGNoID0gKHApID0+ICEhcCAmJiAoMCwgc3BlY3NfMS5ieXRlc0VxdWFsKShrZXksIHAua2V5KTtcbiAgICBpZiAobWF0Y2gocHJvb2YuZXhpc3QpKSB7XG4gICAgICAgIHJldHVybiBwcm9vZi5leGlzdDtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvb2YuYmF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHByb29mLmJhdGNoLmVudHJpZXMubWFwKCh4KSA9PiB4LmV4aXN0IHx8IG51bGwpLmZpbmQobWF0Y2gpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0Tm9uRXhpc3RGb3JLZXkocHJvb2YsIGtleSkge1xuICAgIGNvbnN0IG1hdGNoID0gKHApID0+IHtcbiAgICAgICAgcmV0dXJuICghIXAgJiZcbiAgICAgICAgICAgICghcC5sZWZ0IHx8ICgwLCBzcGVjc18xLmJ5dGVzQmVmb3JlKShwLmxlZnQua2V5LCBrZXkpKSAmJlxuICAgICAgICAgICAgKCFwLnJpZ2h0IHx8ICgwLCBzcGVjc18xLmJ5dGVzQmVmb3JlKShrZXksIHAucmlnaHQua2V5KSkpO1xuICAgIH07XG4gICAgaWYgKG1hdGNoKHByb29mLm5vbmV4aXN0KSkge1xuICAgICAgICByZXR1cm4gcHJvb2Yubm9uZXhpc3Q7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb29mLmJhdGNoKSB7XG4gICAgICAgIHJldHVybiBwcm9vZi5iYXRjaC5lbnRyaWVzLm1hcCgoeCkgPT4geC5ub25leGlzdCB8fCBudWxsKS5maW5kKG1hdGNoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWljczIzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@confio/ics23/build/ics23.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@confio/ics23/build/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@confio/ics23/build/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.verifyNonExistence = exports.verifyExistence = exports.tendermintSpec = exports.iavlSpec = exports.calculateExistenceRoot = exports.verifyNonMembership = exports.verifyMembership = exports.ics23 = void 0;\nvar codecimpl_1 = __webpack_require__(/*! ./generated/codecimpl */ \"(ssr)/./node_modules/@confio/ics23/build/generated/codecimpl.js\");\nObject.defineProperty(exports, \"ics23\", ({ enumerable: true, get: function () { return codecimpl_1.ics23; } }));\nvar ics23_1 = __webpack_require__(/*! ./ics23 */ \"(ssr)/./node_modules/@confio/ics23/build/ics23.js\");\nObject.defineProperty(exports, \"verifyMembership\", ({ enumerable: true, get: function () { return ics23_1.verifyMembership; } }));\nObject.defineProperty(exports, \"verifyNonMembership\", ({ enumerable: true, get: function () { return ics23_1.verifyNonMembership; } }));\nvar proofs_1 = __webpack_require__(/*! ./proofs */ \"(ssr)/./node_modules/@confio/ics23/build/proofs.js\");\nObject.defineProperty(exports, \"calculateExistenceRoot\", ({ enumerable: true, get: function () { return proofs_1.calculateExistenceRoot; } }));\nObject.defineProperty(exports, \"iavlSpec\", ({ enumerable: true, get: function () { return proofs_1.iavlSpec; } }));\nObject.defineProperty(exports, \"tendermintSpec\", ({ enumerable: true, get: function () { return proofs_1.tendermintSpec; } }));\nObject.defineProperty(exports, \"verifyExistence\", ({ enumerable: true, get: function () { return proofs_1.verifyExistence; } }));\nObject.defineProperty(exports, \"verifyNonExistence\", ({ enumerable: true, get: function () { return proofs_1.verifyNonExistence; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbmZpby9pY3MyMy9idWlsZC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyx1QkFBdUIsR0FBRyxzQkFBc0IsR0FBRyxnQkFBZ0IsR0FBRyw4QkFBOEIsR0FBRywyQkFBMkIsR0FBRyx3QkFBd0IsR0FBRyxhQUFhO0FBQzFNLGtCQUFrQixtQkFBTyxDQUFDLDhGQUF1QjtBQUNqRCx5Q0FBd0MsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDN0csY0FBYyxtQkFBTyxDQUFDLGtFQUFTO0FBQy9CLG9EQUFtRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUMvSCx1REFBc0QsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDckksZUFBZSxtQkFBTyxDQUFDLG9FQUFVO0FBQ2pDLDBEQUF5RCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUM1SSw0Q0FBMkMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDaEgsa0RBQWlELEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzVILG1EQUFrRCxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUM5SCxzREFBcUQsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDcEkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9AY29uZmlvL2ljczIzL2J1aWxkL2luZGV4LmpzPzIwNGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcmlmeU5vbkV4aXN0ZW5jZSA9IGV4cG9ydHMudmVyaWZ5RXhpc3RlbmNlID0gZXhwb3J0cy50ZW5kZXJtaW50U3BlYyA9IGV4cG9ydHMuaWF2bFNwZWMgPSBleHBvcnRzLmNhbGN1bGF0ZUV4aXN0ZW5jZVJvb3QgPSBleHBvcnRzLnZlcmlmeU5vbk1lbWJlcnNoaXAgPSBleHBvcnRzLnZlcmlmeU1lbWJlcnNoaXAgPSBleHBvcnRzLmljczIzID0gdm9pZCAwO1xudmFyIGNvZGVjaW1wbF8xID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVkL2NvZGVjaW1wbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImljczIzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlY2ltcGxfMS5pY3MyMzsgfSB9KTtcbnZhciBpY3MyM18xID0gcmVxdWlyZShcIi4vaWNzMjNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJpZnlNZW1iZXJzaGlwXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpY3MyM18xLnZlcmlmeU1lbWJlcnNoaXA7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJpZnlOb25NZW1iZXJzaGlwXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpY3MyM18xLnZlcmlmeU5vbk1lbWJlcnNoaXA7IH0gfSk7XG52YXIgcHJvb2ZzXzEgPSByZXF1aXJlKFwiLi9wcm9vZnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjYWxjdWxhdGVFeGlzdGVuY2VSb290XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9vZnNfMS5jYWxjdWxhdGVFeGlzdGVuY2VSb290OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaWF2bFNwZWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb29mc18xLmlhdmxTcGVjOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidGVuZGVybWludFNwZWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb29mc18xLnRlbmRlcm1pbnRTcGVjOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmVyaWZ5RXhpc3RlbmNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9vZnNfMS52ZXJpZnlFeGlzdGVuY2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJpZnlOb25FeGlzdGVuY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb29mc18xLnZlcmlmeU5vbkV4aXN0ZW5jZTsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@confio/ics23/build/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@confio/ics23/build/ops.js":
/*!*************************************************!*\
  !*** ./node_modules/@confio/ics23/build/ops.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.doHash = exports.applyInner = exports.applyLeaf = void 0;\nconst ripemd160_1 = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(ssr)/./node_modules/@noble/hashes/ripemd160.js\");\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/sha256.js\");\nconst sha512_1 = __webpack_require__(/*! @noble/hashes/sha512 */ \"(ssr)/./node_modules/@noble/hashes/sha512.js\");\nconst codecimpl_1 = __webpack_require__(/*! ./generated/codecimpl */ \"(ssr)/./node_modules/@confio/ics23/build/generated/codecimpl.js\");\nfunction applyLeaf(leaf, key, value) {\n    if (key.length === 0) {\n        throw new Error(\"Missing key\");\n    }\n    if (value.length === 0) {\n        throw new Error(\"Missing value\");\n    }\n    const pkey = prepareLeafData(ensureHash(leaf.prehashKey), ensureLength(leaf.length), key);\n    const pvalue = prepareLeafData(ensureHash(leaf.prehashValue), ensureLength(leaf.length), value);\n    const data = new Uint8Array([\n        ...ensureBytes(leaf.prefix),\n        ...pkey,\n        ...pvalue,\n    ]);\n    return doHash(ensureHash(leaf.hash), data);\n}\nexports.applyLeaf = applyLeaf;\nfunction applyInner(inner, child) {\n    if (child.length === 0) {\n        throw new Error(\"Inner op needs child value\");\n    }\n    const preimage = new Uint8Array([\n        ...ensureBytes(inner.prefix),\n        ...child,\n        ...ensureBytes(inner.suffix),\n    ]);\n    return doHash(ensureHash(inner.hash), preimage);\n}\nexports.applyInner = applyInner;\nfunction ensure(maybe, value) {\n    return maybe === undefined || maybe === null ? value : maybe;\n}\nconst ensureHash = (h) => ensure(h, codecimpl_1.ics23.HashOp.NO_HASH);\nconst ensureLength = (l) => ensure(l, codecimpl_1.ics23.LengthOp.NO_PREFIX);\nconst ensureBytes = (b) => ensure(b, new Uint8Array([]));\nfunction prepareLeafData(hashOp, lengthOp, data) {\n    const h = doHashOrNoop(hashOp, data);\n    return doLengthOp(lengthOp, h);\n}\n// doHashOrNoop will return the preimage untouched if hashOp == NONE,\n// otherwise, perform doHash\nfunction doHashOrNoop(hashOp, preimage) {\n    if (hashOp === codecimpl_1.ics23.HashOp.NO_HASH) {\n        return preimage;\n    }\n    return doHash(hashOp, preimage);\n}\n// doHash will preform the specified hash on the preimage.\n// if hashOp == NONE, it will return an error (use doHashOrNoop if you want different behavior)\nfunction doHash(hashOp, preimage) {\n    switch (hashOp) {\n        case codecimpl_1.ics23.HashOp.SHA256:\n            return (0, sha256_1.sha256)(preimage);\n        case codecimpl_1.ics23.HashOp.SHA512:\n            return (0, sha512_1.sha512)(preimage);\n        case codecimpl_1.ics23.HashOp.RIPEMD160:\n            return (0, ripemd160_1.ripemd160)(preimage);\n        case codecimpl_1.ics23.HashOp.BITCOIN:\n            return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(preimage));\n        case codecimpl_1.ics23.HashOp.SHA512_256:\n            return (0, sha512_1.sha512_256)(preimage);\n    }\n    throw new Error(`Unsupported hashop: ${hashOp}`);\n}\nexports.doHash = doHash;\n// doLengthOp will calculate the proper prefix and return it prepended\n//   doLengthOp(op, data) -> length(data) || data\nfunction doLengthOp(lengthOp, data) {\n    switch (lengthOp) {\n        case codecimpl_1.ics23.LengthOp.NO_PREFIX:\n            return data;\n        case codecimpl_1.ics23.LengthOp.VAR_PROTO:\n            return new Uint8Array([...encodeVarintProto(data.length), ...data]);\n        case codecimpl_1.ics23.LengthOp.REQUIRE_32_BYTES:\n            if (data.length !== 32) {\n                throw new Error(`Length is ${data.length}, not 32 bytes`);\n            }\n            return data;\n        case codecimpl_1.ics23.LengthOp.REQUIRE_64_BYTES:\n            if (data.length !== 64) {\n                throw new Error(`Length is ${data.length}, not 64 bytes`);\n            }\n            return data;\n        case codecimpl_1.ics23.LengthOp.FIXED32_LITTLE:\n            return new Uint8Array([...encodeFixed32Le(data.length), ...data]);\n        // TODO\n        // case LengthOp_VAR_RLP:\n        // case LengthOp_FIXED32_BIG:\n        // case LengthOp_FIXED64_BIG:\n        // case LengthOp_FIXED64_LITTLE:\n    }\n    throw new Error(`Unsupported lengthop: ${lengthOp}`);\n}\nfunction encodeVarintProto(n) {\n    let enc = [];\n    let l = n;\n    while (l >= 128) {\n        const b = (l % 128) + 128;\n        enc = [...enc, b];\n        l = l / 128;\n    }\n    enc = [...enc, l];\n    return new Uint8Array(enc);\n}\nfunction encodeFixed32Le(n) {\n    const enc = new Uint8Array(4);\n    let l = n;\n    for (let i = enc.length; i > 0; i--) {\n        enc[Math.abs(i - enc.length)] = l % 256;\n        l = Math.floor(l / 256);\n    }\n    return enc;\n}\n//# sourceMappingURL=ops.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbmZpby9pY3MyMy9idWlsZC9vcHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGtCQUFrQixHQUFHLGlCQUFpQjtBQUN2RCxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBeUI7QUFDckQsaUJBQWlCLG1CQUFPLENBQUMsMEVBQXNCO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLDBFQUFzQjtBQUMvQyxvQkFBb0IsbUJBQU8sQ0FBQyw4RkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9AY29uZmlvL2ljczIzL2J1aWxkL29wcy5qcz9hN2YyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kb0hhc2ggPSBleHBvcnRzLmFwcGx5SW5uZXIgPSBleHBvcnRzLmFwcGx5TGVhZiA9IHZvaWQgMDtcbmNvbnN0IHJpcGVtZDE2MF8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvcmlwZW1kMTYwXCIpO1xuY29uc3Qgc2hhMjU2XzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIik7XG5jb25zdCBzaGE1MTJfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTUxMlwiKTtcbmNvbnN0IGNvZGVjaW1wbF8xID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVkL2NvZGVjaW1wbFwiKTtcbmZ1bmN0aW9uIGFwcGx5TGVhZihsZWFmLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBrZXlcIik7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZVwiKTtcbiAgICB9XG4gICAgY29uc3QgcGtleSA9IHByZXBhcmVMZWFmRGF0YShlbnN1cmVIYXNoKGxlYWYucHJlaGFzaEtleSksIGVuc3VyZUxlbmd0aChsZWFmLmxlbmd0aCksIGtleSk7XG4gICAgY29uc3QgcHZhbHVlID0gcHJlcGFyZUxlYWZEYXRhKGVuc3VyZUhhc2gobGVhZi5wcmVoYXNoVmFsdWUpLCBlbnN1cmVMZW5ndGgobGVhZi5sZW5ndGgpLCB2YWx1ZSk7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgLi4uZW5zdXJlQnl0ZXMobGVhZi5wcmVmaXgpLFxuICAgICAgICAuLi5wa2V5LFxuICAgICAgICAuLi5wdmFsdWUsXG4gICAgXSk7XG4gICAgcmV0dXJuIGRvSGFzaChlbnN1cmVIYXNoKGxlYWYuaGFzaCksIGRhdGEpO1xufVxuZXhwb3J0cy5hcHBseUxlYWYgPSBhcHBseUxlYWY7XG5mdW5jdGlvbiBhcHBseUlubmVyKGlubmVyLCBjaGlsZCkge1xuICAgIGlmIChjaGlsZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5uZXIgb3AgbmVlZHMgY2hpbGQgdmFsdWVcIik7XG4gICAgfVxuICAgIGNvbnN0IHByZWltYWdlID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAuLi5lbnN1cmVCeXRlcyhpbm5lci5wcmVmaXgpLFxuICAgICAgICAuLi5jaGlsZCxcbiAgICAgICAgLi4uZW5zdXJlQnl0ZXMoaW5uZXIuc3VmZml4KSxcbiAgICBdKTtcbiAgICByZXR1cm4gZG9IYXNoKGVuc3VyZUhhc2goaW5uZXIuaGFzaCksIHByZWltYWdlKTtcbn1cbmV4cG9ydHMuYXBwbHlJbm5lciA9IGFwcGx5SW5uZXI7XG5mdW5jdGlvbiBlbnN1cmUobWF5YmUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG1heWJlID09PSB1bmRlZmluZWQgfHwgbWF5YmUgPT09IG51bGwgPyB2YWx1ZSA6IG1heWJlO1xufVxuY29uc3QgZW5zdXJlSGFzaCA9IChoKSA9PiBlbnN1cmUoaCwgY29kZWNpbXBsXzEuaWNzMjMuSGFzaE9wLk5PX0hBU0gpO1xuY29uc3QgZW5zdXJlTGVuZ3RoID0gKGwpID0+IGVuc3VyZShsLCBjb2RlY2ltcGxfMS5pY3MyMy5MZW5ndGhPcC5OT19QUkVGSVgpO1xuY29uc3QgZW5zdXJlQnl0ZXMgPSAoYikgPT4gZW5zdXJlKGIsIG5ldyBVaW50OEFycmF5KFtdKSk7XG5mdW5jdGlvbiBwcmVwYXJlTGVhZkRhdGEoaGFzaE9wLCBsZW5ndGhPcCwgZGF0YSkge1xuICAgIGNvbnN0IGggPSBkb0hhc2hPck5vb3AoaGFzaE9wLCBkYXRhKTtcbiAgICByZXR1cm4gZG9MZW5ndGhPcChsZW5ndGhPcCwgaCk7XG59XG4vLyBkb0hhc2hPck5vb3Agd2lsbCByZXR1cm4gdGhlIHByZWltYWdlIHVudG91Y2hlZCBpZiBoYXNoT3AgPT0gTk9ORSxcbi8vIG90aGVyd2lzZSwgcGVyZm9ybSBkb0hhc2hcbmZ1bmN0aW9uIGRvSGFzaE9yTm9vcChoYXNoT3AsIHByZWltYWdlKSB7XG4gICAgaWYgKGhhc2hPcCA9PT0gY29kZWNpbXBsXzEuaWNzMjMuSGFzaE9wLk5PX0hBU0gpIHtcbiAgICAgICAgcmV0dXJuIHByZWltYWdlO1xuICAgIH1cbiAgICByZXR1cm4gZG9IYXNoKGhhc2hPcCwgcHJlaW1hZ2UpO1xufVxuLy8gZG9IYXNoIHdpbGwgcHJlZm9ybSB0aGUgc3BlY2lmaWVkIGhhc2ggb24gdGhlIHByZWltYWdlLlxuLy8gaWYgaGFzaE9wID09IE5PTkUsIGl0IHdpbGwgcmV0dXJuIGFuIGVycm9yICh1c2UgZG9IYXNoT3JOb29wIGlmIHlvdSB3YW50IGRpZmZlcmVudCBiZWhhdmlvcilcbmZ1bmN0aW9uIGRvSGFzaChoYXNoT3AsIHByZWltYWdlKSB7XG4gICAgc3dpdGNoIChoYXNoT3ApIHtcbiAgICAgICAgY2FzZSBjb2RlY2ltcGxfMS5pY3MyMy5IYXNoT3AuU0hBMjU2OlxuICAgICAgICAgICAgcmV0dXJuICgwLCBzaGEyNTZfMS5zaGEyNTYpKHByZWltYWdlKTtcbiAgICAgICAgY2FzZSBjb2RlY2ltcGxfMS5pY3MyMy5IYXNoT3AuU0hBNTEyOlxuICAgICAgICAgICAgcmV0dXJuICgwLCBzaGE1MTJfMS5zaGE1MTIpKHByZWltYWdlKTtcbiAgICAgICAgY2FzZSBjb2RlY2ltcGxfMS5pY3MyMy5IYXNoT3AuUklQRU1EMTYwOlxuICAgICAgICAgICAgcmV0dXJuICgwLCByaXBlbWQxNjBfMS5yaXBlbWQxNjApKHByZWltYWdlKTtcbiAgICAgICAgY2FzZSBjb2RlY2ltcGxfMS5pY3MyMy5IYXNoT3AuQklUQ09JTjpcbiAgICAgICAgICAgIHJldHVybiAoMCwgcmlwZW1kMTYwXzEucmlwZW1kMTYwKSgoMCwgc2hhMjU2XzEuc2hhMjU2KShwcmVpbWFnZSkpO1xuICAgICAgICBjYXNlIGNvZGVjaW1wbF8xLmljczIzLkhhc2hPcC5TSEE1MTJfMjU2OlxuICAgICAgICAgICAgcmV0dXJuICgwLCBzaGE1MTJfMS5zaGE1MTJfMjU2KShwcmVpbWFnZSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgaGFzaG9wOiAke2hhc2hPcH1gKTtcbn1cbmV4cG9ydHMuZG9IYXNoID0gZG9IYXNoO1xuLy8gZG9MZW5ndGhPcCB3aWxsIGNhbGN1bGF0ZSB0aGUgcHJvcGVyIHByZWZpeCBhbmQgcmV0dXJuIGl0IHByZXBlbmRlZFxuLy8gICBkb0xlbmd0aE9wKG9wLCBkYXRhKSAtPiBsZW5ndGgoZGF0YSkgfHwgZGF0YVxuZnVuY3Rpb24gZG9MZW5ndGhPcChsZW5ndGhPcCwgZGF0YSkge1xuICAgIHN3aXRjaCAobGVuZ3RoT3ApIHtcbiAgICAgICAgY2FzZSBjb2RlY2ltcGxfMS5pY3MyMy5MZW5ndGhPcC5OT19QUkVGSVg6XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgY2FzZSBjb2RlY2ltcGxfMS5pY3MyMy5MZW5ndGhPcC5WQVJfUFJPVE86XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWy4uLmVuY29kZVZhcmludFByb3RvKGRhdGEubGVuZ3RoKSwgLi4uZGF0YV0pO1xuICAgICAgICBjYXNlIGNvZGVjaW1wbF8xLmljczIzLkxlbmd0aE9wLlJFUVVJUkVfMzJfQllURVM6XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZW5ndGggaXMgJHtkYXRhLmxlbmd0aH0sIG5vdCAzMiBieXRlc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIGNhc2UgY29kZWNpbXBsXzEuaWNzMjMuTGVuZ3RoT3AuUkVRVUlSRV82NF9CWVRFUzpcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gNjQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExlbmd0aCBpcyAke2RhdGEubGVuZ3RofSwgbm90IDY0IGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgY2FzZSBjb2RlY2ltcGxfMS5pY3MyMy5MZW5ndGhPcC5GSVhFRDMyX0xJVFRMRTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbLi4uZW5jb2RlRml4ZWQzMkxlKGRhdGEubGVuZ3RoKSwgLi4uZGF0YV0pO1xuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIGNhc2UgTGVuZ3RoT3BfVkFSX1JMUDpcbiAgICAgICAgLy8gY2FzZSBMZW5ndGhPcF9GSVhFRDMyX0JJRzpcbiAgICAgICAgLy8gY2FzZSBMZW5ndGhPcF9GSVhFRDY0X0JJRzpcbiAgICAgICAgLy8gY2FzZSBMZW5ndGhPcF9GSVhFRDY0X0xJVFRMRTpcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBsZW5ndGhvcDogJHtsZW5ndGhPcH1gKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVZhcmludFByb3RvKG4pIHtcbiAgICBsZXQgZW5jID0gW107XG4gICAgbGV0IGwgPSBuO1xuICAgIHdoaWxlIChsID49IDEyOCkge1xuICAgICAgICBjb25zdCBiID0gKGwgJSAxMjgpICsgMTI4O1xuICAgICAgICBlbmMgPSBbLi4uZW5jLCBiXTtcbiAgICAgICAgbCA9IGwgLyAxMjg7XG4gICAgfVxuICAgIGVuYyA9IFsuLi5lbmMsIGxdO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShlbmMpO1xufVxuZnVuY3Rpb24gZW5jb2RlRml4ZWQzMkxlKG4pIHtcbiAgICBjb25zdCBlbmMgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBsZXQgbCA9IG47XG4gICAgZm9yIChsZXQgaSA9IGVuYy5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgZW5jW01hdGguYWJzKGkgLSBlbmMubGVuZ3RoKV0gPSBsICUgMjU2O1xuICAgICAgICBsID0gTWF0aC5mbG9vcihsIC8gMjU2KTtcbiAgICB9XG4gICAgcmV0dXJuIGVuYztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@confio/ics23/build/ops.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@confio/ics23/build/proofs.js":
/*!****************************************************!*\
  !*** ./node_modules/@confio/ics23/build/proofs.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ensureLeftNeighbor = exports.ensureSpec = exports.calculateExistenceRoot = exports.verifyNonExistence = exports.verifyExistence = exports.smtSpec = exports.tendermintSpec = exports.iavlSpec = void 0;\nconst codecimpl_1 = __webpack_require__(/*! ./generated/codecimpl */ \"(ssr)/./node_modules/@confio/ics23/build/generated/codecimpl.js\");\nconst ops_1 = __webpack_require__(/*! ./ops */ \"(ssr)/./node_modules/@confio/ics23/build/ops.js\");\nconst specs_1 = __webpack_require__(/*! ./specs */ \"(ssr)/./node_modules/@confio/ics23/build/specs.js\");\nexports.iavlSpec = {\n    leafSpec: {\n        prefix: Uint8Array.from([0]),\n        hash: codecimpl_1.ics23.HashOp.SHA256,\n        prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n        length: codecimpl_1.ics23.LengthOp.VAR_PROTO,\n    },\n    innerSpec: {\n        childOrder: [0, 1],\n        minPrefixLength: 4,\n        maxPrefixLength: 12,\n        childSize: 33,\n        hash: codecimpl_1.ics23.HashOp.SHA256,\n    },\n};\nexports.tendermintSpec = {\n    leafSpec: {\n        prefix: Uint8Array.from([0]),\n        hash: codecimpl_1.ics23.HashOp.SHA256,\n        prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n        length: codecimpl_1.ics23.LengthOp.VAR_PROTO,\n    },\n    innerSpec: {\n        childOrder: [0, 1],\n        minPrefixLength: 1,\n        maxPrefixLength: 1,\n        childSize: 32,\n        hash: codecimpl_1.ics23.HashOp.SHA256,\n    },\n};\nexports.smtSpec = {\n    leafSpec: {\n        hash: codecimpl_1.ics23.HashOp.SHA256,\n        prehashKey: codecimpl_1.ics23.HashOp.NO_HASH,\n        prehashValue: codecimpl_1.ics23.HashOp.SHA256,\n        length: codecimpl_1.ics23.LengthOp.NO_PREFIX,\n        prefix: Uint8Array.from([0]),\n    },\n    innerSpec: {\n        childOrder: [0, 1],\n        childSize: 32,\n        minPrefixLength: 1,\n        maxPrefixLength: 1,\n        emptyChild: new Uint8Array(32),\n        hash: codecimpl_1.ics23.HashOp.SHA256,\n    },\n    maxDepth: 256,\n};\n// verifyExistence will throw an error if the proof doesn't link key, value -> root\n// or if it doesn't fulfill the spec\nfunction verifyExistence(proof, spec, root, key, value) {\n    ensureSpec(proof, spec);\n    const calc = calculateExistenceRoot(proof);\n    (0, specs_1.ensureBytesEqual)(calc, root);\n    (0, specs_1.ensureBytesEqual)(key, proof.key);\n    (0, specs_1.ensureBytesEqual)(value, proof.value);\n}\nexports.verifyExistence = verifyExistence;\n// Verify does all checks to ensure the proof has valid non-existence proofs,\n// and they ensure the given key is not in the CommitmentState,\n// throwing an error if there is an issue\nfunction verifyNonExistence(proof, spec, root, key) {\n    let leftKey;\n    let rightKey;\n    if (proof.left) {\n        verifyExistence(proof.left, spec, root, proof.left.key, proof.left.value);\n        leftKey = proof.left.key;\n    }\n    if (proof.right) {\n        verifyExistence(proof.right, spec, root, proof.right.key, proof.right.value);\n        rightKey = proof.right.key;\n    }\n    if (!leftKey && !rightKey) {\n        throw new Error(\"neither left nor right proof defined\");\n    }\n    if (leftKey) {\n        (0, specs_1.ensureBytesBefore)(leftKey, key);\n    }\n    if (rightKey) {\n        (0, specs_1.ensureBytesBefore)(key, rightKey);\n    }\n    if (!spec.innerSpec) {\n        throw new Error(\"no inner spec\");\n    }\n    if (!leftKey) {\n        ensureLeftMost(spec.innerSpec, proof.right.path);\n    }\n    else if (!rightKey) {\n        ensureRightMost(spec.innerSpec, proof.left.path);\n    }\n    else {\n        ensureLeftNeighbor(spec.innerSpec, proof.left.path, proof.right.path);\n    }\n    return;\n}\nexports.verifyNonExistence = verifyNonExistence;\n// Calculate determines the root hash that matches the given proof.\n// You must validate the result is what you have in a header.\n// Returns error if the calculations cannot be performed.\nfunction calculateExistenceRoot(proof) {\n    if (!proof.key || !proof.value) {\n        throw new Error(\"Existence proof needs key and value set\");\n    }\n    if (!proof.leaf) {\n        throw new Error(\"Existence proof must start with a leaf operation\");\n    }\n    const path = proof.path || [];\n    let res = (0, ops_1.applyLeaf)(proof.leaf, proof.key, proof.value);\n    for (const inner of path) {\n        res = (0, ops_1.applyInner)(inner, res);\n    }\n    return res;\n}\nexports.calculateExistenceRoot = calculateExistenceRoot;\n// ensureSpec throws an Error if proof doesn't fulfill spec\nfunction ensureSpec(proof, spec) {\n    if (!proof.leaf) {\n        throw new Error(\"Existence proof must start with a leaf operation\");\n    }\n    if (!spec.leafSpec) {\n        throw new Error(\"Spec must include leafSpec\");\n    }\n    if (!spec.innerSpec) {\n        throw new Error(\"Spec must include innerSpec\");\n    }\n    (0, specs_1.ensureLeaf)(proof.leaf, spec.leafSpec);\n    const path = proof.path || [];\n    if (spec.minDepth && path.length < spec.minDepth) {\n        throw new Error(`Too few inner nodes ${path.length}`);\n    }\n    if (spec.maxDepth && path.length > spec.maxDepth) {\n        throw new Error(`Too many inner nodes ${path.length}`);\n    }\n    for (const inner of path) {\n        (0, specs_1.ensureInner)(inner, spec.leafSpec.prefix, spec.innerSpec);\n    }\n}\nexports.ensureSpec = ensureSpec;\nfunction ensureLeftMost(spec, path) {\n    const { minPrefix, maxPrefix, suffix } = getPadding(spec, 0);\n    // ensure every step has a prefix and suffix defined to be leftmost\n    for (const step of path) {\n        if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {\n            throw new Error(\"Step not leftmost\");\n        }\n    }\n}\nfunction ensureRightMost(spec, path) {\n    const len = spec.childOrder.length - 1;\n    const { minPrefix, maxPrefix, suffix } = getPadding(spec, len);\n    // ensure every step has a prefix and suffix defined to be leftmost\n    for (const step of path) {\n        if (!hasPadding(step, minPrefix, maxPrefix, suffix)) {\n            throw new Error(\"Step not leftmost\");\n        }\n    }\n}\nfunction ensureLeftNeighbor(spec, left, right) {\n    const mutleft = [...left];\n    const mutright = [...right];\n    let topleft = mutleft.pop();\n    let topright = mutright.pop();\n    while ((0, specs_1.bytesEqual)(topleft.prefix, topright.prefix) &&\n        (0, specs_1.bytesEqual)(topleft.suffix, topright.suffix)) {\n        topleft = mutleft.pop();\n        topright = mutright.pop();\n    }\n    // now topleft and topright are the first divergent nodes\n    // make sure they are left and right of each other\n    if (!isLeftStep(spec, topleft, topright)) {\n        throw new Error(`Not left neightbor at first divergent step`);\n    }\n    // make sure the paths are left and right most possibilities respectively\n    ensureRightMost(spec, mutleft);\n    ensureLeftMost(spec, mutright);\n}\nexports.ensureLeftNeighbor = ensureLeftNeighbor;\n// isLeftStep assumes left and right have common parents\n// checks if left is exactly one slot to the left of right\nfunction isLeftStep(spec, left, right) {\n    const leftidx = orderFromPadding(spec, left);\n    const rightidx = orderFromPadding(spec, right);\n    return rightidx === leftidx + 1;\n}\nfunction orderFromPadding(spec, inner) {\n    for (let branch = 0; branch < spec.childOrder.length; branch++) {\n        const { minPrefix, maxPrefix, suffix } = getPadding(spec, branch);\n        if (hasPadding(inner, minPrefix, maxPrefix, suffix)) {\n            return branch;\n        }\n    }\n    throw new Error(`Cannot find any valid spacing for this node`);\n}\nfunction hasPadding(op, minPrefix, maxPrefix, suffix) {\n    if ((op.prefix || []).length < minPrefix) {\n        return false;\n    }\n    if ((op.prefix || []).length > maxPrefix) {\n        return false;\n    }\n    return (op.suffix || []).length === suffix;\n}\nfunction getPadding(spec, branch) {\n    const idx = getPosition(spec.childOrder, branch);\n    // count how many children are in the prefix\n    const prefix = idx * spec.childSize;\n    const minPrefix = prefix + spec.minPrefixLength;\n    const maxPrefix = prefix + spec.maxPrefixLength;\n    // count how many children are in the suffix\n    const suffix = (spec.childOrder.length - 1 - idx) * spec.childSize;\n    return { minPrefix, maxPrefix, suffix };\n}\nfunction getPosition(order, branch) {\n    if (branch < 0 || branch >= order.length) {\n        throw new Error(`Invalid branch: ${branch}`);\n    }\n    return order.findIndex((val) => val === branch);\n}\n//# sourceMappingURL=proofs.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbmZpby9pY3MyMy9idWlsZC9wcm9vZnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsa0JBQWtCLEdBQUcsOEJBQThCLEdBQUcsMEJBQTBCLEdBQUcsdUJBQXVCLEdBQUcsZUFBZSxHQUFHLHNCQUFzQixHQUFHLGdCQUFnQjtBQUNyTSxvQkFBb0IsbUJBQU8sQ0FBQyw4RkFBdUI7QUFDbkQsY0FBYyxtQkFBTyxDQUFDLDhEQUFPO0FBQzdCLGdCQUFnQixtQkFBTyxDQUFDLGtFQUFTO0FBQ2pDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUNBQWlDO0FBQzFELGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0Bjb25maW8vaWNzMjMvYnVpbGQvcHJvb2ZzLmpzP2E5OTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuc3VyZUxlZnROZWlnaGJvciA9IGV4cG9ydHMuZW5zdXJlU3BlYyA9IGV4cG9ydHMuY2FsY3VsYXRlRXhpc3RlbmNlUm9vdCA9IGV4cG9ydHMudmVyaWZ5Tm9uRXhpc3RlbmNlID0gZXhwb3J0cy52ZXJpZnlFeGlzdGVuY2UgPSBleHBvcnRzLnNtdFNwZWMgPSBleHBvcnRzLnRlbmRlcm1pbnRTcGVjID0gZXhwb3J0cy5pYXZsU3BlYyA9IHZvaWQgMDtcbmNvbnN0IGNvZGVjaW1wbF8xID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVkL2NvZGVjaW1wbFwiKTtcbmNvbnN0IG9wc18xID0gcmVxdWlyZShcIi4vb3BzXCIpO1xuY29uc3Qgc3BlY3NfMSA9IHJlcXVpcmUoXCIuL3NwZWNzXCIpO1xuZXhwb3J0cy5pYXZsU3BlYyA9IHtcbiAgICBsZWFmU3BlYzoge1xuICAgICAgICBwcmVmaXg6IFVpbnQ4QXJyYXkuZnJvbShbMF0pLFxuICAgICAgICBoYXNoOiBjb2RlY2ltcGxfMS5pY3MyMy5IYXNoT3AuU0hBMjU2LFxuICAgICAgICBwcmVoYXNoVmFsdWU6IGNvZGVjaW1wbF8xLmljczIzLkhhc2hPcC5TSEEyNTYsXG4gICAgICAgIHByZWhhc2hLZXk6IGNvZGVjaW1wbF8xLmljczIzLkhhc2hPcC5OT19IQVNILFxuICAgICAgICBsZW5ndGg6IGNvZGVjaW1wbF8xLmljczIzLkxlbmd0aE9wLlZBUl9QUk9UTyxcbiAgICB9LFxuICAgIGlubmVyU3BlYzoge1xuICAgICAgICBjaGlsZE9yZGVyOiBbMCwgMV0sXG4gICAgICAgIG1pblByZWZpeExlbmd0aDogNCxcbiAgICAgICAgbWF4UHJlZml4TGVuZ3RoOiAxMixcbiAgICAgICAgY2hpbGRTaXplOiAzMyxcbiAgICAgICAgaGFzaDogY29kZWNpbXBsXzEuaWNzMjMuSGFzaE9wLlNIQTI1NixcbiAgICB9LFxufTtcbmV4cG9ydHMudGVuZGVybWludFNwZWMgPSB7XG4gICAgbGVhZlNwZWM6IHtcbiAgICAgICAgcHJlZml4OiBVaW50OEFycmF5LmZyb20oWzBdKSxcbiAgICAgICAgaGFzaDogY29kZWNpbXBsXzEuaWNzMjMuSGFzaE9wLlNIQTI1NixcbiAgICAgICAgcHJlaGFzaFZhbHVlOiBjb2RlY2ltcGxfMS5pY3MyMy5IYXNoT3AuU0hBMjU2LFxuICAgICAgICBwcmVoYXNoS2V5OiBjb2RlY2ltcGxfMS5pY3MyMy5IYXNoT3AuTk9fSEFTSCxcbiAgICAgICAgbGVuZ3RoOiBjb2RlY2ltcGxfMS5pY3MyMy5MZW5ndGhPcC5WQVJfUFJPVE8sXG4gICAgfSxcbiAgICBpbm5lclNwZWM6IHtcbiAgICAgICAgY2hpbGRPcmRlcjogWzAsIDFdLFxuICAgICAgICBtaW5QcmVmaXhMZW5ndGg6IDEsXG4gICAgICAgIG1heFByZWZpeExlbmd0aDogMSxcbiAgICAgICAgY2hpbGRTaXplOiAzMixcbiAgICAgICAgaGFzaDogY29kZWNpbXBsXzEuaWNzMjMuSGFzaE9wLlNIQTI1NixcbiAgICB9LFxufTtcbmV4cG9ydHMuc210U3BlYyA9IHtcbiAgICBsZWFmU3BlYzoge1xuICAgICAgICBoYXNoOiBjb2RlY2ltcGxfMS5pY3MyMy5IYXNoT3AuU0hBMjU2LFxuICAgICAgICBwcmVoYXNoS2V5OiBjb2RlY2ltcGxfMS5pY3MyMy5IYXNoT3AuTk9fSEFTSCxcbiAgICAgICAgcHJlaGFzaFZhbHVlOiBjb2RlY2ltcGxfMS5pY3MyMy5IYXNoT3AuU0hBMjU2LFxuICAgICAgICBsZW5ndGg6IGNvZGVjaW1wbF8xLmljczIzLkxlbmd0aE9wLk5PX1BSRUZJWCxcbiAgICAgICAgcHJlZml4OiBVaW50OEFycmF5LmZyb20oWzBdKSxcbiAgICB9LFxuICAgIGlubmVyU3BlYzoge1xuICAgICAgICBjaGlsZE9yZGVyOiBbMCwgMV0sXG4gICAgICAgIGNoaWxkU2l6ZTogMzIsXG4gICAgICAgIG1pblByZWZpeExlbmd0aDogMSxcbiAgICAgICAgbWF4UHJlZml4TGVuZ3RoOiAxLFxuICAgICAgICBlbXB0eUNoaWxkOiBuZXcgVWludDhBcnJheSgzMiksXG4gICAgICAgIGhhc2g6IGNvZGVjaW1wbF8xLmljczIzLkhhc2hPcC5TSEEyNTYsXG4gICAgfSxcbiAgICBtYXhEZXB0aDogMjU2LFxufTtcbi8vIHZlcmlmeUV4aXN0ZW5jZSB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBwcm9vZiBkb2Vzbid0IGxpbmsga2V5LCB2YWx1ZSAtPiByb290XG4vLyBvciBpZiBpdCBkb2Vzbid0IGZ1bGZpbGwgdGhlIHNwZWNcbmZ1bmN0aW9uIHZlcmlmeUV4aXN0ZW5jZShwcm9vZiwgc3BlYywgcm9vdCwga2V5LCB2YWx1ZSkge1xuICAgIGVuc3VyZVNwZWMocHJvb2YsIHNwZWMpO1xuICAgIGNvbnN0IGNhbGMgPSBjYWxjdWxhdGVFeGlzdGVuY2VSb290KHByb29mKTtcbiAgICAoMCwgc3BlY3NfMS5lbnN1cmVCeXRlc0VxdWFsKShjYWxjLCByb290KTtcbiAgICAoMCwgc3BlY3NfMS5lbnN1cmVCeXRlc0VxdWFsKShrZXksIHByb29mLmtleSk7XG4gICAgKDAsIHNwZWNzXzEuZW5zdXJlQnl0ZXNFcXVhbCkodmFsdWUsIHByb29mLnZhbHVlKTtcbn1cbmV4cG9ydHMudmVyaWZ5RXhpc3RlbmNlID0gdmVyaWZ5RXhpc3RlbmNlO1xuLy8gVmVyaWZ5IGRvZXMgYWxsIGNoZWNrcyB0byBlbnN1cmUgdGhlIHByb29mIGhhcyB2YWxpZCBub24tZXhpc3RlbmNlIHByb29mcyxcbi8vIGFuZCB0aGV5IGVuc3VyZSB0aGUgZ2l2ZW4ga2V5IGlzIG5vdCBpbiB0aGUgQ29tbWl0bWVudFN0YXRlLFxuLy8gdGhyb3dpbmcgYW4gZXJyb3IgaWYgdGhlcmUgaXMgYW4gaXNzdWVcbmZ1bmN0aW9uIHZlcmlmeU5vbkV4aXN0ZW5jZShwcm9vZiwgc3BlYywgcm9vdCwga2V5KSB7XG4gICAgbGV0IGxlZnRLZXk7XG4gICAgbGV0IHJpZ2h0S2V5O1xuICAgIGlmIChwcm9vZi5sZWZ0KSB7XG4gICAgICAgIHZlcmlmeUV4aXN0ZW5jZShwcm9vZi5sZWZ0LCBzcGVjLCByb290LCBwcm9vZi5sZWZ0LmtleSwgcHJvb2YubGVmdC52YWx1ZSk7XG4gICAgICAgIGxlZnRLZXkgPSBwcm9vZi5sZWZ0LmtleTtcbiAgICB9XG4gICAgaWYgKHByb29mLnJpZ2h0KSB7XG4gICAgICAgIHZlcmlmeUV4aXN0ZW5jZShwcm9vZi5yaWdodCwgc3BlYywgcm9vdCwgcHJvb2YucmlnaHQua2V5LCBwcm9vZi5yaWdodC52YWx1ZSk7XG4gICAgICAgIHJpZ2h0S2V5ID0gcHJvb2YucmlnaHQua2V5O1xuICAgIH1cbiAgICBpZiAoIWxlZnRLZXkgJiYgIXJpZ2h0S2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5laXRoZXIgbGVmdCBub3IgcmlnaHQgcHJvb2YgZGVmaW5lZFwiKTtcbiAgICB9XG4gICAgaWYgKGxlZnRLZXkpIHtcbiAgICAgICAgKDAsIHNwZWNzXzEuZW5zdXJlQnl0ZXNCZWZvcmUpKGxlZnRLZXksIGtleSk7XG4gICAgfVxuICAgIGlmIChyaWdodEtleSkge1xuICAgICAgICAoMCwgc3BlY3NfMS5lbnN1cmVCeXRlc0JlZm9yZSkoa2V5LCByaWdodEtleSk7XG4gICAgfVxuICAgIGlmICghc3BlYy5pbm5lclNwZWMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gaW5uZXIgc3BlY1wiKTtcbiAgICB9XG4gICAgaWYgKCFsZWZ0S2V5KSB7XG4gICAgICAgIGVuc3VyZUxlZnRNb3N0KHNwZWMuaW5uZXJTcGVjLCBwcm9vZi5yaWdodC5wYXRoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXJpZ2h0S2V5KSB7XG4gICAgICAgIGVuc3VyZVJpZ2h0TW9zdChzcGVjLmlubmVyU3BlYywgcHJvb2YubGVmdC5wYXRoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVuc3VyZUxlZnROZWlnaGJvcihzcGVjLmlubmVyU3BlYywgcHJvb2YubGVmdC5wYXRoLCBwcm9vZi5yaWdodC5wYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuO1xufVxuZXhwb3J0cy52ZXJpZnlOb25FeGlzdGVuY2UgPSB2ZXJpZnlOb25FeGlzdGVuY2U7XG4vLyBDYWxjdWxhdGUgZGV0ZXJtaW5lcyB0aGUgcm9vdCBoYXNoIHRoYXQgbWF0Y2hlcyB0aGUgZ2l2ZW4gcHJvb2YuXG4vLyBZb3UgbXVzdCB2YWxpZGF0ZSB0aGUgcmVzdWx0IGlzIHdoYXQgeW91IGhhdmUgaW4gYSBoZWFkZXIuXG4vLyBSZXR1cm5zIGVycm9yIGlmIHRoZSBjYWxjdWxhdGlvbnMgY2Fubm90IGJlIHBlcmZvcm1lZC5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUV4aXN0ZW5jZVJvb3QocHJvb2YpIHtcbiAgICBpZiAoIXByb29mLmtleSB8fCAhcHJvb2YudmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhpc3RlbmNlIHByb29mIG5lZWRzIGtleSBhbmQgdmFsdWUgc2V0XCIpO1xuICAgIH1cbiAgICBpZiAoIXByb29mLmxlYWYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhpc3RlbmNlIHByb29mIG11c3Qgc3RhcnQgd2l0aCBhIGxlYWYgb3BlcmF0aW9uXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYXRoID0gcHJvb2YucGF0aCB8fCBbXTtcbiAgICBsZXQgcmVzID0gKDAsIG9wc18xLmFwcGx5TGVhZikocHJvb2YubGVhZiwgcHJvb2Yua2V5LCBwcm9vZi52YWx1ZSk7XG4gICAgZm9yIChjb25zdCBpbm5lciBvZiBwYXRoKSB7XG4gICAgICAgIHJlcyA9ICgwLCBvcHNfMS5hcHBseUlubmVyKShpbm5lciwgcmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuY2FsY3VsYXRlRXhpc3RlbmNlUm9vdCA9IGNhbGN1bGF0ZUV4aXN0ZW5jZVJvb3Q7XG4vLyBlbnN1cmVTcGVjIHRocm93cyBhbiBFcnJvciBpZiBwcm9vZiBkb2Vzbid0IGZ1bGZpbGwgc3BlY1xuZnVuY3Rpb24gZW5zdXJlU3BlYyhwcm9vZiwgc3BlYykge1xuICAgIGlmICghcHJvb2YubGVhZikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeGlzdGVuY2UgcHJvb2YgbXVzdCBzdGFydCB3aXRoIGEgbGVhZiBvcGVyYXRpb25cIik7XG4gICAgfVxuICAgIGlmICghc3BlYy5sZWFmU3BlYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcGVjIG11c3QgaW5jbHVkZSBsZWFmU3BlY1wiKTtcbiAgICB9XG4gICAgaWYgKCFzcGVjLmlubmVyU3BlYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTcGVjIG11c3QgaW5jbHVkZSBpbm5lclNwZWNcIik7XG4gICAgfVxuICAgICgwLCBzcGVjc18xLmVuc3VyZUxlYWYpKHByb29mLmxlYWYsIHNwZWMubGVhZlNwZWMpO1xuICAgIGNvbnN0IHBhdGggPSBwcm9vZi5wYXRoIHx8IFtdO1xuICAgIGlmIChzcGVjLm1pbkRlcHRoICYmIHBhdGgubGVuZ3RoIDwgc3BlYy5taW5EZXB0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvbyBmZXcgaW5uZXIgbm9kZXMgJHtwYXRoLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgaWYgKHNwZWMubWF4RGVwdGggJiYgcGF0aC5sZW5ndGggPiBzcGVjLm1heERlcHRoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vIG1hbnkgaW5uZXIgbm9kZXMgJHtwYXRoLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBpbm5lciBvZiBwYXRoKSB7XG4gICAgICAgICgwLCBzcGVjc18xLmVuc3VyZUlubmVyKShpbm5lciwgc3BlYy5sZWFmU3BlYy5wcmVmaXgsIHNwZWMuaW5uZXJTcGVjKTtcbiAgICB9XG59XG5leHBvcnRzLmVuc3VyZVNwZWMgPSBlbnN1cmVTcGVjO1xuZnVuY3Rpb24gZW5zdXJlTGVmdE1vc3Qoc3BlYywgcGF0aCkge1xuICAgIGNvbnN0IHsgbWluUHJlZml4LCBtYXhQcmVmaXgsIHN1ZmZpeCB9ID0gZ2V0UGFkZGluZyhzcGVjLCAwKTtcbiAgICAvLyBlbnN1cmUgZXZlcnkgc3RlcCBoYXMgYSBwcmVmaXggYW5kIHN1ZmZpeCBkZWZpbmVkIHRvIGJlIGxlZnRtb3N0XG4gICAgZm9yIChjb25zdCBzdGVwIG9mIHBhdGgpIHtcbiAgICAgICAgaWYgKCFoYXNQYWRkaW5nKHN0ZXAsIG1pblByZWZpeCwgbWF4UHJlZml4LCBzdWZmaXgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGVwIG5vdCBsZWZ0bW9zdFwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGVuc3VyZVJpZ2h0TW9zdChzcGVjLCBwYXRoKSB7XG4gICAgY29uc3QgbGVuID0gc3BlYy5jaGlsZE9yZGVyLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgeyBtaW5QcmVmaXgsIG1heFByZWZpeCwgc3VmZml4IH0gPSBnZXRQYWRkaW5nKHNwZWMsIGxlbik7XG4gICAgLy8gZW5zdXJlIGV2ZXJ5IHN0ZXAgaGFzIGEgcHJlZml4IGFuZCBzdWZmaXggZGVmaW5lZCB0byBiZSBsZWZ0bW9zdFxuICAgIGZvciAoY29uc3Qgc3RlcCBvZiBwYXRoKSB7XG4gICAgICAgIGlmICghaGFzUGFkZGluZyhzdGVwLCBtaW5QcmVmaXgsIG1heFByZWZpeCwgc3VmZml4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RlcCBub3QgbGVmdG1vc3RcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBlbnN1cmVMZWZ0TmVpZ2hib3Ioc3BlYywgbGVmdCwgcmlnaHQpIHtcbiAgICBjb25zdCBtdXRsZWZ0ID0gWy4uLmxlZnRdO1xuICAgIGNvbnN0IG11dHJpZ2h0ID0gWy4uLnJpZ2h0XTtcbiAgICBsZXQgdG9wbGVmdCA9IG11dGxlZnQucG9wKCk7XG4gICAgbGV0IHRvcHJpZ2h0ID0gbXV0cmlnaHQucG9wKCk7XG4gICAgd2hpbGUgKCgwLCBzcGVjc18xLmJ5dGVzRXF1YWwpKHRvcGxlZnQucHJlZml4LCB0b3ByaWdodC5wcmVmaXgpICYmXG4gICAgICAgICgwLCBzcGVjc18xLmJ5dGVzRXF1YWwpKHRvcGxlZnQuc3VmZml4LCB0b3ByaWdodC5zdWZmaXgpKSB7XG4gICAgICAgIHRvcGxlZnQgPSBtdXRsZWZ0LnBvcCgpO1xuICAgICAgICB0b3ByaWdodCA9IG11dHJpZ2h0LnBvcCgpO1xuICAgIH1cbiAgICAvLyBub3cgdG9wbGVmdCBhbmQgdG9wcmlnaHQgYXJlIHRoZSBmaXJzdCBkaXZlcmdlbnQgbm9kZXNcbiAgICAvLyBtYWtlIHN1cmUgdGhleSBhcmUgbGVmdCBhbmQgcmlnaHQgb2YgZWFjaCBvdGhlclxuICAgIGlmICghaXNMZWZ0U3RlcChzcGVjLCB0b3BsZWZ0LCB0b3ByaWdodCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgbGVmdCBuZWlnaHRib3IgYXQgZmlyc3QgZGl2ZXJnZW50IHN0ZXBgKTtcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHRoZSBwYXRocyBhcmUgbGVmdCBhbmQgcmlnaHQgbW9zdCBwb3NzaWJpbGl0aWVzIHJlc3BlY3RpdmVseVxuICAgIGVuc3VyZVJpZ2h0TW9zdChzcGVjLCBtdXRsZWZ0KTtcbiAgICBlbnN1cmVMZWZ0TW9zdChzcGVjLCBtdXRyaWdodCk7XG59XG5leHBvcnRzLmVuc3VyZUxlZnROZWlnaGJvciA9IGVuc3VyZUxlZnROZWlnaGJvcjtcbi8vIGlzTGVmdFN0ZXAgYXNzdW1lcyBsZWZ0IGFuZCByaWdodCBoYXZlIGNvbW1vbiBwYXJlbnRzXG4vLyBjaGVja3MgaWYgbGVmdCBpcyBleGFjdGx5IG9uZSBzbG90IHRvIHRoZSBsZWZ0IG9mIHJpZ2h0XG5mdW5jdGlvbiBpc0xlZnRTdGVwKHNwZWMsIGxlZnQsIHJpZ2h0KSB7XG4gICAgY29uc3QgbGVmdGlkeCA9IG9yZGVyRnJvbVBhZGRpbmcoc3BlYywgbGVmdCk7XG4gICAgY29uc3QgcmlnaHRpZHggPSBvcmRlckZyb21QYWRkaW5nKHNwZWMsIHJpZ2h0KTtcbiAgICByZXR1cm4gcmlnaHRpZHggPT09IGxlZnRpZHggKyAxO1xufVxuZnVuY3Rpb24gb3JkZXJGcm9tUGFkZGluZyhzcGVjLCBpbm5lcikge1xuICAgIGZvciAobGV0IGJyYW5jaCA9IDA7IGJyYW5jaCA8IHNwZWMuY2hpbGRPcmRlci5sZW5ndGg7IGJyYW5jaCsrKSB7XG4gICAgICAgIGNvbnN0IHsgbWluUHJlZml4LCBtYXhQcmVmaXgsIHN1ZmZpeCB9ID0gZ2V0UGFkZGluZyhzcGVjLCBicmFuY2gpO1xuICAgICAgICBpZiAoaGFzUGFkZGluZyhpbm5lciwgbWluUHJlZml4LCBtYXhQcmVmaXgsIHN1ZmZpeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBicmFuY2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBhbnkgdmFsaWQgc3BhY2luZyBmb3IgdGhpcyBub2RlYCk7XG59XG5mdW5jdGlvbiBoYXNQYWRkaW5nKG9wLCBtaW5QcmVmaXgsIG1heFByZWZpeCwgc3VmZml4KSB7XG4gICAgaWYgKChvcC5wcmVmaXggfHwgW10pLmxlbmd0aCA8IG1pblByZWZpeCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgob3AucHJlZml4IHx8IFtdKS5sZW5ndGggPiBtYXhQcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKG9wLnN1ZmZpeCB8fCBbXSkubGVuZ3RoID09PSBzdWZmaXg7XG59XG5mdW5jdGlvbiBnZXRQYWRkaW5nKHNwZWMsIGJyYW5jaCkge1xuICAgIGNvbnN0IGlkeCA9IGdldFBvc2l0aW9uKHNwZWMuY2hpbGRPcmRlciwgYnJhbmNoKTtcbiAgICAvLyBjb3VudCBob3cgbWFueSBjaGlsZHJlbiBhcmUgaW4gdGhlIHByZWZpeFxuICAgIGNvbnN0IHByZWZpeCA9IGlkeCAqIHNwZWMuY2hpbGRTaXplO1xuICAgIGNvbnN0IG1pblByZWZpeCA9IHByZWZpeCArIHNwZWMubWluUHJlZml4TGVuZ3RoO1xuICAgIGNvbnN0IG1heFByZWZpeCA9IHByZWZpeCArIHNwZWMubWF4UHJlZml4TGVuZ3RoO1xuICAgIC8vIGNvdW50IGhvdyBtYW55IGNoaWxkcmVuIGFyZSBpbiB0aGUgc3VmZml4XG4gICAgY29uc3Qgc3VmZml4ID0gKHNwZWMuY2hpbGRPcmRlci5sZW5ndGggLSAxIC0gaWR4KSAqIHNwZWMuY2hpbGRTaXplO1xuICAgIHJldHVybiB7IG1pblByZWZpeCwgbWF4UHJlZml4LCBzdWZmaXggfTtcbn1cbmZ1bmN0aW9uIGdldFBvc2l0aW9uKG9yZGVyLCBicmFuY2gpIHtcbiAgICBpZiAoYnJhbmNoIDwgMCB8fCBicmFuY2ggPj0gb3JkZXIubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBicmFuY2g6ICR7YnJhbmNofWApO1xuICAgIH1cbiAgICByZXR1cm4gb3JkZXIuZmluZEluZGV4KCh2YWwpID0+IHZhbCA9PT0gYnJhbmNoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb29mcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@confio/ics23/build/proofs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@confio/ics23/build/specs.js":
/*!***************************************************!*\
  !*** ./node_modules/@confio/ics23/build/specs.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bytesBefore = exports.ensureBytesBefore = exports.bytesEqual = exports.ensureBytesEqual = exports.ensureInner = exports.ensureLeaf = void 0;\nfunction ensureLeaf(leaf, spec) {\n    if (leaf.hash !== spec.hash) {\n        throw new Error(`Unexpected hashOp: ${leaf.hash}`);\n    }\n    if (leaf.prehashKey !== spec.prehashKey) {\n        throw new Error(`Unexpected prehashKey: ${leaf.prehashKey}`);\n    }\n    if (leaf.prehashValue !== spec.prehashValue) {\n        throw new Error(`Unexpected prehashValue: ${leaf.prehashValue}`);\n    }\n    if (leaf.length !== spec.length) {\n        throw new Error(`Unexpected length op: ${leaf.length}`);\n    }\n    ensurePrefix(leaf.prefix, spec.prefix);\n}\nexports.ensureLeaf = ensureLeaf;\nfunction ensureInner(inner, prefix, spec) {\n    if (inner.hash !== spec.hash) {\n        throw new Error(`Unexpected hashOp: ${inner.hash}`);\n    }\n    if (!inner.prefix) {\n        throw new Error(\"No prefix set for inner node\");\n    }\n    if (hasPrefix(inner.prefix, prefix)) {\n        throw new Error(`Inner node has leaf prefix`);\n    }\n    if (inner.prefix.length < (spec.minPrefixLength || 0)) {\n        throw new Error(`Prefix too short: ${inner.prefix.length} bytes`);\n    }\n    const maxLeftChildBytes = (spec.childOrder.length - 1) * spec.childSize;\n    if (inner.prefix.length > (spec.maxPrefixLength || 0) + maxLeftChildBytes) {\n        throw new Error(`Prefix too long: ${inner.prefix.length} bytes`);\n    }\n}\nexports.ensureInner = ensureInner;\nfunction ensurePrefix(check, prefix) {\n    // no prefix supplied, means everything passes\n    if (!prefix || prefix.length === 0) {\n        return;\n    }\n    if (!check) {\n        throw new Error(`Target bytes missing`);\n    }\n    ensureBytesEqual(prefix, check.slice(0, prefix.length));\n}\n// ensureBytesEqual throws an error if the arrays are different\nfunction ensureBytesEqual(a, b) {\n    if (a.length !== b.length) {\n        throw new Error(`Different lengths ${a.length} vs ${b.length}`);\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            throw new Error(`Arrays differ at index ${i}: ${a[i]} vs ${b[i]}`);\n        }\n    }\n}\nexports.ensureBytesEqual = ensureBytesEqual;\nfunction bytesEqual(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.bytesEqual = bytesEqual;\nfunction hasPrefix(check, prefix) {\n    // no prefix supplied, means everything passes\n    if (!prefix || prefix.length === 0) {\n        return false;\n    }\n    if (!check) {\n        return false;\n    }\n    if (check.length <= prefix.length) {\n        return false;\n    }\n    for (let i = 0; i < prefix.length; i++) {\n        if (check[i] !== prefix[i]) {\n            return false;\n        }\n    }\n    throw true;\n}\n// ensureBytesBefore throws an error if first >= last\n// we compare byte by byte\nfunction ensureBytesBefore(first, last) {\n    if (!bytesBefore(first, last)) {\n        throw new Error(\"first is after last\");\n    }\n}\nexports.ensureBytesBefore = ensureBytesBefore;\nfunction bytesBefore(first, last) {\n    const min = first.length < last.length ? first.length : last.length;\n    for (let i = 0; i < min; i++) {\n        if (first[i] < last[i]) {\n            return true;\n        }\n        if (first[i] > last[i]) {\n            return false;\n        }\n        // if they are equal, continue to next step\n    }\n    // if they match, ensure that last is longer than first..\n    return first.length < last.length;\n}\nexports.bytesBefore = bytesBefore;\n//# sourceMappingURL=specs.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvbmZpby9pY3MyMy9idWlsZC9zcGVjcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyx5QkFBeUIsR0FBRyxrQkFBa0IsR0FBRyx3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRyxrQkFBa0I7QUFDMUk7QUFDQTtBQUNBLDhDQUE4QyxVQUFVO0FBQ3hEO0FBQ0E7QUFDQSxrREFBa0QsZ0JBQWdCO0FBQ2xFO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQSxpREFBaUQsWUFBWTtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLDhDQUE4QyxXQUFXO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxxQkFBcUI7QUFDakU7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxVQUFVLEtBQUssU0FBUztBQUNyRTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0Esc0RBQXNELEVBQUUsSUFBSSxNQUFNLEtBQUssS0FBSztBQUM1RTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9AY29uZmlvL2ljczIzL2J1aWxkL3NwZWNzLmpzP2FkN2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJ5dGVzQmVmb3JlID0gZXhwb3J0cy5lbnN1cmVCeXRlc0JlZm9yZSA9IGV4cG9ydHMuYnl0ZXNFcXVhbCA9IGV4cG9ydHMuZW5zdXJlQnl0ZXNFcXVhbCA9IGV4cG9ydHMuZW5zdXJlSW5uZXIgPSBleHBvcnRzLmVuc3VyZUxlYWYgPSB2b2lkIDA7XG5mdW5jdGlvbiBlbnN1cmVMZWFmKGxlYWYsIHNwZWMpIHtcbiAgICBpZiAobGVhZi5oYXNoICE9PSBzcGVjLmhhc2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGhhc2hPcDogJHtsZWFmLmhhc2h9YCk7XG4gICAgfVxuICAgIGlmIChsZWFmLnByZWhhc2hLZXkgIT09IHNwZWMucHJlaGFzaEtleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgcHJlaGFzaEtleTogJHtsZWFmLnByZWhhc2hLZXl9YCk7XG4gICAgfVxuICAgIGlmIChsZWFmLnByZWhhc2hWYWx1ZSAhPT0gc3BlYy5wcmVoYXNoVmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHByZWhhc2hWYWx1ZTogJHtsZWFmLnByZWhhc2hWYWx1ZX1gKTtcbiAgICB9XG4gICAgaWYgKGxlYWYubGVuZ3RoICE9PSBzcGVjLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgbGVuZ3RoIG9wOiAke2xlYWYubGVuZ3RofWApO1xuICAgIH1cbiAgICBlbnN1cmVQcmVmaXgobGVhZi5wcmVmaXgsIHNwZWMucHJlZml4KTtcbn1cbmV4cG9ydHMuZW5zdXJlTGVhZiA9IGVuc3VyZUxlYWY7XG5mdW5jdGlvbiBlbnN1cmVJbm5lcihpbm5lciwgcHJlZml4LCBzcGVjKSB7XG4gICAgaWYgKGlubmVyLmhhc2ggIT09IHNwZWMuaGFzaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaGFzaE9wOiAke2lubmVyLmhhc2h9YCk7XG4gICAgfVxuICAgIGlmICghaW5uZXIucHJlZml4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHByZWZpeCBzZXQgZm9yIGlubmVyIG5vZGVcIik7XG4gICAgfVxuICAgIGlmIChoYXNQcmVmaXgoaW5uZXIucHJlZml4LCBwcmVmaXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5uZXIgbm9kZSBoYXMgbGVhZiBwcmVmaXhgKTtcbiAgICB9XG4gICAgaWYgKGlubmVyLnByZWZpeC5sZW5ndGggPCAoc3BlYy5taW5QcmVmaXhMZW5ndGggfHwgMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcmVmaXggdG9vIHNob3J0OiAke2lubmVyLnByZWZpeC5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgfVxuICAgIGNvbnN0IG1heExlZnRDaGlsZEJ5dGVzID0gKHNwZWMuY2hpbGRPcmRlci5sZW5ndGggLSAxKSAqIHNwZWMuY2hpbGRTaXplO1xuICAgIGlmIChpbm5lci5wcmVmaXgubGVuZ3RoID4gKHNwZWMubWF4UHJlZml4TGVuZ3RoIHx8IDApICsgbWF4TGVmdENoaWxkQnl0ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcmVmaXggdG9vIGxvbmc6ICR7aW5uZXIucHJlZml4Lmxlbmd0aH0gYnl0ZXNgKTtcbiAgICB9XG59XG5leHBvcnRzLmVuc3VyZUlubmVyID0gZW5zdXJlSW5uZXI7XG5mdW5jdGlvbiBlbnN1cmVQcmVmaXgoY2hlY2ssIHByZWZpeCkge1xuICAgIC8vIG5vIHByZWZpeCBzdXBwbGllZCwgbWVhbnMgZXZlcnl0aGluZyBwYXNzZXNcbiAgICBpZiAoIXByZWZpeCB8fCBwcmVmaXgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjaGVjaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRhcmdldCBieXRlcyBtaXNzaW5nYCk7XG4gICAgfVxuICAgIGVuc3VyZUJ5dGVzRXF1YWwocHJlZml4LCBjaGVjay5zbGljZSgwLCBwcmVmaXgubGVuZ3RoKSk7XG59XG4vLyBlbnN1cmVCeXRlc0VxdWFsIHRocm93cyBhbiBlcnJvciBpZiB0aGUgYXJyYXlzIGFyZSBkaWZmZXJlbnRcbmZ1bmN0aW9uIGVuc3VyZUJ5dGVzRXF1YWwoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaWZmZXJlbnQgbGVuZ3RocyAke2EubGVuZ3RofSB2cyAke2IubGVuZ3RofWApO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXJyYXlzIGRpZmZlciBhdCBpbmRleCAke2l9OiAke2FbaV19IHZzICR7YltpXX1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZW5zdXJlQnl0ZXNFcXVhbCA9IGVuc3VyZUJ5dGVzRXF1YWw7XG5mdW5jdGlvbiBieXRlc0VxdWFsKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmJ5dGVzRXF1YWwgPSBieXRlc0VxdWFsO1xuZnVuY3Rpb24gaGFzUHJlZml4KGNoZWNrLCBwcmVmaXgpIHtcbiAgICAvLyBubyBwcmVmaXggc3VwcGxpZWQsIG1lYW5zIGV2ZXJ5dGhpbmcgcGFzc2VzXG4gICAgaWYgKCFwcmVmaXggfHwgcHJlZml4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY2hlY2subGVuZ3RoIDw9IHByZWZpeC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWZpeC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY2hlY2tbaV0gIT09IHByZWZpeFtpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IHRydWU7XG59XG4vLyBlbnN1cmVCeXRlc0JlZm9yZSB0aHJvd3MgYW4gZXJyb3IgaWYgZmlyc3QgPj0gbGFzdFxuLy8gd2UgY29tcGFyZSBieXRlIGJ5IGJ5dGVcbmZ1bmN0aW9uIGVuc3VyZUJ5dGVzQmVmb3JlKGZpcnN0LCBsYXN0KSB7XG4gICAgaWYgKCFieXRlc0JlZm9yZShmaXJzdCwgbGFzdCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmlyc3QgaXMgYWZ0ZXIgbGFzdFwiKTtcbiAgICB9XG59XG5leHBvcnRzLmVuc3VyZUJ5dGVzQmVmb3JlID0gZW5zdXJlQnl0ZXNCZWZvcmU7XG5mdW5jdGlvbiBieXRlc0JlZm9yZShmaXJzdCwgbGFzdCkge1xuICAgIGNvbnN0IG1pbiA9IGZpcnN0Lmxlbmd0aCA8IGxhc3QubGVuZ3RoID8gZmlyc3QubGVuZ3RoIDogbGFzdC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaW47IGkrKykge1xuICAgICAgICBpZiAoZmlyc3RbaV0gPCBsYXN0W2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3RbaV0gPiBsYXN0W2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhleSBhcmUgZXF1YWwsIGNvbnRpbnVlIHRvIG5leHQgc3RlcFxuICAgIH1cbiAgICAvLyBpZiB0aGV5IG1hdGNoLCBlbnN1cmUgdGhhdCBsYXN0IGlzIGxvbmdlciB0aGFuIGZpcnN0Li5cbiAgICByZXR1cm4gZmlyc3QubGVuZ3RoIDwgbGFzdC5sZW5ndGg7XG59XG5leHBvcnRzLmJ5dGVzQmVmb3JlID0gYnl0ZXNCZWZvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcGVjcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@confio/ics23/build/specs.js\n");

/***/ })

};
;