"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@keplr-wallet";
exports.ids = ["vendor-chunks/@keplr-wallet"];
exports.modules = {

/***/ "(ssr)/./node_modules/@keplr-wallet/common/build/denom/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@keplr-wallet/common/build/denom/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DenomHelper = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\nconst crypto_1 = __webpack_require__(/*! @keplr-wallet/crypto */ \"(ssr)/./node_modules/@keplr-wallet/crypto/build/index.js\");\nclass DenomHelper {\n    static ibcDenom(paths, coinMinimalDenom) {\n        const prefixes = [];\n        for (const path of paths) {\n            prefixes.push(`${path.portId}/${path.channelId}`);\n        }\n        const prefix = prefixes.join(\"/\");\n        const denom = `${prefix}/${coinMinimalDenom}`;\n        return (\"ibc/\" +\n            buffer_1.Buffer.from(crypto_1.Hash.sha256(buffer_1.Buffer.from(denom)))\n                .toString(\"hex\")\n                .toUpperCase());\n    }\n    constructor(_denom) {\n        this._denom = _denom;\n        // Remember that the coin's actual denom should start with \"type:contractAddress:denom\" if it is for the token based on contract.\n        const split = this.denom.split(/(\\w+):(\\w+):(.+)/).filter(Boolean);\n        if (split.length !== 1 && split.length !== 3) {\n            throw new Error(`Invalid denom: ${this.denom}`);\n        }\n        this._type = split.length === 3 ? split[0] : \"\";\n        this._contractAddress = split.length === 3 ? split[1] : \"\";\n    }\n    get denom() {\n        return this._denom;\n    }\n    get type() {\n        return this._type || \"native\";\n    }\n    get contractAddress() {\n        return this._contractAddress;\n    }\n}\nexports.DenomHelper = DenomHelper;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQvZGVub20vaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CLGlCQUFpQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2xDLGlCQUFpQixtQkFBTyxDQUFDLHNGQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixZQUFZLEdBQUcsZUFBZTtBQUMzRDtBQUNBO0FBQ0EseUJBQXlCLE9BQU8sR0FBRyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsV0FBVztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQvZGVub20vaW5kZXguanM/ZmIxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVub21IZWxwZXIgPSB2b2lkIDA7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiQGtlcGxyLXdhbGxldC9jcnlwdG9cIik7XG5jbGFzcyBEZW5vbUhlbHBlciB7XG4gICAgc3RhdGljIGliY0Rlbm9tKHBhdGhzLCBjb2luTWluaW1hbERlbm9tKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeGVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgICAgICAgcHJlZml4ZXMucHVzaChgJHtwYXRoLnBvcnRJZH0vJHtwYXRoLmNoYW5uZWxJZH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVmaXggPSBwcmVmaXhlcy5qb2luKFwiL1wiKTtcbiAgICAgICAgY29uc3QgZGVub20gPSBgJHtwcmVmaXh9LyR7Y29pbk1pbmltYWxEZW5vbX1gO1xuICAgICAgICByZXR1cm4gKFwiaWJjL1wiICtcbiAgICAgICAgICAgIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGNyeXB0b18xLkhhc2guc2hhMjU2KGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGRlbm9tKSkpXG4gICAgICAgICAgICAgICAgLnRvU3RyaW5nKFwiaGV4XCIpXG4gICAgICAgICAgICAgICAgLnRvVXBwZXJDYXNlKCkpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihfZGVub20pIHtcbiAgICAgICAgdGhpcy5fZGVub20gPSBfZGVub207XG4gICAgICAgIC8vIFJlbWVtYmVyIHRoYXQgdGhlIGNvaW4ncyBhY3R1YWwgZGVub20gc2hvdWxkIHN0YXJ0IHdpdGggXCJ0eXBlOmNvbnRyYWN0QWRkcmVzczpkZW5vbVwiIGlmIGl0IGlzIGZvciB0aGUgdG9rZW4gYmFzZWQgb24gY29udHJhY3QuXG4gICAgICAgIGNvbnN0IHNwbGl0ID0gdGhpcy5kZW5vbS5zcGxpdCgvKFxcdyspOihcXHcrKTooLispLykuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgICBpZiAoc3BsaXQubGVuZ3RoICE9PSAxICYmIHNwbGl0Lmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRlbm9tOiAke3RoaXMuZGVub219YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHlwZSA9IHNwbGl0Lmxlbmd0aCA9PT0gMyA/IHNwbGl0WzBdIDogXCJcIjtcbiAgICAgICAgdGhpcy5fY29udHJhY3RBZGRyZXNzID0gc3BsaXQubGVuZ3RoID09PSAzID8gc3BsaXRbMV0gOiBcIlwiO1xuICAgIH1cbiAgICBnZXQgZGVub20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZW5vbTtcbiAgICB9XG4gICAgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlIHx8IFwibmF0aXZlXCI7XG4gICAgfVxuICAgIGdldCBjb250cmFjdEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250cmFjdEFkZHJlc3M7XG4gICAgfVxufVxuZXhwb3J0cy5EZW5vbUhlbHBlciA9IERlbm9tSGVscGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/common/build/denom/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/common/build/escape/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@keplr-wallet/common/build/escape/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unescapeHTML = exports.escapeHTML = void 0;\n/**\n * Escapes <,>,& in string.\n * Golang's json marshaller escapes <,>,& by default.\n * However, because JS doesn't do that by default, to match the sign doc with cosmos-sdk,\n * we should escape <,>,& in string manually.\n * @param str\n */\nfunction escapeHTML(str) {\n    return str\n        .replace(/</g, \"\\\\u003c\")\n        .replace(/>/g, \"\\\\u003e\")\n        .replace(/&/g, \"\\\\u0026\");\n}\nexports.escapeHTML = escapeHTML;\n/**\n * Unescapes \\u003c/(<),\\u003e(>),\\u0026(&) in string.\n * Golang's json marshaller escapes <,>,& by default, whilst for most of the users, such escape characters are unfamiliar.\n * This function can be used to show the escaped characters with more familiar characters.\n * @param str\n */\nfunction unescapeHTML(str) {\n    return str\n        .replace(/\\\\u003c/g, \"<\")\n        .replace(/\\\\u003e/g, \">\")\n        .replace(/\\\\u0026/g, \"&\");\n}\nexports.unescapeHTML = unescapeHTML;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQvZXNjYXBlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L2NvbW1vbi9idWlsZC9lc2NhcGUvaW5kZXguanM/MmFiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudW5lc2NhcGVIVE1MID0gZXhwb3J0cy5lc2NhcGVIVE1MID0gdm9pZCAwO1xuLyoqXG4gKiBFc2NhcGVzIDwsPiwmIGluIHN0cmluZy5cbiAqIEdvbGFuZydzIGpzb24gbWFyc2hhbGxlciBlc2NhcGVzIDwsPiwmIGJ5IGRlZmF1bHQuXG4gKiBIb3dldmVyLCBiZWNhdXNlIEpTIGRvZXNuJ3QgZG8gdGhhdCBieSBkZWZhdWx0LCB0byBtYXRjaCB0aGUgc2lnbiBkb2Mgd2l0aCBjb3Ntb3Mtc2RrLFxuICogd2Ugc2hvdWxkIGVzY2FwZSA8LD4sJiBpbiBzdHJpbmcgbWFudWFsbHkuXG4gKiBAcGFyYW0gc3RyXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUhUTUwoc3RyKSB7XG4gICAgcmV0dXJuIHN0clxuICAgICAgICAucmVwbGFjZSgvPC9nLCBcIlxcXFx1MDAzY1wiKVxuICAgICAgICAucmVwbGFjZSgvPi9nLCBcIlxcXFx1MDAzZVwiKVxuICAgICAgICAucmVwbGFjZSgvJi9nLCBcIlxcXFx1MDAyNlwiKTtcbn1cbmV4cG9ydHMuZXNjYXBlSFRNTCA9IGVzY2FwZUhUTUw7XG4vKipcbiAqIFVuZXNjYXBlcyBcXHUwMDNjLyg8KSxcXHUwMDNlKD4pLFxcdTAwMjYoJikgaW4gc3RyaW5nLlxuICogR29sYW5nJ3MganNvbiBtYXJzaGFsbGVyIGVzY2FwZXMgPCw+LCYgYnkgZGVmYXVsdCwgd2hpbHN0IGZvciBtb3N0IG9mIHRoZSB1c2Vycywgc3VjaCBlc2NhcGUgY2hhcmFjdGVycyBhcmUgdW5mYW1pbGlhci5cbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gc2hvdyB0aGUgZXNjYXBlZCBjaGFyYWN0ZXJzIHdpdGggbW9yZSBmYW1pbGlhciBjaGFyYWN0ZXJzLlxuICogQHBhcmFtIHN0clxuICovXG5mdW5jdGlvbiB1bmVzY2FwZUhUTUwoc3RyKSB7XG4gICAgcmV0dXJuIHN0clxuICAgICAgICAucmVwbGFjZSgvXFxcXHUwMDNjL2csIFwiPFwiKVxuICAgICAgICAucmVwbGFjZSgvXFxcXHUwMDNlL2csIFwiPlwiKVxuICAgICAgICAucmVwbGFjZSgvXFxcXHUwMDI2L2csIFwiJlwiKTtcbn1cbmV4cG9ydHMudW5lc2NhcGVIVE1MID0gdW5lc2NhcGVIVE1MO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/common/build/escape/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/common/build/icns/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@keplr-wallet/common/build/icns/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateICNSName = exports.parseICNSName = void 0;\nfunction parseICNSName(name) {\n    const split = name.split(\".\");\n    if (split.length === 2) {\n        if (split[0].length > 0 && split[1].length > 0) {\n            return [split[0], split[1]];\n        }\n    }\n    return undefined;\n}\nexports.parseICNSName = parseICNSName;\nfunction validateICNSName(name, bech32Prefix) {\n    const parsed = parseICNSName(name);\n    if (!parsed) {\n        return false;\n    }\n    return parsed[1] === bech32Prefix;\n}\nexports.validateICNSName = validateICNSName;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQvaWNucy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyxxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQvaWNucy9pbmRleC5qcz8wNzhhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZUlDTlNOYW1lID0gZXhwb3J0cy5wYXJzZUlDTlNOYW1lID0gdm9pZCAwO1xuZnVuY3Rpb24gcGFyc2VJQ05TTmFtZShuYW1lKSB7XG4gICAgY29uc3Qgc3BsaXQgPSBuYW1lLnNwbGl0KFwiLlwiKTtcbiAgICBpZiAoc3BsaXQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGlmIChzcGxpdFswXS5sZW5ndGggPiAwICYmIHNwbGl0WzFdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbc3BsaXRbMF0sIHNwbGl0WzFdXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5wYXJzZUlDTlNOYW1lID0gcGFyc2VJQ05TTmFtZTtcbmZ1bmN0aW9uIHZhbGlkYXRlSUNOU05hbWUobmFtZSwgYmVjaDMyUHJlZml4KSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VJQ05TTmFtZShuYW1lKTtcbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWRbMV0gPT09IGJlY2gzMlByZWZpeDtcbn1cbmV4cG9ydHMudmFsaWRhdGVJQ05TTmFtZSA9IHZhbGlkYXRlSUNOU05hbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/common/build/icns/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/common/build/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@keplr-wallet/common/build/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./kv-store */ \"(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./denom */ \"(ssr)/./node_modules/@keplr-wallet/common/build/denom/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./mobx */ \"(ssr)/./node_modules/@keplr-wallet/common/build/mobx/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@keplr-wallet/common/build/utils/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./escape */ \"(ssr)/./node_modules/@keplr-wallet/common/build/escape/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./json */ \"(ssr)/./node_modules/@keplr-wallet/common/build/json/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./icns */ \"(ssr)/./node_modules/@keplr-wallet/common/build/icns/index.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLHFGQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQywrRUFBUztBQUM5QixhQUFhLG1CQUFPLENBQUMsNkVBQVE7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLCtFQUFTO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyxpRkFBVTtBQUMvQixhQUFhLG1CQUFPLENBQUMsNkVBQVE7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLDZFQUFRO0FBQzdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQvaW5kZXguanM/Yzg1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2t2LXN0b3JlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9kZW5vbVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9ieFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2VzY2FwZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vanNvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaWNuc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/common/build/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/common/build/json/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@keplr-wallet/common/build/json/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./sort */ \"(ssr)/./node_modules/@keplr-wallet/common/build/json/sort.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQvanNvbi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsNEVBQVE7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L2NvbW1vbi9idWlsZC9qc29uL2luZGV4LmpzPzg0MGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zb3J0XCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/common/build/json/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/common/build/json/sort.js":
/*!**************************************************************!*\
  !*** ./node_modules/@keplr-wallet/common/build/json/sort.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sortedJsonByKeyStringify = exports.sortObjectByKey = void 0;\nfunction sortObjectByKey(obj) {\n    if (typeof obj !== \"object\" || obj === null) {\n        return obj;\n    }\n    if (Array.isArray(obj)) {\n        return obj.map(sortObjectByKey);\n    }\n    const sortedKeys = Object.keys(obj).sort();\n    const result = {};\n    sortedKeys.forEach((key) => {\n        result[key] = sortObjectByKey(obj[key]);\n    });\n    return result;\n}\nexports.sortObjectByKey = sortObjectByKey;\nfunction sortedJsonByKeyStringify(obj) {\n    return JSON.stringify(sortObjectByKey(obj));\n}\nexports.sortedJsonByKeyStringify = sortedJsonByKeyStringify;\n//# sourceMappingURL=sort.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQvanNvbi9zb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQyxHQUFHLHVCQUF1QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQvanNvbi9zb3J0LmpzPzcxN2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNvcnRlZEpzb25CeUtleVN0cmluZ2lmeSA9IGV4cG9ydHMuc29ydE9iamVjdEJ5S2V5ID0gdm9pZCAwO1xuZnVuY3Rpb24gc29ydE9iamVjdEJ5S2V5KG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHJldHVybiBvYmoubWFwKHNvcnRPYmplY3RCeUtleSk7XG4gICAgfVxuICAgIGNvbnN0IHNvcnRlZEtleXMgPSBPYmplY3Qua2V5cyhvYmopLnNvcnQoKTtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBzb3J0ZWRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICByZXN1bHRba2V5XSA9IHNvcnRPYmplY3RCeUtleShvYmpba2V5XSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuc29ydE9iamVjdEJ5S2V5ID0gc29ydE9iamVjdEJ5S2V5O1xuZnVuY3Rpb24gc29ydGVkSnNvbkJ5S2V5U3RyaW5naWZ5KG9iaikge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzb3J0T2JqZWN0QnlLZXkob2JqKSk7XG59XG5leHBvcnRzLnNvcnRlZEpzb25CeUtleVN0cmluZ2lmeSA9IHNvcnRlZEpzb25CeUtleVN0cmluZ2lmeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvcnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/common/build/json/sort.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/base.js":
/*!******************************************************************!*\
  !*** ./node_modules/@keplr-wallet/common/build/kv-store/base.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseKVStore = void 0;\nclass BaseKVStore {\n    constructor(provider, _prefix) {\n        this.provider = provider;\n        this._prefix = _prefix;\n    }\n    get(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const k = this.prefix() + \"/\" + key;\n            const data = yield this.provider.get();\n            return data[k];\n        });\n    }\n    set(key, data) {\n        const k = this.prefix() + \"/\" + key;\n        return this.provider.set({ [k]: data });\n    }\n    prefix() {\n        return this._prefix;\n    }\n}\nexports.BaseKVStore = BaseKVStore;\n//# sourceMappingURL=base.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQva3Ytc3RvcmUvYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxXQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L2NvbW1vbi9idWlsZC9rdi1zdG9yZS9iYXNlLmpzPzIyYmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZUtWU3RvcmUgPSB2b2lkIDA7XG5jbGFzcyBCYXNlS1ZTdG9yZSB7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIF9wcmVmaXgpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLl9wcmVmaXggPSBfcHJlZml4O1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBrID0gdGhpcy5wcmVmaXgoKSArIFwiL1wiICsga2V5O1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHRoaXMucHJvdmlkZXIuZ2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVtrXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldChrZXksIGRhdGEpIHtcbiAgICAgICAgY29uc3QgayA9IHRoaXMucHJlZml4KCkgKyBcIi9cIiArIGtleTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2V0KHsgW2tdOiBkYXRhIH0pO1xuICAgIH1cbiAgICBwcmVmaXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmVmaXg7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlS1ZTdG9yZSA9IEJhc2VLVlN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/extension.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@keplr-wallet/common/build/kv-store/extension.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ExtensionKVStore = void 0;\nconst base_1 = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/base.js\");\nclass ExtensionKVStore extends base_1.BaseKVStore {\n    constructor(prefix) {\n        if (!ExtensionKVStore.KVStoreProvider) {\n            if (typeof browser === \"undefined\") {\n                console.log(\"You should use ExtensionKVStore on the extension environment.\");\n            }\n            else if (!browser.storage || !browser.storage.local) {\n                console.log(\"The 'browser' exists, but it doesn't seem to be an extension environment. This can happen in Safari browser.\");\n            }\n            else {\n                ExtensionKVStore.KVStoreProvider = {\n                    get: browser.storage.local.get,\n                    set: browser.storage.local.set,\n                    multiGet: browser.storage.local.get,\n                };\n            }\n        }\n        if (!ExtensionKVStore.KVStoreProvider) {\n            throw new Error(\"Can't initialize kv store for browser extension\");\n        }\n        super(ExtensionKVStore.KVStoreProvider, prefix);\n    }\n    multiGet(keys) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            // Remove duplications\n            keys = Array.from(new Set(keys));\n            const res = (_a = (yield ExtensionKVStore.KVStoreProvider.multiGet(keys.map((k) => this.prefix() + \"/\" + k)))) !== null && _a !== void 0 ? _a : {};\n            const prefixedKeys = Object.keys(res);\n            for (const prefixedKey of prefixedKeys) {\n                const key = prefixedKey.slice(this.prefix().length + 1);\n                res[key] = res[prefixedKey];\n                delete res[prefixedKey];\n            }\n            return res;\n        });\n    }\n}\nexports.ExtensionKVStore = ExtensionKVStore;\n//# sourceMappingURL=extension.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQva3Ytc3RvcmUvZXh0ZW5zaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsZUFBZSxtQkFBTyxDQUFDLGdGQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvY29tbW9uL2J1aWxkL2t2LXN0b3JlL2V4dGVuc2lvbi5qcz9mYWEzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV4dGVuc2lvbktWU3RvcmUgPSB2b2lkIDA7XG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi9iYXNlXCIpO1xuY2xhc3MgRXh0ZW5zaW9uS1ZTdG9yZSBleHRlbmRzIGJhc2VfMS5CYXNlS1ZTdG9yZSB7XG4gICAgY29uc3RydWN0b3IocHJlZml4KSB7XG4gICAgICAgIGlmICghRXh0ZW5zaW9uS1ZTdG9yZS5LVlN0b3JlUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYnJvd3NlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiWW91IHNob3VsZCB1c2UgRXh0ZW5zaW9uS1ZTdG9yZSBvbiB0aGUgZXh0ZW5zaW9uIGVudmlyb25tZW50LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFicm93c2VyLnN0b3JhZ2UgfHwgIWJyb3dzZXIuc3RvcmFnZS5sb2NhbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVGhlICdicm93c2VyJyBleGlzdHMsIGJ1dCBpdCBkb2Vzbid0IHNlZW0gdG8gYmUgYW4gZXh0ZW5zaW9uIGVudmlyb25tZW50LiBUaGlzIGNhbiBoYXBwZW4gaW4gU2FmYXJpIGJyb3dzZXIuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgRXh0ZW5zaW9uS1ZTdG9yZS5LVlN0b3JlUHJvdmlkZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogYnJvd3Nlci5zdG9yYWdlLmxvY2FsLmdldCxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBicm93c2VyLnN0b3JhZ2UubG9jYWwuc2V0LFxuICAgICAgICAgICAgICAgICAgICBtdWx0aUdldDogYnJvd3Nlci5zdG9yYWdlLmxvY2FsLmdldCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghRXh0ZW5zaW9uS1ZTdG9yZS5LVlN0b3JlUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGluaXRpYWxpemUga3Ygc3RvcmUgZm9yIGJyb3dzZXIgZXh0ZW5zaW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKEV4dGVuc2lvbktWU3RvcmUuS1ZTdG9yZVByb3ZpZGVyLCBwcmVmaXgpO1xuICAgIH1cbiAgICBtdWx0aUdldChrZXlzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBkdXBsaWNhdGlvbnNcbiAgICAgICAgICAgIGtleXMgPSBBcnJheS5mcm9tKG5ldyBTZXQoa2V5cykpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gKF9hID0gKHlpZWxkIEV4dGVuc2lvbktWU3RvcmUuS1ZTdG9yZVByb3ZpZGVyLm11bHRpR2V0KGtleXMubWFwKChrKSA9PiB0aGlzLnByZWZpeCgpICsgXCIvXCIgKyBrKSkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeGVkS2V5cyA9IE9iamVjdC5rZXlzKHJlcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByZWZpeGVkS2V5IG9mIHByZWZpeGVkS2V5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHByZWZpeGVkS2V5LnNsaWNlKHRoaXMucHJlZml4KCkubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgICAgcmVzW2tleV0gPSByZXNbcHJlZml4ZWRLZXldO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJlZml4ZWRLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5FeHRlbnNpb25LVlN0b3JlID0gRXh0ZW5zaW9uS1ZTdG9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dGVuc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/extension.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@keplr-wallet/common/build/kv-store/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./interface */ \"(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/interface.js\"), exports);\n__exportStar(__webpack_require__(/*! ./extension */ \"(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/extension.js\"), exports);\n__exportStar(__webpack_require__(/*! ./base */ \"(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/base.js\"), exports);\n__exportStar(__webpack_require__(/*! ./memory */ \"(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/memory.js\"), exports);\n__exportStar(__webpack_require__(/*! ./local */ \"(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/local.js\"), exports);\n__exportStar(__webpack_require__(/*! ./indexed-db */ \"(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/indexed-db.js\"), exports);\n__exportStar(__webpack_require__(/*! ./prefix */ \"(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/prefix.js\"), exports);\n__exportStar(__webpack_require__(/*! ./multi-get */ \"(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/multi-get.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQva3Ytc3RvcmUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLDBGQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQywwRkFBYTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsZ0ZBQVE7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLG9GQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxrRkFBUztBQUM5QixhQUFhLG1CQUFPLENBQUMsNEZBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLG9GQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQywwRkFBYTtBQUNsQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvY29tbW9uL2J1aWxkL2t2LXN0b3JlL2luZGV4LmpzP2Y4NDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pbnRlcmZhY2VcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4dGVuc2lvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmFzZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbWVtb3J5XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9sb2NhbFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaW5kZXhlZC1kYlwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHJlZml4XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tdWx0aS1nZXRcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/indexed-db.js":
/*!************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/common/build/kv-store/indexed-db.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IndexedDBKVStore = void 0;\nclass IndexedDBKVStore {\n    constructor(_prefix) {\n        this._prefix = _prefix;\n    }\n    get(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tx = (yield this.getDB()).transaction([this.prefix()], \"readonly\");\n            const store = tx.objectStore(this.prefix());\n            return new Promise((resolve, reject) => {\n                const request = store.get(key);\n                request.onerror = (event) => {\n                    event.stopPropagation();\n                    reject(event.target);\n                };\n                request.onsuccess = () => {\n                    if (!request.result) {\n                        resolve(undefined);\n                    }\n                    else {\n                        resolve(request.result.data);\n                    }\n                };\n            });\n        });\n    }\n    set(key, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (data === null) {\n                const tx = (yield this.getDB()).transaction([this.prefix()], \"readwrite\");\n                const store = tx.objectStore(this.prefix());\n                return new Promise((resolve, reject) => {\n                    const request = store.delete(key);\n                    request.onerror = (event) => {\n                        event.stopPropagation();\n                        reject(event.target);\n                    };\n                    request.onsuccess = () => {\n                        resolve();\n                    };\n                });\n            }\n            else {\n                const tx = (yield this.getDB()).transaction([this.prefix()], \"readwrite\");\n                const store = tx.objectStore(this.prefix());\n                return new Promise((resolve, reject) => {\n                    const request = store.put({\n                        key,\n                        data,\n                    });\n                    request.onerror = (event) => {\n                        event.stopPropagation();\n                        reject(event.target);\n                    };\n                    request.onsuccess = () => {\n                        resolve();\n                    };\n                });\n            }\n        });\n    }\n    prefix() {\n        return this._prefix;\n    }\n    getDB() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.cachedDB) {\n                return this.cachedDB;\n            }\n            return new Promise((resolve, reject) => {\n                const request = window.indexedDB.open(this.prefix());\n                request.onerror = (event) => {\n                    event.stopPropagation();\n                    reject(event.target);\n                };\n                request.onupgradeneeded = (event) => {\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore\n                    const db = event.target.result;\n                    db.createObjectStore(this.prefix(), { keyPath: \"key\" });\n                };\n                request.onsuccess = () => {\n                    this.cachedDB = request.result;\n                    resolve(request.result);\n                };\n            });\n        });\n    }\n}\nexports.IndexedDBKVStore = IndexedDBKVStore;\n//# sourceMappingURL=indexed-db.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQva3Ytc3RvcmUvaW5kZXhlZC1kYi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxnQkFBZ0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvY29tbW9uL2J1aWxkL2t2LXN0b3JlL2luZGV4ZWQtZGIuanM/ODNlNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbmRleGVkREJLVlN0b3JlID0gdm9pZCAwO1xuY2xhc3MgSW5kZXhlZERCS1ZTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoX3ByZWZpeCkge1xuICAgICAgICB0aGlzLl9wcmVmaXggPSBfcHJlZml4O1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9ICh5aWVsZCB0aGlzLmdldERCKCkpLnRyYW5zYWN0aW9uKFt0aGlzLnByZWZpeCgpXSwgXCJyZWFkb25seVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gdHgub2JqZWN0U3RvcmUodGhpcy5wcmVmaXgoKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVxdWVzdC5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVxdWVzdC5yZXN1bHQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXQoa2V5LCBkYXRhKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gKHlpZWxkIHRoaXMuZ2V0REIoKSkudHJhbnNhY3Rpb24oW3RoaXMucHJlZml4KCldLCBcInJlYWR3cml0ZVwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHR4Lm9iamVjdFN0b3JlKHRoaXMucHJlZml4KCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gKHlpZWxkIHRoaXMuZ2V0REIoKSkudHJhbnNhY3Rpb24oW3RoaXMucHJlZml4KCldLCBcInJlYWR3cml0ZVwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZSA9IHR4Lm9iamVjdFN0b3JlKHRoaXMucHJlZml4KCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBzdG9yZS5wdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwcmVmaXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmVmaXg7XG4gICAgfVxuICAgIGdldERCKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGVkREIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZWREQjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHdpbmRvdy5pbmRleGVkREIub3Blbih0aGlzLnByZWZpeCgpKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRiID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUodGhpcy5wcmVmaXgoKSwgeyBrZXlQYXRoOiBcImtleVwiIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkREIgPSByZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkluZGV4ZWREQktWU3RvcmUgPSBJbmRleGVkREJLVlN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXhlZC1kYi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/indexed-db.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/interface.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@keplr-wallet/common/build/kv-store/interface.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQva3Ytc3RvcmUvaW50ZXJmYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQva3Ytc3RvcmUvaW50ZXJmYWNlLmpzPzhiMGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/interface.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/local.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@keplr-wallet/common/build/kv-store/local.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LocalKVStore = void 0;\nclass LocalKVStore {\n    constructor(_prefix) {\n        this._prefix = _prefix;\n    }\n    get(key) {\n        const k = this.prefix() + \"/\" + key;\n        const data = localStorage.getItem(k);\n        if (data === null) {\n            return Promise.resolve(undefined);\n        }\n        return Promise.resolve(JSON.parse(data));\n    }\n    set(key, data) {\n        const k = this.prefix() + \"/\" + key;\n        if (data === null) {\n            return Promise.resolve(localStorage.removeItem(k));\n        }\n        return Promise.resolve(localStorage.setItem(k, JSON.stringify(data)));\n    }\n    prefix() {\n        return this._prefix;\n    }\n}\nexports.LocalKVStore = LocalKVStore;\n//# sourceMappingURL=local.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQva3Ytc3RvcmUvbG9jYWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L2NvbW1vbi9idWlsZC9rdi1zdG9yZS9sb2NhbC5qcz9hMDJlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb2NhbEtWU3RvcmUgPSB2b2lkIDA7XG5jbGFzcyBMb2NhbEtWU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKF9wcmVmaXgpIHtcbiAgICAgICAgdGhpcy5fcHJlZml4ID0gX3ByZWZpeDtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICBjb25zdCBrID0gdGhpcy5wcmVmaXgoKSArIFwiL1wiICsga2V5O1xuICAgICAgICBjb25zdCBkYXRhID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oayk7XG4gICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShKU09OLnBhcnNlKGRhdGEpKTtcbiAgICB9XG4gICAgc2V0KGtleSwgZGF0YSkge1xuICAgICAgICBjb25zdCBrID0gdGhpcy5wcmVmaXgoKSArIFwiL1wiICsga2V5O1xuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrLCBKU09OLnN0cmluZ2lmeShkYXRhKSkpO1xuICAgIH1cbiAgICBwcmVmaXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmVmaXg7XG4gICAgfVxufVxuZXhwb3J0cy5Mb2NhbEtWU3RvcmUgPSBMb2NhbEtWU3RvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/local.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/memory.js":
/*!********************************************************************!*\
  !*** ./node_modules/@keplr-wallet/common/build/kv-store/memory.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MemoryKVStore = void 0;\nconst base_1 = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/base.js\");\nclass MemoryKVStoreProvider {\n    constructor() {\n        this.store = {};\n    }\n    get() {\n        return Promise.resolve(this.store);\n    }\n    set(items) {\n        // Generally, memory kv store is used for testing, and mocking.\n        // However, we can store non-primitive type to memory even though local storage generally can't do that.\n        // To mitigate the risk, we check the type of value to be stored if env is for testing.\n        if (typeof process !== \"undefined\" &&\n            ( false ||\n                \"development\" === \"development\")) {\n            this.checkNotPrimitiveField(items);\n        }\n        this.store = Object.assign(Object.assign({}, this.store), items);\n        return Promise.resolve();\n    }\n    checkNotPrimitiveField(items) {\n        Object.keys(items).forEach((key) => {\n            const value = items[key];\n            if (value != null && typeof value === \"object\") {\n                if (value.constructor !== Object && value.constructor !== Array) {\n                    throw new Error(`${key} may not be serializable: ${value.constructor.name}`);\n                }\n                this.checkNotPrimitiveField(value);\n            }\n        });\n    }\n}\nclass MemoryKVStore extends base_1.BaseKVStore {\n    constructor(prefix) {\n        super(new MemoryKVStoreProvider(), prefix);\n    }\n}\nexports.MemoryKVStore = MemoryKVStore;\n//# sourceMappingURL=memory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQva3Ytc3RvcmUvbWVtb3J5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixlQUFlLG1CQUFPLENBQUMsZ0ZBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFrQztBQUMvQyxnQkFBZ0IsYUFBdUI7QUFDdkM7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxLQUFLLDJCQUEyQix1QkFBdUI7QUFDOUY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQva3Ytc3RvcmUvbWVtb3J5LmpzPzE5ZGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lbW9yeUtWU3RvcmUgPSB2b2lkIDA7XG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi9iYXNlXCIpO1xuY2xhc3MgTWVtb3J5S1ZTdG9yZVByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdG9yZSA9IHt9O1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5zdG9yZSk7XG4gICAgfVxuICAgIHNldChpdGVtcykge1xuICAgICAgICAvLyBHZW5lcmFsbHksIG1lbW9yeSBrdiBzdG9yZSBpcyB1c2VkIGZvciB0ZXN0aW5nLCBhbmQgbW9ja2luZy5cbiAgICAgICAgLy8gSG93ZXZlciwgd2UgY2FuIHN0b3JlIG5vbi1wcmltaXRpdmUgdHlwZSB0byBtZW1vcnkgZXZlbiB0aG91Z2ggbG9jYWwgc3RvcmFnZSBnZW5lcmFsbHkgY2FuJ3QgZG8gdGhhdC5cbiAgICAgICAgLy8gVG8gbWl0aWdhdGUgdGhlIHJpc2ssIHdlIGNoZWNrIHRoZSB0eXBlIG9mIHZhbHVlIHRvIGJlIHN0b3JlZCBpZiBlbnYgaXMgZm9yIHRlc3RpbmcuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgKHByb2Nlc3MuZW52W1wiTk9ERV9FTlZcIl0gPT09IFwidGVzdFwiIHx8XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnZbXCJOT0RFX0VOVlwiXSA9PT0gXCJkZXZlbG9wbWVudFwiKSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja05vdFByaW1pdGl2ZUZpZWxkKGl0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3JlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0b3JlKSwgaXRlbXMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGNoZWNrTm90UHJpbWl0aXZlRmllbGQoaXRlbXMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoaXRlbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpdGVtc1trZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmNvbnN0cnVjdG9yICE9PSBPYmplY3QgJiYgdmFsdWUuY29uc3RydWN0b3IgIT09IEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtrZXl9IG1heSBub3QgYmUgc2VyaWFsaXphYmxlOiAke3ZhbHVlLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tOb3RQcmltaXRpdmVGaWVsZCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIE1lbW9yeUtWU3RvcmUgZXh0ZW5kcyBiYXNlXzEuQmFzZUtWU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKHByZWZpeCkge1xuICAgICAgICBzdXBlcihuZXcgTWVtb3J5S1ZTdG9yZVByb3ZpZGVyKCksIHByZWZpeCk7XG4gICAgfVxufVxuZXhwb3J0cy5NZW1vcnlLVlN0b3JlID0gTWVtb3J5S1ZTdG9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lbW9yeS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/memory.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/multi-get.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@keplr-wallet/common/build/kv-store/multi-get.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WrapMultiGetKVStore = void 0;\nclass WrapMultiGetKVStore {\n    constructor(kvStore) {\n        this.kvStore = kvStore;\n    }\n    multiGet(keys) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Remove duplications\n            keys = Array.from(new Set(keys));\n            const res = {};\n            const promises = [];\n            for (const key of keys) {\n                promises.push((() => __awaiter(this, void 0, void 0, function* () {\n                    res[key] = yield this.kvStore.get(key);\n                }))());\n            }\n            yield Promise.all(promises);\n            return res;\n        });\n    }\n}\nexports.WrapMultiGetKVStore = WrapMultiGetKVStore;\n//# sourceMappingURL=multi-get.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQva3Ytc3RvcmUvbXVsdGktZ2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L2NvbW1vbi9idWlsZC9rdi1zdG9yZS9tdWx0aS1nZXQuanM/MWFhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XcmFwTXVsdGlHZXRLVlN0b3JlID0gdm9pZCAwO1xuY2xhc3MgV3JhcE11bHRpR2V0S1ZTdG9yZSB7XG4gICAgY29uc3RydWN0b3Ioa3ZTdG9yZSkge1xuICAgICAgICB0aGlzLmt2U3RvcmUgPSBrdlN0b3JlO1xuICAgIH1cbiAgICBtdWx0aUdldChrZXlzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgZHVwbGljYXRpb25zXG4gICAgICAgICAgICBrZXlzID0gQXJyYXkuZnJvbShuZXcgU2V0KGtleXMpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0geWllbGQgdGhpcy5rdlN0b3JlLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIH0pKSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuV3JhcE11bHRpR2V0S1ZTdG9yZSA9IFdyYXBNdWx0aUdldEtWU3RvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aS1nZXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/multi-get.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/prefix.js":
/*!********************************************************************!*\
  !*** ./node_modules/@keplr-wallet/common/build/kv-store/prefix.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PrefixKVStore = void 0;\nclass PrefixKVStore {\n    constructor(kvStore, _prefix) {\n        this.kvStore = kvStore;\n        this._prefix = _prefix;\n    }\n    prefix() {\n        return this._prefix;\n    }\n    get(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const k = this.prefix() + \"/\" + key;\n            return yield this.kvStore.get(k);\n        });\n    }\n    set(key, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const k = this.prefix() + \"/\" + key;\n            return yield this.kvStore.set(k, data);\n        });\n    }\n}\nexports.PrefixKVStore = PrefixKVStore;\n//# sourceMappingURL=prefix.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQva3Ytc3RvcmUvcHJlZml4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvY29tbW9uL2J1aWxkL2t2LXN0b3JlL3ByZWZpeC5qcz9kN2E1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByZWZpeEtWU3RvcmUgPSB2b2lkIDA7XG5jbGFzcyBQcmVmaXhLVlN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihrdlN0b3JlLCBfcHJlZml4KSB7XG4gICAgICAgIHRoaXMua3ZTdG9yZSA9IGt2U3RvcmU7XG4gICAgICAgIHRoaXMuX3ByZWZpeCA9IF9wcmVmaXg7XG4gICAgfVxuICAgIHByZWZpeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZWZpeDtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgayA9IHRoaXMucHJlZml4KCkgKyBcIi9cIiArIGtleTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmt2U3RvcmUuZ2V0KGspO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0KGtleSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgayA9IHRoaXMucHJlZml4KCkgKyBcIi9cIiArIGtleTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmt2U3RvcmUuc2V0KGssIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlByZWZpeEtWU3RvcmUgPSBQcmVmaXhLVlN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlZml4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/common/build/kv-store/prefix.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/common/build/mobx/debounce.js":
/*!******************************************************************!*\
  !*** ./node_modules/@keplr-wallet/common/build/mobx/debounce.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DebounceActionTimer = void 0;\nconst mobx_1 = __webpack_require__(/*! mobx */ \"(ssr)/./node_modules/mobx/dist/mobx.esm.js\");\nclass DebounceActionTimer {\n    constructor(debounceMs, handler) {\n        this.debounceMs = debounceMs;\n        this.handler = handler;\n        this.requests = [];\n        this.startTime = 0;\n        this.tick = () => {\n            let shouldExec = this.debounceMs <= 0;\n            if (this.debounceMs > 0) {\n                const now = Date.now();\n                if (now - this.startTime >= this.debounceMs) {\n                    shouldExec = true;\n                }\n            }\n            if (shouldExec) {\n                // Should use sliced (copied) array\n                const requests = this.requests.slice();\n                const responses = this.handler(requests);\n                if (typeof responses === \"object\" && \"then\" in responses) {\n                    Promise.resolve(responses).then((responses) => {\n                        this.handleResponses(requests, responses);\n                    });\n                }\n                else {\n                    this.handleResponses(requests, responses);\n                }\n                this.requests = [];\n            }\n            else {\n                this.nextTick(this.tick);\n            }\n        };\n        this.handleResponses = (requests, responses) => {\n            (0, mobx_1.runInAction)(() => {\n                for (let i = 0; i < requests.length; i++) {\n                    const req = requests[i];\n                    const res = responses[i];\n                    req.action(res);\n                }\n            });\n            for (const req of requests) {\n                req.resolver();\n            }\n        };\n    }\n    call(args, action) {\n        return new Promise((resolve) => {\n            const newStart = this.requests.length === 0;\n            this.requests.push({ args, action, resolver: resolve });\n            if (newStart) {\n                this.startTimer();\n            }\n        });\n    }\n    startTimer() {\n        this.startTime = Date.now();\n        this.nextTick(this.tick);\n    }\n    nextTick(fn) {\n        if (this.debounceMs <= 0) {\n            Promise.resolve().then(fn);\n            return;\n        }\n        if (typeof window !== \"undefined\" && window.requestAnimationFrame) {\n            window.requestAnimationFrame(fn);\n        }\n        else {\n            setTimeout(fn, this.debounceMs);\n        }\n    }\n}\nexports.DebounceActionTimer = DebounceActionTimer;\n//# sourceMappingURL=debounce.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQvbW9ieC9kZWJvdW5jZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0IsZUFBZSxtQkFBTyxDQUFDLHdEQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaUNBQWlDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L2NvbW1vbi9idWlsZC9tb2J4L2RlYm91bmNlLmpzPzc1NTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlYm91bmNlQWN0aW9uVGltZXIgPSB2b2lkIDA7XG5jb25zdCBtb2J4XzEgPSByZXF1aXJlKFwibW9ieFwiKTtcbmNsYXNzIERlYm91bmNlQWN0aW9uVGltZXIge1xuICAgIGNvbnN0cnVjdG9yKGRlYm91bmNlTXMsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5kZWJvdW5jZU1zID0gZGVib3VuY2VNcztcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgdGhpcy5yZXF1ZXN0cyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IDA7XG4gICAgICAgIHRoaXMudGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCBzaG91bGRFeGVjID0gdGhpcy5kZWJvdW5jZU1zIDw9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWJvdW5jZU1zID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vdyAtIHRoaXMuc3RhcnRUaW1lID49IHRoaXMuZGVib3VuY2VNcykge1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRFeGVjID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkRXhlYykge1xuICAgICAgICAgICAgICAgIC8vIFNob3VsZCB1c2Ugc2xpY2VkIChjb3BpZWQpIGFycmF5XG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdHMgPSB0aGlzLnJlcXVlc3RzLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VzID0gdGhpcy5oYW5kbGVyKHJlcXVlc3RzKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3BvbnNlcyA9PT0gXCJvYmplY3RcIiAmJiBcInRoZW5cIiBpbiByZXNwb25zZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlcykudGhlbigocmVzcG9uc2VzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc3BvbnNlcyhyZXF1ZXN0cywgcmVzcG9uc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc3BvbnNlcyhyZXF1ZXN0cywgcmVzcG9uc2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0VGljayh0aGlzLnRpY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJlc3BvbnNlcyA9IChyZXF1ZXN0cywgcmVzcG9uc2VzKSA9PiB7XG4gICAgICAgICAgICAoMCwgbW9ieF8xLnJ1bkluQWN0aW9uKSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXEgPSByZXF1ZXN0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gcmVzcG9uc2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICByZXEuYWN0aW9uKHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlcSBvZiByZXF1ZXN0cykge1xuICAgICAgICAgICAgICAgIHJlcS5yZXNvbHZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjYWxsKGFyZ3MsIGFjdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gdGhpcy5yZXF1ZXN0cy5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RzLnB1c2goeyBhcmdzLCBhY3Rpb24sIHJlc29sdmVyOiByZXNvbHZlIH0pO1xuICAgICAgICAgICAgaWYgKG5ld1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFRpbWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGFydFRpbWVyKCkge1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMubmV4dFRpY2sodGhpcy50aWNrKTtcbiAgICB9XG4gICAgbmV4dFRpY2soZm4pIHtcbiAgICAgICAgaWYgKHRoaXMuZGVib3VuY2VNcyA8PSAwKSB7XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZuKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZm4sIHRoaXMuZGVib3VuY2VNcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkRlYm91bmNlQWN0aW9uVGltZXIgPSBEZWJvdW5jZUFjdGlvblRpbWVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVib3VuY2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/common/build/mobx/debounce.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/common/build/mobx/etc.js":
/*!*************************************************************!*\
  !*** ./node_modules/@keplr-wallet/common/build/mobx/etc.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toGenerator = void 0;\n// Copied from the mobx-state-tree repository.\n/**\n * @experimental\n * experimental api - might change on minor/patch releases\n *\n * Convert a promise to a generator yielding that promise\n * This is intended to allow for usage of `yield*` in async actions to\n * retain the promise return type.\n *\n * Example:\n * ```ts\n * function getDataAsync(input: string): Promise<number> { ... }\n *\n * const someModel.actions(self => ({\n *   someAction: flow(function*() {\n *     // value is typed as number\n *     const value = yield* toGenerator(getDataAsync(\"input value\"));\n *     ...\n *   })\n * }))\n * ```\n */\nfunction* toGenerator(p) {\n    return (yield p);\n}\nexports.toGenerator = toGenerator;\n//# sourceMappingURL=etc.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQvbW9ieC9ldGMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQvbW9ieC9ldGMuanM/OGQ0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9HZW5lcmF0b3IgPSB2b2lkIDA7XG4vLyBDb3BpZWQgZnJvbSB0aGUgbW9ieC1zdGF0ZS10cmVlIHJlcG9zaXRvcnkuXG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqIGV4cGVyaW1lbnRhbCBhcGkgLSBtaWdodCBjaGFuZ2Ugb24gbWlub3IvcGF0Y2ggcmVsZWFzZXNcbiAqXG4gKiBDb252ZXJ0IGEgcHJvbWlzZSB0byBhIGdlbmVyYXRvciB5aWVsZGluZyB0aGF0IHByb21pc2VcbiAqIFRoaXMgaXMgaW50ZW5kZWQgdG8gYWxsb3cgZm9yIHVzYWdlIG9mIGB5aWVsZCpgIGluIGFzeW5jIGFjdGlvbnMgdG9cbiAqIHJldGFpbiB0aGUgcHJvbWlzZSByZXR1cm4gdHlwZS5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgdHNcbiAqIGZ1bmN0aW9uIGdldERhdGFBc3luYyhpbnB1dDogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHsgLi4uIH1cbiAqXG4gKiBjb25zdCBzb21lTW9kZWwuYWN0aW9ucyhzZWxmID0+ICh7XG4gKiAgIHNvbWVBY3Rpb246IGZsb3coZnVuY3Rpb24qKCkge1xuICogICAgIC8vIHZhbHVlIGlzIHR5cGVkIGFzIG51bWJlclxuICogICAgIGNvbnN0IHZhbHVlID0geWllbGQqIHRvR2VuZXJhdG9yKGdldERhdGFBc3luYyhcImlucHV0IHZhbHVlXCIpKTtcbiAqICAgICAuLi5cbiAqICAgfSlcbiAqIH0pKVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uKiB0b0dlbmVyYXRvcihwKSB7XG4gICAgcmV0dXJuICh5aWVsZCBwKTtcbn1cbmV4cG9ydHMudG9HZW5lcmF0b3IgPSB0b0dlbmVyYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV0Yy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/common/build/mobx/etc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/common/build/mobx/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@keplr-wallet/common/build/mobx/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./etc */ \"(ssr)/./node_modules/@keplr-wallet/common/build/mobx/etc.js\"), exports);\n__exportStar(__webpack_require__(/*! ./debounce */ \"(ssr)/./node_modules/@keplr-wallet/common/build/mobx/debounce.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQvbW9ieC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsMEVBQU87QUFDNUIsYUFBYSxtQkFBTyxDQUFDLG9GQUFZO0FBQ2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQvbW9ieC9pbmRleC5qcz9lYjdhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXRjXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9kZWJvdW5jZVwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/common/build/mobx/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/common/build/utils/debouncer.js":
/*!********************************************************************!*\
  !*** ./node_modules/@keplr-wallet/common/build/utils/debouncer.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Debouncer = void 0;\nclass Debouncer {\n    static promise(fn) {\n        let currentPromise;\n        return (...arguments_) => __awaiter(this, void 0, void 0, function* () {\n            if (currentPromise) {\n                return currentPromise;\n            }\n            try {\n                currentPromise = fn.apply(this, arguments_);\n                return yield currentPromise;\n            }\n            finally {\n                currentPromise = undefined;\n            }\n        });\n    }\n}\nexports.Debouncer = Debouncer;\n//# sourceMappingURL=debouncer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQvdXRpbHMvZGVib3VuY2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQvdXRpbHMvZGVib3VuY2VyLmpzP2RmZDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVib3VuY2VyID0gdm9pZCAwO1xuY2xhc3MgRGVib3VuY2VyIHtcbiAgICBzdGF0aWMgcHJvbWlzZShmbikge1xuICAgICAgICBsZXQgY3VycmVudFByb21pc2U7XG4gICAgICAgIHJldHVybiAoLi4uYXJndW1lbnRzXykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvbWlzZSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50c18pO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBjdXJyZW50UHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkRlYm91bmNlciA9IERlYm91bmNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYm91bmNlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/common/build/utils/debouncer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/common/build/utils/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@keplr-wallet/common/build/utils/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./debouncer */ \"(ssr)/./node_modules/@keplr-wallet/common/build/utils/debouncer.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQvdXRpbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLHVGQUFhO0FBQ2xDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb21tb24vYnVpbGQvdXRpbHMvaW5kZXguanM/ZWY3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2RlYm91bmNlclwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/common/build/utils/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/cosmos/build/account/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@keplr-wallet/cosmos/build/account/index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseAccount = void 0;\nconst unit_1 = __webpack_require__(/*! @keplr-wallet/unit */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/index.js\");\nconst simple_fetch_1 = __webpack_require__(/*! @keplr-wallet/simple-fetch */ \"(ssr)/./node_modules/@keplr-wallet/simple-fetch/build/index.js\");\nclass BaseAccount {\n    static fetchFromRest(rest, address, \n    // If the account doesn't exist, the result from `auth/accounts` would not have the address.\n    // In this case, if `defaultBech32Address` param is provided, this will use it instead of the result from rest.\n    defaultBech32Address = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield (0, simple_fetch_1.simpleFetch)(rest, `/cosmos/auth/v1beta1/accounts/${address}`, {\n                validateStatus: function (status) {\n                    // Permit 404 not found to handle the case of account not exists\n                    return (status >= 200 && status < 300) || status === 404;\n                },\n            });\n            return BaseAccount.fromProtoJSON(result.data, defaultBech32Address ? address : \"\");\n        });\n    }\n    static fromProtoJSON(obj, \n    // If the account doesn't exist, the result from `auth/accounts` would not have the address.\n    // In this case, if `defaultBech32Address` param is provided, this will use it instead of the result from rest.\n    defaultBech32Address = \"\") {\n        if (!obj.account) {\n            // Case of not existing account.\n            // {\n            //   \"code\": 5,\n            //   \"message\": \"rpc error: code = NotFound desc = account {address} not found: key not found\",\n            //   \"details\": [\n            //   ]\n            // }\n            if (!defaultBech32Address) {\n                throw new Error(`Account's address is unknown: ${JSON.stringify(obj)}`);\n            }\n            return new BaseAccount(\"\", defaultBech32Address, new unit_1.Int(0), new unit_1.Int(0));\n        }\n        let value = obj.account;\n        const type = value[\"@type\"] || \"\";\n        // If the chain modifies the account type, handle the case where the account type embeds the base account.\n        // (Actually, the only existent case is ethermint, and this is the line for handling ethermint)\n        const baseAccount = value.BaseAccount || value.baseAccount || value.base_account;\n        if (baseAccount) {\n            value = baseAccount;\n        }\n        // If the chain modifies the account type, handle the case where the account type embeds the account.\n        // (Actually, the only existent case is desmos, and this is the line for handling desmos)\n        const embedAccount = value.account;\n        if (embedAccount) {\n            value = embedAccount;\n        }\n        // If the account is the vesting account that embeds the base vesting account,\n        // the actual base account exists under the base vesting account.\n        // But, this can be different according to the version of cosmos-sdk.\n        // So, anyway, try to parse it by some ways...\n        const baseVestingAccount = value.BaseVestingAccount ||\n            value.baseVestingAccount ||\n            value.base_vesting_account;\n        if (baseVestingAccount) {\n            value = baseVestingAccount;\n            const baseAccount = value.BaseAccount || value.baseAccount || value.base_account;\n            if (baseAccount) {\n                value = baseAccount;\n            }\n        }\n        let address = value.address;\n        if (!address) {\n            if (!defaultBech32Address) {\n                throw new Error(`Account's address is unknown: ${JSON.stringify(obj)}`);\n            }\n            address = defaultBech32Address;\n        }\n        const accountNumber = value.account_number;\n        const sequence = value.sequence;\n        return new BaseAccount(type, address, new unit_1.Int(accountNumber || \"0\"), new unit_1.Int(sequence || \"0\"));\n    }\n    constructor(type, address, accountNumber, sequence) {\n        this.type = type;\n        this.address = address;\n        this.accountNumber = accountNumber;\n        this.sequence = sequence;\n    }\n    getType() {\n        return this.type;\n    }\n    getAddress() {\n        return this.address;\n    }\n    getAccountNumber() {\n        return this.accountNumber;\n    }\n    getSequence() {\n        return this.sequence;\n    }\n}\nexports.BaseAccount = BaseAccount;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvYWNjb3VudC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CLGVBQWUsbUJBQU8sQ0FBQyxrRkFBb0I7QUFDM0MsdUJBQXVCLG1CQUFPLENBQUMsa0dBQTRCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RyxRQUFRO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFNBQVM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsb0JBQW9CO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLG9CQUFvQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvYWNjb3VudC9pbmRleC5qcz8wMTUxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2VBY2NvdW50ID0gdm9pZCAwO1xuY29uc3QgdW5pdF8xID0gcmVxdWlyZShcIkBrZXBsci13YWxsZXQvdW5pdFwiKTtcbmNvbnN0IHNpbXBsZV9mZXRjaF8xID0gcmVxdWlyZShcIkBrZXBsci13YWxsZXQvc2ltcGxlLWZldGNoXCIpO1xuY2xhc3MgQmFzZUFjY291bnQge1xuICAgIHN0YXRpYyBmZXRjaEZyb21SZXN0KHJlc3QsIGFkZHJlc3MsIFxuICAgIC8vIElmIHRoZSBhY2NvdW50IGRvZXNuJ3QgZXhpc3QsIHRoZSByZXN1bHQgZnJvbSBgYXV0aC9hY2NvdW50c2Agd291bGQgbm90IGhhdmUgdGhlIGFkZHJlc3MuXG4gICAgLy8gSW4gdGhpcyBjYXNlLCBpZiBgZGVmYXVsdEJlY2gzMkFkZHJlc3NgIHBhcmFtIGlzIHByb3ZpZGVkLCB0aGlzIHdpbGwgdXNlIGl0IGluc3RlYWQgb2YgdGhlIHJlc3VsdCBmcm9tIHJlc3QuXG4gICAgZGVmYXVsdEJlY2gzMkFkZHJlc3MgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgKDAsIHNpbXBsZV9mZXRjaF8xLnNpbXBsZUZldGNoKShyZXN0LCBgL2Nvc21vcy9hdXRoL3YxYmV0YTEvYWNjb3VudHMvJHthZGRyZXNzfWAsIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAvLyBQZXJtaXQgNDA0IG5vdCBmb3VuZCB0byBoYW5kbGUgdGhlIGNhc2Ugb2YgYWNjb3VudCBub3QgZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDApIHx8IHN0YXR1cyA9PT0gNDA0O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBCYXNlQWNjb3VudC5mcm9tUHJvdG9KU09OKHJlc3VsdC5kYXRhLCBkZWZhdWx0QmVjaDMyQWRkcmVzcyA/IGFkZHJlc3MgOiBcIlwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUHJvdG9KU09OKG9iaiwgXG4gICAgLy8gSWYgdGhlIGFjY291bnQgZG9lc24ndCBleGlzdCwgdGhlIHJlc3VsdCBmcm9tIGBhdXRoL2FjY291bnRzYCB3b3VsZCBub3QgaGF2ZSB0aGUgYWRkcmVzcy5cbiAgICAvLyBJbiB0aGlzIGNhc2UsIGlmIGBkZWZhdWx0QmVjaDMyQWRkcmVzc2AgcGFyYW0gaXMgcHJvdmlkZWQsIHRoaXMgd2lsbCB1c2UgaXQgaW5zdGVhZCBvZiB0aGUgcmVzdWx0IGZyb20gcmVzdC5cbiAgICBkZWZhdWx0QmVjaDMyQWRkcmVzcyA9IFwiXCIpIHtcbiAgICAgICAgaWYgKCFvYmouYWNjb3VudCkge1xuICAgICAgICAgICAgLy8gQ2FzZSBvZiBub3QgZXhpc3RpbmcgYWNjb3VudC5cbiAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgIC8vICAgXCJjb2RlXCI6IDUsXG4gICAgICAgICAgICAvLyAgIFwibWVzc2FnZVwiOiBcInJwYyBlcnJvcjogY29kZSA9IE5vdEZvdW5kIGRlc2MgPSBhY2NvdW50IHthZGRyZXNzfSBub3QgZm91bmQ6IGtleSBub3QgZm91bmRcIixcbiAgICAgICAgICAgIC8vICAgXCJkZXRhaWxzXCI6IFtcbiAgICAgICAgICAgIC8vICAgXVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgaWYgKCFkZWZhdWx0QmVjaDMyQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQWNjb3VudCdzIGFkZHJlc3MgaXMgdW5rbm93bjogJHtKU09OLnN0cmluZ2lmeShvYmopfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCYXNlQWNjb3VudChcIlwiLCBkZWZhdWx0QmVjaDMyQWRkcmVzcywgbmV3IHVuaXRfMS5JbnQoMCksIG5ldyB1bml0XzEuSW50KDApKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFsdWUgPSBvYmouYWNjb3VudDtcbiAgICAgICAgY29uc3QgdHlwZSA9IHZhbHVlW1wiQHR5cGVcIl0gfHwgXCJcIjtcbiAgICAgICAgLy8gSWYgdGhlIGNoYWluIG1vZGlmaWVzIHRoZSBhY2NvdW50IHR5cGUsIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgYWNjb3VudCB0eXBlIGVtYmVkcyB0aGUgYmFzZSBhY2NvdW50LlxuICAgICAgICAvLyAoQWN0dWFsbHksIHRoZSBvbmx5IGV4aXN0ZW50IGNhc2UgaXMgZXRoZXJtaW50LCBhbmQgdGhpcyBpcyB0aGUgbGluZSBmb3IgaGFuZGxpbmcgZXRoZXJtaW50KVxuICAgICAgICBjb25zdCBiYXNlQWNjb3VudCA9IHZhbHVlLkJhc2VBY2NvdW50IHx8IHZhbHVlLmJhc2VBY2NvdW50IHx8IHZhbHVlLmJhc2VfYWNjb3VudDtcbiAgICAgICAgaWYgKGJhc2VBY2NvdW50KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VBY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBjaGFpbiBtb2RpZmllcyB0aGUgYWNjb3VudCB0eXBlLCBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGFjY291bnQgdHlwZSBlbWJlZHMgdGhlIGFjY291bnQuXG4gICAgICAgIC8vIChBY3R1YWxseSwgdGhlIG9ubHkgZXhpc3RlbnQgY2FzZSBpcyBkZXNtb3MsIGFuZCB0aGlzIGlzIHRoZSBsaW5lIGZvciBoYW5kbGluZyBkZXNtb3MpXG4gICAgICAgIGNvbnN0IGVtYmVkQWNjb3VudCA9IHZhbHVlLmFjY291bnQ7XG4gICAgICAgIGlmIChlbWJlZEFjY291bnQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZW1iZWRBY2NvdW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBhY2NvdW50IGlzIHRoZSB2ZXN0aW5nIGFjY291bnQgdGhhdCBlbWJlZHMgdGhlIGJhc2UgdmVzdGluZyBhY2NvdW50LFxuICAgICAgICAvLyB0aGUgYWN0dWFsIGJhc2UgYWNjb3VudCBleGlzdHMgdW5kZXIgdGhlIGJhc2UgdmVzdGluZyBhY2NvdW50LlxuICAgICAgICAvLyBCdXQsIHRoaXMgY2FuIGJlIGRpZmZlcmVudCBhY2NvcmRpbmcgdG8gdGhlIHZlcnNpb24gb2YgY29zbW9zLXNkay5cbiAgICAgICAgLy8gU28sIGFueXdheSwgdHJ5IHRvIHBhcnNlIGl0IGJ5IHNvbWUgd2F5cy4uLlxuICAgICAgICBjb25zdCBiYXNlVmVzdGluZ0FjY291bnQgPSB2YWx1ZS5CYXNlVmVzdGluZ0FjY291bnQgfHxcbiAgICAgICAgICAgIHZhbHVlLmJhc2VWZXN0aW5nQWNjb3VudCB8fFxuICAgICAgICAgICAgdmFsdWUuYmFzZV92ZXN0aW5nX2FjY291bnQ7XG4gICAgICAgIGlmIChiYXNlVmVzdGluZ0FjY291bnQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZVZlc3RpbmdBY2NvdW50O1xuICAgICAgICAgICAgY29uc3QgYmFzZUFjY291bnQgPSB2YWx1ZS5CYXNlQWNjb3VudCB8fCB2YWx1ZS5iYXNlQWNjb3VudCB8fCB2YWx1ZS5iYXNlX2FjY291bnQ7XG4gICAgICAgICAgICBpZiAoYmFzZUFjY291bnQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGJhc2VBY2NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBhZGRyZXNzID0gdmFsdWUuYWRkcmVzcztcbiAgICAgICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICAgICAgICBpZiAoIWRlZmF1bHRCZWNoMzJBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBY2NvdW50J3MgYWRkcmVzcyBpcyB1bmtub3duOiAke0pTT04uc3RyaW5naWZ5KG9iail9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRyZXNzID0gZGVmYXVsdEJlY2gzMkFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWNjb3VudE51bWJlciA9IHZhbHVlLmFjY291bnRfbnVtYmVyO1xuICAgICAgICBjb25zdCBzZXF1ZW5jZSA9IHZhbHVlLnNlcXVlbmNlO1xuICAgICAgICByZXR1cm4gbmV3IEJhc2VBY2NvdW50KHR5cGUsIGFkZHJlc3MsIG5ldyB1bml0XzEuSW50KGFjY291bnROdW1iZXIgfHwgXCIwXCIpLCBuZXcgdW5pdF8xLkludChzZXF1ZW5jZSB8fCBcIjBcIikpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBhZGRyZXNzLCBhY2NvdW50TnVtYmVyLCBzZXF1ZW5jZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICB0aGlzLmFjY291bnROdW1iZXIgPSBhY2NvdW50TnVtYmVyO1xuICAgICAgICB0aGlzLnNlcXVlbmNlID0gc2VxdWVuY2U7XG4gICAgfVxuICAgIGdldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgfVxuICAgIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZHJlc3M7XG4gICAgfVxuICAgIGdldEFjY291bnROdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjY291bnROdW1iZXI7XG4gICAgfVxuICAgIGdldFNlcXVlbmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXF1ZW5jZTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VBY2NvdW50ID0gQmFzZUFjY291bnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/cosmos/build/account/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/cosmos/build/adr-36/amino.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@keplr-wallet/cosmos/build/adr-36/amino.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.verifyADR36Amino = exports.verifyADR36AminoSignDoc = exports.makeADR36AminoSignDoc = exports.checkAndValidateADR36AminoSignDoc = void 0;\nconst signing_1 = __webpack_require__(/*! ../signing */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/signing/index.js\");\nconst bech32_1 = __webpack_require__(/*! ../bech32 */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/bech32/index.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\nconst crypto_1 = __webpack_require__(/*! @keplr-wallet/crypto */ \"(ssr)/./node_modules/@keplr-wallet/crypto/build/index.js\");\n/**\n * Check the sign doc is for ADR-36.\n * If the sign doc is expected to be ADR-36, validate the sign doc and throw an error if the sign doc is valid ADR-36.\n * @param signDoc\n * @param bech32PrefixAccAddr If this argument is provided, validate the signer in the `MsgSignData` with this prefix.\n *                            If not, validate the signer in the `MsgSignData` without considering the bech32 prefix.\n */\nfunction checkAndValidateADR36AminoSignDoc(signDoc, bech32PrefixAccAddr) {\n    const hasOnlyMsgSignData = (() => {\n        if (signDoc &&\n            signDoc.msgs &&\n            Array.isArray(signDoc.msgs) &&\n            signDoc.msgs.length === 1) {\n            const msg = signDoc.msgs[0];\n            return msg.type === \"sign/MsgSignData\";\n        }\n        else {\n            return false;\n        }\n    })();\n    if (!hasOnlyMsgSignData) {\n        return false;\n    }\n    if (signDoc.chain_id !== \"\") {\n        throw new Error(\"Chain id should be empty string for ADR-36 signing\");\n    }\n    if (signDoc.memo !== \"\") {\n        throw new Error(\"Memo should be empty string for ADR-36 signing\");\n    }\n    if (signDoc.account_number !== \"0\") {\n        throw new Error('Account number should be \"0\" for ADR-36 signing');\n    }\n    if (signDoc.sequence !== \"0\") {\n        throw new Error('Sequence should be \"0\" for ADR-36 signing');\n    }\n    if (signDoc.fee.gas !== \"0\") {\n        throw new Error('Gas should be \"0\" for ADR-36 signing');\n    }\n    if (signDoc.fee.amount.length !== 0) {\n        throw new Error(\"Fee amount should be empty array for ADR-36 signing\");\n    }\n    const msg = signDoc.msgs[0];\n    if (msg.type !== \"sign/MsgSignData\") {\n        throw new Error(`Invalid type of ADR-36 sign msg: ${msg.type}`);\n    }\n    if (!msg.value) {\n        throw new Error(\"Empty value in the msg\");\n    }\n    const signer = msg.value.signer;\n    if (!signer) {\n        throw new Error(\"Empty signer in the ADR-36 msg\");\n    }\n    bech32_1.Bech32Address.validate(signer, bech32PrefixAccAddr);\n    const data = msg.value.data;\n    if (!data) {\n        throw new Error(\"Empty data in the ADR-36 msg\");\n    }\n    const rawData = buffer_1.Buffer.from(data, \"base64\");\n    // Validate the data is encoded as base64.\n    if (rawData.toString(\"base64\") !== data) {\n        throw new Error(\"Data is not encoded by base64\");\n    }\n    if (rawData.length === 0) {\n        throw new Error(\"Empty data in the ADR-36 msg\");\n    }\n    return true;\n}\nexports.checkAndValidateADR36AminoSignDoc = checkAndValidateADR36AminoSignDoc;\nfunction makeADR36AminoSignDoc(signer, data) {\n    if (typeof data === \"string\") {\n        data = buffer_1.Buffer.from(data).toString(\"base64\");\n    }\n    else {\n        data = buffer_1.Buffer.from(data).toString(\"base64\");\n    }\n    return {\n        chain_id: \"\",\n        account_number: \"0\",\n        sequence: \"0\",\n        fee: {\n            gas: \"0\",\n            amount: [],\n        },\n        msgs: [\n            {\n                type: \"sign/MsgSignData\",\n                value: {\n                    signer,\n                    data,\n                },\n            },\n        ],\n        memo: \"\",\n    };\n}\nexports.makeADR36AminoSignDoc = makeADR36AminoSignDoc;\nfunction verifyADR36AminoSignDoc(bech32PrefixAccAddr, signDoc, pubKey, signature, algo = \"secp256k1\") {\n    if (!checkAndValidateADR36AminoSignDoc(signDoc, bech32PrefixAccAddr)) {\n        throw new Error(\"Invalid sign doc for ADR-36\");\n    }\n    const cryptoPubKey = new crypto_1.PubKeySecp256k1(pubKey);\n    const expectedSigner = (() => {\n        if (algo === \"ethsecp256k1\") {\n            return new bech32_1.Bech32Address(cryptoPubKey.getEthAddress()).toBech32(bech32PrefixAccAddr);\n        }\n        return new bech32_1.Bech32Address(cryptoPubKey.getCosmosAddress()).toBech32(bech32PrefixAccAddr);\n    })();\n    const signer = signDoc.msgs[0].value.signer;\n    if (expectedSigner !== signer) {\n        throw new Error(\"Unmatched signer\");\n    }\n    const msg = (0, signing_1.serializeSignDoc)(signDoc);\n    return cryptoPubKey.verifyDigest32((() => {\n        if (algo === \"ethsecp256k1\") {\n            return crypto_1.Hash.keccak256(msg);\n        }\n        return crypto_1.Hash.sha256(msg);\n    })(), signature);\n}\nexports.verifyADR36AminoSignDoc = verifyADR36AminoSignDoc;\nfunction verifyADR36Amino(bech32PrefixAccAddr, signer, data, pubKey, signature, algo = \"secp256k1\") {\n    const signDoc = makeADR36AminoSignDoc(signer, data);\n    return verifyADR36AminoSignDoc(bech32PrefixAccAddr, signDoc, pubKey, signature, algo);\n}\nexports.verifyADR36Amino = verifyADR36Amino;\n//# sourceMappingURL=amino.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvYWRyLTM2L2FtaW5vLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLCtCQUErQixHQUFHLDZCQUE2QixHQUFHLHlDQUF5QztBQUN0SSxrQkFBa0IsbUJBQU8sQ0FBQyxvRkFBWTtBQUN0QyxpQkFBaUIsbUJBQU8sQ0FBQyxrRkFBVztBQUNwQyxpQkFBaUIsbUJBQU8sQ0FBQyxxREFBUztBQUNsQyxpQkFBaUIsbUJBQU8sQ0FBQyxzRkFBc0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxTQUFTO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvYWRyLTM2L2FtaW5vLmpzPzk0NWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcmlmeUFEUjM2QW1pbm8gPSBleHBvcnRzLnZlcmlmeUFEUjM2QW1pbm9TaWduRG9jID0gZXhwb3J0cy5tYWtlQURSMzZBbWlub1NpZ25Eb2MgPSBleHBvcnRzLmNoZWNrQW5kVmFsaWRhdGVBRFIzNkFtaW5vU2lnbkRvYyA9IHZvaWQgMDtcbmNvbnN0IHNpZ25pbmdfMSA9IHJlcXVpcmUoXCIuLi9zaWduaW5nXCIpO1xuY29uc3QgYmVjaDMyXzEgPSByZXF1aXJlKFwiLi4vYmVjaDMyXCIpO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIkBrZXBsci13YWxsZXQvY3J5cHRvXCIpO1xuLyoqXG4gKiBDaGVjayB0aGUgc2lnbiBkb2MgaXMgZm9yIEFEUi0zNi5cbiAqIElmIHRoZSBzaWduIGRvYyBpcyBleHBlY3RlZCB0byBiZSBBRFItMzYsIHZhbGlkYXRlIHRoZSBzaWduIGRvYyBhbmQgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHNpZ24gZG9jIGlzIHZhbGlkIEFEUi0zNi5cbiAqIEBwYXJhbSBzaWduRG9jXG4gKiBAcGFyYW0gYmVjaDMyUHJlZml4QWNjQWRkciBJZiB0aGlzIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCB2YWxpZGF0ZSB0aGUgc2lnbmVyIGluIHRoZSBgTXNnU2lnbkRhdGFgIHdpdGggdGhpcyBwcmVmaXguXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiBub3QsIHZhbGlkYXRlIHRoZSBzaWduZXIgaW4gdGhlIGBNc2dTaWduRGF0YWAgd2l0aG91dCBjb25zaWRlcmluZyB0aGUgYmVjaDMyIHByZWZpeC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tBbmRWYWxpZGF0ZUFEUjM2QW1pbm9TaWduRG9jKHNpZ25Eb2MsIGJlY2gzMlByZWZpeEFjY0FkZHIpIHtcbiAgICBjb25zdCBoYXNPbmx5TXNnU2lnbkRhdGEgPSAoKCkgPT4ge1xuICAgICAgICBpZiAoc2lnbkRvYyAmJlxuICAgICAgICAgICAgc2lnbkRvYy5tc2dzICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHNpZ25Eb2MubXNncykgJiZcbiAgICAgICAgICAgIHNpZ25Eb2MubXNncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IHNpZ25Eb2MubXNnc1swXTtcbiAgICAgICAgICAgIHJldHVybiBtc2cudHlwZSA9PT0gXCJzaWduL01zZ1NpZ25EYXRhXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICAgIGlmICghaGFzT25seU1zZ1NpZ25EYXRhKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHNpZ25Eb2MuY2hhaW5faWQgIT09IFwiXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2hhaW4gaWQgc2hvdWxkIGJlIGVtcHR5IHN0cmluZyBmb3IgQURSLTM2IHNpZ25pbmdcIik7XG4gICAgfVxuICAgIGlmIChzaWduRG9jLm1lbW8gIT09IFwiXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWVtbyBzaG91bGQgYmUgZW1wdHkgc3RyaW5nIGZvciBBRFItMzYgc2lnbmluZ1wiKTtcbiAgICB9XG4gICAgaWYgKHNpZ25Eb2MuYWNjb3VudF9udW1iZXIgIT09IFwiMFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWNjb3VudCBudW1iZXIgc2hvdWxkIGJlIFwiMFwiIGZvciBBRFItMzYgc2lnbmluZycpO1xuICAgIH1cbiAgICBpZiAoc2lnbkRvYy5zZXF1ZW5jZSAhPT0gXCIwXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXF1ZW5jZSBzaG91bGQgYmUgXCIwXCIgZm9yIEFEUi0zNiBzaWduaW5nJyk7XG4gICAgfVxuICAgIGlmIChzaWduRG9jLmZlZS5nYXMgIT09IFwiMFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR2FzIHNob3VsZCBiZSBcIjBcIiBmb3IgQURSLTM2IHNpZ25pbmcnKTtcbiAgICB9XG4gICAgaWYgKHNpZ25Eb2MuZmVlLmFtb3VudC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmVlIGFtb3VudCBzaG91bGQgYmUgZW1wdHkgYXJyYXkgZm9yIEFEUi0zNiBzaWduaW5nXCIpO1xuICAgIH1cbiAgICBjb25zdCBtc2cgPSBzaWduRG9jLm1zZ3NbMF07XG4gICAgaWYgKG1zZy50eXBlICE9PSBcInNpZ24vTXNnU2lnbkRhdGFcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdHlwZSBvZiBBRFItMzYgc2lnbiBtc2c6ICR7bXNnLnR5cGV9YCk7XG4gICAgfVxuICAgIGlmICghbXNnLnZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVtcHR5IHZhbHVlIGluIHRoZSBtc2dcIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lciA9IG1zZy52YWx1ZS5zaWduZXI7XG4gICAgaWYgKCFzaWduZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW1wdHkgc2lnbmVyIGluIHRoZSBBRFItMzYgbXNnXCIpO1xuICAgIH1cbiAgICBiZWNoMzJfMS5CZWNoMzJBZGRyZXNzLnZhbGlkYXRlKHNpZ25lciwgYmVjaDMyUHJlZml4QWNjQWRkcik7XG4gICAgY29uc3QgZGF0YSA9IG1zZy52YWx1ZS5kYXRhO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbXB0eSBkYXRhIGluIHRoZSBBRFItMzYgbXNnXCIpO1xuICAgIH1cbiAgICBjb25zdCByYXdEYXRhID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oZGF0YSwgXCJiYXNlNjRcIik7XG4gICAgLy8gVmFsaWRhdGUgdGhlIGRhdGEgaXMgZW5jb2RlZCBhcyBiYXNlNjQuXG4gICAgaWYgKHJhd0RhdGEudG9TdHJpbmcoXCJiYXNlNjRcIikgIT09IGRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBpcyBub3QgZW5jb2RlZCBieSBiYXNlNjRcIik7XG4gICAgfVxuICAgIGlmIChyYXdEYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbXB0eSBkYXRhIGluIHRoZSBBRFItMzYgbXNnXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuY2hlY2tBbmRWYWxpZGF0ZUFEUjM2QW1pbm9TaWduRG9jID0gY2hlY2tBbmRWYWxpZGF0ZUFEUjM2QW1pbm9TaWduRG9jO1xuZnVuY3Rpb24gbWFrZUFEUjM2QW1pbm9TaWduRG9jKHNpZ25lciwgZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkYXRhID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oZGF0YSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkYXRhID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oZGF0YSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNoYWluX2lkOiBcIlwiLFxuICAgICAgICBhY2NvdW50X251bWJlcjogXCIwXCIsXG4gICAgICAgIHNlcXVlbmNlOiBcIjBcIixcbiAgICAgICAgZmVlOiB7XG4gICAgICAgICAgICBnYXM6IFwiMFwiLFxuICAgICAgICAgICAgYW1vdW50OiBbXSxcbiAgICAgICAgfSxcbiAgICAgICAgbXNnczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic2lnbi9Nc2dTaWduRGF0YVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25lcixcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgbWVtbzogXCJcIixcbiAgICB9O1xufVxuZXhwb3J0cy5tYWtlQURSMzZBbWlub1NpZ25Eb2MgPSBtYWtlQURSMzZBbWlub1NpZ25Eb2M7XG5mdW5jdGlvbiB2ZXJpZnlBRFIzNkFtaW5vU2lnbkRvYyhiZWNoMzJQcmVmaXhBY2NBZGRyLCBzaWduRG9jLCBwdWJLZXksIHNpZ25hdHVyZSwgYWxnbyA9IFwic2VjcDI1NmsxXCIpIHtcbiAgICBpZiAoIWNoZWNrQW5kVmFsaWRhdGVBRFIzNkFtaW5vU2lnbkRvYyhzaWduRG9jLCBiZWNoMzJQcmVmaXhBY2NBZGRyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNpZ24gZG9jIGZvciBBRFItMzZcIik7XG4gICAgfVxuICAgIGNvbnN0IGNyeXB0b1B1YktleSA9IG5ldyBjcnlwdG9fMS5QdWJLZXlTZWNwMjU2azEocHViS2V5KTtcbiAgICBjb25zdCBleHBlY3RlZFNpZ25lciA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChhbGdvID09PSBcImV0aHNlY3AyNTZrMVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGJlY2gzMl8xLkJlY2gzMkFkZHJlc3MoY3J5cHRvUHViS2V5LmdldEV0aEFkZHJlc3MoKSkudG9CZWNoMzIoYmVjaDMyUHJlZml4QWNjQWRkcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBiZWNoMzJfMS5CZWNoMzJBZGRyZXNzKGNyeXB0b1B1YktleS5nZXRDb3Ntb3NBZGRyZXNzKCkpLnRvQmVjaDMyKGJlY2gzMlByZWZpeEFjY0FkZHIpO1xuICAgIH0pKCk7XG4gICAgY29uc3Qgc2lnbmVyID0gc2lnbkRvYy5tc2dzWzBdLnZhbHVlLnNpZ25lcjtcbiAgICBpZiAoZXhwZWN0ZWRTaWduZXIgIT09IHNpZ25lcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbm1hdGNoZWQgc2lnbmVyXCIpO1xuICAgIH1cbiAgICBjb25zdCBtc2cgPSAoMCwgc2lnbmluZ18xLnNlcmlhbGl6ZVNpZ25Eb2MpKHNpZ25Eb2MpO1xuICAgIHJldHVybiBjcnlwdG9QdWJLZXkudmVyaWZ5RGlnZXN0MzIoKCgpID0+IHtcbiAgICAgICAgaWYgKGFsZ28gPT09IFwiZXRoc2VjcDI1NmsxXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjcnlwdG9fMS5IYXNoLmtlY2NhazI1Nihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcnlwdG9fMS5IYXNoLnNoYTI1Nihtc2cpO1xuICAgIH0pKCksIHNpZ25hdHVyZSk7XG59XG5leHBvcnRzLnZlcmlmeUFEUjM2QW1pbm9TaWduRG9jID0gdmVyaWZ5QURSMzZBbWlub1NpZ25Eb2M7XG5mdW5jdGlvbiB2ZXJpZnlBRFIzNkFtaW5vKGJlY2gzMlByZWZpeEFjY0FkZHIsIHNpZ25lciwgZGF0YSwgcHViS2V5LCBzaWduYXR1cmUsIGFsZ28gPSBcInNlY3AyNTZrMVwiKSB7XG4gICAgY29uc3Qgc2lnbkRvYyA9IG1ha2VBRFIzNkFtaW5vU2lnbkRvYyhzaWduZXIsIGRhdGEpO1xuICAgIHJldHVybiB2ZXJpZnlBRFIzNkFtaW5vU2lnbkRvYyhiZWNoMzJQcmVmaXhBY2NBZGRyLCBzaWduRG9jLCBwdWJLZXksIHNpZ25hdHVyZSwgYWxnbyk7XG59XG5leHBvcnRzLnZlcmlmeUFEUjM2QW1pbm8gPSB2ZXJpZnlBRFIzNkFtaW5vO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW1pbm8uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/cosmos/build/adr-36/amino.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/cosmos/build/adr-36/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@keplr-wallet/cosmos/build/adr-36/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./amino */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/adr-36/amino.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvYWRyLTM2L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxnRkFBUztBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvY29zbW9zL2J1aWxkL2Fkci0zNi9pbmRleC5qcz9hMDZhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYW1pbm9cIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/cosmos/build/adr-36/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/cosmos/build/bech32/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@keplr-wallet/cosmos/build/bech32/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Bech32Address = void 0;\nconst bech32_1 = __importStar(__webpack_require__(/*! bech32 */ \"(ssr)/./node_modules/bech32/index.js\"));\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\nconst address_1 = __webpack_require__(/*! @ethersproject/address */ \"(ssr)/./node_modules/@ethersproject/address/lib.esm/index.js\");\nclass Bech32Address {\n    static shortenAddress(bech32, maxCharacters) {\n        if (maxCharacters >= bech32.length) {\n            return bech32;\n        }\n        const i = bech32.indexOf(\"1\");\n        const prefix = bech32.slice(0, i);\n        const address = bech32.slice(i + 1);\n        maxCharacters -= prefix.length;\n        maxCharacters -= 3; // For \"...\"\n        maxCharacters -= 1; // For \"1\"\n        if (maxCharacters <= 0) {\n            return \"\";\n        }\n        const mid = Math.floor(address.length / 2);\n        let former = address.slice(0, mid);\n        let latter = address.slice(mid);\n        while (maxCharacters < former.length + latter.length) {\n            if ((former.length + latter.length) % 2 === 1 && former.length > 0) {\n                former = former.slice(0, former.length - 1);\n            }\n            else {\n                latter = latter.slice(1);\n            }\n        }\n        return prefix + \"1\" + former + \"...\" + latter;\n    }\n    static fromBech32(bech32Address, prefix) {\n        const decoded = bech32_1.default.decode(bech32Address);\n        if (prefix && decoded.prefix !== prefix) {\n            throw new Error(\"Unmatched prefix\");\n        }\n        return new Bech32Address(new Uint8Array((0, bech32_1.fromWords)(decoded.words)));\n    }\n    static validate(bech32Address, prefix) {\n        const { prefix: decodedPrefix } = bech32_1.default.decode(bech32Address);\n        if (prefix && prefix !== decodedPrefix) {\n            throw new Error(`Unexpected prefix (expected: ${prefix}, actual: ${decodedPrefix})`);\n        }\n    }\n    static defaultBech32Config(mainPrefix, validatorPrefix = \"val\", consensusPrefix = \"cons\", publicPrefix = \"pub\", operatorPrefix = \"oper\") {\n        return {\n            bech32PrefixAccAddr: mainPrefix,\n            bech32PrefixAccPub: mainPrefix + publicPrefix,\n            bech32PrefixValAddr: mainPrefix + validatorPrefix + operatorPrefix,\n            bech32PrefixValPub: mainPrefix + validatorPrefix + operatorPrefix + publicPrefix,\n            bech32PrefixConsAddr: mainPrefix + validatorPrefix + consensusPrefix,\n            bech32PrefixConsPub: mainPrefix + validatorPrefix + consensusPrefix + publicPrefix,\n        };\n    }\n    constructor(address) {\n        this.address = address;\n    }\n    toBech32(prefix) {\n        const words = bech32_1.default.toWords(this.address);\n        return bech32_1.default.encode(prefix, words);\n    }\n    toHex(mixedCaseChecksum = true) {\n        const hex = buffer_1.Buffer.from(this.address).toString(\"hex\");\n        if (hex.length === 0) {\n            throw new Error(\"Empty address\");\n        }\n        if (mixedCaseChecksum) {\n            return (0, address_1.getAddress)(\"0x\" + hex);\n        }\n        else {\n            return \"0x\" + hex;\n        }\n    }\n}\nexports.Bech32Address = Bech32Address;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvYmVjaDMyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIsOEJBQThCLG1CQUFPLENBQUMsb0RBQVE7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMscURBQVM7QUFDbEMsa0JBQWtCLG1CQUFPLENBQUMsNEZBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QztBQUNBLDREQUE0RCxPQUFPLFlBQVksY0FBYztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvYmVjaDMyL2luZGV4LmpzPzAwN2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmVjaDMyQWRkcmVzcyA9IHZvaWQgMDtcbmNvbnN0IGJlY2gzMl8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJiZWNoMzJcIikpO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbmNvbnN0IGFkZHJlc3NfMSA9IHJlcXVpcmUoXCJAZXRoZXJzcHJvamVjdC9hZGRyZXNzXCIpO1xuY2xhc3MgQmVjaDMyQWRkcmVzcyB7XG4gICAgc3RhdGljIHNob3J0ZW5BZGRyZXNzKGJlY2gzMiwgbWF4Q2hhcmFjdGVycykge1xuICAgICAgICBpZiAobWF4Q2hhcmFjdGVycyA+PSBiZWNoMzIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gYmVjaDMyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGkgPSBiZWNoMzIuaW5kZXhPZihcIjFcIik7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGJlY2gzMi5zbGljZSgwLCBpKTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGJlY2gzMi5zbGljZShpICsgMSk7XG4gICAgICAgIG1heENoYXJhY3RlcnMgLT0gcHJlZml4Lmxlbmd0aDtcbiAgICAgICAgbWF4Q2hhcmFjdGVycyAtPSAzOyAvLyBGb3IgXCIuLi5cIlxuICAgICAgICBtYXhDaGFyYWN0ZXJzIC09IDE7IC8vIEZvciBcIjFcIlxuICAgICAgICBpZiAobWF4Q2hhcmFjdGVycyA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKGFkZHJlc3MubGVuZ3RoIC8gMik7XG4gICAgICAgIGxldCBmb3JtZXIgPSBhZGRyZXNzLnNsaWNlKDAsIG1pZCk7XG4gICAgICAgIGxldCBsYXR0ZXIgPSBhZGRyZXNzLnNsaWNlKG1pZCk7XG4gICAgICAgIHdoaWxlIChtYXhDaGFyYWN0ZXJzIDwgZm9ybWVyLmxlbmd0aCArIGxhdHRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICgoZm9ybWVyLmxlbmd0aCArIGxhdHRlci5sZW5ndGgpICUgMiA9PT0gMSAmJiBmb3JtZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvcm1lciA9IGZvcm1lci5zbGljZSgwLCBmb3JtZXIubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXR0ZXIgPSBsYXR0ZXIuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZWZpeCArIFwiMVwiICsgZm9ybWVyICsgXCIuLi5cIiArIGxhdHRlcjtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CZWNoMzIoYmVjaDMyQWRkcmVzcywgcHJlZml4KSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBiZWNoMzJfMS5kZWZhdWx0LmRlY29kZShiZWNoMzJBZGRyZXNzKTtcbiAgICAgICAgaWYgKHByZWZpeCAmJiBkZWNvZGVkLnByZWZpeCAhPT0gcHJlZml4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbm1hdGNoZWQgcHJlZml4XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQmVjaDMyQWRkcmVzcyhuZXcgVWludDhBcnJheSgoMCwgYmVjaDMyXzEuZnJvbVdvcmRzKShkZWNvZGVkLndvcmRzKSkpO1xuICAgIH1cbiAgICBzdGF0aWMgdmFsaWRhdGUoYmVjaDMyQWRkcmVzcywgcHJlZml4KSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4OiBkZWNvZGVkUHJlZml4IH0gPSBiZWNoMzJfMS5kZWZhdWx0LmRlY29kZShiZWNoMzJBZGRyZXNzKTtcbiAgICAgICAgaWYgKHByZWZpeCAmJiBwcmVmaXggIT09IGRlY29kZWRQcmVmaXgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBwcmVmaXggKGV4cGVjdGVkOiAke3ByZWZpeH0sIGFjdHVhbDogJHtkZWNvZGVkUHJlZml4fSlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZGVmYXVsdEJlY2gzMkNvbmZpZyhtYWluUHJlZml4LCB2YWxpZGF0b3JQcmVmaXggPSBcInZhbFwiLCBjb25zZW5zdXNQcmVmaXggPSBcImNvbnNcIiwgcHVibGljUHJlZml4ID0gXCJwdWJcIiwgb3BlcmF0b3JQcmVmaXggPSBcIm9wZXJcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmVjaDMyUHJlZml4QWNjQWRkcjogbWFpblByZWZpeCxcbiAgICAgICAgICAgIGJlY2gzMlByZWZpeEFjY1B1YjogbWFpblByZWZpeCArIHB1YmxpY1ByZWZpeCxcbiAgICAgICAgICAgIGJlY2gzMlByZWZpeFZhbEFkZHI6IG1haW5QcmVmaXggKyB2YWxpZGF0b3JQcmVmaXggKyBvcGVyYXRvclByZWZpeCxcbiAgICAgICAgICAgIGJlY2gzMlByZWZpeFZhbFB1YjogbWFpblByZWZpeCArIHZhbGlkYXRvclByZWZpeCArIG9wZXJhdG9yUHJlZml4ICsgcHVibGljUHJlZml4LFxuICAgICAgICAgICAgYmVjaDMyUHJlZml4Q29uc0FkZHI6IG1haW5QcmVmaXggKyB2YWxpZGF0b3JQcmVmaXggKyBjb25zZW5zdXNQcmVmaXgsXG4gICAgICAgICAgICBiZWNoMzJQcmVmaXhDb25zUHViOiBtYWluUHJlZml4ICsgdmFsaWRhdG9yUHJlZml4ICsgY29uc2Vuc3VzUHJlZml4ICsgcHVibGljUHJlZml4LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzKSB7XG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgfVxuICAgIHRvQmVjaDMyKHByZWZpeCkge1xuICAgICAgICBjb25zdCB3b3JkcyA9IGJlY2gzMl8xLmRlZmF1bHQudG9Xb3Jkcyh0aGlzLmFkZHJlc3MpO1xuICAgICAgICByZXR1cm4gYmVjaDMyXzEuZGVmYXVsdC5lbmNvZGUocHJlZml4LCB3b3Jkcyk7XG4gICAgfVxuICAgIHRvSGV4KG1peGVkQ2FzZUNoZWNrc3VtID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBoZXggPSBidWZmZXJfMS5CdWZmZXIuZnJvbSh0aGlzLmFkZHJlc3MpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW1wdHkgYWRkcmVzc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWl4ZWRDYXNlQ2hlY2tzdW0pIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgYWRkcmVzc18xLmdldEFkZHJlc3MpKFwiMHhcIiArIGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCIweFwiICsgaGV4O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5CZWNoMzJBZGRyZXNzID0gQmVjaDMyQWRkcmVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/cosmos/build/bech32/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/cosmos/build/chain-id/cosmos.js":
/*!********************************************************************!*\
  !*** ./node_modules/@keplr-wallet/cosmos/build/chain-id/cosmos.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChainIdHelper = void 0;\nclass ChainIdHelper {\n    static parse(chainId) {\n        // In the case of injective dev/testnet, there is a difficult problem to deal with keplr's chain identifier system...\n        // Fundamentally, keplr's chain identifier system started when the app was created, so too mnay logic depends on chain identifier.\n        // Temporarily deal with it in the way below.\n        // There is a possibility of some kind of problem...\n        // But anyway, it's not a big problem because it's dev/testnet...\n        if (chainId === \"injective-777\" || chainId === \"injective-888\") {\n            return {\n                identifier: chainId,\n                version: 0,\n            };\n        }\n        const split = chainId\n            .split(ChainIdHelper.VersionFormatRegExp)\n            .filter(Boolean);\n        if (split.length !== 2) {\n            return {\n                identifier: chainId,\n                version: 0,\n            };\n        }\n        else {\n            return { identifier: split[0], version: parseInt(split[1]) };\n        }\n    }\n    static hasChainVersion(chainId) {\n        const version = ChainIdHelper.parse(chainId);\n        return version.identifier !== chainId;\n    }\n}\nexports.ChainIdHelper = ChainIdHelper;\n// VersionFormatRegExp checks if a chainID is in the format required for parsing versions\n// The chainID should be in the form: `{identifier}-{version}`\nChainIdHelper.VersionFormatRegExp = /(.+)-([\\d]+)/;\n//# sourceMappingURL=cosmos.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvY2hhaW4taWQvY29zbW9zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0Esd0NBQXdDLFdBQVcsRUFBRSxRQUFRO0FBQzdEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L2Nvc21vcy9idWlsZC9jaGFpbi1pZC9jb3Ntb3MuanM/MDllZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hhaW5JZEhlbHBlciA9IHZvaWQgMDtcbmNsYXNzIENoYWluSWRIZWxwZXIge1xuICAgIHN0YXRpYyBwYXJzZShjaGFpbklkKSB7XG4gICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGluamVjdGl2ZSBkZXYvdGVzdG5ldCwgdGhlcmUgaXMgYSBkaWZmaWN1bHQgcHJvYmxlbSB0byBkZWFsIHdpdGgga2VwbHIncyBjaGFpbiBpZGVudGlmaWVyIHN5c3RlbS4uLlxuICAgICAgICAvLyBGdW5kYW1lbnRhbGx5LCBrZXBscidzIGNoYWluIGlkZW50aWZpZXIgc3lzdGVtIHN0YXJ0ZWQgd2hlbiB0aGUgYXBwIHdhcyBjcmVhdGVkLCBzbyB0b28gbW5heSBsb2dpYyBkZXBlbmRzIG9uIGNoYWluIGlkZW50aWZpZXIuXG4gICAgICAgIC8vIFRlbXBvcmFyaWx5IGRlYWwgd2l0aCBpdCBpbiB0aGUgd2F5IGJlbG93LlxuICAgICAgICAvLyBUaGVyZSBpcyBhIHBvc3NpYmlsaXR5IG9mIHNvbWUga2luZCBvZiBwcm9ibGVtLi4uXG4gICAgICAgIC8vIEJ1dCBhbnl3YXksIGl0J3Mgbm90IGEgYmlnIHByb2JsZW0gYmVjYXVzZSBpdCdzIGRldi90ZXN0bmV0Li4uXG4gICAgICAgIGlmIChjaGFpbklkID09PSBcImluamVjdGl2ZS03NzdcIiB8fCBjaGFpbklkID09PSBcImluamVjdGl2ZS04ODhcIikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBjaGFpbklkLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gY2hhaW5JZFxuICAgICAgICAgICAgLnNwbGl0KENoYWluSWRIZWxwZXIuVmVyc2lvbkZvcm1hdFJlZ0V4cClcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG4gICAgICAgIGlmIChzcGxpdC5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcjogY2hhaW5JZCxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGlkZW50aWZpZXI6IHNwbGl0WzBdLCB2ZXJzaW9uOiBwYXJzZUludChzcGxpdFsxXSkgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgaGFzQ2hhaW5WZXJzaW9uKGNoYWluSWQpIHtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IENoYWluSWRIZWxwZXIucGFyc2UoY2hhaW5JZCk7XG4gICAgICAgIHJldHVybiB2ZXJzaW9uLmlkZW50aWZpZXIgIT09IGNoYWluSWQ7XG4gICAgfVxufVxuZXhwb3J0cy5DaGFpbklkSGVscGVyID0gQ2hhaW5JZEhlbHBlcjtcbi8vIFZlcnNpb25Gb3JtYXRSZWdFeHAgY2hlY2tzIGlmIGEgY2hhaW5JRCBpcyBpbiB0aGUgZm9ybWF0IHJlcXVpcmVkIGZvciBwYXJzaW5nIHZlcnNpb25zXG4vLyBUaGUgY2hhaW5JRCBzaG91bGQgYmUgaW4gdGhlIGZvcm06IGB7aWRlbnRpZmllcn0te3ZlcnNpb259YFxuQ2hhaW5JZEhlbHBlci5WZXJzaW9uRm9ybWF0UmVnRXhwID0gLyguKyktKFtcXGRdKykvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29zbW9zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/cosmos/build/chain-id/cosmos.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/cosmos/build/chain-id/ethermint.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@keplr-wallet/cosmos/build/chain-id/ethermint.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EthermintChainIdHelper = void 0;\nconst cosmos_1 = __webpack_require__(/*! ./cosmos */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/chain-id/cosmos.js\");\nclass EthermintChainIdHelper {\n    static parse(chainId) {\n        const cosmosChainId = cosmos_1.ChainIdHelper.parse(chainId);\n        if (chainId.startsWith(\"injective\")) {\n            const injectiveTestnetChainIds = [\"injective-777\", \"injective-888\"];\n            if (injectiveTestnetChainIds.includes(chainId)) {\n                return Object.assign({ ethChainId: 5 }, cosmosChainId);\n            }\n            return Object.assign({ ethChainId: 1 }, cosmosChainId);\n        }\n        const matches = chainId.match(\"^([a-z]{1,})_{1}([1-9][0-9]*)-{1}([1-9][0-9]*)$\");\n        if (!matches ||\n            matches.length !== 4 ||\n            matches[1] === \"\" ||\n            Number.isNaN(parseFloat(matches[2])) ||\n            !Number.isInteger(parseFloat(matches[2]))) {\n            throw new Error(`Invalid chainId for ethermint: ${chainId}`);\n        }\n        return Object.assign(Object.assign({}, cosmosChainId), { ethChainId: parseFloat(matches[2]) });\n    }\n}\nexports.EthermintChainIdHelper = EthermintChainIdHelper;\n//# sourceMappingURL=ethermint.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvY2hhaW4taWQvZXRoZXJtaW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QjtBQUM5QixpQkFBaUIsbUJBQU8sQ0FBQyxvRkFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZTtBQUN0RDtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xEO0FBQ0EsK0NBQStDLEdBQUcsR0FBRyxFQUFFLGVBQWUsRUFBRTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFFBQVE7QUFDdEU7QUFDQSw2Q0FBNkMsb0JBQW9CLG9DQUFvQztBQUNyRztBQUNBO0FBQ0EsOEJBQThCO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvY2hhaW4taWQvZXRoZXJtaW50LmpzP2U3MmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV0aGVybWludENoYWluSWRIZWxwZXIgPSB2b2lkIDA7XG5jb25zdCBjb3Ntb3NfMSA9IHJlcXVpcmUoXCIuL2Nvc21vc1wiKTtcbmNsYXNzIEV0aGVybWludENoYWluSWRIZWxwZXIge1xuICAgIHN0YXRpYyBwYXJzZShjaGFpbklkKSB7XG4gICAgICAgIGNvbnN0IGNvc21vc0NoYWluSWQgPSBjb3Ntb3NfMS5DaGFpbklkSGVscGVyLnBhcnNlKGNoYWluSWQpO1xuICAgICAgICBpZiAoY2hhaW5JZC5zdGFydHNXaXRoKFwiaW5qZWN0aXZlXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBpbmplY3RpdmVUZXN0bmV0Q2hhaW5JZHMgPSBbXCJpbmplY3RpdmUtNzc3XCIsIFwiaW5qZWN0aXZlLTg4OFwiXTtcbiAgICAgICAgICAgIGlmIChpbmplY3RpdmVUZXN0bmV0Q2hhaW5JZHMuaW5jbHVkZXMoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IGV0aENoYWluSWQ6IDUgfSwgY29zbW9zQ2hhaW5JZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IGV0aENoYWluSWQ6IDEgfSwgY29zbW9zQ2hhaW5JZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGNoYWluSWQubWF0Y2goXCJeKFthLXpdezEsfSlfezF9KFsxLTldWzAtOV0qKS17MX0oWzEtOV1bMC05XSopJFwiKTtcbiAgICAgICAgaWYgKCFtYXRjaGVzIHx8XG4gICAgICAgICAgICBtYXRjaGVzLmxlbmd0aCAhPT0gNCB8fFxuICAgICAgICAgICAgbWF0Y2hlc1sxXSA9PT0gXCJcIiB8fFxuICAgICAgICAgICAgTnVtYmVyLmlzTmFOKHBhcnNlRmxvYXQobWF0Y2hlc1syXSkpIHx8XG4gICAgICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihwYXJzZUZsb2F0KG1hdGNoZXNbMl0pKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoYWluSWQgZm9yIGV0aGVybWludDogJHtjaGFpbklkfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvc21vc0NoYWluSWQpLCB7IGV0aENoYWluSWQ6IHBhcnNlRmxvYXQobWF0Y2hlc1syXSkgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5FdGhlcm1pbnRDaGFpbklkSGVscGVyID0gRXRoZXJtaW50Q2hhaW5JZEhlbHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV0aGVybWludC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/cosmos/build/chain-id/ethermint.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/cosmos/build/chain-id/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@keplr-wallet/cosmos/build/chain-id/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./cosmos */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/chain-id/cosmos.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ethermint */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/chain-id/ethermint.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvY2hhaW4taWQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLG9GQUFVO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQywwRkFBYTtBQUNsQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvY29zbW9zL2J1aWxkL2NoYWluLWlkL2luZGV4LmpzPzY0MmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb3Ntb3NcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V0aGVybWludFwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/cosmos/build/chain-id/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/cosmos/build/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@keplr-wallet/cosmos/build/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./account */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/account/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./bech32 */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/bech32/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./chain-id */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/chain-id/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./tx-tracer */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/tx-tracer/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./stargate */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/stargate/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./adr-36 */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/adr-36/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./signing */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/signing/index.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLG1GQUFXO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyxpRkFBVTtBQUMvQixhQUFhLG1CQUFPLENBQUMscUZBQVk7QUFDakMsYUFBYSxtQkFBTyxDQUFDLHVGQUFhO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxxRkFBWTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsaUZBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLG1GQUFXO0FBQ2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvaW5kZXguanM/YmNjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FjY291bnRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2JlY2gzMlwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2hhaW4taWRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R4LXRyYWNlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3RhcmdhdGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fkci0zNlwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2lnbmluZ1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/cosmos/build/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/cosmos/build/signing/encode.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@keplr-wallet/cosmos/build/signing/encode.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeSignDoc = exports.encodeSecp256k1Signature = exports.encodeSecp256k1Pubkey = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\nconst common_1 = __webpack_require__(/*! @keplr-wallet/common */ \"(ssr)/./node_modules/@keplr-wallet/common/build/index.js\");\nfunction encodeSecp256k1Pubkey(pubkey) {\n    if (pubkey.length !== 33 || (pubkey[0] !== 0x02 && pubkey[0] !== 0x03)) {\n        throw new Error(\"Public key must be compressed secp256k1, i.e. 33 bytes starting with 0x02 or 0x03\");\n    }\n    return {\n        type: \"tendermint/PubKeySecp256k1\",\n        value: buffer_1.Buffer.from(pubkey).toString(\"base64\"),\n    };\n}\nexports.encodeSecp256k1Pubkey = encodeSecp256k1Pubkey;\nfunction encodeSecp256k1Signature(pubkey, signature) {\n    if (signature.length !== 64) {\n        throw new Error(\"Signature must be 64 bytes long. Cosmos SDK uses a 2x32 byte fixed length encoding for the secp256k1 signature integers r and s.\");\n    }\n    return {\n        pub_key: encodeSecp256k1Pubkey(pubkey),\n        signature: buffer_1.Buffer.from(signature).toString(\"base64\"),\n    };\n}\nexports.encodeSecp256k1Signature = encodeSecp256k1Signature;\nfunction serializeSignDoc(signDoc) {\n    return buffer_1.Buffer.from((0, common_1.escapeHTML)((0, common_1.sortedJsonByKeyStringify)(signDoc)));\n}\nexports.serializeSignDoc = serializeSignDoc;\n//# sourceMappingURL=encode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvc2lnbmluZy9lbmNvZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsZ0NBQWdDLEdBQUcsNkJBQTZCO0FBQzNGLGlCQUFpQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2xDLGlCQUFpQixtQkFBTyxDQUFDLHNGQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvY29zbW9zL2J1aWxkL3NpZ25pbmcvZW5jb2RlLmpzP2Q3YjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNlcmlhbGl6ZVNpZ25Eb2MgPSBleHBvcnRzLmVuY29kZVNlY3AyNTZrMVNpZ25hdHVyZSA9IGV4cG9ydHMuZW5jb2RlU2VjcDI1NmsxUHVia2V5ID0gdm9pZCAwO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIkBrZXBsci13YWxsZXQvY29tbW9uXCIpO1xuZnVuY3Rpb24gZW5jb2RlU2VjcDI1NmsxUHVia2V5KHB1YmtleSkge1xuICAgIGlmIChwdWJrZXkubGVuZ3RoICE9PSAzMyB8fCAocHVia2V5WzBdICE9PSAweDAyICYmIHB1YmtleVswXSAhPT0gMHgwMykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHVibGljIGtleSBtdXN0IGJlIGNvbXByZXNzZWQgc2VjcDI1NmsxLCBpLmUuIDMzIGJ5dGVzIHN0YXJ0aW5nIHdpdGggMHgwMiBvciAweDAzXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInRlbmRlcm1pbnQvUHViS2V5U2VjcDI1NmsxXCIsXG4gICAgICAgIHZhbHVlOiBidWZmZXJfMS5CdWZmZXIuZnJvbShwdWJrZXkpLnRvU3RyaW5nKFwiYmFzZTY0XCIpLFxuICAgIH07XG59XG5leHBvcnRzLmVuY29kZVNlY3AyNTZrMVB1YmtleSA9IGVuY29kZVNlY3AyNTZrMVB1YmtleTtcbmZ1bmN0aW9uIGVuY29kZVNlY3AyNTZrMVNpZ25hdHVyZShwdWJrZXksIHNpZ25hdHVyZSkge1xuICAgIGlmIChzaWduYXR1cmUubGVuZ3RoICE9PSA2NCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWduYXR1cmUgbXVzdCBiZSA2NCBieXRlcyBsb25nLiBDb3Ntb3MgU0RLIHVzZXMgYSAyeDMyIGJ5dGUgZml4ZWQgbGVuZ3RoIGVuY29kaW5nIGZvciB0aGUgc2VjcDI1NmsxIHNpZ25hdHVyZSBpbnRlZ2VycyByIGFuZCBzLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHViX2tleTogZW5jb2RlU2VjcDI1NmsxUHVia2V5KHB1YmtleSksXG4gICAgICAgIHNpZ25hdHVyZTogYnVmZmVyXzEuQnVmZmVyLmZyb20oc2lnbmF0dXJlKS50b1N0cmluZyhcImJhc2U2NFwiKSxcbiAgICB9O1xufVxuZXhwb3J0cy5lbmNvZGVTZWNwMjU2azFTaWduYXR1cmUgPSBlbmNvZGVTZWNwMjU2azFTaWduYXR1cmU7XG5mdW5jdGlvbiBzZXJpYWxpemVTaWduRG9jKHNpZ25Eb2MpIHtcbiAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20oKDAsIGNvbW1vbl8xLmVzY2FwZUhUTUwpKCgwLCBjb21tb25fMS5zb3J0ZWRKc29uQnlLZXlTdHJpbmdpZnkpKHNpZ25Eb2MpKSk7XG59XG5leHBvcnRzLnNlcmlhbGl6ZVNpZ25Eb2MgPSBzZXJpYWxpemVTaWduRG9jO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5jb2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/cosmos/build/signing/encode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/cosmos/build/signing/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@keplr-wallet/cosmos/build/signing/index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./encode */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/signing/encode.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvc2lnbmluZy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsbUZBQVU7QUFDL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L2Nvc21vcy9idWlsZC9zaWduaW5nL2luZGV4LmpzPzNjZDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lbmNvZGVcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/cosmos/build/signing/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/cosmos/build/stargate/codec/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/cosmos/build/stargate/codec/index.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultProtoCodec = exports.ProtoCodec = void 0;\nconst msgs_1 = __webpack_require__(/*! @keplr-wallet/proto-types/agoric/swingset/msgs */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/agoric/swingset/msgs.js\");\nconst tx_1 = __webpack_require__(/*! @keplr-wallet/proto-types/cosmos/bank/v1beta1/tx */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/tx.js\");\nconst tx_2 = __webpack_require__(/*! @keplr-wallet/proto-types/cosmos/staking/v1beta1/tx */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/tx.js\");\nconst tx_3 = __webpack_require__(/*! @keplr-wallet/proto-types/cosmos/authz/v1beta1/tx */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/authz/v1beta1/tx.js\");\nconst tx_4 = __webpack_require__(/*! @keplr-wallet/proto-types/cosmos/gov/v1beta1/tx */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/gov/v1beta1/tx.js\");\nconst tx_5 = __webpack_require__(/*! @keplr-wallet/proto-types/cosmos/distribution/v1beta1/tx */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/distribution/v1beta1/tx.js\");\nconst tx_6 = __webpack_require__(/*! @keplr-wallet/proto-types/cosmwasm/wasm/v1/tx */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmwasm/wasm/v1/tx.js\");\nconst tx_7 = __webpack_require__(/*! @keplr-wallet/proto-types/ibc/applications/transfer/v1/tx */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/ibc/applications/transfer/v1/tx.js\");\nconst unknown_1 = __webpack_require__(/*! ./unknown */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/stargate/codec/unknown.js\");\nconst authz_1 = __webpack_require__(/*! @keplr-wallet/proto-types/cosmos/authz/v1beta1/authz */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/authz/v1beta1/authz.js\");\nconst authz_2 = __webpack_require__(/*! @keplr-wallet/proto-types/cosmos/staking/v1beta1/authz */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/authz.js\");\nconst authz_3 = __webpack_require__(/*! @keplr-wallet/proto-types/cosmos/bank/v1beta1/authz */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/authz.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\n__exportStar(__webpack_require__(/*! ./unknown */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/stargate/codec/unknown.js\"), exports);\nclass ProtoCodec {\n    constructor() {\n        this.typeUrlMap = new Map();\n    }\n    unpackAnyFactory(typeUrl) {\n        if (!this.typeUrlMap.has(typeUrl)) {\n            return undefined;\n        }\n        return this.typeUrlMap.get(typeUrl);\n    }\n    /**\n     * Unpack the any to the registered message.\n     * NOTE: If there is no matched message, it will not throw an error but return the `UnknownMessage` class.\n     * @param any\n     */\n    unpackAny(any) {\n        const factory = this.unpackAnyFactory(any.typeUrl);\n        if (!factory) {\n            return new unknown_1.UnknownMessage(any.typeUrl, any.value);\n        }\n        const unpacked = factory.decode(any.value);\n        return Object.assign(Object.assign({}, any), { unpacked });\n    }\n    unpackedAnyToJSONRecursive(unpacked) {\n        if (unpacked instanceof unknown_1.UnknownMessage) {\n            return unpacked.toJSON();\n        }\n        const factory = this.unpackAnyFactory(unpacked.typeUrl);\n        if (factory && \"unpacked\" in unpacked && unpacked.unpacked) {\n            const isJSONEncodedAny = (any) => {\n                const r = typeof any === \"object\" &&\n                    !(any instanceof unknown_1.UnknownMessage) &&\n                    \"typeUrl\" in any &&\n                    any.typeUrl &&\n                    typeof any.typeUrl === \"string\" &&\n                    \"value\" in any &&\n                    any.value &&\n                    typeof any.value === \"string\";\n                if (r) {\n                    try {\n                        buffer_1.Buffer.from(any.value, \"base64\");\n                    }\n                    catch (_a) {\n                        return false;\n                    }\n                }\n                return r;\n            };\n            const unpackJSONEncodedAnyInner = (jsonEncodedAny) => {\n                const factory = this.unpackAnyFactory(jsonEncodedAny.typeUrl);\n                const bz = buffer_1.Buffer.from(jsonEncodedAny.value, \"base64\");\n                if (!factory) {\n                    return new unknown_1.UnknownMessage(jsonEncodedAny.typeUrl, bz).toJSON();\n                }\n                const unpacked = factory.decode(bz);\n                return {\n                    typeUrl: jsonEncodedAny.typeUrl,\n                    value: factory.toJSON(unpacked),\n                };\n            };\n            const unpackedJSONEncodedAnyRecursive = (obj) => {\n                if (Array.isArray(obj)) {\n                    for (let i = 0; i < obj.length; i++) {\n                        const value = obj[i];\n                        if (isJSONEncodedAny(value)) {\n                            obj[i] = unpackJSONEncodedAnyInner(value);\n                        }\n                        else if (typeof value === \"object\") {\n                            obj[i] = unpackedJSONEncodedAnyRecursive(value);\n                        }\n                    }\n                }\n                else {\n                    for (const key in obj) {\n                        const value = obj[key];\n                        if (isJSONEncodedAny(value)) {\n                            obj[key] = unpackJSONEncodedAnyInner(value);\n                        }\n                        else if (typeof value === \"object\") {\n                            obj[key] = unpackedJSONEncodedAnyRecursive(value);\n                        }\n                    }\n                }\n                return obj;\n            };\n            // This is mutated by logic.\n            let mutObj = factory.toJSON(unpacked.unpacked);\n            if (mutObj && typeof mutObj === \"object\") {\n                mutObj = unpackedJSONEncodedAnyRecursive(mutObj);\n                return {\n                    typeUrl: unpacked.typeUrl,\n                    value: mutObj,\n                };\n            }\n        }\n        return new unknown_1.UnknownMessage(unpacked.typeUrl, unpacked.value).toJSON();\n    }\n    registerAny(typeUrl, message) {\n        this.typeUrlMap.set(typeUrl, message);\n    }\n}\nexports.ProtoCodec = ProtoCodec;\nexports.defaultProtoCodec = new ProtoCodec();\nexports.defaultProtoCodec.registerAny(\"/agoric.swingset.MsgWalletSpendAction\", msgs_1.MsgWalletSpendAction);\nexports.defaultProtoCodec.registerAny(\"/agoric.swingset.MsgProvision\", msgs_1.MsgProvision);\nexports.defaultProtoCodec.registerAny(\"/cosmos.bank.v1beta1.MsgSend\", tx_1.MsgSend);\nexports.defaultProtoCodec.registerAny(\"/cosmos.bank.v1beta1.MsgMultiSend\", tx_1.MsgMultiSend);\nexports.defaultProtoCodec.registerAny(\"/cosmos.staking.v1beta1.MsgDelegate\", tx_2.MsgDelegate);\nexports.defaultProtoCodec.registerAny(\"/cosmos.staking.v1beta1.MsgUndelegate\", tx_2.MsgUndelegate);\nexports.defaultProtoCodec.registerAny(\"/cosmos.staking.v1beta1.MsgBeginRedelegate\", tx_2.MsgBeginRedelegate);\nexports.defaultProtoCodec.registerAny(\"/cosmwasm.wasm.v1.MsgExecuteContract\", tx_6.MsgExecuteContract);\nexports.defaultProtoCodec.registerAny(\"/cosmwasm.wasm.v1.MsgInstantiateContract\", tx_6.MsgInstantiateContract);\nexports.defaultProtoCodec.registerAny(\"/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward\", tx_5.MsgWithdrawDelegatorReward);\nexports.defaultProtoCodec.registerAny(\"/cosmos.distribution.v1beta1.MsgSetWithdrawAddress\", tx_5.MsgSetWithdrawAddress);\nexports.defaultProtoCodec.registerAny(\"/ibc.applications.transfer.v1.MsgTransfer\", tx_7.MsgTransfer);\nexports.defaultProtoCodec.registerAny(\"/cosmos.gov.v1beta1.MsgVote\", tx_4.MsgVote);\nexports.defaultProtoCodec.registerAny(\"/cosmos.authz.v1beta1.MsgGrant\", tx_3.MsgGrant);\n// ----- Authz grants -----\nexports.defaultProtoCodec.registerAny(\"/cosmos.authz.v1beta1.GenericAuthorization\", authz_1.GenericAuthorization);\nexports.defaultProtoCodec.registerAny(\"/cosmos.staking.v1beta1.StakeAuthorization\", authz_2.StakeAuthorization);\nexports.defaultProtoCodec.registerAny(\"/cosmos.bank.v1beta1.SendAuthorization\", authz_3.SendAuthorization);\n// ----- Authz grants -----\nexports.defaultProtoCodec.registerAny(\"/cosmos.authz.v1beta1.MsgRevoke\", tx_3.MsgRevoke);\nexports.defaultProtoCodec.registerAny(\"/cosmos.authz.v1beta1.MsgExec\", tx_3.MsgExec);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvc3RhcmdhdGUvY29kZWMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLEdBQUcsa0JBQWtCO0FBQzlDLGVBQWUsbUJBQU8sQ0FBQyw4SEFBZ0Q7QUFDdkUsYUFBYSxtQkFBTyxDQUFDLGtJQUFrRDtBQUN2RSxhQUFhLG1CQUFPLENBQUMsd0lBQXFEO0FBQzFFLGFBQWEsbUJBQU8sQ0FBQyxvSUFBbUQ7QUFDeEUsYUFBYSxtQkFBTyxDQUFDLGdJQUFpRDtBQUN0RSxhQUFhLG1CQUFPLENBQUMsa0pBQTBEO0FBQy9FLGFBQWEsbUJBQU8sQ0FBQyw0SEFBK0M7QUFDcEUsYUFBYSxtQkFBTyxDQUFDLG9KQUEyRDtBQUNoRixrQkFBa0IsbUJBQU8sQ0FBQyw0RkFBVztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQywwSUFBc0Q7QUFDOUUsZ0JBQWdCLG1CQUFPLENBQUMsOElBQXdEO0FBQ2hGLGdCQUFnQixtQkFBTyxDQUFDLHdJQUFxRDtBQUM3RSxpQkFBaUIsbUJBQU8sQ0FBQyxxREFBUztBQUNsQyxhQUFhLG1CQUFPLENBQUMsNEZBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFVBQVUsVUFBVTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L2Nvc21vcy9idWlsZC9zdGFyZ2F0ZS9jb2RlYy9pbmRleC5qcz8xYmYxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHRQcm90b0NvZGVjID0gZXhwb3J0cy5Qcm90b0NvZGVjID0gdm9pZCAwO1xuY29uc3QgbXNnc18xID0gcmVxdWlyZShcIkBrZXBsci13YWxsZXQvcHJvdG8tdHlwZXMvYWdvcmljL3N3aW5nc2V0L21zZ3NcIik7XG5jb25zdCB0eF8xID0gcmVxdWlyZShcIkBrZXBsci13YWxsZXQvcHJvdG8tdHlwZXMvY29zbW9zL2JhbmsvdjFiZXRhMS90eFwiKTtcbmNvbnN0IHR4XzIgPSByZXF1aXJlKFwiQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3Mvc3Rha2luZy92MWJldGExL3R4XCIpO1xuY29uc3QgdHhfMyA9IHJlcXVpcmUoXCJAa2VwbHItd2FsbGV0L3Byb3RvLXR5cGVzL2Nvc21vcy9hdXRoei92MWJldGExL3R4XCIpO1xuY29uc3QgdHhfNCA9IHJlcXVpcmUoXCJAa2VwbHItd2FsbGV0L3Byb3RvLXR5cGVzL2Nvc21vcy9nb3YvdjFiZXRhMS90eFwiKTtcbmNvbnN0IHR4XzUgPSByZXF1aXJlKFwiQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3MvZGlzdHJpYnV0aW9uL3YxYmV0YTEvdHhcIik7XG5jb25zdCB0eF82ID0gcmVxdWlyZShcIkBrZXBsci13YWxsZXQvcHJvdG8tdHlwZXMvY29zbXdhc20vd2FzbS92MS90eFwiKTtcbmNvbnN0IHR4XzcgPSByZXF1aXJlKFwiQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9pYmMvYXBwbGljYXRpb25zL3RyYW5zZmVyL3YxL3R4XCIpO1xuY29uc3QgdW5rbm93bl8xID0gcmVxdWlyZShcIi4vdW5rbm93blwiKTtcbmNvbnN0IGF1dGh6XzEgPSByZXF1aXJlKFwiQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3MvYXV0aHovdjFiZXRhMS9hdXRoelwiKTtcbmNvbnN0IGF1dGh6XzIgPSByZXF1aXJlKFwiQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3Mvc3Rha2luZy92MWJldGExL2F1dGh6XCIpO1xuY29uc3QgYXV0aHpfMyA9IHJlcXVpcmUoXCJAa2VwbHItd2FsbGV0L3Byb3RvLXR5cGVzL2Nvc21vcy9iYW5rL3YxYmV0YTEvYXV0aHpcIik7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Vua25vd25cIiksIGV4cG9ydHMpO1xuY2xhc3MgUHJvdG9Db2RlYyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudHlwZVVybE1hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgdW5wYWNrQW55RmFjdG9yeSh0eXBlVXJsKSB7XG4gICAgICAgIGlmICghdGhpcy50eXBlVXJsTWFwLmhhcyh0eXBlVXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50eXBlVXJsTWFwLmdldCh0eXBlVXJsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5wYWNrIHRoZSBhbnkgdG8gdGhlIHJlZ2lzdGVyZWQgbWVzc2FnZS5cbiAgICAgKiBOT1RFOiBJZiB0aGVyZSBpcyBubyBtYXRjaGVkIG1lc3NhZ2UsIGl0IHdpbGwgbm90IHRocm93IGFuIGVycm9yIGJ1dCByZXR1cm4gdGhlIGBVbmtub3duTWVzc2FnZWAgY2xhc3MuXG4gICAgICogQHBhcmFtIGFueVxuICAgICAqL1xuICAgIHVucGFja0FueShhbnkpIHtcbiAgICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXMudW5wYWNrQW55RmFjdG9yeShhbnkudHlwZVVybCk7XG4gICAgICAgIGlmICghZmFjdG9yeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB1bmtub3duXzEuVW5rbm93bk1lc3NhZ2UoYW55LnR5cGVVcmwsIGFueS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdW5wYWNrZWQgPSBmYWN0b3J5LmRlY29kZShhbnkudmFsdWUpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhbnkpLCB7IHVucGFja2VkIH0pO1xuICAgIH1cbiAgICB1bnBhY2tlZEFueVRvSlNPTlJlY3Vyc2l2ZSh1bnBhY2tlZCkge1xuICAgICAgICBpZiAodW5wYWNrZWQgaW5zdGFuY2VvZiB1bmtub3duXzEuVW5rbm93bk1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiB1bnBhY2tlZC50b0pTT04oKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy51bnBhY2tBbnlGYWN0b3J5KHVucGFja2VkLnR5cGVVcmwpO1xuICAgICAgICBpZiAoZmFjdG9yeSAmJiBcInVucGFja2VkXCIgaW4gdW5wYWNrZWQgJiYgdW5wYWNrZWQudW5wYWNrZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzSlNPTkVuY29kZWRBbnkgPSAoYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IHR5cGVvZiBhbnkgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgIShhbnkgaW5zdGFuY2VvZiB1bmtub3duXzEuVW5rbm93bk1lc3NhZ2UpICYmXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVVybFwiIGluIGFueSAmJlxuICAgICAgICAgICAgICAgICAgICBhbnkudHlwZVVybCAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgYW55LnR5cGVVcmwgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZVwiIGluIGFueSAmJlxuICAgICAgICAgICAgICAgICAgICBhbnkudmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGFueS52YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyXzEuQnVmZmVyLmZyb20oYW55LnZhbHVlLCBcImJhc2U2NFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB1bnBhY2tKU09ORW5jb2RlZEFueUlubmVyID0gKGpzb25FbmNvZGVkQW55KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXMudW5wYWNrQW55RmFjdG9yeShqc29uRW5jb2RlZEFueS50eXBlVXJsKTtcbiAgICAgICAgICAgICAgICBjb25zdCBieiA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGpzb25FbmNvZGVkQW55LnZhbHVlLCBcImJhc2U2NFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoIWZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB1bmtub3duXzEuVW5rbm93bk1lc3NhZ2UoanNvbkVuY29kZWRBbnkudHlwZVVybCwgYnopLnRvSlNPTigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB1bnBhY2tlZCA9IGZhY3RvcnkuZGVjb2RlKGJ6KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlVXJsOiBqc29uRW5jb2RlZEFueS50eXBlVXJsLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZmFjdG9yeS50b0pTT04odW5wYWNrZWQpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdW5wYWNrZWRKU09ORW5jb2RlZEFueVJlY3Vyc2l2ZSA9IChvYmopID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0pTT05FbmNvZGVkQW55KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtpXSA9IHVucGFja0pTT05FbmNvZGVkQW55SW5uZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2ldID0gdW5wYWNrZWRKU09ORW5jb2RlZEFueVJlY3Vyc2l2ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0pTT05FbmNvZGVkQW55KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdW5wYWNrSlNPTkVuY29kZWRBbnlJbm5lcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHVucGFja2VkSlNPTkVuY29kZWRBbnlSZWN1cnNpdmUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBtdXRhdGVkIGJ5IGxvZ2ljLlxuICAgICAgICAgICAgbGV0IG11dE9iaiA9IGZhY3RvcnkudG9KU09OKHVucGFja2VkLnVucGFja2VkKTtcbiAgICAgICAgICAgIGlmIChtdXRPYmogJiYgdHlwZW9mIG11dE9iaiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIG11dE9iaiA9IHVucGFja2VkSlNPTkVuY29kZWRBbnlSZWN1cnNpdmUobXV0T2JqKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlVXJsOiB1bnBhY2tlZC50eXBlVXJsLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbXV0T2JqLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyB1bmtub3duXzEuVW5rbm93bk1lc3NhZ2UodW5wYWNrZWQudHlwZVVybCwgdW5wYWNrZWQudmFsdWUpLnRvSlNPTigpO1xuICAgIH1cbiAgICByZWdpc3RlckFueSh0eXBlVXJsLCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMudHlwZVVybE1hcC5zZXQodHlwZVVybCwgbWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm90b0NvZGVjID0gUHJvdG9Db2RlYztcbmV4cG9ydHMuZGVmYXVsdFByb3RvQ29kZWMgPSBuZXcgUHJvdG9Db2RlYygpO1xuZXhwb3J0cy5kZWZhdWx0UHJvdG9Db2RlYy5yZWdpc3RlckFueShcIi9hZ29yaWMuc3dpbmdzZXQuTXNnV2FsbGV0U3BlbmRBY3Rpb25cIiwgbXNnc18xLk1zZ1dhbGxldFNwZW5kQWN0aW9uKTtcbmV4cG9ydHMuZGVmYXVsdFByb3RvQ29kZWMucmVnaXN0ZXJBbnkoXCIvYWdvcmljLnN3aW5nc2V0Lk1zZ1Byb3Zpc2lvblwiLCBtc2dzXzEuTXNnUHJvdmlzaW9uKTtcbmV4cG9ydHMuZGVmYXVsdFByb3RvQ29kZWMucmVnaXN0ZXJBbnkoXCIvY29zbW9zLmJhbmsudjFiZXRhMS5Nc2dTZW5kXCIsIHR4XzEuTXNnU2VuZCk7XG5leHBvcnRzLmRlZmF1bHRQcm90b0NvZGVjLnJlZ2lzdGVyQW55KFwiL2Nvc21vcy5iYW5rLnYxYmV0YTEuTXNnTXVsdGlTZW5kXCIsIHR4XzEuTXNnTXVsdGlTZW5kKTtcbmV4cG9ydHMuZGVmYXVsdFByb3RvQ29kZWMucmVnaXN0ZXJBbnkoXCIvY29zbW9zLnN0YWtpbmcudjFiZXRhMS5Nc2dEZWxlZ2F0ZVwiLCB0eF8yLk1zZ0RlbGVnYXRlKTtcbmV4cG9ydHMuZGVmYXVsdFByb3RvQ29kZWMucmVnaXN0ZXJBbnkoXCIvY29zbW9zLnN0YWtpbmcudjFiZXRhMS5Nc2dVbmRlbGVnYXRlXCIsIHR4XzIuTXNnVW5kZWxlZ2F0ZSk7XG5leHBvcnRzLmRlZmF1bHRQcm90b0NvZGVjLnJlZ2lzdGVyQW55KFwiL2Nvc21vcy5zdGFraW5nLnYxYmV0YTEuTXNnQmVnaW5SZWRlbGVnYXRlXCIsIHR4XzIuTXNnQmVnaW5SZWRlbGVnYXRlKTtcbmV4cG9ydHMuZGVmYXVsdFByb3RvQ29kZWMucmVnaXN0ZXJBbnkoXCIvY29zbXdhc20ud2FzbS52MS5Nc2dFeGVjdXRlQ29udHJhY3RcIiwgdHhfNi5Nc2dFeGVjdXRlQ29udHJhY3QpO1xuZXhwb3J0cy5kZWZhdWx0UHJvdG9Db2RlYy5yZWdpc3RlckFueShcIi9jb3Ntd2FzbS53YXNtLnYxLk1zZ0luc3RhbnRpYXRlQ29udHJhY3RcIiwgdHhfNi5Nc2dJbnN0YW50aWF0ZUNvbnRyYWN0KTtcbmV4cG9ydHMuZGVmYXVsdFByb3RvQ29kZWMucmVnaXN0ZXJBbnkoXCIvY29zbW9zLmRpc3RyaWJ1dGlvbi52MWJldGExLk1zZ1dpdGhkcmF3RGVsZWdhdG9yUmV3YXJkXCIsIHR4XzUuTXNnV2l0aGRyYXdEZWxlZ2F0b3JSZXdhcmQpO1xuZXhwb3J0cy5kZWZhdWx0UHJvdG9Db2RlYy5yZWdpc3RlckFueShcIi9jb3Ntb3MuZGlzdHJpYnV0aW9uLnYxYmV0YTEuTXNnU2V0V2l0aGRyYXdBZGRyZXNzXCIsIHR4XzUuTXNnU2V0V2l0aGRyYXdBZGRyZXNzKTtcbmV4cG9ydHMuZGVmYXVsdFByb3RvQ29kZWMucmVnaXN0ZXJBbnkoXCIvaWJjLmFwcGxpY2F0aW9ucy50cmFuc2Zlci52MS5Nc2dUcmFuc2ZlclwiLCB0eF83Lk1zZ1RyYW5zZmVyKTtcbmV4cG9ydHMuZGVmYXVsdFByb3RvQ29kZWMucmVnaXN0ZXJBbnkoXCIvY29zbW9zLmdvdi52MWJldGExLk1zZ1ZvdGVcIiwgdHhfNC5Nc2dWb3RlKTtcbmV4cG9ydHMuZGVmYXVsdFByb3RvQ29kZWMucmVnaXN0ZXJBbnkoXCIvY29zbW9zLmF1dGh6LnYxYmV0YTEuTXNnR3JhbnRcIiwgdHhfMy5Nc2dHcmFudCk7XG4vLyAtLS0tLSBBdXRoeiBncmFudHMgLS0tLS1cbmV4cG9ydHMuZGVmYXVsdFByb3RvQ29kZWMucmVnaXN0ZXJBbnkoXCIvY29zbW9zLmF1dGh6LnYxYmV0YTEuR2VuZXJpY0F1dGhvcml6YXRpb25cIiwgYXV0aHpfMS5HZW5lcmljQXV0aG9yaXphdGlvbik7XG5leHBvcnRzLmRlZmF1bHRQcm90b0NvZGVjLnJlZ2lzdGVyQW55KFwiL2Nvc21vcy5zdGFraW5nLnYxYmV0YTEuU3Rha2VBdXRob3JpemF0aW9uXCIsIGF1dGh6XzIuU3Rha2VBdXRob3JpemF0aW9uKTtcbmV4cG9ydHMuZGVmYXVsdFByb3RvQ29kZWMucmVnaXN0ZXJBbnkoXCIvY29zbW9zLmJhbmsudjFiZXRhMS5TZW5kQXV0aG9yaXphdGlvblwiLCBhdXRoel8zLlNlbmRBdXRob3JpemF0aW9uKTtcbi8vIC0tLS0tIEF1dGh6IGdyYW50cyAtLS0tLVxuZXhwb3J0cy5kZWZhdWx0UHJvdG9Db2RlYy5yZWdpc3RlckFueShcIi9jb3Ntb3MuYXV0aHoudjFiZXRhMS5Nc2dSZXZva2VcIiwgdHhfMy5Nc2dSZXZva2UpO1xuZXhwb3J0cy5kZWZhdWx0UHJvdG9Db2RlYy5yZWdpc3RlckFueShcIi9jb3Ntb3MuYXV0aHoudjFiZXRhMS5Nc2dFeGVjXCIsIHR4XzMuTXNnRXhlYyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/cosmos/build/stargate/codec/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/cosmos/build/stargate/codec/unknown.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/cosmos/build/stargate/codec/unknown.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UnknownMessage = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\nclass UnknownMessage {\n    constructor(\n    /** Any type_url. */\n    _typeUrl, \n    /** Any value. */\n    _value) {\n        this._typeUrl = _typeUrl;\n        this._value = _value;\n    }\n    get typeUrl() {\n        return this._typeUrl;\n    }\n    get value() {\n        return this._value;\n    }\n    toJSON() {\n        return {\n            typeUrl: this._typeUrl,\n            value: buffer_1.Buffer.from(this._value).toString(\"base64\"),\n        };\n    }\n}\nexports.UnknownMessage = UnknownMessage;\n//# sourceMappingURL=unknown.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvc3RhcmdhdGUvY29kZWMvdW5rbm93bi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsaUJBQWlCLG1CQUFPLENBQUMscURBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L2Nvc21vcy9idWlsZC9zdGFyZ2F0ZS9jb2RlYy91bmtub3duLmpzPzUyYmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVua25vd25NZXNzYWdlID0gdm9pZCAwO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbmNsYXNzIFVua25vd25NZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKiogQW55IHR5cGVfdXJsLiAqL1xuICAgIF90eXBlVXJsLCBcbiAgICAvKiogQW55IHZhbHVlLiAqL1xuICAgIF92YWx1ZSkge1xuICAgICAgICB0aGlzLl90eXBlVXJsID0gX3R5cGVVcmw7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xuICAgIH1cbiAgICBnZXQgdHlwZVVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGVVcmw7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlVXJsOiB0aGlzLl90eXBlVXJsLFxuICAgICAgICAgICAgdmFsdWU6IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHRoaXMuX3ZhbHVlKS50b1N0cmluZyhcImJhc2U2NFwiKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlVua25vd25NZXNzYWdlID0gVW5rbm93bk1lc3NhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmtub3duLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/cosmos/build/stargate/codec/unknown.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/cosmos/build/stargate/decoder/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/cosmos/build/stargate/decoder/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ProtoSignDocDecoder = void 0;\nconst tx_1 = __webpack_require__(/*! @keplr-wallet/proto-types/cosmos/tx/v1beta1/tx */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/tx/v1beta1/tx.js\");\nconst codec_1 = __webpack_require__(/*! ../codec */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/stargate/codec/index.js\");\nclass ProtoSignDocDecoder {\n    static decode(bytes) {\n        return new ProtoSignDocDecoder(tx_1.SignDoc.decode(bytes));\n    }\n    constructor(signDoc, protoCodec = codec_1.defaultProtoCodec) {\n        this.signDoc = signDoc;\n        this.protoCodec = protoCodec;\n    }\n    get txBody() {\n        if (!this._txBody) {\n            this._txBody = tx_1.TxBody.decode(this.signDoc.bodyBytes);\n        }\n        return this._txBody;\n    }\n    get txMsgs() {\n        const msgs = [];\n        for (const msg of this.txBody.messages) {\n            msgs.push(this.protoCodec.unpackAny(msg));\n        }\n        return msgs;\n    }\n    get authInfo() {\n        if (!this._authInfo) {\n            this._authInfo = tx_1.AuthInfo.decode(this.signDoc.authInfoBytes);\n        }\n        return this._authInfo;\n    }\n    get chainId() {\n        return this.signDoc.chainId;\n    }\n    get accountNumber() {\n        return this.signDoc.accountNumber.toString();\n    }\n    toBytes() {\n        return tx_1.SignDoc.encode(this.signDoc).finish();\n    }\n    toJSON() {\n        return {\n            txBody: Object.assign(Object.assign({}, tx_1.TxBody.toJSON(this.txBody)), {\n                messages: this.txMsgs.map((msg) => {\n                    return this.protoCodec.unpackedAnyToJSONRecursive(msg);\n                }),\n            }),\n            authInfo: tx_1.AuthInfo.toJSON(this.authInfo),\n            chainId: this.chainId,\n            accountNumber: this.accountNumber,\n        };\n    }\n}\nexports.ProtoSignDocDecoder = ProtoSignDocDecoder;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvc3RhcmdhdGUvZGVjb2Rlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0IsYUFBYSxtQkFBTyxDQUFDLDhIQUFnRDtBQUNyRSxnQkFBZ0IsbUJBQU8sQ0FBQyx5RkFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvY29zbW9zL2J1aWxkL3N0YXJnYXRlL2RlY29kZXIvaW5kZXguanM/OThjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJvdG9TaWduRG9jRGVjb2RlciA9IHZvaWQgMDtcbmNvbnN0IHR4XzEgPSByZXF1aXJlKFwiQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3MvdHgvdjFiZXRhMS90eFwiKTtcbmNvbnN0IGNvZGVjXzEgPSByZXF1aXJlKFwiLi4vY29kZWNcIik7XG5jbGFzcyBQcm90b1NpZ25Eb2NEZWNvZGVyIHtcbiAgICBzdGF0aWMgZGVjb2RlKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvdG9TaWduRG9jRGVjb2Rlcih0eF8xLlNpZ25Eb2MuZGVjb2RlKGJ5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHNpZ25Eb2MsIHByb3RvQ29kZWMgPSBjb2RlY18xLmRlZmF1bHRQcm90b0NvZGVjKSB7XG4gICAgICAgIHRoaXMuc2lnbkRvYyA9IHNpZ25Eb2M7XG4gICAgICAgIHRoaXMucHJvdG9Db2RlYyA9IHByb3RvQ29kZWM7XG4gICAgfVxuICAgIGdldCB0eEJvZHkoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdHhCb2R5KSB7XG4gICAgICAgICAgICB0aGlzLl90eEJvZHkgPSB0eF8xLlR4Qm9keS5kZWNvZGUodGhpcy5zaWduRG9jLmJvZHlCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3R4Qm9keTtcbiAgICB9XG4gICAgZ2V0IHR4TXNncygpIHtcbiAgICAgICAgY29uc3QgbXNncyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG1zZyBvZiB0aGlzLnR4Qm9keS5tZXNzYWdlcykge1xuICAgICAgICAgICAgbXNncy5wdXNoKHRoaXMucHJvdG9Db2RlYy51bnBhY2tBbnkobXNnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1zZ3M7XG4gICAgfVxuICAgIGdldCBhdXRoSW5mbygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hdXRoSW5mbykge1xuICAgICAgICAgICAgdGhpcy5fYXV0aEluZm8gPSB0eF8xLkF1dGhJbmZvLmRlY29kZSh0aGlzLnNpZ25Eb2MuYXV0aEluZm9CeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1dGhJbmZvO1xuICAgIH1cbiAgICBnZXQgY2hhaW5JZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbkRvYy5jaGFpbklkO1xuICAgIH1cbiAgICBnZXQgYWNjb3VudE51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbkRvYy5hY2NvdW50TnVtYmVyLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRvQnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0eF8xLlNpZ25Eb2MuZW5jb2RlKHRoaXMuc2lnbkRvYykuZmluaXNoKCk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR4Qm9keTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0eF8xLlR4Qm9keS50b0pTT04odGhpcy50eEJvZHkpKSwge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiB0aGlzLnR4TXNncy5tYXAoKG1zZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm90b0NvZGVjLnVucGFja2VkQW55VG9KU09OUmVjdXJzaXZlKG1zZyk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGF1dGhJbmZvOiB0eF8xLkF1dGhJbmZvLnRvSlNPTih0aGlzLmF1dGhJbmZvKSxcbiAgICAgICAgICAgIGNoYWluSWQ6IHRoaXMuY2hhaW5JZCxcbiAgICAgICAgICAgIGFjY291bnROdW1iZXI6IHRoaXMuYWNjb3VudE51bWJlcixcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlByb3RvU2lnbkRvY0RlY29kZXIgPSBQcm90b1NpZ25Eb2NEZWNvZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/cosmos/build/stargate/decoder/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/cosmos/build/stargate/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@keplr-wallet/cosmos/build/stargate/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./codec */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/stargate/codec/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./decoder */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/stargate/decoder/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./wrapper */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/stargate/wrapper/index.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvc3RhcmdhdGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLHdGQUFTO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyw0RkFBVztBQUNoQyxhQUFhLG1CQUFPLENBQUMsNEZBQVc7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L2Nvc21vcy9idWlsZC9zdGFyZ2F0ZS9pbmRleC5qcz81OTEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29kZWNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2RlY29kZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3dyYXBwZXJcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/cosmos/build/stargate/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/cosmos/build/stargate/wrapper/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/cosmos/build/stargate/wrapper/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SignDocWrapper = void 0;\nconst decoder_1 = __webpack_require__(/*! ../decoder */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/stargate/decoder/index.js\");\nconst tx_1 = __webpack_require__(/*! @keplr-wallet/proto-types/cosmos/tx/v1beta1/tx */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/tx/v1beta1/tx.js\");\nconst adr_36_1 = __webpack_require__(/*! ../../adr-36 */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/adr-36/index.js\");\nclass SignDocWrapper {\n    constructor(signDoc) {\n        this.signDoc = signDoc;\n        if (\"msgs\" in signDoc) {\n            this.mode = \"amino\";\n        }\n        else {\n            this.mode = \"direct\";\n        }\n        if (this.mode === \"amino\") {\n            // Check that the sign doc is for ADR-36.\n            // The validation should be performed on the background process.\n            // So, here, we check once more, but the validation related to bech32 is considered to be done in the background process.\n            this.isADR36SignDoc = (0, adr_36_1.checkAndValidateADR36AminoSignDoc)(this.aminoSignDoc);\n        }\n        else {\n            // Currently, only support amino sign doc for ADR-36\n            this.isADR36SignDoc = false;\n        }\n    }\n    static fromAminoSignDoc(signDoc) {\n        return new SignDocWrapper(signDoc);\n    }\n    static fromDirectSignDoc(signDoc) {\n        return new SignDocWrapper(signDoc);\n    }\n    static fromDirectSignDocBytes(signDocBytes) {\n        return new SignDocWrapper(tx_1.SignDoc.decode(signDocBytes));\n    }\n    clone() {\n        return new SignDocWrapper(this.signDoc);\n    }\n    get protoSignDoc() {\n        if (this.mode === \"amino\") {\n            throw new Error(\"Sign doc is encoded as Amino Json\");\n        }\n        if (\"msgs\" in this.signDoc) {\n            throw new Error(\"Unexpected error\");\n        }\n        if (!this._protoSignDoc) {\n            this._protoSignDoc = new decoder_1.ProtoSignDocDecoder(this.signDoc);\n        }\n        return this._protoSignDoc;\n    }\n    get aminoSignDoc() {\n        if (this.mode === \"direct\") {\n            throw new Error(\"Sign doc is encoded as Protobuf\");\n        }\n        if (!(\"msgs\" in this.signDoc)) {\n            throw new Error(\"Unexpected error\");\n        }\n        return this.signDoc;\n    }\n    get chainId() {\n        if (this.mode === \"direct\") {\n            return this.protoSignDoc.chainId;\n        }\n        return this.aminoSignDoc.chain_id;\n    }\n    get memo() {\n        if (this.mode === \"direct\") {\n            return this.protoSignDoc.txBody.memo;\n        }\n        return this.aminoSignDoc.memo;\n    }\n    get fees() {\n        var _a, _b;\n        if (this.mode === \"direct\") {\n            const fees = [];\n            for (const coinObj of (_b = (_a = this.protoSignDoc.authInfo.fee) === null || _a === void 0 ? void 0 : _a.amount) !== null && _b !== void 0 ? _b : []) {\n                if (coinObj.denom == null || coinObj.amount == null) {\n                    throw new Error(\"Invalid fee\");\n                }\n                fees.push({\n                    denom: coinObj.denom,\n                    amount: coinObj.amount,\n                });\n            }\n            return fees;\n        }\n        return this.aminoSignDoc.fee.amount;\n    }\n    get payer() {\n        var _a;\n        if (this.mode === \"direct\") {\n            return (_a = this.protoSignDoc.authInfo.fee) === null || _a === void 0 ? void 0 : _a.payer;\n        }\n        return this.aminoSignDoc.fee.payer;\n    }\n    get granter() {\n        var _a;\n        if (this.mode === \"direct\") {\n            return (_a = this.protoSignDoc.authInfo.fee) === null || _a === void 0 ? void 0 : _a.granter;\n        }\n        return this.aminoSignDoc.fee.granter;\n    }\n    get gas() {\n        var _a;\n        if (this.mode === \"direct\") {\n            if ((_a = this.protoSignDoc.authInfo.fee) === null || _a === void 0 ? void 0 : _a.gasLimit) {\n                return parseInt(this.protoSignDoc.authInfo.fee.gasLimit);\n            }\n            else {\n                return 0;\n            }\n        }\n        return parseInt(this.aminoSignDoc.fee.gas);\n    }\n}\nexports.SignDocWrapper = SignDocWrapper;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvc3RhcmdhdGUvd3JhcHBlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsa0JBQWtCLG1CQUFPLENBQUMsNkZBQVk7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLDhIQUFnRDtBQUNyRSxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvc3RhcmdhdGUvd3JhcHBlci9pbmRleC5qcz82ODJkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaWduRG9jV3JhcHBlciA9IHZvaWQgMDtcbmNvbnN0IGRlY29kZXJfMSA9IHJlcXVpcmUoXCIuLi9kZWNvZGVyXCIpO1xuY29uc3QgdHhfMSA9IHJlcXVpcmUoXCJAa2VwbHItd2FsbGV0L3Byb3RvLXR5cGVzL2Nvc21vcy90eC92MWJldGExL3R4XCIpO1xuY29uc3QgYWRyXzM2XzEgPSByZXF1aXJlKFwiLi4vLi4vYWRyLTM2XCIpO1xuY2xhc3MgU2lnbkRvY1dyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKHNpZ25Eb2MpIHtcbiAgICAgICAgdGhpcy5zaWduRG9jID0gc2lnbkRvYztcbiAgICAgICAgaWYgKFwibXNnc1wiIGluIHNpZ25Eb2MpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IFwiYW1pbm9cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IFwiZGlyZWN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gXCJhbWlub1wiKSB7XG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBzaWduIGRvYyBpcyBmb3IgQURSLTM2LlxuICAgICAgICAgICAgLy8gVGhlIHZhbGlkYXRpb24gc2hvdWxkIGJlIHBlcmZvcm1lZCBvbiB0aGUgYmFja2dyb3VuZCBwcm9jZXNzLlxuICAgICAgICAgICAgLy8gU28sIGhlcmUsIHdlIGNoZWNrIG9uY2UgbW9yZSwgYnV0IHRoZSB2YWxpZGF0aW9uIHJlbGF0ZWQgdG8gYmVjaDMyIGlzIGNvbnNpZGVyZWQgdG8gYmUgZG9uZSBpbiB0aGUgYmFja2dyb3VuZCBwcm9jZXNzLlxuICAgICAgICAgICAgdGhpcy5pc0FEUjM2U2lnbkRvYyA9ICgwLCBhZHJfMzZfMS5jaGVja0FuZFZhbGlkYXRlQURSMzZBbWlub1NpZ25Eb2MpKHRoaXMuYW1pbm9TaWduRG9jKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEN1cnJlbnRseSwgb25seSBzdXBwb3J0IGFtaW5vIHNpZ24gZG9jIGZvciBBRFItMzZcbiAgICAgICAgICAgIHRoaXMuaXNBRFIzNlNpZ25Eb2MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZnJvbUFtaW5vU2lnbkRvYyhzaWduRG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2lnbkRvY1dyYXBwZXIoc2lnbkRvYyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRGlyZWN0U2lnbkRvYyhzaWduRG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2lnbkRvY1dyYXBwZXIoc2lnbkRvYyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRGlyZWN0U2lnbkRvY0J5dGVzKHNpZ25Eb2NCeXRlcykge1xuICAgICAgICByZXR1cm4gbmV3IFNpZ25Eb2NXcmFwcGVyKHR4XzEuU2lnbkRvYy5kZWNvZGUoc2lnbkRvY0J5dGVzKSk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNpZ25Eb2NXcmFwcGVyKHRoaXMuc2lnbkRvYyk7XG4gICAgfVxuICAgIGdldCBwcm90b1NpZ25Eb2MoKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IFwiYW1pbm9cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbiBkb2MgaXMgZW5jb2RlZCBhcyBBbWlubyBKc29uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcIm1zZ3NcIiBpbiB0aGlzLnNpZ25Eb2MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgZXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9wcm90b1NpZ25Eb2MpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvU2lnbkRvYyA9IG5ldyBkZWNvZGVyXzEuUHJvdG9TaWduRG9jRGVjb2Rlcih0aGlzLnNpZ25Eb2MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm90b1NpZ25Eb2M7XG4gICAgfVxuICAgIGdldCBhbWlub1NpZ25Eb2MoKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IFwiZGlyZWN0XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ24gZG9jIGlzIGVuY29kZWQgYXMgUHJvdG9idWZcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoXCJtc2dzXCIgaW4gdGhpcy5zaWduRG9jKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBlcnJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zaWduRG9jO1xuICAgIH1cbiAgICBnZXQgY2hhaW5JZCgpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gXCJkaXJlY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdG9TaWduRG9jLmNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYW1pbm9TaWduRG9jLmNoYWluX2lkO1xuICAgIH1cbiAgICBnZXQgbWVtbygpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gXCJkaXJlY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdG9TaWduRG9jLnR4Qm9keS5tZW1vO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFtaW5vU2lnbkRvYy5tZW1vO1xuICAgIH1cbiAgICBnZXQgZmVlcygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gXCJkaXJlY3RcIikge1xuICAgICAgICAgICAgY29uc3QgZmVlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb2luT2JqIG9mIChfYiA9IChfYSA9IHRoaXMucHJvdG9TaWduRG9jLmF1dGhJbmZvLmZlZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFtb3VudCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29pbk9iai5kZW5vbSA9PSBudWxsIHx8IGNvaW5PYmouYW1vdW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBmZWVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZlZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGRlbm9tOiBjb2luT2JqLmRlbm9tLFxuICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IGNvaW5PYmouYW1vdW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZlZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYW1pbm9TaWduRG9jLmZlZS5hbW91bnQ7XG4gICAgfVxuICAgIGdldCBwYXllcigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSBcImRpcmVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5wcm90b1NpZ25Eb2MuYXV0aEluZm8uZmVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF5ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYW1pbm9TaWduRG9jLmZlZS5wYXllcjtcbiAgICB9XG4gICAgZ2V0IGdyYW50ZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gXCJkaXJlY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMucHJvdG9TaWduRG9jLmF1dGhJbmZvLmZlZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdyYW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYW1pbm9TaWduRG9jLmZlZS5ncmFudGVyO1xuICAgIH1cbiAgICBnZXQgZ2FzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IFwiZGlyZWN0XCIpIHtcbiAgICAgICAgICAgIGlmICgoX2EgPSB0aGlzLnByb3RvU2lnbkRvYy5hdXRoSW5mby5mZWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nYXNMaW1pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLnByb3RvU2lnbkRvYy5hdXRoSW5mby5mZWUuZ2FzTGltaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuYW1pbm9TaWduRG9jLmZlZS5nYXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2lnbkRvY1dyYXBwZXIgPSBTaWduRG9jV3JhcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/cosmos/build/stargate/wrapper/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/cosmos/build/tx-tracer/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@keplr-wallet/cosmos/build/tx-tracer/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TendermintTxTracer = void 0;\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@keplr-wallet/cosmos/build/tx-tracer/types.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\nclass TendermintTxTracer {\n    constructor(url, wsEndpoint, options = {}) {\n        this.url = url;\n        this.wsEndpoint = wsEndpoint;\n        this.options = options;\n        this.newBlockSubscribes = [];\n        // Key is \"id\" for jsonrpc\n        this.txSubscribes = new Map();\n        // Key is \"id\" for jsonrpc\n        this.pendingQueries = new Map();\n        this.listeners = {};\n        this.onOpen = (e) => {\n            var _a;\n            if (this.newBlockSubscribes.length > 0) {\n                this.sendSubscribeBlockRpc();\n            }\n            for (const [id, tx] of this.txSubscribes) {\n                this.sendSubscribeTxRpc(id, tx.params);\n            }\n            for (const [id, query] of this.pendingQueries) {\n                this.sendQueryRpc(id, query.method, query.params);\n            }\n            for (const listener of (_a = this.listeners.open) !== null && _a !== void 0 ? _a : []) {\n                listener(e);\n            }\n        };\n        this.onMessage = (e) => {\n            var _a, _b, _c, _d, _e, _f;\n            for (const listener of (_a = this.listeners.message) !== null && _a !== void 0 ? _a : []) {\n                listener(e);\n            }\n            if (e.data) {\n                try {\n                    const obj = JSON.parse(e.data);\n                    if (obj === null || obj === void 0 ? void 0 : obj.id) {\n                        if (this.pendingQueries.has(obj.id)) {\n                            if (obj.error) {\n                                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                                this.pendingQueries\n                                    .get(obj.id)\n                                    .rejector(new Error(obj.error.data || obj.error.message));\n                            }\n                            else {\n                                // XXX: I'm not sure why this happens, but somtimes the form of tx id delivered under the \"tx_result\" field.\n                                if ((_b = obj.result) === null || _b === void 0 ? void 0 : _b.tx_result) {\n                                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                                    this.pendingQueries.get(obj.id).resolver(obj.result.tx_result);\n                                }\n                                else {\n                                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                                    this.pendingQueries.get(obj.id).resolver(obj.result);\n                                }\n                            }\n                            this.pendingQueries.delete(obj.id);\n                        }\n                    }\n                    if (((_d = (_c = obj === null || obj === void 0 ? void 0 : obj.result) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d.type) === \"tendermint/event/NewBlock\") {\n                        for (const handler of this.newBlockSubscribes) {\n                            handler.handler(obj.result.data.value);\n                        }\n                    }\n                    if (((_f = (_e = obj === null || obj === void 0 ? void 0 : obj.result) === null || _e === void 0 ? void 0 : _e.data) === null || _f === void 0 ? void 0 : _f.type) === \"tendermint/event/Tx\") {\n                        if (obj === null || obj === void 0 ? void 0 : obj.id) {\n                            if (this.txSubscribes.has(obj.id)) {\n                                if (obj.error) {\n                                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                                    this.txSubscribes\n                                        .get(obj.id)\n                                        .rejector(new Error(obj.error.data || obj.error.message));\n                                }\n                                else {\n                                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                                    this.txSubscribes\n                                        .get(obj.id)\n                                        .resolver(obj.result.data.value.TxResult.result);\n                                }\n                                this.txSubscribes.delete(obj.id);\n                            }\n                        }\n                    }\n                }\n                catch (e) {\n                    console.log(`Tendermint websocket jsonrpc response is not JSON: ${e.message || e.toString()}`);\n                }\n            }\n        };\n        this.onClose = (e) => {\n            var _a;\n            for (const listener of (_a = this.listeners.close) !== null && _a !== void 0 ? _a : []) {\n                listener(e);\n            }\n        };\n        this.ws = this.options.wsObject\n            ? new this.options.wsObject(this.getWsEndpoint())\n            : new WebSocket(this.getWsEndpoint());\n        this.ws.onopen = this.onOpen;\n        this.ws.onmessage = this.onMessage;\n        this.ws.onclose = this.onClose;\n    }\n    getWsEndpoint() {\n        let url = this.url;\n        if (url.startsWith(\"http\")) {\n            url = url.replace(\"http\", \"ws\");\n        }\n        if (!url.endsWith(this.wsEndpoint)) {\n            const wsEndpoint = this.wsEndpoint.startsWith(\"/\")\n                ? this.wsEndpoint\n                : \"/\" + this.wsEndpoint;\n            url = url.endsWith(\"/\") ? url + wsEndpoint.slice(1) : url + wsEndpoint;\n        }\n        return url;\n    }\n    close() {\n        this.ws.close();\n    }\n    get readyState() {\n        switch (this.ws.readyState) {\n            case 0:\n                return types_1.WsReadyState.CONNECTING;\n            case 1:\n                return types_1.WsReadyState.OPEN;\n            case 2:\n                return types_1.WsReadyState.CLOSING;\n            case 3:\n                return types_1.WsReadyState.CLOSED;\n            default:\n                return types_1.WsReadyState.NONE;\n        }\n    }\n    addEventListener(type, listener) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.listeners[type].push(listener);\n    }\n    /**\n     * SubscribeBlock receives the handler for the block.\n     * The handelrs shares the subscription of block.\n     * @param handler\n     * @return unsubscriber\n     */\n    subscribeBlock(handler) {\n        this.newBlockSubscribes.push({\n            handler,\n        });\n        if (this.newBlockSubscribes.length === 1) {\n            this.sendSubscribeBlockRpc();\n        }\n        return () => {\n            this.newBlockSubscribes = this.newBlockSubscribes.filter((s) => s.handler !== handler);\n        };\n    }\n    sendSubscribeBlockRpc() {\n        if (this.readyState === types_1.WsReadyState.OPEN) {\n            this.ws.send(JSON.stringify({\n                jsonrpc: \"2.0\",\n                method: \"subscribe\",\n                params: [\"tm.event='NewBlock'\"],\n                id: 1,\n            }));\n        }\n    }\n    // Query the tx and subscribe the tx.\n    traceTx(query) {\n        return new Promise((resolve) => {\n            // At first, try to query the tx at the same time of subscribing the tx.\n            // But, the querying's error will be ignored.\n            this.queryTx(query)\n                .then((result) => {\n                if (query instanceof Uint8Array) {\n                    resolve(result);\n                    return;\n                }\n                if ((result === null || result === void 0 ? void 0 : result.total_count) !== \"0\") {\n                    resolve(result);\n                    return;\n                }\n            })\n                .catch(() => {\n                // noop\n            });\n            this.subscribeTx(query).then(resolve);\n        }).then((tx) => {\n            // Occasionally, even if the subscribe tx event occurs, the state through query is not changed yet.\n            // Perhaps it is because the block has not been committed yet even though the result of deliverTx in tendermint is complete.\n            // This method is usually used to reflect the state change through query when tx is completed.\n            // The simplest solution is to just add a little delay.\n            return new Promise((resolve) => {\n                setTimeout(() => resolve(tx), 100);\n            });\n        });\n    }\n    subscribeTx(query) {\n        if (query instanceof Uint8Array) {\n            const id = this.createRandomId();\n            const params = {\n                query: `tm.event='Tx' AND tx.hash='${buffer_1.Buffer.from(query)\n                    .toString(\"hex\")\n                    .toUpperCase()}'`,\n            };\n            return new Promise((resolve, reject) => {\n                this.txSubscribes.set(id, {\n                    params,\n                    resolver: resolve,\n                    rejector: reject,\n                });\n                this.sendSubscribeTxRpc(id, params);\n            });\n        }\n        else {\n            const id = this.createRandomId();\n            const params = {\n                query: `tm.event='Tx' and ` +\n                    Object.keys(query)\n                        .map((key) => {\n                        return {\n                            key,\n                            value: query[key],\n                        };\n                    })\n                        .map((obj) => {\n                        return `${obj.key}=${typeof obj.value === \"string\" ? `'${obj.value}'` : obj.value}`;\n                    })\n                        .join(\" and \"),\n                page: \"1\",\n                per_page: \"1\",\n                order_by: \"desc\",\n            };\n            return new Promise((resolve, reject) => {\n                this.txSubscribes.set(id, {\n                    params,\n                    resolver: resolve,\n                    rejector: reject,\n                });\n                this.sendSubscribeTxRpc(id, params);\n            });\n        }\n    }\n    sendSubscribeTxRpc(id, params) {\n        if (this.readyState === types_1.WsReadyState.OPEN) {\n            this.ws.send(JSON.stringify({\n                jsonrpc: \"2.0\",\n                method: \"subscribe\",\n                params: params,\n                id,\n            }));\n        }\n    }\n    queryTx(query) {\n        if (query instanceof Uint8Array) {\n            return this.query(\"tx\", {\n                hash: buffer_1.Buffer.from(query).toString(\"base64\"),\n                prove: false,\n            });\n        }\n        else {\n            const params = {\n                query: Object.keys(query)\n                    .map((key) => {\n                    return {\n                        key,\n                        value: query[key],\n                    };\n                })\n                    .map((obj) => {\n                    return `${obj.key}=${typeof obj.value === \"string\" ? `'${obj.value}'` : obj.value}`;\n                })\n                    .join(\" and \"),\n                page: \"1\",\n                per_page: \"1\",\n                order_by: \"desc\",\n            };\n            return this.query(\"tx_search\", params);\n        }\n    }\n    query(method, params) {\n        const id = this.createRandomId();\n        return new Promise((resolve, reject) => {\n            this.pendingQueries.set(id, {\n                method,\n                params,\n                resolver: resolve,\n                rejector: reject,\n            });\n            this.sendQueryRpc(id, method, params);\n        });\n    }\n    sendQueryRpc(id, method, params) {\n        if (this.readyState === types_1.WsReadyState.OPEN) {\n            this.ws.send(JSON.stringify({\n                jsonrpc: \"2.0\",\n                method,\n                params,\n                id,\n            }));\n        }\n    }\n    createRandomId() {\n        return parseInt(Array.from({ length: 6 })\n            .map(() => Math.floor(Math.random() * 100))\n            .join(\"\"));\n    }\n}\nexports.TendermintTxTracer = TendermintTxTracer;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvdHgtdHJhY2VyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQixnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxxREFBUztBQUNsQztBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLDBCQUEwQjtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxrQ0FBa0MsUUFBUSxHQUFHLG9DQUFvQyxVQUFVLGVBQWU7QUFDMUcscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw4QkFBOEIsUUFBUSxHQUFHLG9DQUFvQyxVQUFVLGVBQWU7QUFDdEcsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFdBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L2Nvc21vcy9idWlsZC90eC10cmFjZXIvaW5kZXguanM/MzRkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVGVuZGVybWludFR4VHJhY2VyID0gdm9pZCAwO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbmNsYXNzIFRlbmRlcm1pbnRUeFRyYWNlciB7XG4gICAgY29uc3RydWN0b3IodXJsLCB3c0VuZHBvaW50LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMud3NFbmRwb2ludCA9IHdzRW5kcG9pbnQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMubmV3QmxvY2tTdWJzY3JpYmVzID0gW107XG4gICAgICAgIC8vIEtleSBpcyBcImlkXCIgZm9yIGpzb25ycGNcbiAgICAgICAgdGhpcy50eFN1YnNjcmliZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIEtleSBpcyBcImlkXCIgZm9yIGpzb25ycGNcbiAgICAgICAgdGhpcy5wZW5kaW5nUXVlcmllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgdGhpcy5vbk9wZW4gPSAoZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKHRoaXMubmV3QmxvY2tTdWJzY3JpYmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRTdWJzY3JpYmVCbG9ja1JwYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBbaWQsIHR4XSBvZiB0aGlzLnR4U3Vic2NyaWJlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFN1YnNjcmliZVR4UnBjKGlkLCB0eC5wYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBbaWQsIHF1ZXJ5XSBvZiB0aGlzLnBlbmRpbmdRdWVyaWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kUXVlcnlScGMoaWQsIHF1ZXJ5Lm1ldGhvZCwgcXVlcnkucGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgKF9hID0gdGhpcy5saXN0ZW5lcnMub3BlbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2UgPSAoZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIChfYSA9IHRoaXMubGlzdGVuZXJzLm1lc3NhZ2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqID0gSlNPTi5wYXJzZShlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nUXVlcmllcy5oYXMob2JqLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmouZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUXVlcmllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldChvYmouaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVqZWN0b3IobmV3IEVycm9yKG9iai5lcnJvci5kYXRhIHx8IG9iai5lcnJvci5tZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBYWFg6IEknbSBub3Qgc3VyZSB3aHkgdGhpcyBoYXBwZW5zLCBidXQgc29tdGltZXMgdGhlIGZvcm0gb2YgdHggaWQgZGVsaXZlcmVkIHVuZGVyIHRoZSBcInR4X3Jlc3VsdFwiIGZpZWxkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKF9iID0gb2JqLnJlc3VsdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnR4X3Jlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1F1ZXJpZXMuZ2V0KG9iai5pZCkucmVzb2x2ZXIob2JqLnJlc3VsdC50eF9yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1F1ZXJpZXMuZ2V0KG9iai5pZCkucmVzb2x2ZXIob2JqLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUXVlcmllcy5kZWxldGUob2JqLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKChfZCA9IChfYyA9IG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5yZXN1bHQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5kYXRhKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudHlwZSkgPT09IFwidGVuZGVybWludC9ldmVudC9OZXdCbG9ja1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgdGhpcy5uZXdCbG9ja1N1YnNjcmliZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmhhbmRsZXIob2JqLnJlc3VsdC5kYXRhLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKChfZiA9IChfZSA9IG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iai5yZXN1bHQpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5kYXRhKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YudHlwZSkgPT09IFwidGVuZGVybWludC9ldmVudC9UeFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHhTdWJzY3JpYmVzLmhhcyhvYmouaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmouZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnR4U3Vic2NyaWJlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXQob2JqLmlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZWplY3RvcihuZXcgRXJyb3Iob2JqLmVycm9yLmRhdGEgfHwgb2JqLmVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnR4U3Vic2NyaWJlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXQob2JqLmlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXNvbHZlcihvYmoucmVzdWx0LmRhdGEudmFsdWUuVHhSZXN1bHQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnR4U3Vic2NyaWJlcy5kZWxldGUob2JqLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFRlbmRlcm1pbnQgd2Vic29ja2V0IGpzb25ycGMgcmVzcG9uc2UgaXMgbm90IEpTT046ICR7ZS5tZXNzYWdlIHx8IGUudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25DbG9zZSA9IChlKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIChfYSA9IHRoaXMubGlzdGVuZXJzLmNsb3NlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndzID0gdGhpcy5vcHRpb25zLndzT2JqZWN0XG4gICAgICAgICAgICA/IG5ldyB0aGlzLm9wdGlvbnMud3NPYmplY3QodGhpcy5nZXRXc0VuZHBvaW50KCkpXG4gICAgICAgICAgICA6IG5ldyBXZWJTb2NrZXQodGhpcy5nZXRXc0VuZHBvaW50KCkpO1xuICAgICAgICB0aGlzLndzLm9ub3BlbiA9IHRoaXMub25PcGVuO1xuICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IHRoaXMub25NZXNzYWdlO1xuICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSB0aGlzLm9uQ2xvc2U7XG4gICAgfVxuICAgIGdldFdzRW5kcG9pbnQoKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybDtcbiAgICAgICAgaWYgKHVybC5zdGFydHNXaXRoKFwiaHR0cFwiKSkge1xuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoXCJodHRwXCIsIFwid3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1cmwuZW5kc1dpdGgodGhpcy53c0VuZHBvaW50KSkge1xuICAgICAgICAgICAgY29uc3Qgd3NFbmRwb2ludCA9IHRoaXMud3NFbmRwb2ludC5zdGFydHNXaXRoKFwiL1wiKVxuICAgICAgICAgICAgICAgID8gdGhpcy53c0VuZHBvaW50XG4gICAgICAgICAgICAgICAgOiBcIi9cIiArIHRoaXMud3NFbmRwb2ludDtcbiAgICAgICAgICAgIHVybCA9IHVybC5lbmRzV2l0aChcIi9cIikgPyB1cmwgKyB3c0VuZHBvaW50LnNsaWNlKDEpIDogdXJsICsgd3NFbmRwb2ludDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgIH1cbiAgICBnZXQgcmVhZHlTdGF0ZSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLndzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5Xc1JlYWR5U3RhdGUuQ09OTkVDVElORztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5Xc1JlYWR5U3RhdGUuT1BFTjtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5Xc1JlYWR5U3RhdGUuQ0xPU0lORztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5Xc1JlYWR5U3RhdGUuQ0xPU0VEO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5Xc1JlYWR5U3RhdGUuTk9ORTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5saXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVCbG9jayByZWNlaXZlcyB0aGUgaGFuZGxlciBmb3IgdGhlIGJsb2NrLlxuICAgICAqIFRoZSBoYW5kZWxycyBzaGFyZXMgdGhlIHN1YnNjcmlwdGlvbiBvZiBibG9jay5cbiAgICAgKiBAcGFyYW0gaGFuZGxlclxuICAgICAqIEByZXR1cm4gdW5zdWJzY3JpYmVyXG4gICAgICovXG4gICAgc3Vic2NyaWJlQmxvY2soaGFuZGxlcikge1xuICAgICAgICB0aGlzLm5ld0Jsb2NrU3Vic2NyaWJlcy5wdXNoKHtcbiAgICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5uZXdCbG9ja1N1YnNjcmliZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRTdWJzY3JpYmVCbG9ja1JwYygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5ld0Jsb2NrU3Vic2NyaWJlcyA9IHRoaXMubmV3QmxvY2tTdWJzY3JpYmVzLmZpbHRlcigocykgPT4gcy5oYW5kbGVyICE9PSBoYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2VuZFN1YnNjcmliZUJsb2NrUnBjKCkge1xuICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0eXBlc18xLldzUmVhZHlTdGF0ZS5PUEVOKSB7XG4gICAgICAgICAgICB0aGlzLndzLnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcInN1YnNjcmliZVwiLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW1widG0uZXZlbnQ9J05ld0Jsb2NrJ1wiXSxcbiAgICAgICAgICAgICAgICBpZDogMSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBRdWVyeSB0aGUgdHggYW5kIHN1YnNjcmliZSB0aGUgdHguXG4gICAgdHJhY2VUeChxdWVyeSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIC8vIEF0IGZpcnN0LCB0cnkgdG8gcXVlcnkgdGhlIHR4IGF0IHRoZSBzYW1lIHRpbWUgb2Ygc3Vic2NyaWJpbmcgdGhlIHR4LlxuICAgICAgICAgICAgLy8gQnV0LCB0aGUgcXVlcnlpbmcncyBlcnJvciB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5VHgocXVlcnkpXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChxdWVyeSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0LnRvdGFsX2NvdW50KSAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVUeChxdWVyeSkudGhlbihyZXNvbHZlKTtcbiAgICAgICAgfSkudGhlbigodHgpID0+IHtcbiAgICAgICAgICAgIC8vIE9jY2FzaW9uYWxseSwgZXZlbiBpZiB0aGUgc3Vic2NyaWJlIHR4IGV2ZW50IG9jY3VycywgdGhlIHN0YXRlIHRocm91Z2ggcXVlcnkgaXMgbm90IGNoYW5nZWQgeWV0LlxuICAgICAgICAgICAgLy8gUGVyaGFwcyBpdCBpcyBiZWNhdXNlIHRoZSBibG9jayBoYXMgbm90IGJlZW4gY29tbWl0dGVkIHlldCBldmVuIHRob3VnaCB0aGUgcmVzdWx0IG9mIGRlbGl2ZXJUeCBpbiB0ZW5kZXJtaW50IGlzIGNvbXBsZXRlLlxuICAgICAgICAgICAgLy8gVGhpcyBtZXRob2QgaXMgdXN1YWxseSB1c2VkIHRvIHJlZmxlY3QgdGhlIHN0YXRlIGNoYW5nZSB0aHJvdWdoIHF1ZXJ5IHdoZW4gdHggaXMgY29tcGxldGVkLlxuICAgICAgICAgICAgLy8gVGhlIHNpbXBsZXN0IHNvbHV0aW9uIGlzIHRvIGp1c3QgYWRkIGEgbGl0dGxlIGRlbGF5LlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKHR4KSwgMTAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3Vic2NyaWJlVHgocXVlcnkpIHtcbiAgICAgICAgaWYgKHF1ZXJ5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLmNyZWF0ZVJhbmRvbUlkKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgcXVlcnk6IGB0bS5ldmVudD0nVHgnIEFORCB0eC5oYXNoPScke2J1ZmZlcl8xLkJ1ZmZlci5mcm9tKHF1ZXJ5KVxuICAgICAgICAgICAgICAgICAgICAudG9TdHJpbmcoXCJoZXhcIilcbiAgICAgICAgICAgICAgICAgICAgLnRvVXBwZXJDYXNlKCl9J2AsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnR4U3Vic2NyaWJlcy5zZXQoaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlcjogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0b3I6IHJlamVjdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRTdWJzY3JpYmVUeFJwYyhpZCwgcGFyYW1zKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaWQgPSB0aGlzLmNyZWF0ZVJhbmRvbUlkKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgcXVlcnk6IGB0bS5ldmVudD0nVHgnIGFuZCBgICtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocXVlcnkpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBxdWVyeVtrZXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKG9iaikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke29iai5rZXl9PSR7dHlwZW9mIG9iai52YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IGAnJHtvYmoudmFsdWV9J2AgOiBvYmoudmFsdWV9YDtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKFwiIGFuZCBcIiksXG4gICAgICAgICAgICAgICAgcGFnZTogXCIxXCIsXG4gICAgICAgICAgICAgICAgcGVyX3BhZ2U6IFwiMVwiLFxuICAgICAgICAgICAgICAgIG9yZGVyX2J5OiBcImRlc2NcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHhTdWJzY3JpYmVzLnNldChpZCwge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVyOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICByZWplY3RvcjogcmVqZWN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFN1YnNjcmliZVR4UnBjKGlkLCBwYXJhbXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZFN1YnNjcmliZVR4UnBjKGlkLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdHlwZXNfMS5Xc1JlYWR5U3RhdGUuT1BFTikge1xuICAgICAgICAgICAgdGhpcy53cy5zZW5kKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJzdWJzY3JpYmVcIixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWVyeVR4KHF1ZXJ5KSB7XG4gICAgICAgIGlmIChxdWVyeSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5KFwidHhcIiwge1xuICAgICAgICAgICAgICAgIGhhc2g6IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHF1ZXJ5KS50b1N0cmluZyhcImJhc2U2NFwiKSxcbiAgICAgICAgICAgICAgICBwcm92ZTogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBxdWVyeTogT2JqZWN0LmtleXMocXVlcnkpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHF1ZXJ5W2tleV0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgob2JqKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtvYmoua2V5fT0ke3R5cGVvZiBvYmoudmFsdWUgPT09IFwic3RyaW5nXCIgPyBgJyR7b2JqLnZhbHVlfSdgIDogb2JqLnZhbHVlfWA7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oXCIgYW5kIFwiKSxcbiAgICAgICAgICAgICAgICBwYWdlOiBcIjFcIixcbiAgICAgICAgICAgICAgICBwZXJfcGFnZTogXCIxXCIsXG4gICAgICAgICAgICAgICAgb3JkZXJfYnk6IFwiZGVzY1wiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5KFwidHhfc2VhcmNoXCIsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVlcnkobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLmNyZWF0ZVJhbmRvbUlkKCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdRdWVyaWVzLnNldChpZCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZXI6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgcmVqZWN0b3I6IHJlamVjdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zZW5kUXVlcnlScGMoaWQsIG1ldGhvZCwgcGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRRdWVyeVJwYyhpZCwgbWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdHlwZXNfMS5Xc1JlYWR5U3RhdGUuT1BFTikge1xuICAgICAgICAgICAgdGhpcy53cy5zZW5kKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlUmFuZG9tSWQoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChBcnJheS5mcm9tKHsgbGVuZ3RoOiA2IH0pXG4gICAgICAgICAgICAubWFwKCgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMCkpXG4gICAgICAgICAgICAuam9pbihcIlwiKSk7XG4gICAgfVxufVxuZXhwb3J0cy5UZW5kZXJtaW50VHhUcmFjZXIgPSBUZW5kZXJtaW50VHhUcmFjZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/cosmos/build/tx-tracer/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/cosmos/build/tx-tracer/types.js":
/*!********************************************************************!*\
  !*** ./node_modules/@keplr-wallet/cosmos/build/tx-tracer/types.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WsReadyState = void 0;\nvar WsReadyState;\n(function (WsReadyState) {\n    WsReadyState[WsReadyState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n    WsReadyState[WsReadyState[\"OPEN\"] = 1] = \"OPEN\";\n    WsReadyState[WsReadyState[\"CLOSING\"] = 2] = \"CLOSING\";\n    WsReadyState[WsReadyState[\"CLOSED\"] = 3] = \"CLOSED\";\n    // WS is not initialized or the ready state of WS is unknown\n    WsReadyState[WsReadyState[\"NONE\"] = 4] = \"NONE\";\n})(WsReadyState = exports.WsReadyState || (exports.WsReadyState = {}));\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jb3Ntb3MvYnVpbGQvdHgtdHJhY2VyL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEMsb0JBQW9CLEtBQUs7QUFDcEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L2Nvc21vcy9idWlsZC90eC10cmFjZXIvdHlwZXMuanM/ZDRkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV3NSZWFkeVN0YXRlID0gdm9pZCAwO1xudmFyIFdzUmVhZHlTdGF0ZTtcbihmdW5jdGlvbiAoV3NSZWFkeVN0YXRlKSB7XG4gICAgV3NSZWFkeVN0YXRlW1dzUmVhZHlTdGF0ZVtcIkNPTk5FQ1RJTkdcIl0gPSAwXSA9IFwiQ09OTkVDVElOR1wiO1xuICAgIFdzUmVhZHlTdGF0ZVtXc1JlYWR5U3RhdGVbXCJPUEVOXCJdID0gMV0gPSBcIk9QRU5cIjtcbiAgICBXc1JlYWR5U3RhdGVbV3NSZWFkeVN0YXRlW1wiQ0xPU0lOR1wiXSA9IDJdID0gXCJDTE9TSU5HXCI7XG4gICAgV3NSZWFkeVN0YXRlW1dzUmVhZHlTdGF0ZVtcIkNMT1NFRFwiXSA9IDNdID0gXCJDTE9TRURcIjtcbiAgICAvLyBXUyBpcyBub3QgaW5pdGlhbGl6ZWQgb3IgdGhlIHJlYWR5IHN0YXRlIG9mIFdTIGlzIHVua25vd25cbiAgICBXc1JlYWR5U3RhdGVbV3NSZWFkeVN0YXRlW1wiTk9ORVwiXSA9IDRdID0gXCJOT05FXCI7XG59KShXc1JlYWR5U3RhdGUgPSBleHBvcnRzLldzUmVhZHlTdGF0ZSB8fCAoZXhwb3J0cy5Xc1JlYWR5U3RhdGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/cosmos/build/tx-tracer/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/crypto/build/hash.js":
/*!*********************************************************!*\
  !*** ./node_modules/@keplr-wallet/crypto/build/hash.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Hash = void 0;\nconst sha_js_1 = __webpack_require__(/*! sha.js */ \"(ssr)/./node_modules/sha.js/index.js\");\nconst keccak256_1 = __webpack_require__(/*! @ethersproject/keccak256 */ \"(ssr)/./node_modules/@ethersproject/keccak256/lib.esm/index.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\nclass Hash {\n    static sha256(data) {\n        return new Uint8Array(new sha_js_1.sha256().update(data).digest());\n    }\n    static keccak256(data) {\n        return buffer_1.Buffer.from((0, keccak256_1.keccak256)(data).replace(\"0x\", \"\"), \"hex\");\n    }\n    static truncHashPortion(str, firstCharCount = str.length, endCharCount = 0) {\n        return (str.substring(0, firstCharCount) +\n            \"…\" +\n            str.substring(str.length - endCharCount, str.length));\n    }\n}\nexports.Hash = Hash;\n//# sourceMappingURL=hash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jcnlwdG8vYnVpbGQvaGFzaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osaUJBQWlCLG1CQUFPLENBQUMsb0RBQVE7QUFDakMsb0JBQW9CLG1CQUFPLENBQUMsZ0dBQTBCO0FBQ3RELGlCQUFpQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jcnlwdG8vYnVpbGQvaGFzaC5qcz85MTEzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IYXNoID0gdm9pZCAwO1xuY29uc3Qgc2hhX2pzXzEgPSByZXF1aXJlKFwic2hhLmpzXCIpO1xuY29uc3Qga2VjY2FrMjU2XzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2XCIpO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbmNsYXNzIEhhc2gge1xuICAgIHN0YXRpYyBzaGEyNTYoZGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IHNoYV9qc18xLnNoYTI1NigpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKSk7XG4gICAgfVxuICAgIHN0YXRpYyBrZWNjYWsyNTYoZGF0YSkge1xuICAgICAgICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmZyb20oKDAsIGtlY2NhazI1Nl8xLmtlY2NhazI1NikoZGF0YSkucmVwbGFjZShcIjB4XCIsIFwiXCIpLCBcImhleFwiKTtcbiAgICB9XG4gICAgc3RhdGljIHRydW5jSGFzaFBvcnRpb24oc3RyLCBmaXJzdENoYXJDb3VudCA9IHN0ci5sZW5ndGgsIGVuZENoYXJDb3VudCA9IDApIHtcbiAgICAgICAgcmV0dXJuIChzdHIuc3Vic3RyaW5nKDAsIGZpcnN0Q2hhckNvdW50KSArXG4gICAgICAgICAgICBcIuKAplwiICtcbiAgICAgICAgICAgIHN0ci5zdWJzdHJpbmcoc3RyLmxlbmd0aCAtIGVuZENoYXJDb3VudCwgc3RyLmxlbmd0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuSGFzaCA9IEhhc2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/crypto/build/hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/crypto/build/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@keplr-wallet/crypto/build/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./mnemonic */ \"(ssr)/./node_modules/@keplr-wallet/crypto/build/mnemonic.js\"), exports);\n__exportStar(__webpack_require__(/*! ./key */ \"(ssr)/./node_modules/@keplr-wallet/crypto/build/key.js\"), exports);\n__exportStar(__webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/@keplr-wallet/crypto/build/hash.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jcnlwdG8vYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLCtFQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxxRUFBTztBQUM1QixhQUFhLG1CQUFPLENBQUMsdUVBQVE7QUFDN0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L2NyeXB0by9idWlsZC9pbmRleC5qcz9hYzhjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW5lbW9uaWNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2tleVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGFzaFwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/crypto/build/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/crypto/build/key.js":
/*!********************************************************!*\
  !*** ./node_modules/@keplr-wallet/crypto/build/key.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PubKeySecp256k1 = exports.PrivKeySecp256k1 = void 0;\nconst elliptic_1 = __webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\");\nconst crypto_js_1 = __importDefault(__webpack_require__(/*! crypto-js */ \"(ssr)/./node_modules/crypto-js/index.js\"));\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\nconst hash_1 = __webpack_require__(/*! ./hash */ \"(ssr)/./node_modules/@keplr-wallet/crypto/build/hash.js\");\nclass PrivKeySecp256k1 {\n    static generateRandomKey() {\n        const secp256k1 = new elliptic_1.ec(\"secp256k1\");\n        return new PrivKeySecp256k1(buffer_1.Buffer.from(secp256k1.genKeyPair().getPrivate().toArray()));\n    }\n    constructor(privKey) {\n        this.privKey = privKey;\n    }\n    toBytes() {\n        return new Uint8Array(this.privKey);\n    }\n    getPubKey() {\n        const secp256k1 = new elliptic_1.ec(\"secp256k1\");\n        const key = secp256k1.keyFromPrivate(this.privKey);\n        return new PubKeySecp256k1(new Uint8Array(key.getPublic().encodeCompressed(\"array\")));\n    }\n    signDigest32(digest) {\n        if (digest.length !== 32) {\n            throw new Error(`Invalid length of digest to sign: ${digest.length}`);\n        }\n        const secp256k1 = new elliptic_1.ec(\"secp256k1\");\n        const key = secp256k1.keyFromPrivate(this.privKey);\n        const signature = key.sign(digest, {\n            canonical: true,\n        });\n        return {\n            r: new Uint8Array(signature.r.toArray(\"be\", 32)),\n            s: new Uint8Array(signature.s.toArray(\"be\", 32)),\n            v: signature.recoveryParam,\n        };\n    }\n}\nexports.PrivKeySecp256k1 = PrivKeySecp256k1;\nclass PubKeySecp256k1 {\n    constructor(pubKey) {\n        this.pubKey = pubKey;\n        if (pubKey.length !== 33 && pubKey.length !== 65) {\n            throw new Error(`Invalid length of public key: ${pubKey.length}`);\n        }\n    }\n    toBytes(uncompressed) {\n        if (uncompressed && this.pubKey.length === 65) {\n            return this.pubKey;\n        }\n        if (!uncompressed && this.pubKey.length === 33) {\n            return this.pubKey;\n        }\n        const keyPair = this.toKeyPair();\n        if (uncompressed) {\n            return new Uint8Array(buffer_1.Buffer.from(keyPair.getPublic().encode(\"hex\", false), \"hex\"));\n        }\n        else {\n            return new Uint8Array(buffer_1.Buffer.from(keyPair.getPublic().encodeCompressed(\"hex\"), \"hex\"));\n        }\n    }\n    /**\n     * @deprecated Use `getCosmosAddress()` instead.\n     */\n    getAddress() {\n        return this.getCosmosAddress();\n    }\n    getCosmosAddress() {\n        let hash = crypto_js_1.default.SHA256(crypto_js_1.default.lib.WordArray.create(this.toBytes(false))).toString();\n        hash = crypto_js_1.default.RIPEMD160(crypto_js_1.default.enc.Hex.parse(hash)).toString();\n        return new Uint8Array(buffer_1.Buffer.from(hash, \"hex\"));\n    }\n    getEthAddress() {\n        // Should be uncompressed.\n        // And remove prefix byte.\n        // And hash by keccak256.\n        // Use last 20 bytes.\n        return hash_1.Hash.keccak256(this.toBytes(true).slice(1)).slice(-20);\n    }\n    toKeyPair() {\n        const secp256k1 = new elliptic_1.ec(\"secp256k1\");\n        return secp256k1.keyFromPublic(buffer_1.Buffer.from(this.pubKey).toString(\"hex\"), \"hex\");\n    }\n    verifyDigest32(digest, signature) {\n        if (digest.length !== 32) {\n            throw new Error(`Invalid length of digest to verify: ${digest.length}`);\n        }\n        if (signature.length !== 64) {\n            throw new Error(`Invalid length of signature: ${signature.length}`);\n        }\n        const secp256k1 = new elliptic_1.ec(\"secp256k1\");\n        const r = signature.slice(0, 32);\n        const s = signature.slice(32);\n        return secp256k1.verify(digest, {\n            r: buffer_1.Buffer.from(r).toString(\"hex\"),\n            s: buffer_1.Buffer.from(s).toString(\"hex\"),\n        }, this.toKeyPair());\n    }\n}\nexports.PubKeySecp256k1 = PubKeySecp256k1;\n//# sourceMappingURL=key.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jcnlwdG8vYnVpbGQva2V5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcsd0JBQXdCO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLCtEQUFVO0FBQ3JDLG9DQUFvQyxtQkFBTyxDQUFDLDBEQUFXO0FBQ3ZELGlCQUFpQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2xDLGVBQWUsbUJBQU8sQ0FBQyx1RUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsY0FBYztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxjQUFjO0FBQ2pGO0FBQ0E7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L2NyeXB0by9idWlsZC9rZXkuanM/Njg2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHViS2V5U2VjcDI1NmsxID0gZXhwb3J0cy5Qcml2S2V5U2VjcDI1NmsxID0gdm9pZCAwO1xuY29uc3QgZWxsaXB0aWNfMSA9IHJlcXVpcmUoXCJlbGxpcHRpY1wiKTtcbmNvbnN0IGNyeXB0b19qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjcnlwdG8tanNcIikpO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbmNvbnN0IGhhc2hfMSA9IHJlcXVpcmUoXCIuL2hhc2hcIik7XG5jbGFzcyBQcml2S2V5U2VjcDI1NmsxIHtcbiAgICBzdGF0aWMgZ2VuZXJhdGVSYW5kb21LZXkoKSB7XG4gICAgICAgIGNvbnN0IHNlY3AyNTZrMSA9IG5ldyBlbGxpcHRpY18xLmVjKFwic2VjcDI1NmsxXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFByaXZLZXlTZWNwMjU2azEoYnVmZmVyXzEuQnVmZmVyLmZyb20oc2VjcDI1NmsxLmdlbktleVBhaXIoKS5nZXRQcml2YXRlKCkudG9BcnJheSgpKSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHByaXZLZXkpIHtcbiAgICAgICAgdGhpcy5wcml2S2V5ID0gcHJpdktleTtcbiAgICB9XG4gICAgdG9CeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMucHJpdktleSk7XG4gICAgfVxuICAgIGdldFB1YktleSgpIHtcbiAgICAgICAgY29uc3Qgc2VjcDI1NmsxID0gbmV3IGVsbGlwdGljXzEuZWMoXCJzZWNwMjU2azFcIik7XG4gICAgICAgIGNvbnN0IGtleSA9IHNlY3AyNTZrMS5rZXlGcm9tUHJpdmF0ZSh0aGlzLnByaXZLZXkpO1xuICAgICAgICByZXR1cm4gbmV3IFB1YktleVNlY3AyNTZrMShuZXcgVWludDhBcnJheShrZXkuZ2V0UHVibGljKCkuZW5jb2RlQ29tcHJlc3NlZChcImFycmF5XCIpKSk7XG4gICAgfVxuICAgIHNpZ25EaWdlc3QzMihkaWdlc3QpIHtcbiAgICAgICAgaWYgKGRpZ2VzdC5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbGVuZ3RoIG9mIGRpZ2VzdCB0byBzaWduOiAke2RpZ2VzdC5sZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VjcDI1NmsxID0gbmV3IGVsbGlwdGljXzEuZWMoXCJzZWNwMjU2azFcIik7XG4gICAgICAgIGNvbnN0IGtleSA9IHNlY3AyNTZrMS5rZXlGcm9tUHJpdmF0ZSh0aGlzLnByaXZLZXkpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBrZXkuc2lnbihkaWdlc3QsIHtcbiAgICAgICAgICAgIGNhbm9uaWNhbDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByOiBuZXcgVWludDhBcnJheShzaWduYXR1cmUuci50b0FycmF5KFwiYmVcIiwgMzIpKSxcbiAgICAgICAgICAgIHM6IG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZS5zLnRvQXJyYXkoXCJiZVwiLCAzMikpLFxuICAgICAgICAgICAgdjogc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW0sXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5Qcml2S2V5U2VjcDI1NmsxID0gUHJpdktleVNlY3AyNTZrMTtcbmNsYXNzIFB1YktleVNlY3AyNTZrMSB7XG4gICAgY29uc3RydWN0b3IocHViS2V5KSB7XG4gICAgICAgIHRoaXMucHViS2V5ID0gcHViS2V5O1xuICAgICAgICBpZiAocHViS2V5Lmxlbmd0aCAhPT0gMzMgJiYgcHViS2V5Lmxlbmd0aCAhPT0gNjUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBsZW5ndGggb2YgcHVibGljIGtleTogJHtwdWJLZXkubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvQnl0ZXModW5jb21wcmVzc2VkKSB7XG4gICAgICAgIGlmICh1bmNvbXByZXNzZWQgJiYgdGhpcy5wdWJLZXkubGVuZ3RoID09PSA2NSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHViS2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdW5jb21wcmVzc2VkICYmIHRoaXMucHViS2V5Lmxlbmd0aCA9PT0gMzMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnB1YktleTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlQYWlyID0gdGhpcy50b0tleVBhaXIoKTtcbiAgICAgICAgaWYgKHVuY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGtleVBhaXIuZ2V0UHVibGljKCkuZW5jb2RlKFwiaGV4XCIsIGZhbHNlKSwgXCJoZXhcIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGtleVBhaXIuZ2V0UHVibGljKCkuZW5jb2RlQ29tcHJlc3NlZChcImhleFwiKSwgXCJoZXhcIikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZ2V0Q29zbW9zQWRkcmVzcygpYCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvc21vc0FkZHJlc3MoKTtcbiAgICB9XG4gICAgZ2V0Q29zbW9zQWRkcmVzcygpIHtcbiAgICAgICAgbGV0IGhhc2ggPSBjcnlwdG9fanNfMS5kZWZhdWx0LlNIQTI1NihjcnlwdG9fanNfMS5kZWZhdWx0LmxpYi5Xb3JkQXJyYXkuY3JlYXRlKHRoaXMudG9CeXRlcyhmYWxzZSkpKS50b1N0cmluZygpO1xuICAgICAgICBoYXNoID0gY3J5cHRvX2pzXzEuZGVmYXVsdC5SSVBFTUQxNjAoY3J5cHRvX2pzXzEuZGVmYXVsdC5lbmMuSGV4LnBhcnNlKGhhc2gpKS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyXzEuQnVmZmVyLmZyb20oaGFzaCwgXCJoZXhcIikpO1xuICAgIH1cbiAgICBnZXRFdGhBZGRyZXNzKCkge1xuICAgICAgICAvLyBTaG91bGQgYmUgdW5jb21wcmVzc2VkLlxuICAgICAgICAvLyBBbmQgcmVtb3ZlIHByZWZpeCBieXRlLlxuICAgICAgICAvLyBBbmQgaGFzaCBieSBrZWNjYWsyNTYuXG4gICAgICAgIC8vIFVzZSBsYXN0IDIwIGJ5dGVzLlxuICAgICAgICByZXR1cm4gaGFzaF8xLkhhc2gua2VjY2FrMjU2KHRoaXMudG9CeXRlcyh0cnVlKS5zbGljZSgxKSkuc2xpY2UoLTIwKTtcbiAgICB9XG4gICAgdG9LZXlQYWlyKCkge1xuICAgICAgICBjb25zdCBzZWNwMjU2azEgPSBuZXcgZWxsaXB0aWNfMS5lYyhcInNlY3AyNTZrMVwiKTtcbiAgICAgICAgcmV0dXJuIHNlY3AyNTZrMS5rZXlGcm9tUHVibGljKGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHRoaXMucHViS2V5KS50b1N0cmluZyhcImhleFwiKSwgXCJoZXhcIik7XG4gICAgfVxuICAgIHZlcmlmeURpZ2VzdDMyKGRpZ2VzdCwgc2lnbmF0dXJlKSB7XG4gICAgICAgIGlmIChkaWdlc3QubGVuZ3RoICE9PSAzMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGxlbmd0aCBvZiBkaWdlc3QgdG8gdmVyaWZ5OiAke2RpZ2VzdC5sZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZ25hdHVyZS5sZW5ndGggIT09IDY0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbGVuZ3RoIG9mIHNpZ25hdHVyZTogJHtzaWduYXR1cmUubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlY3AyNTZrMSA9IG5ldyBlbGxpcHRpY18xLmVjKFwic2VjcDI1NmsxXCIpO1xuICAgICAgICBjb25zdCByID0gc2lnbmF0dXJlLnNsaWNlKDAsIDMyKTtcbiAgICAgICAgY29uc3QgcyA9IHNpZ25hdHVyZS5zbGljZSgzMik7XG4gICAgICAgIHJldHVybiBzZWNwMjU2azEudmVyaWZ5KGRpZ2VzdCwge1xuICAgICAgICAgICAgcjogYnVmZmVyXzEuQnVmZmVyLmZyb20ocikudG9TdHJpbmcoXCJoZXhcIiksXG4gICAgICAgICAgICBzOiBidWZmZXJfMS5CdWZmZXIuZnJvbShzKS50b1N0cmluZyhcImhleFwiKSxcbiAgICAgICAgfSwgdGhpcy50b0tleVBhaXIoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5QdWJLZXlTZWNwMjU2azEgPSBQdWJLZXlTZWNwMjU2azE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/crypto/build/key.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/crypto/build/mnemonic.js":
/*!*************************************************************!*\
  !*** ./node_modules/@keplr-wallet/crypto/build/mnemonic.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Mnemonic = void 0;\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst bip39 = __webpack_require__(/*! bip39 */ \"(ssr)/./node_modules/bip39/src/index.js\");\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst bip32 = __webpack_require__(/*! bip32 */ \"(ssr)/./node_modules/bip32/src/index.js\");\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst bs58check = __webpack_require__(/*! bs58check */ \"(ssr)/./node_modules/bs58check/index.js\");\nconst buffer_1 = __webpack_require__(/*! buffer/ */ \"(ssr)/./node_modules/buffer/index.js\");\nclass Mnemonic {\n    static generateWallet(rng, path = `m/44'/118'/0'/0/0`, password = \"\", strength = 256) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const mnemonic = yield Mnemonic.generateSeed(rng, strength);\n            const privKey = Mnemonic.generateWalletFromMnemonic(mnemonic, path, password);\n            return {\n                privKey,\n                mnemonic,\n            };\n        });\n    }\n    static validateMnemonic(mnemonic) {\n        return bip39.validateMnemonic(mnemonic);\n    }\n    static generateSeed(rng, strength = 128) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (strength % 32 !== 0) {\n                throw new TypeError(\"invalid entropy\");\n            }\n            let bytes = new Uint8Array(strength / 8);\n            bytes = yield rng(bytes);\n            return bip39.entropyToMnemonic(buffer_1.Buffer.from(bytes).toString(\"hex\"));\n        });\n    }\n    static generateWalletFromMnemonic(mnemonic, path = `m/44'/118'/0'/0/0`, password = \"\") {\n        const seed = bip39.mnemonicToSeedSync(mnemonic, password);\n        const masterSeed = bip32.fromSeed(seed);\n        const hd = masterSeed.derivePath(path);\n        const privateKey = hd.privateKey;\n        if (!privateKey) {\n            throw new Error(\"null hd key\");\n        }\n        return privateKey;\n    }\n    static generateMasterSeedFromMnemonic(mnemonic, password = \"\") {\n        const seed = bip39.mnemonicToSeedSync(mnemonic, password);\n        const masterKey = bip32.fromSeed(seed);\n        return buffer_1.Buffer.from(bs58check.decode(masterKey.toBase58()));\n    }\n    static generatePrivateKeyFromMasterSeed(seed, path = `m/44'/118'/0'/0/0`) {\n        const masterSeed = bip32.fromBase58(bs58check.encode(seed));\n        const hd = masterSeed.derivePath(path);\n        const privateKey = hd.privateKey;\n        if (!privateKey) {\n            throw new Error(\"null hd key\");\n        }\n        return privateKey;\n    }\n}\nexports.Mnemonic = Mnemonic;\n//# sourceMappingURL=mnemonic.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9jcnlwdG8vYnVpbGQvbW5lbW9uaWMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQjtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxzREFBTztBQUM3QjtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxzREFBTztBQUM3QjtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDBEQUFXO0FBQ3JDLGlCQUFpQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvY3J5cHRvL2J1aWxkL21uZW1vbmljLmpzP2U2NTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTW5lbW9uaWMgPSB2b2lkIDA7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuY29uc3QgYmlwMzkgPSByZXF1aXJlKFwiYmlwMzlcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuY29uc3QgYmlwMzIgPSByZXF1aXJlKFwiYmlwMzJcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXZhci1yZXF1aXJlc1xuY29uc3QgYnM1OGNoZWNrID0gcmVxdWlyZShcImJzNThjaGVja1wiKTtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlci9cIik7XG5jbGFzcyBNbmVtb25pYyB7XG4gICAgc3RhdGljIGdlbmVyYXRlV2FsbGV0KHJuZywgcGF0aCA9IGBtLzQ0Jy8xMTgnLzAnLzAvMGAsIHBhc3N3b3JkID0gXCJcIiwgc3RyZW5ndGggPSAyNTYpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1uZW1vbmljID0geWllbGQgTW5lbW9uaWMuZ2VuZXJhdGVTZWVkKHJuZywgc3RyZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgcHJpdktleSA9IE1uZW1vbmljLmdlbmVyYXRlV2FsbGV0RnJvbU1uZW1vbmljKG1uZW1vbmljLCBwYXRoLCBwYXNzd29yZCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHByaXZLZXksXG4gICAgICAgICAgICAgICAgbW5lbW9uaWMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHZhbGlkYXRlTW5lbW9uaWMobW5lbW9uaWMpIHtcbiAgICAgICAgcmV0dXJuIGJpcDM5LnZhbGlkYXRlTW5lbW9uaWMobW5lbW9uaWMpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2VuZXJhdGVTZWVkKHJuZywgc3RyZW5ndGggPSAxMjgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChzdHJlbmd0aCAlIDMyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgZW50cm9weVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBieXRlcyA9IG5ldyBVaW50OEFycmF5KHN0cmVuZ3RoIC8gOCk7XG4gICAgICAgICAgICBieXRlcyA9IHlpZWxkIHJuZyhieXRlcyk7XG4gICAgICAgICAgICByZXR1cm4gYmlwMzkuZW50cm9weVRvTW5lbW9uaWMoYnVmZmVyXzEuQnVmZmVyLmZyb20oYnl0ZXMpLnRvU3RyaW5nKFwiaGV4XCIpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZW5lcmF0ZVdhbGxldEZyb21NbmVtb25pYyhtbmVtb25pYywgcGF0aCA9IGBtLzQ0Jy8xMTgnLzAnLzAvMGAsIHBhc3N3b3JkID0gXCJcIikge1xuICAgICAgICBjb25zdCBzZWVkID0gYmlwMzkubW5lbW9uaWNUb1NlZWRTeW5jKG1uZW1vbmljLCBwYXNzd29yZCk7XG4gICAgICAgIGNvbnN0IG1hc3RlclNlZWQgPSBiaXAzMi5mcm9tU2VlZChzZWVkKTtcbiAgICAgICAgY29uc3QgaGQgPSBtYXN0ZXJTZWVkLmRlcml2ZVBhdGgocGF0aCk7XG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBoZC5wcml2YXRlS2V5O1xuICAgICAgICBpZiAoIXByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm51bGwgaGQga2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcml2YXRlS2V5O1xuICAgIH1cbiAgICBzdGF0aWMgZ2VuZXJhdGVNYXN0ZXJTZWVkRnJvbU1uZW1vbmljKG1uZW1vbmljLCBwYXNzd29yZCA9IFwiXCIpIHtcbiAgICAgICAgY29uc3Qgc2VlZCA9IGJpcDM5Lm1uZW1vbmljVG9TZWVkU3luYyhtbmVtb25pYywgcGFzc3dvcmQpO1xuICAgICAgICBjb25zdCBtYXN0ZXJLZXkgPSBiaXAzMi5mcm9tU2VlZChzZWVkKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGJzNThjaGVjay5kZWNvZGUobWFzdGVyS2V5LnRvQmFzZTU4KCkpKTtcbiAgICB9XG4gICAgc3RhdGljIGdlbmVyYXRlUHJpdmF0ZUtleUZyb21NYXN0ZXJTZWVkKHNlZWQsIHBhdGggPSBgbS80NCcvMTE4Jy8wJy8wLzBgKSB7XG4gICAgICAgIGNvbnN0IG1hc3RlclNlZWQgPSBiaXAzMi5mcm9tQmFzZTU4KGJzNThjaGVjay5lbmNvZGUoc2VlZCkpO1xuICAgICAgICBjb25zdCBoZCA9IG1hc3RlclNlZWQuZGVyaXZlUGF0aChwYXRoKTtcbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IGhkLnByaXZhdGVLZXk7XG4gICAgICAgIGlmICghcHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibnVsbCBoZCBrZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByaXZhdGVLZXk7XG4gICAgfVxufVxuZXhwb3J0cy5NbmVtb25pYyA9IE1uZW1vbmljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW5lbW9uaWMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/crypto/build/mnemonic.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/agoric/swingset/msgs.js":
/*!************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/agoric/swingset/msgs.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MsgInstallBundleResponse = exports.MsgInstallBundle = exports.MsgProvisionResponse = exports.MsgProvision = exports.MsgWalletSpendActionResponse = exports.MsgWalletSpendAction = exports.MsgWalletActionResponse = exports.MsgWalletAction = exports.MsgDeliverInboundResponse = exports.MsgDeliverInbound = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nexports.protobufPackage = \"agoric.swingset\";\nfunction createBaseMsgDeliverInbound() {\n    return { messages: [], nums: [], ack: \"0\", submitter: new Uint8Array() };\n}\nexports.MsgDeliverInbound = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.messages) {\n            writer.uint32(10).string(v);\n        }\n        writer.uint32(18).fork();\n        for (const v of message.nums) {\n            writer.uint64(v);\n        }\n        writer.ldelim();\n        if (message.ack !== \"0\") {\n            writer.uint32(24).uint64(message.ack);\n        }\n        if (message.submitter.length !== 0) {\n            writer.uint32(34).bytes(message.submitter);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgDeliverInbound();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.messages.push(reader.string());\n                    break;\n                case 2:\n                    if ((tag & 7) === 2) {\n                        const end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2) {\n                            message.nums.push(longToString(reader.uint64()));\n                        }\n                    }\n                    else {\n                        message.nums.push(longToString(reader.uint64()));\n                    }\n                    break;\n                case 3:\n                    message.ack = longToString(reader.uint64());\n                    break;\n                case 4:\n                    message.submitter = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            messages: Array.isArray(object === null || object === void 0 ? void 0 : object.messages)\n                ? object.messages.map((e) => String(e))\n                : [],\n            nums: Array.isArray(object === null || object === void 0 ? void 0 : object.nums)\n                ? object.nums.map((e) => String(e))\n                : [],\n            ack: isSet(object.ack) ? String(object.ack) : \"0\",\n            submitter: isSet(object.submitter)\n                ? bytesFromBase64(object.submitter)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.messages) {\n            obj.messages = message.messages.map((e) => e);\n        }\n        else {\n            obj.messages = [];\n        }\n        if (message.nums) {\n            obj.nums = message.nums.map((e) => e);\n        }\n        else {\n            obj.nums = [];\n        }\n        message.ack !== undefined && (obj.ack = message.ack);\n        message.submitter !== undefined &&\n            (obj.submitter = base64FromBytes(message.submitter !== undefined ? message.submitter : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseMsgDeliverInbound();\n        message.messages = ((_a = object.messages) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        message.nums = ((_b = object.nums) === null || _b === void 0 ? void 0 : _b.map((e) => e)) || [];\n        message.ack = (_c = object.ack) !== null && _c !== void 0 ? _c : \"0\";\n        message.submitter = (_d = object.submitter) !== null && _d !== void 0 ? _d : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseMsgDeliverInboundResponse() {\n    return {};\n}\nexports.MsgDeliverInboundResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgDeliverInboundResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgDeliverInboundResponse();\n        return message;\n    },\n};\nfunction createBaseMsgWalletAction() {\n    return { owner: new Uint8Array(), action: \"\" };\n}\nexports.MsgWalletAction = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.owner.length !== 0) {\n            writer.uint32(10).bytes(message.owner);\n        }\n        if (message.action !== \"\") {\n            writer.uint32(18).string(message.action);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgWalletAction();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.owner = reader.bytes();\n                    break;\n                case 2:\n                    message.action = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            owner: isSet(object.owner)\n                ? bytesFromBase64(object.owner)\n                : new Uint8Array(),\n            action: isSet(object.action) ? String(object.action) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.owner !== undefined &&\n            (obj.owner = base64FromBytes(message.owner !== undefined ? message.owner : new Uint8Array()));\n        message.action !== undefined && (obj.action = message.action);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseMsgWalletAction();\n        message.owner = (_a = object.owner) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.action = (_b = object.action) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseMsgWalletActionResponse() {\n    return {};\n}\nexports.MsgWalletActionResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgWalletActionResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgWalletActionResponse();\n        return message;\n    },\n};\nfunction createBaseMsgWalletSpendAction() {\n    return { owner: new Uint8Array(), spendAction: \"\" };\n}\nexports.MsgWalletSpendAction = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.owner.length !== 0) {\n            writer.uint32(10).bytes(message.owner);\n        }\n        if (message.spendAction !== \"\") {\n            writer.uint32(18).string(message.spendAction);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgWalletSpendAction();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.owner = reader.bytes();\n                    break;\n                case 2:\n                    message.spendAction = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            owner: isSet(object.owner)\n                ? bytesFromBase64(object.owner)\n                : new Uint8Array(),\n            spendAction: isSet(object.spendAction) ? String(object.spendAction) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.owner !== undefined &&\n            (obj.owner = base64FromBytes(message.owner !== undefined ? message.owner : new Uint8Array()));\n        message.spendAction !== undefined &&\n            (obj.spendAction = message.spendAction);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseMsgWalletSpendAction();\n        message.owner = (_a = object.owner) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.spendAction = (_b = object.spendAction) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseMsgWalletSpendActionResponse() {\n    return {};\n}\nexports.MsgWalletSpendActionResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgWalletSpendActionResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgWalletSpendActionResponse();\n        return message;\n    },\n};\nfunction createBaseMsgProvision() {\n    return {\n        nickname: \"\",\n        address: new Uint8Array(),\n        powerFlags: [],\n        submitter: new Uint8Array(),\n    };\n}\nexports.MsgProvision = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.nickname !== \"\") {\n            writer.uint32(10).string(message.nickname);\n        }\n        if (message.address.length !== 0) {\n            writer.uint32(18).bytes(message.address);\n        }\n        for (const v of message.powerFlags) {\n            writer.uint32(26).string(v);\n        }\n        if (message.submitter.length !== 0) {\n            writer.uint32(34).bytes(message.submitter);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgProvision();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.nickname = reader.string();\n                    break;\n                case 2:\n                    message.address = reader.bytes();\n                    break;\n                case 3:\n                    message.powerFlags.push(reader.string());\n                    break;\n                case 4:\n                    message.submitter = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            nickname: isSet(object.nickname) ? String(object.nickname) : \"\",\n            address: isSet(object.address)\n                ? bytesFromBase64(object.address)\n                : new Uint8Array(),\n            powerFlags: Array.isArray(object === null || object === void 0 ? void 0 : object.powerFlags)\n                ? object.powerFlags.map((e) => String(e))\n                : [],\n            submitter: isSet(object.submitter)\n                ? bytesFromBase64(object.submitter)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.nickname !== undefined && (obj.nickname = message.nickname);\n        message.address !== undefined &&\n            (obj.address = base64FromBytes(message.address !== undefined ? message.address : new Uint8Array()));\n        if (message.powerFlags) {\n            obj.powerFlags = message.powerFlags.map((e) => e);\n        }\n        else {\n            obj.powerFlags = [];\n        }\n        message.submitter !== undefined &&\n            (obj.submitter = base64FromBytes(message.submitter !== undefined ? message.submitter : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseMsgProvision();\n        message.nickname = (_a = object.nickname) !== null && _a !== void 0 ? _a : \"\";\n        message.address = (_b = object.address) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.powerFlags = ((_c = object.powerFlags) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];\n        message.submitter = (_d = object.submitter) !== null && _d !== void 0 ? _d : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseMsgProvisionResponse() {\n    return {};\n}\nexports.MsgProvisionResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgProvisionResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgProvisionResponse();\n        return message;\n    },\n};\nfunction createBaseMsgInstallBundle() {\n    return {\n        bundle: \"\",\n        submitter: new Uint8Array(),\n        compressedBundle: new Uint8Array(),\n        uncompressedSize: \"0\",\n    };\n}\nexports.MsgInstallBundle = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.bundle !== \"\") {\n            writer.uint32(10).string(message.bundle);\n        }\n        if (message.submitter.length !== 0) {\n            writer.uint32(18).bytes(message.submitter);\n        }\n        if (message.compressedBundle.length !== 0) {\n            writer.uint32(26).bytes(message.compressedBundle);\n        }\n        if (message.uncompressedSize !== \"0\") {\n            writer.uint32(32).int64(message.uncompressedSize);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgInstallBundle();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bundle = reader.string();\n                    break;\n                case 2:\n                    message.submitter = reader.bytes();\n                    break;\n                case 3:\n                    message.compressedBundle = reader.bytes();\n                    break;\n                case 4:\n                    message.uncompressedSize = longToString(reader.int64());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            bundle: isSet(object.bundle) ? String(object.bundle) : \"\",\n            submitter: isSet(object.submitter)\n                ? bytesFromBase64(object.submitter)\n                : new Uint8Array(),\n            compressedBundle: isSet(object.compressedBundle)\n                ? bytesFromBase64(object.compressedBundle)\n                : new Uint8Array(),\n            uncompressedSize: isSet(object.uncompressedSize)\n                ? String(object.uncompressedSize)\n                : \"0\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bundle !== undefined && (obj.bundle = message.bundle);\n        message.submitter !== undefined &&\n            (obj.submitter = base64FromBytes(message.submitter !== undefined ? message.submitter : new Uint8Array()));\n        message.compressedBundle !== undefined &&\n            (obj.compressedBundle = base64FromBytes(message.compressedBundle !== undefined\n                ? message.compressedBundle\n                : new Uint8Array()));\n        message.uncompressedSize !== undefined &&\n            (obj.uncompressedSize = message.uncompressedSize);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseMsgInstallBundle();\n        message.bundle = (_a = object.bundle) !== null && _a !== void 0 ? _a : \"\";\n        message.submitter = (_b = object.submitter) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.compressedBundle = (_c = object.compressedBundle) !== null && _c !== void 0 ? _c : new Uint8Array();\n        message.uncompressedSize = (_d = object.uncompressedSize) !== null && _d !== void 0 ? _d : \"0\";\n        return message;\n    },\n};\nfunction createBaseMsgInstallBundleResponse() {\n    return {};\n}\nexports.MsgInstallBundleResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgInstallBundleResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgInstallBundleResponse();\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob ||\n    ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa ||\n    ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (const byte of arr) {\n        bin.push(String.fromCharCode(byte));\n    }\n    return btoa(bin.join(\"\"));\n}\nfunction longToString(long) {\n    return long.toString();\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=msgs.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9hZ29yaWMvc3dpbmdzZXQvbXNncy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQyxHQUFHLHdCQUF3QixHQUFHLDRCQUE0QixHQUFHLG9CQUFvQixHQUFHLG9DQUFvQyxHQUFHLDRCQUE0QixHQUFHLCtCQUErQixHQUFHLHVCQUF1QixHQUFHLGlDQUFpQyxHQUFHLHlCQUF5QixHQUFHLHVCQUF1QjtBQUM3VTtBQUNBLCtCQUErQixtQkFBTyxDQUFDLG1EQUFNO0FBQzdDLGtDQUFrQyxtQkFBTyxDQUFDLHNFQUFvQjtBQUM5RCx1QkFBdUI7QUFDdkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9hZ29yaWMvc3dpbmdzZXQvbXNncy5qcz85NzYzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Nc2dJbnN0YWxsQnVuZGxlUmVzcG9uc2UgPSBleHBvcnRzLk1zZ0luc3RhbGxCdW5kbGUgPSBleHBvcnRzLk1zZ1Byb3Zpc2lvblJlc3BvbnNlID0gZXhwb3J0cy5Nc2dQcm92aXNpb24gPSBleHBvcnRzLk1zZ1dhbGxldFNwZW5kQWN0aW9uUmVzcG9uc2UgPSBleHBvcnRzLk1zZ1dhbGxldFNwZW5kQWN0aW9uID0gZXhwb3J0cy5Nc2dXYWxsZXRBY3Rpb25SZXNwb25zZSA9IGV4cG9ydHMuTXNnV2FsbGV0QWN0aW9uID0gZXhwb3J0cy5Nc2dEZWxpdmVySW5ib3VuZFJlc3BvbnNlID0gZXhwb3J0cy5Nc2dEZWxpdmVySW5ib3VuZCA9IGV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGxvbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9uZ1wiKSk7XG5jb25zdCBtaW5pbWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKSk7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwiYWdvcmljLnN3aW5nc2V0XCI7XG5mdW5jdGlvbiBjcmVhdGVCYXNlTXNnRGVsaXZlckluYm91bmQoKSB7XG4gICAgcmV0dXJuIHsgbWVzc2FnZXM6IFtdLCBudW1zOiBbXSwgYWNrOiBcIjBcIiwgc3VibWl0dGVyOiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnRzLk1zZ0RlbGl2ZXJJbmJvdW5kID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyh2KTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIudWludDMyKDE4KS5mb3JrKCk7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLm51bXMpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50NjQodik7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLmxkZWxpbSgpO1xuICAgICAgICBpZiAobWVzc2FnZS5hY2sgIT09IFwiMFwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI0KS51aW50NjQobWVzc2FnZS5hY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnN1Ym1pdHRlci5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMzQpLmJ5dGVzKG1lc3NhZ2Uuc3VibWl0dGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dEZWxpdmVySW5ib3VuZCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWVzc2FnZXMucHVzaChyZWFkZXIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5udW1zLnB1c2gobG9uZ1RvU3RyaW5nKHJlYWRlci51aW50NjQoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5udW1zLnB1c2gobG9uZ1RvU3RyaW5nKHJlYWRlci51aW50NjQoKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hY2sgPSBsb25nVG9TdHJpbmcocmVhZGVyLnVpbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN1Ym1pdHRlciA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QubWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QubWVzc2FnZXMubWFwKChlKSA9PiBTdHJpbmcoZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgICAgIG51bXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0Lm51bXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QubnVtcy5tYXAoKGUpID0+IFN0cmluZyhlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgYWNrOiBpc1NldChvYmplY3QuYWNrKSA/IFN0cmluZyhvYmplY3QuYWNrKSA6IFwiMFwiLFxuICAgICAgICAgICAgc3VibWl0dGVyOiBpc1NldChvYmplY3Quc3VibWl0dGVyKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5zdWJtaXR0ZXIpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBvYmoubWVzc2FnZXMgPSBtZXNzYWdlLm1lc3NhZ2VzLm1hcCgoZSkgPT4gZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5udW1zKSB7XG4gICAgICAgICAgICBvYmoubnVtcyA9IG1lc3NhZ2UubnVtcy5tYXAoKGUpID0+IGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLm51bXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLmFjayAhPT0gdW5kZWZpbmVkICYmIChvYmouYWNrID0gbWVzc2FnZS5hY2spO1xuICAgICAgICBtZXNzYWdlLnN1Ym1pdHRlciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnN1Ym1pdHRlciA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLnN1Ym1pdHRlciAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5zdWJtaXR0ZXIgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ0RlbGl2ZXJJbmJvdW5kKCk7XG4gICAgICAgIG1lc3NhZ2UubWVzc2FnZXMgPSAoKF9hID0gb2JqZWN0Lm1lc3NhZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBlKSkgfHwgW107XG4gICAgICAgIG1lc3NhZ2UubnVtcyA9ICgoX2IgPSBvYmplY3QubnVtcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1hcCgoZSkgPT4gZSkpIHx8IFtdO1xuICAgICAgICBtZXNzYWdlLmFjayA9IChfYyA9IG9iamVjdC5hY2spICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFwiMFwiO1xuICAgICAgICBtZXNzYWdlLnN1Ym1pdHRlciA9IChfZCA9IG9iamVjdC5zdWJtaXR0ZXIpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ0RlbGl2ZXJJbmJvdW5kUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHt9O1xufVxuZXhwb3J0cy5Nc2dEZWxpdmVySW5ib3VuZFJlc3BvbnNlID0ge1xuICAgIGVuY29kZShfLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnRGVsaXZlckluYm91bmRSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04oXykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcbiAgICB0b0pTT04oXykge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKF8pIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dEZWxpdmVySW5ib3VuZFJlc3BvbnNlKCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ1dhbGxldEFjdGlvbigpIHtcbiAgICByZXR1cm4geyBvd25lcjogbmV3IFVpbnQ4QXJyYXkoKSwgYWN0aW9uOiBcIlwiIH07XG59XG5leHBvcnRzLk1zZ1dhbGxldEFjdGlvbiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLm93bmVyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5vd25lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYWN0aW9uICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS5hY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ1dhbGxldEFjdGlvbigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3duZXIgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFjdGlvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3duZXI6IGlzU2V0KG9iamVjdC5vd25lcilcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3Qub3duZXIpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgYWN0aW9uOiBpc1NldChvYmplY3QuYWN0aW9uKSA/IFN0cmluZyhvYmplY3QuYWN0aW9uKSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5vd25lciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLm93bmVyID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2Uub3duZXIgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2Uub3duZXIgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UuYWN0aW9uICE9PSB1bmRlZmluZWQgJiYgKG9iai5hY3Rpb24gPSBtZXNzYWdlLmFjdGlvbik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dXYWxsZXRBY3Rpb24oKTtcbiAgICAgICAgbWVzc2FnZS5vd25lciA9IChfYSA9IG9iamVjdC5vd25lcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5hY3Rpb24gPSAoX2IgPSBvYmplY3QuYWN0aW9uKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dXYWxsZXRBY3Rpb25SZXNwb25zZSgpIHtcbiAgICByZXR1cm4ge307XG59XG5leHBvcnRzLk1zZ1dhbGxldEFjdGlvblJlc3BvbnNlID0ge1xuICAgIGVuY29kZShfLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnV2FsbGV0QWN0aW9uUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKF8pIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH0sXG4gICAgdG9KU09OKF8pIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChfKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnV2FsbGV0QWN0aW9uUmVzcG9uc2UoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlTXNnV2FsbGV0U3BlbmRBY3Rpb24oKSB7XG4gICAgcmV0dXJuIHsgb3duZXI6IG5ldyBVaW50OEFycmF5KCksIHNwZW5kQWN0aW9uOiBcIlwiIH07XG59XG5leHBvcnRzLk1zZ1dhbGxldFNwZW5kQWN0aW9uID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uub3duZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLm93bmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zcGVuZEFjdGlvbiAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2Uuc3BlbmRBY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ1dhbGxldFNwZW5kQWN0aW9uKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vd25lciA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3BlbmRBY3Rpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG93bmVyOiBpc1NldChvYmplY3Qub3duZXIpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0Lm93bmVyKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIHNwZW5kQWN0aW9uOiBpc1NldChvYmplY3Quc3BlbmRBY3Rpb24pID8gU3RyaW5nKG9iamVjdC5zcGVuZEFjdGlvbikgOiBcIlwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uub3duZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5vd25lciA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLm93bmVyICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLm93bmVyIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLnNwZW5kQWN0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc3BlbmRBY3Rpb24gPSBtZXNzYWdlLnNwZW5kQWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ1dhbGxldFNwZW5kQWN0aW9uKCk7XG4gICAgICAgIG1lc3NhZ2Uub3duZXIgPSAoX2EgPSBvYmplY3Qub3duZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2Uuc3BlbmRBY3Rpb24gPSAoX2IgPSBvYmplY3Quc3BlbmRBY3Rpb24pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ1dhbGxldFNwZW5kQWN0aW9uUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHt9O1xufVxuZXhwb3J0cy5Nc2dXYWxsZXRTcGVuZEFjdGlvblJlc3BvbnNlID0ge1xuICAgIGVuY29kZShfLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnV2FsbGV0U3BlbmRBY3Rpb25SZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04oXykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcbiAgICB0b0pTT04oXykge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKF8pIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dXYWxsZXRTcGVuZEFjdGlvblJlc3BvbnNlKCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ1Byb3Zpc2lvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuaWNrbmFtZTogXCJcIixcbiAgICAgICAgYWRkcmVzczogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgcG93ZXJGbGFnczogW10sXG4gICAgICAgIHN1Ym1pdHRlcjogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICB9O1xufVxuZXhwb3J0cy5Nc2dQcm92aXNpb24gPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5uaWNrbmFtZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2Uubmlja25hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmFkZHJlc3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5ieXRlcyhtZXNzYWdlLmFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnBvd2VyRmxhZ3MpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLnN0cmluZyh2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zdWJtaXR0ZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDM0KS5ieXRlcyhtZXNzYWdlLnN1Ym1pdHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnUHJvdmlzaW9uKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5uaWNrbmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZHJlc3MgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBvd2VyRmxhZ3MucHVzaChyZWFkZXIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc3VibWl0dGVyID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5pY2tuYW1lOiBpc1NldChvYmplY3Qubmlja25hbWUpID8gU3RyaW5nKG9iamVjdC5uaWNrbmFtZSkgOiBcIlwiLFxuICAgICAgICAgICAgYWRkcmVzczogaXNTZXQob2JqZWN0LmFkZHJlc3MpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmFkZHJlc3MpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgcG93ZXJGbGFnczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QucG93ZXJGbGFncylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5wb3dlckZsYWdzLm1hcCgoZSkgPT4gU3RyaW5nKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgICAgICBzdWJtaXR0ZXI6IGlzU2V0KG9iamVjdC5zdWJtaXR0ZXIpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnN1Ym1pdHRlcilcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5uaWNrbmFtZSAhPT0gdW5kZWZpbmVkICYmIChvYmoubmlja25hbWUgPSBtZXNzYWdlLm5pY2tuYW1lKTtcbiAgICAgICAgbWVzc2FnZS5hZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYWRkcmVzcyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmFkZHJlc3MgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuYWRkcmVzcyA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucG93ZXJGbGFncykge1xuICAgICAgICAgICAgb2JqLnBvd2VyRmxhZ3MgPSBtZXNzYWdlLnBvd2VyRmxhZ3MubWFwKChlKSA9PiBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5wb3dlckZsYWdzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZS5zdWJtaXR0ZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zdWJtaXR0ZXIgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5zdWJtaXR0ZXIgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2Uuc3VibWl0dGVyIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dQcm92aXNpb24oKTtcbiAgICAgICAgbWVzc2FnZS5uaWNrbmFtZSA9IChfYSA9IG9iamVjdC5uaWNrbmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5hZGRyZXNzID0gKF9iID0gb2JqZWN0LmFkZHJlc3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UucG93ZXJGbGFncyA9ICgoX2MgPSBvYmplY3QucG93ZXJGbGFncykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1hcCgoZSkgPT4gZSkpIHx8IFtdO1xuICAgICAgICBtZXNzYWdlLnN1Ym1pdHRlciA9IChfZCA9IG9iamVjdC5zdWJtaXR0ZXIpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ1Byb3Zpc2lvblJlc3BvbnNlKCkge1xuICAgIHJldHVybiB7fTtcbn1cbmV4cG9ydHMuTXNnUHJvdmlzaW9uUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKF8sIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dQcm92aXNpb25SZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04oXykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcbiAgICB0b0pTT04oXykge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKF8pIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dQcm92aXNpb25SZXNwb25zZSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dJbnN0YWxsQnVuZGxlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJ1bmRsZTogXCJcIixcbiAgICAgICAgc3VibWl0dGVyOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICBjb21wcmVzc2VkQnVuZGxlOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB1bmNvbXByZXNzZWRTaXplOiBcIjBcIixcbiAgICB9O1xufVxuZXhwb3J0cy5Nc2dJbnN0YWxsQnVuZGxlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYnVuZGxlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5idW5kbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnN1Ym1pdHRlci5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2Uuc3VibWl0dGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb21wcmVzc2VkQnVuZGxlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuYnl0ZXMobWVzc2FnZS5jb21wcmVzc2VkQnVuZGxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS51bmNvbXByZXNzZWRTaXplICE9PSBcIjBcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzMikuaW50NjQobWVzc2FnZS51bmNvbXByZXNzZWRTaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dJbnN0YWxsQnVuZGxlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5idW5kbGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdWJtaXR0ZXIgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbXByZXNzZWRCdW5kbGUgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVuY29tcHJlc3NlZFNpemUgPSBsb25nVG9TdHJpbmcocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBidW5kbGU6IGlzU2V0KG9iamVjdC5idW5kbGUpID8gU3RyaW5nKG9iamVjdC5idW5kbGUpIDogXCJcIixcbiAgICAgICAgICAgIHN1Ym1pdHRlcjogaXNTZXQob2JqZWN0LnN1Ym1pdHRlcilcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3Quc3VibWl0dGVyKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIGNvbXByZXNzZWRCdW5kbGU6IGlzU2V0KG9iamVjdC5jb21wcmVzc2VkQnVuZGxlKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5jb21wcmVzc2VkQnVuZGxlKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIHVuY29tcHJlc3NlZFNpemU6IGlzU2V0KG9iamVjdC51bmNvbXByZXNzZWRTaXplKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC51bmNvbXByZXNzZWRTaXplKVxuICAgICAgICAgICAgICAgIDogXCIwXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5idW5kbGUgIT09IHVuZGVmaW5lZCAmJiAob2JqLmJ1bmRsZSA9IG1lc3NhZ2UuYnVuZGxlKTtcbiAgICAgICAgbWVzc2FnZS5zdWJtaXR0ZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zdWJtaXR0ZXIgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5zdWJtaXR0ZXIgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2Uuc3VibWl0dGVyIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLmNvbXByZXNzZWRCdW5kbGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb21wcmVzc2VkQnVuZGxlID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuY29tcHJlc3NlZEJ1bmRsZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBtZXNzYWdlLmNvbXByZXNzZWRCdW5kbGVcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS51bmNvbXByZXNzZWRTaXplICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudW5jb21wcmVzc2VkU2l6ZSA9IG1lc3NhZ2UudW5jb21wcmVzc2VkU2l6ZSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ0luc3RhbGxCdW5kbGUoKTtcbiAgICAgICAgbWVzc2FnZS5idW5kbGUgPSAoX2EgPSBvYmplY3QuYnVuZGxlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnN1Ym1pdHRlciA9IChfYiA9IG9iamVjdC5zdWJtaXR0ZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UuY29tcHJlc3NlZEJ1bmRsZSA9IChfYyA9IG9iamVjdC5jb21wcmVzc2VkQnVuZGxlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLnVuY29tcHJlc3NlZFNpemUgPSAoX2QgPSBvYmplY3QudW5jb21wcmVzc2VkU2l6ZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogXCIwXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ0luc3RhbGxCdW5kbGVSZXNwb25zZSgpIHtcbiAgICByZXR1cm4ge307XG59XG5leHBvcnRzLk1zZ0luc3RhbGxCdW5kbGVSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUoXywgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ0luc3RhbGxCdW5kbGVSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04oXykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcbiAgICB0b0pTT04oXykge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKF8pIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dJbnN0YWxsQnVuZGxlUmVzcG9uc2UoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG52YXIgZ2xvYmFsVGhpcyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIHRocm93IFwiVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0XCI7XG59KSgpO1xuY29uc3QgYXRvYiA9IGdsb2JhbFRoaXMuYXRvYiB8fFxuICAgICgoYjY0KSA9PiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikudG9TdHJpbmcoXCJiaW5hcnlcIikpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NCkge1xuICAgIGNvbnN0IGJpbiA9IGF0b2IoYjY0KTtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmNvbnN0IGJ0b2EgPSBnbG9iYWxUaGlzLmJ0b2EgfHxcbiAgICAoKGJpbikgPT4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiaW4sIFwiYmluYXJ5XCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpKTtcbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnIpIHtcbiAgICBjb25zdCBiaW4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGJ5dGUgb2YgYXJyKSB7XG4gICAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYShiaW4uam9pbihcIlwiKSk7XG59XG5mdW5jdGlvbiBsb25nVG9TdHJpbmcobG9uZykge1xuICAgIHJldHVybiBsb25nLnRvU3RyaW5nKCk7XG59XG5pZiAobWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nICE9PSBsb25nXzEuZGVmYXVsdCkge1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyA9IGxvbmdfMS5kZWZhdWx0O1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1zZ3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/agoric/swingset/msgs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/authz/v1beta1/authz.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/cosmos/authz/v1beta1/authz.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Grant = exports.GenericAuthorization = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nconst timestamp_1 = __webpack_require__(/*! ../../../google/protobuf/timestamp */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/timestamp.js\");\nconst any_1 = __webpack_require__(/*! ../../../google/protobuf/any */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/any.js\");\nexports.protobufPackage = \"cosmos.authz.v1beta1\";\nfunction createBaseGenericAuthorization() {\n    return { msg: \"\" };\n}\nexports.GenericAuthorization = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.msg !== \"\") {\n            writer.uint32(10).string(message.msg);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGenericAuthorization();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.msg = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            msg: isSet(object.msg) ? String(object.msg) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.msg !== undefined && (obj.msg = message.msg);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGenericAuthorization();\n        message.msg = (_a = object.msg) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseGrant() {\n    return { authorization: undefined, expiration: undefined };\n}\nexports.Grant = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.authorization !== undefined) {\n            any_1.Any.encode(message.authorization, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.expiration !== undefined) {\n            timestamp_1.Timestamp.encode(toTimestamp(message.expiration), writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGrant();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.authorization = any_1.Any.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.expiration = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            authorization: isSet(object.authorization)\n                ? any_1.Any.fromJSON(object.authorization)\n                : undefined,\n            expiration: isSet(object.expiration)\n                ? fromJsonTimestamp(object.expiration)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.authorization !== undefined &&\n            (obj.authorization = message.authorization\n                ? any_1.Any.toJSON(message.authorization)\n                : undefined);\n        message.expiration !== undefined &&\n            (obj.expiration = message.expiration.toISOString());\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGrant();\n        message.authorization =\n            object.authorization !== undefined && object.authorization !== null\n                ? any_1.Any.fromPartial(object.authorization)\n                : undefined;\n        message.expiration = (_a = object.expiration) !== null && _a !== void 0 ? _a : undefined;\n        return message;\n    },\n};\nfunction toTimestamp(date) {\n    const seconds = Math.trunc(date.getTime() / 1000).toString();\n    const nanos = (date.getTime() % 1000) * 1000000;\n    return { seconds, nanos };\n}\nfunction fromTimestamp(t) {\n    let millis = Number(t.seconds) * 1000;\n    millis += t.nanos / 1000000;\n    return new Date(millis);\n}\nfunction fromJsonTimestamp(o) {\n    if (o instanceof Date) {\n        return o;\n    }\n    else if (typeof o === \"string\") {\n        return new Date(o);\n    }\n    else {\n        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));\n    }\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=authz.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3MvYXV0aHovdjFiZXRhMS9hdXRoei5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyw0QkFBNEIsR0FBRyx1QkFBdUI7QUFDdEU7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyxtREFBTTtBQUM3QyxrQ0FBa0MsbUJBQU8sQ0FBQyxzRUFBb0I7QUFDOUQsb0JBQW9CLG1CQUFPLENBQUMsdUhBQW9DO0FBQ2hFLGNBQWMsbUJBQU8sQ0FBQywyR0FBOEI7QUFDcEQsdUJBQXVCO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L3Byb3RvLXR5cGVzL2Nvc21vcy9hdXRoei92MWJldGExL2F1dGh6LmpzPzAxMGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdyYW50ID0gZXhwb3J0cy5HZW5lcmljQXV0aG9yaXphdGlvbiA9IGV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGxvbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9uZ1wiKSk7XG5jb25zdCBtaW5pbWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKSk7XG5jb25zdCB0aW1lc3RhbXBfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9nb29nbGUvcHJvdG9idWYvdGltZXN0YW1wXCIpO1xuY29uc3QgYW55XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vZ29vZ2xlL3Byb3RvYnVmL2FueVwiKTtcbmV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gXCJjb3Ntb3MuYXV0aHoudjFiZXRhMVwiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZUdlbmVyaWNBdXRob3JpemF0aW9uKCkge1xuICAgIHJldHVybiB7IG1zZzogXCJcIiB9O1xufVxuZXhwb3J0cy5HZW5lcmljQXV0aG9yaXphdGlvbiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLm1zZyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UubXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZW5lcmljQXV0aG9yaXphdGlvbigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubXNnID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtc2c6IGlzU2V0KG9iamVjdC5tc2cpID8gU3RyaW5nKG9iamVjdC5tc2cpIDogXCJcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLm1zZyAhPT0gdW5kZWZpbmVkICYmIChvYmoubXNnID0gbWVzc2FnZS5tc2cpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHZW5lcmljQXV0aG9yaXphdGlvbigpO1xuICAgICAgICBtZXNzYWdlLm1zZyA9IChfYSA9IG9iamVjdC5tc2cpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUdyYW50KCkge1xuICAgIHJldHVybiB7IGF1dGhvcml6YXRpb246IHVuZGVmaW5lZCwgZXhwaXJhdGlvbjogdW5kZWZpbmVkIH07XG59XG5leHBvcnRzLkdyYW50ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYXV0aG9yaXphdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhbnlfMS5BbnkuZW5jb2RlKG1lc3NhZ2UuYXV0aG9yaXphdGlvbiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5leHBpcmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcF8xLlRpbWVzdGFtcC5lbmNvZGUodG9UaW1lc3RhbXAobWVzc2FnZS5leHBpcmF0aW9uKSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHcmFudCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXV0aG9yaXphdGlvbiA9IGFueV8xLkFueS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXhwaXJhdGlvbiA9IGZyb21UaW1lc3RhbXAodGltZXN0YW1wXzEuVGltZXN0YW1wLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdXRob3JpemF0aW9uOiBpc1NldChvYmplY3QuYXV0aG9yaXphdGlvbilcbiAgICAgICAgICAgICAgICA/IGFueV8xLkFueS5mcm9tSlNPTihvYmplY3QuYXV0aG9yaXphdGlvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGV4cGlyYXRpb246IGlzU2V0KG9iamVjdC5leHBpcmF0aW9uKVxuICAgICAgICAgICAgICAgID8gZnJvbUpzb25UaW1lc3RhbXAob2JqZWN0LmV4cGlyYXRpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5hdXRob3JpemF0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYXV0aG9yaXphdGlvbiA9IG1lc3NhZ2UuYXV0aG9yaXphdGlvblxuICAgICAgICAgICAgICAgID8gYW55XzEuQW55LnRvSlNPTihtZXNzYWdlLmF1dGhvcml6YXRpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmV4cGlyYXRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5leHBpcmF0aW9uID0gbWVzc2FnZS5leHBpcmF0aW9uLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VHcmFudCgpO1xuICAgICAgICBtZXNzYWdlLmF1dGhvcml6YXRpb24gPVxuICAgICAgICAgICAgb2JqZWN0LmF1dGhvcml6YXRpb24gIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuYXV0aG9yaXphdGlvbiAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gYW55XzEuQW55LmZyb21QYXJ0aWFsKG9iamVjdC5hdXRob3JpemF0aW9uKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmV4cGlyYXRpb24gPSAoX2EgPSBvYmplY3QuZXhwaXJhdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHRvVGltZXN0YW1wKGRhdGUpIHtcbiAgICBjb25zdCBzZWNvbmRzID0gTWF0aC50cnVuYyhkYXRlLmdldFRpbWUoKSAvIDEwMDApLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgbmFub3MgPSAoZGF0ZS5nZXRUaW1lKCkgJSAxMDAwKSAqIDEwMDAwMDA7XG4gICAgcmV0dXJuIHsgc2Vjb25kcywgbmFub3MgfTtcbn1cbmZ1bmN0aW9uIGZyb21UaW1lc3RhbXAodCkge1xuICAgIGxldCBtaWxsaXMgPSBOdW1iZXIodC5zZWNvbmRzKSAqIDEwMDA7XG4gICAgbWlsbGlzICs9IHQubmFub3MgLyAxMDAwMDAwO1xuICAgIHJldHVybiBuZXcgRGF0ZShtaWxsaXMpO1xufVxuZnVuY3Rpb24gZnJvbUpzb25UaW1lc3RhbXAobykge1xuICAgIGlmIChvIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gbztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG8pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZyb21UaW1lc3RhbXAodGltZXN0YW1wXzEuVGltZXN0YW1wLmZyb21KU09OKG8pKTtcbiAgICB9XG59XG5pZiAobWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nICE9PSBsb25nXzEuZGVmYXVsdCkge1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyA9IGxvbmdfMS5kZWZhdWx0O1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGh6LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/authz/v1beta1/authz.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/authz/v1beta1/tx.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/cosmos/authz/v1beta1/tx.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MsgRevokeResponse = exports.MsgRevoke = exports.MsgGrantResponse = exports.MsgExec = exports.MsgExecResponse = exports.MsgGrant = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nconst authz_1 = __webpack_require__(/*! ../../../cosmos/authz/v1beta1/authz */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/authz/v1beta1/authz.js\");\nconst any_1 = __webpack_require__(/*! ../../../google/protobuf/any */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/any.js\");\nexports.protobufPackage = \"cosmos.authz.v1beta1\";\nfunction createBaseMsgGrant() {\n    return { granter: \"\", grantee: \"\", grant: undefined };\n}\nexports.MsgGrant = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.granter !== \"\") {\n            writer.uint32(10).string(message.granter);\n        }\n        if (message.grantee !== \"\") {\n            writer.uint32(18).string(message.grantee);\n        }\n        if (message.grant !== undefined) {\n            authz_1.Grant.encode(message.grant, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgGrant();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.granter = reader.string();\n                    break;\n                case 2:\n                    message.grantee = reader.string();\n                    break;\n                case 3:\n                    message.grant = authz_1.Grant.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            granter: isSet(object.granter) ? String(object.granter) : \"\",\n            grantee: isSet(object.grantee) ? String(object.grantee) : \"\",\n            grant: isSet(object.grant) ? authz_1.Grant.fromJSON(object.grant) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.granter !== undefined && (obj.granter = message.granter);\n        message.grantee !== undefined && (obj.grantee = message.grantee);\n        message.grant !== undefined &&\n            (obj.grant = message.grant ? authz_1.Grant.toJSON(message.grant) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseMsgGrant();\n        message.granter = (_a = object.granter) !== null && _a !== void 0 ? _a : \"\";\n        message.grantee = (_b = object.grantee) !== null && _b !== void 0 ? _b : \"\";\n        message.grant =\n            object.grant !== undefined && object.grant !== null\n                ? authz_1.Grant.fromPartial(object.grant)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseMsgExecResponse() {\n    return { results: [] };\n}\nexports.MsgExecResponse = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.results) {\n            writer.uint32(10).bytes(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgExecResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.results.push(reader.bytes());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            results: Array.isArray(object === null || object === void 0 ? void 0 : object.results)\n                ? object.results.map((e) => bytesFromBase64(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.results) {\n            obj.results = message.results.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));\n        }\n        else {\n            obj.results = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseMsgExecResponse();\n        message.results = ((_a = object.results) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBaseMsgExec() {\n    return { grantee: \"\", msgs: [] };\n}\nexports.MsgExec = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.grantee !== \"\") {\n            writer.uint32(10).string(message.grantee);\n        }\n        for (const v of message.msgs) {\n            any_1.Any.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgExec();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.grantee = reader.string();\n                    break;\n                case 2:\n                    message.msgs.push(any_1.Any.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            grantee: isSet(object.grantee) ? String(object.grantee) : \"\",\n            msgs: Array.isArray(object === null || object === void 0 ? void 0 : object.msgs)\n                ? object.msgs.map((e) => any_1.Any.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.grantee !== undefined && (obj.grantee = message.grantee);\n        if (message.msgs) {\n            obj.msgs = message.msgs.map((e) => (e ? any_1.Any.toJSON(e) : undefined));\n        }\n        else {\n            obj.msgs = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseMsgExec();\n        message.grantee = (_a = object.grantee) !== null && _a !== void 0 ? _a : \"\";\n        message.msgs = ((_b = object.msgs) === null || _b === void 0 ? void 0 : _b.map((e) => any_1.Any.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseMsgGrantResponse() {\n    return {};\n}\nexports.MsgGrantResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgGrantResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgGrantResponse();\n        return message;\n    },\n};\nfunction createBaseMsgRevoke() {\n    return { granter: \"\", grantee: \"\", msgTypeUrl: \"\" };\n}\nexports.MsgRevoke = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.granter !== \"\") {\n            writer.uint32(10).string(message.granter);\n        }\n        if (message.grantee !== \"\") {\n            writer.uint32(18).string(message.grantee);\n        }\n        if (message.msgTypeUrl !== \"\") {\n            writer.uint32(26).string(message.msgTypeUrl);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgRevoke();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.granter = reader.string();\n                    break;\n                case 2:\n                    message.grantee = reader.string();\n                    break;\n                case 3:\n                    message.msgTypeUrl = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            granter: isSet(object.granter) ? String(object.granter) : \"\",\n            grantee: isSet(object.grantee) ? String(object.grantee) : \"\",\n            msgTypeUrl: isSet(object.msgTypeUrl) ? String(object.msgTypeUrl) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.granter !== undefined && (obj.granter = message.granter);\n        message.grantee !== undefined && (obj.grantee = message.grantee);\n        message.msgTypeUrl !== undefined && (obj.msgTypeUrl = message.msgTypeUrl);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseMsgRevoke();\n        message.granter = (_a = object.granter) !== null && _a !== void 0 ? _a : \"\";\n        message.grantee = (_b = object.grantee) !== null && _b !== void 0 ? _b : \"\";\n        message.msgTypeUrl = (_c = object.msgTypeUrl) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBaseMsgRevokeResponse() {\n    return {};\n}\nexports.MsgRevokeResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgRevokeResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgRevokeResponse();\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob ||\n    ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa ||\n    ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (const byte of arr) {\n        bin.push(String.fromCharCode(byte));\n    }\n    return btoa(bin.join(\"\"));\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=tx.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3MvYXV0aHovdjFiZXRhMS90eC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLGlCQUFpQixHQUFHLHdCQUF3QixHQUFHLGVBQWUsR0FBRyx1QkFBdUIsR0FBRyxnQkFBZ0IsR0FBRyx1QkFBdUI7QUFDaks7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyxtREFBTTtBQUM3QyxrQ0FBa0MsbUJBQU8sQ0FBQyxzRUFBb0I7QUFDOUQsZ0JBQWdCLG1CQUFPLENBQUMseUhBQXFDO0FBQzdELGNBQWMsbUJBQU8sQ0FBQywyR0FBOEI7QUFDcEQsdUJBQXVCO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvcHJvdG8tdHlwZXMvY29zbW9zL2F1dGh6L3YxYmV0YTEvdHguanM/Y2NhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTXNnUmV2b2tlUmVzcG9uc2UgPSBleHBvcnRzLk1zZ1Jldm9rZSA9IGV4cG9ydHMuTXNnR3JhbnRSZXNwb25zZSA9IGV4cG9ydHMuTXNnRXhlYyA9IGV4cG9ydHMuTXNnRXhlY1Jlc3BvbnNlID0gZXhwb3J0cy5Nc2dHcmFudCA9IGV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGxvbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9uZ1wiKSk7XG5jb25zdCBtaW5pbWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKSk7XG5jb25zdCBhdXRoel8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2Nvc21vcy9hdXRoei92MWJldGExL2F1dGh6XCIpO1xuY29uc3QgYW55XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vZ29vZ2xlL3Byb3RvYnVmL2FueVwiKTtcbmV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gXCJjb3Ntb3MuYXV0aHoudjFiZXRhMVwiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ0dyYW50KCkge1xuICAgIHJldHVybiB7IGdyYW50ZXI6IFwiXCIsIGdyYW50ZWU6IFwiXCIsIGdyYW50OiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydHMuTXNnR3JhbnQgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5ncmFudGVyICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5ncmFudGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5ncmFudGVlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS5ncmFudGVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5ncmFudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhdXRoel8xLkdyYW50LmVuY29kZShtZXNzYWdlLmdyYW50LCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ0dyYW50KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ncmFudGVyID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZ3JhbnRlZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmdyYW50ID0gYXV0aHpfMS5HcmFudC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBncmFudGVyOiBpc1NldChvYmplY3QuZ3JhbnRlcikgPyBTdHJpbmcob2JqZWN0LmdyYW50ZXIpIDogXCJcIixcbiAgICAgICAgICAgIGdyYW50ZWU6IGlzU2V0KG9iamVjdC5ncmFudGVlKSA/IFN0cmluZyhvYmplY3QuZ3JhbnRlZSkgOiBcIlwiLFxuICAgICAgICAgICAgZ3JhbnQ6IGlzU2V0KG9iamVjdC5ncmFudCkgPyBhdXRoel8xLkdyYW50LmZyb21KU09OKG9iamVjdC5ncmFudCkgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5ncmFudGVyICE9PSB1bmRlZmluZWQgJiYgKG9iai5ncmFudGVyID0gbWVzc2FnZS5ncmFudGVyKTtcbiAgICAgICAgbWVzc2FnZS5ncmFudGVlICE9PSB1bmRlZmluZWQgJiYgKG9iai5ncmFudGVlID0gbWVzc2FnZS5ncmFudGVlKTtcbiAgICAgICAgbWVzc2FnZS5ncmFudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmdyYW50ID0gbWVzc2FnZS5ncmFudCA/IGF1dGh6XzEuR3JhbnQudG9KU09OKG1lc3NhZ2UuZ3JhbnQpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ0dyYW50KCk7XG4gICAgICAgIG1lc3NhZ2UuZ3JhbnRlciA9IChfYSA9IG9iamVjdC5ncmFudGVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmdyYW50ZWUgPSAoX2IgPSBvYmplY3QuZ3JhbnRlZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5ncmFudCA9XG4gICAgICAgICAgICBvYmplY3QuZ3JhbnQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZ3JhbnQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGF1dGh6XzEuR3JhbnQuZnJvbVBhcnRpYWwob2JqZWN0LmdyYW50KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dFeGVjUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHsgcmVzdWx0czogW10gfTtcbn1cbmV4cG9ydHMuTXNnRXhlY1Jlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucmVzdWx0cykge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXModik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnRXhlY1Jlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXN1bHRzLnB1c2gocmVhZGVyLmJ5dGVzKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHRzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5yZXN1bHRzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LnJlc3VsdHMubWFwKChlKSA9PiBieXRlc0Zyb21CYXNlNjQoZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5yZXN1bHRzKSB7XG4gICAgICAgICAgICBvYmoucmVzdWx0cyA9IG1lc3NhZ2UucmVzdWx0cy5tYXAoKGUpID0+IGJhc2U2NEZyb21CeXRlcyhlICE9PSB1bmRlZmluZWQgPyBlIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnJlc3VsdHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dFeGVjUmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5yZXN1bHRzID0gKChfYSA9IG9iamVjdC5yZXN1bHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBlKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ0V4ZWMoKSB7XG4gICAgcmV0dXJuIHsgZ3JhbnRlZTogXCJcIiwgbXNnczogW10gfTtcbn1cbmV4cG9ydHMuTXNnRXhlYyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmdyYW50ZWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmdyYW50ZWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLm1zZ3MpIHtcbiAgICAgICAgICAgIGFueV8xLkFueS5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dFeGVjKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ncmFudGVlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubXNncy5wdXNoKGFueV8xLkFueS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ3JhbnRlZTogaXNTZXQob2JqZWN0LmdyYW50ZWUpID8gU3RyaW5nKG9iamVjdC5ncmFudGVlKSA6IFwiXCIsXG4gICAgICAgICAgICBtc2dzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5tc2dzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0Lm1zZ3MubWFwKChlKSA9PiBhbnlfMS5BbnkuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmdyYW50ZWUgIT09IHVuZGVmaW5lZCAmJiAob2JqLmdyYW50ZWUgPSBtZXNzYWdlLmdyYW50ZWUpO1xuICAgICAgICBpZiAobWVzc2FnZS5tc2dzKSB7XG4gICAgICAgICAgICBvYmoubXNncyA9IG1lc3NhZ2UubXNncy5tYXAoKGUpID0+IChlID8gYW55XzEuQW55LnRvSlNPTihlKSA6IHVuZGVmaW5lZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLm1zZ3MgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnRXhlYygpO1xuICAgICAgICBtZXNzYWdlLmdyYW50ZWUgPSAoX2EgPSBvYmplY3QuZ3JhbnRlZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5tc2dzID0gKChfYiA9IG9iamVjdC5tc2dzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWFwKChlKSA9PiBhbnlfMS5BbnkuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlTXNnR3JhbnRSZXNwb25zZSgpIHtcbiAgICByZXR1cm4ge307XG59XG5leHBvcnRzLk1zZ0dyYW50UmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKF8sIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dHcmFudFJlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihfKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9LFxuICAgIHRvSlNPTihfKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwoXykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ0dyYW50UmVzcG9uc2UoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlTXNnUmV2b2tlKCkge1xuICAgIHJldHVybiB7IGdyYW50ZXI6IFwiXCIsIGdyYW50ZWU6IFwiXCIsIG1zZ1R5cGVVcmw6IFwiXCIgfTtcbn1cbmV4cG9ydHMuTXNnUmV2b2tlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZ3JhbnRlciAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuZ3JhbnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZ3JhbnRlZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UuZ3JhbnRlZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubXNnVHlwZVVybCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuc3RyaW5nKG1lc3NhZ2UubXNnVHlwZVVybCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnUmV2b2tlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ncmFudGVyID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZ3JhbnRlZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1zZ1R5cGVVcmwgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdyYW50ZXI6IGlzU2V0KG9iamVjdC5ncmFudGVyKSA/IFN0cmluZyhvYmplY3QuZ3JhbnRlcikgOiBcIlwiLFxuICAgICAgICAgICAgZ3JhbnRlZTogaXNTZXQob2JqZWN0LmdyYW50ZWUpID8gU3RyaW5nKG9iamVjdC5ncmFudGVlKSA6IFwiXCIsXG4gICAgICAgICAgICBtc2dUeXBlVXJsOiBpc1NldChvYmplY3QubXNnVHlwZVVybCkgPyBTdHJpbmcob2JqZWN0Lm1zZ1R5cGVVcmwpIDogXCJcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmdyYW50ZXIgIT09IHVuZGVmaW5lZCAmJiAob2JqLmdyYW50ZXIgPSBtZXNzYWdlLmdyYW50ZXIpO1xuICAgICAgICBtZXNzYWdlLmdyYW50ZWUgIT09IHVuZGVmaW5lZCAmJiAob2JqLmdyYW50ZWUgPSBtZXNzYWdlLmdyYW50ZWUpO1xuICAgICAgICBtZXNzYWdlLm1zZ1R5cGVVcmwgIT09IHVuZGVmaW5lZCAmJiAob2JqLm1zZ1R5cGVVcmwgPSBtZXNzYWdlLm1zZ1R5cGVVcmwpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ1Jldm9rZSgpO1xuICAgICAgICBtZXNzYWdlLmdyYW50ZXIgPSAoX2EgPSBvYmplY3QuZ3JhbnRlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5ncmFudGVlID0gKF9iID0gb2JqZWN0LmdyYW50ZWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UubXNnVHlwZVVybCA9IChfYyA9IG9iamVjdC5tc2dUeXBlVXJsKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dSZXZva2VSZXNwb25zZSgpIHtcbiAgICByZXR1cm4ge307XG59XG5leHBvcnRzLk1zZ1Jldm9rZVJlc3BvbnNlID0ge1xuICAgIGVuY29kZShfLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnUmV2b2tlUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKF8pIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH0sXG4gICAgdG9KU09OKF8pIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChfKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnUmV2b2tlUmVzcG9uc2UoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG52YXIgZ2xvYmFsVGhpcyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIHRocm93IFwiVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0XCI7XG59KSgpO1xuY29uc3QgYXRvYiA9IGdsb2JhbFRoaXMuYXRvYiB8fFxuICAgICgoYjY0KSA9PiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikudG9TdHJpbmcoXCJiaW5hcnlcIikpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NCkge1xuICAgIGNvbnN0IGJpbiA9IGF0b2IoYjY0KTtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmNvbnN0IGJ0b2EgPSBnbG9iYWxUaGlzLmJ0b2EgfHxcbiAgICAoKGJpbikgPT4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiaW4sIFwiYmluYXJ5XCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpKTtcbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnIpIHtcbiAgICBjb25zdCBiaW4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGJ5dGUgb2YgYXJyKSB7XG4gICAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYShiaW4uam9pbihcIlwiKSk7XG59XG5pZiAobWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nICE9PSBsb25nXzEuZGVmYXVsdCkge1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyA9IGxvbmdfMS5kZWZhdWx0O1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/authz/v1beta1/tx.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/authz.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/authz.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SendAuthorization = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nconst coin_1 = __webpack_require__(/*! ../../../cosmos/base/v1beta1/coin */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/base/v1beta1/coin.js\");\nexports.protobufPackage = \"cosmos.bank.v1beta1\";\nfunction createBaseSendAuthorization() {\n    return { spendLimit: [] };\n}\nexports.SendAuthorization = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.spendLimit) {\n            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSendAuthorization();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.spendLimit.push(coin_1.Coin.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            spendLimit: Array.isArray(object === null || object === void 0 ? void 0 : object.spendLimit)\n                ? object.spendLimit.map((e) => coin_1.Coin.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.spendLimit) {\n            obj.spendLimit = message.spendLimit.map((e) => e ? coin_1.Coin.toJSON(e) : undefined);\n        }\n        else {\n            obj.spendLimit = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSendAuthorization();\n        message.spendLimit =\n            ((_a = object.spendLimit) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];\n        return message;\n    },\n};\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\n//# sourceMappingURL=authz.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3MvYmFuay92MWJldGExL2F1dGh6LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLEdBQUcsdUJBQXVCO0FBQ25EO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMsbURBQU07QUFDN0Msa0NBQWtDLG1CQUFPLENBQUMsc0VBQW9CO0FBQzlELGVBQWUsbUJBQU8sQ0FBQyxxSEFBbUM7QUFDMUQsdUJBQXVCO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3MvYmFuay92MWJldGExL2F1dGh6LmpzP2IxYWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlbmRBdXRob3JpemF0aW9uID0gZXhwb3J0cy5wcm90b2J1ZlBhY2thZ2UgPSB2b2lkIDA7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuY29uc3QgbG9uZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb25nXCIpKTtcbmNvbnN0IG1pbmltYWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicHJvdG9idWZqcy9taW5pbWFsXCIpKTtcbmNvbnN0IGNvaW5fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3Ntb3MvYmFzZS92MWJldGExL2NvaW5cIik7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwiY29zbW9zLmJhbmsudjFiZXRhMVwiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNlbmRBdXRob3JpemF0aW9uKCkge1xuICAgIHJldHVybiB7IHNwZW5kTGltaXQ6IFtdIH07XG59XG5leHBvcnRzLlNlbmRBdXRob3JpemF0aW9uID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2Uuc3BlbmRMaW1pdCkge1xuICAgICAgICAgICAgY29pbl8xLkNvaW4uZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2VuZEF1dGhvcml6YXRpb24oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNwZW5kTGltaXQucHVzaChjb2luXzEuQ29pbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3BlbmRMaW1pdDogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3Quc3BlbmRMaW1pdClcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5zcGVuZExpbWl0Lm1hcCgoZSkgPT4gY29pbl8xLkNvaW4uZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5zcGVuZExpbWl0KSB7XG4gICAgICAgICAgICBvYmouc3BlbmRMaW1pdCA9IG1lc3NhZ2Uuc3BlbmRMaW1pdC5tYXAoKGUpID0+IGUgPyBjb2luXzEuQ29pbi50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnNwZW5kTGltaXQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTZW5kQXV0aG9yaXphdGlvbigpO1xuICAgICAgICBtZXNzYWdlLnNwZW5kTGltaXQgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC5zcGVuZExpbWl0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBjb2luXzEuQ29pbi5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmlmIChtaW5pbWFsXzEuZGVmYXVsdC51dGlsLkxvbmcgIT09IGxvbmdfMS5kZWZhdWx0KSB7XG4gICAgbWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nID0gbG9uZ18xLmRlZmF1bHQ7XG4gICAgbWluaW1hbF8xLmRlZmF1bHQuY29uZmlndXJlKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRoei5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/authz.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/bank.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/bank.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Metadata = exports.DenomUnit = exports.Supply = exports.Output = exports.Input = exports.SendEnabled = exports.Params = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nconst coin_1 = __webpack_require__(/*! ../../../cosmos/base/v1beta1/coin */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/base/v1beta1/coin.js\");\nexports.protobufPackage = \"cosmos.bank.v1beta1\";\nfunction createBaseParams() {\n    return { sendEnabled: [], defaultSendEnabled: false };\n}\nexports.Params = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.sendEnabled) {\n            exports.SendEnabled.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.defaultSendEnabled === true) {\n            writer.uint32(16).bool(message.defaultSendEnabled);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseParams();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sendEnabled.push(exports.SendEnabled.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.defaultSendEnabled = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            sendEnabled: Array.isArray(object === null || object === void 0 ? void 0 : object.sendEnabled)\n                ? object.sendEnabled.map((e) => exports.SendEnabled.fromJSON(e))\n                : [],\n            defaultSendEnabled: isSet(object.defaultSendEnabled)\n                ? Boolean(object.defaultSendEnabled)\n                : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.sendEnabled) {\n            obj.sendEnabled = message.sendEnabled.map((e) => e ? exports.SendEnabled.toJSON(e) : undefined);\n        }\n        else {\n            obj.sendEnabled = [];\n        }\n        message.defaultSendEnabled !== undefined &&\n            (obj.defaultSendEnabled = message.defaultSendEnabled);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseParams();\n        message.sendEnabled =\n            ((_a = object.sendEnabled) === null || _a === void 0 ? void 0 : _a.map((e) => exports.SendEnabled.fromPartial(e))) || [];\n        message.defaultSendEnabled = (_b = object.defaultSendEnabled) !== null && _b !== void 0 ? _b : false;\n        return message;\n    },\n};\nfunction createBaseSendEnabled() {\n    return { denom: \"\", enabled: false };\n}\nexports.SendEnabled = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.denom !== \"\") {\n            writer.uint32(10).string(message.denom);\n        }\n        if (message.enabled === true) {\n            writer.uint32(16).bool(message.enabled);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSendEnabled();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.denom = reader.string();\n                    break;\n                case 2:\n                    message.enabled = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            denom: isSet(object.denom) ? String(object.denom) : \"\",\n            enabled: isSet(object.enabled) ? Boolean(object.enabled) : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.denom !== undefined && (obj.denom = message.denom);\n        message.enabled !== undefined && (obj.enabled = message.enabled);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseSendEnabled();\n        message.denom = (_a = object.denom) !== null && _a !== void 0 ? _a : \"\";\n        message.enabled = (_b = object.enabled) !== null && _b !== void 0 ? _b : false;\n        return message;\n    },\n};\nfunction createBaseInput() {\n    return { address: \"\", coins: [] };\n}\nexports.Input = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.address !== \"\") {\n            writer.uint32(10).string(message.address);\n        }\n        for (const v of message.coins) {\n            coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseInput();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.address = reader.string();\n                    break;\n                case 2:\n                    message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            address: isSet(object.address) ? String(object.address) : \"\",\n            coins: Array.isArray(object === null || object === void 0 ? void 0 : object.coins)\n                ? object.coins.map((e) => coin_1.Coin.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.address !== undefined && (obj.address = message.address);\n        if (message.coins) {\n            obj.coins = message.coins.map((e) => (e ? coin_1.Coin.toJSON(e) : undefined));\n        }\n        else {\n            obj.coins = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseInput();\n        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : \"\";\n        message.coins = ((_b = object.coins) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseOutput() {\n    return { address: \"\", coins: [] };\n}\nexports.Output = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.address !== \"\") {\n            writer.uint32(10).string(message.address);\n        }\n        for (const v of message.coins) {\n            coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseOutput();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.address = reader.string();\n                    break;\n                case 2:\n                    message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            address: isSet(object.address) ? String(object.address) : \"\",\n            coins: Array.isArray(object === null || object === void 0 ? void 0 : object.coins)\n                ? object.coins.map((e) => coin_1.Coin.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.address !== undefined && (obj.address = message.address);\n        if (message.coins) {\n            obj.coins = message.coins.map((e) => (e ? coin_1.Coin.toJSON(e) : undefined));\n        }\n        else {\n            obj.coins = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseOutput();\n        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : \"\";\n        message.coins = ((_b = object.coins) === null || _b === void 0 ? void 0 : _b.map((e) => coin_1.Coin.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseSupply() {\n    return { total: [] };\n}\nexports.Supply = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.total) {\n            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSupply();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.total.push(coin_1.Coin.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            total: Array.isArray(object === null || object === void 0 ? void 0 : object.total)\n                ? object.total.map((e) => coin_1.Coin.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.total) {\n            obj.total = message.total.map((e) => (e ? coin_1.Coin.toJSON(e) : undefined));\n        }\n        else {\n            obj.total = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSupply();\n        message.total = ((_a = object.total) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseDenomUnit() {\n    return { denom: \"\", exponent: 0, aliases: [] };\n}\nexports.DenomUnit = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.denom !== \"\") {\n            writer.uint32(10).string(message.denom);\n        }\n        if (message.exponent !== 0) {\n            writer.uint32(16).uint32(message.exponent);\n        }\n        for (const v of message.aliases) {\n            writer.uint32(26).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDenomUnit();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.denom = reader.string();\n                    break;\n                case 2:\n                    message.exponent = reader.uint32();\n                    break;\n                case 3:\n                    message.aliases.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            denom: isSet(object.denom) ? String(object.denom) : \"\",\n            exponent: isSet(object.exponent) ? Number(object.exponent) : 0,\n            aliases: Array.isArray(object === null || object === void 0 ? void 0 : object.aliases)\n                ? object.aliases.map((e) => String(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.denom !== undefined && (obj.denom = message.denom);\n        message.exponent !== undefined &&\n            (obj.exponent = Math.round(message.exponent));\n        if (message.aliases) {\n            obj.aliases = message.aliases.map((e) => e);\n        }\n        else {\n            obj.aliases = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseDenomUnit();\n        message.denom = (_a = object.denom) !== null && _a !== void 0 ? _a : \"\";\n        message.exponent = (_b = object.exponent) !== null && _b !== void 0 ? _b : 0;\n        message.aliases = ((_c = object.aliases) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBaseMetadata() {\n    return {\n        description: \"\",\n        denomUnits: [],\n        base: \"\",\n        display: \"\",\n        name: \"\",\n        symbol: \"\",\n    };\n}\nexports.Metadata = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.description !== \"\") {\n            writer.uint32(10).string(message.description);\n        }\n        for (const v of message.denomUnits) {\n            exports.DenomUnit.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.base !== \"\") {\n            writer.uint32(26).string(message.base);\n        }\n        if (message.display !== \"\") {\n            writer.uint32(34).string(message.display);\n        }\n        if (message.name !== \"\") {\n            writer.uint32(42).string(message.name);\n        }\n        if (message.symbol !== \"\") {\n            writer.uint32(50).string(message.symbol);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMetadata();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.description = reader.string();\n                    break;\n                case 2:\n                    message.denomUnits.push(exports.DenomUnit.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.base = reader.string();\n                    break;\n                case 4:\n                    message.display = reader.string();\n                    break;\n                case 5:\n                    message.name = reader.string();\n                    break;\n                case 6:\n                    message.symbol = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            description: isSet(object.description) ? String(object.description) : \"\",\n            denomUnits: Array.isArray(object === null || object === void 0 ? void 0 : object.denomUnits)\n                ? object.denomUnits.map((e) => exports.DenomUnit.fromJSON(e))\n                : [],\n            base: isSet(object.base) ? String(object.base) : \"\",\n            display: isSet(object.display) ? String(object.display) : \"\",\n            name: isSet(object.name) ? String(object.name) : \"\",\n            symbol: isSet(object.symbol) ? String(object.symbol) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.description !== undefined &&\n            (obj.description = message.description);\n        if (message.denomUnits) {\n            obj.denomUnits = message.denomUnits.map((e) => e ? exports.DenomUnit.toJSON(e) : undefined);\n        }\n        else {\n            obj.denomUnits = [];\n        }\n        message.base !== undefined && (obj.base = message.base);\n        message.display !== undefined && (obj.display = message.display);\n        message.name !== undefined && (obj.name = message.name);\n        message.symbol !== undefined && (obj.symbol = message.symbol);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f;\n        const message = createBaseMetadata();\n        message.description = (_a = object.description) !== null && _a !== void 0 ? _a : \"\";\n        message.denomUnits =\n            ((_b = object.denomUnits) === null || _b === void 0 ? void 0 : _b.map((e) => exports.DenomUnit.fromPartial(e))) || [];\n        message.base = (_c = object.base) !== null && _c !== void 0 ? _c : \"\";\n        message.display = (_d = object.display) !== null && _d !== void 0 ? _d : \"\";\n        message.name = (_e = object.name) !== null && _e !== void 0 ? _e : \"\";\n        message.symbol = (_f = object.symbol) !== null && _f !== void 0 ? _f : \"\";\n        return message;\n    },\n};\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=bank.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3MvYmFuay92MWJldGExL2JhbmsuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxpQkFBaUIsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxtQkFBbUIsR0FBRyxjQUFjLEdBQUcsdUJBQXVCO0FBQ3ZKO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMsbURBQU07QUFDN0Msa0NBQWtDLG1CQUFPLENBQUMsc0VBQW9CO0FBQzlELGVBQWUsbUJBQU8sQ0FBQyxxSEFBbUM7QUFDMUQsdUJBQXVCO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvcHJvdG8tdHlwZXMvY29zbW9zL2JhbmsvdjFiZXRhMS9iYW5rLmpzP2UzN2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1ldGFkYXRhID0gZXhwb3J0cy5EZW5vbVVuaXQgPSBleHBvcnRzLlN1cHBseSA9IGV4cG9ydHMuT3V0cHV0ID0gZXhwb3J0cy5JbnB1dCA9IGV4cG9ydHMuU2VuZEVuYWJsZWQgPSBleHBvcnRzLlBhcmFtcyA9IGV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGxvbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9uZ1wiKSk7XG5jb25zdCBtaW5pbWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKSk7XG5jb25zdCBjb2luXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29zbW9zL2Jhc2UvdjFiZXRhMS9jb2luXCIpO1xuZXhwb3J0cy5wcm90b2J1ZlBhY2thZ2UgPSBcImNvc21vcy5iYW5rLnYxYmV0YTFcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQYXJhbXMoKSB7XG4gICAgcmV0dXJuIHsgc2VuZEVuYWJsZWQ6IFtdLCBkZWZhdWx0U2VuZEVuYWJsZWQ6IGZhbHNlIH07XG59XG5leHBvcnRzLlBhcmFtcyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnNlbmRFbmFibGVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLlNlbmRFbmFibGVkLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmRlZmF1bHRTZW5kRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikuYm9vbChtZXNzYWdlLmRlZmF1bHRTZW5kRW5hYmxlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUGFyYW1zKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZW5kRW5hYmxlZC5wdXNoKGV4cG9ydHMuU2VuZEVuYWJsZWQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kZWZhdWx0U2VuZEVuYWJsZWQgPSByZWFkZXIuYm9vbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZW5kRW5hYmxlZDogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3Quc2VuZEVuYWJsZWQpXG4gICAgICAgICAgICAgICAgPyBvYmplY3Quc2VuZEVuYWJsZWQubWFwKChlKSA9PiBleHBvcnRzLlNlbmRFbmFibGVkLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgICAgICBkZWZhdWx0U2VuZEVuYWJsZWQ6IGlzU2V0KG9iamVjdC5kZWZhdWx0U2VuZEVuYWJsZWQpXG4gICAgICAgICAgICAgICAgPyBCb29sZWFuKG9iamVjdC5kZWZhdWx0U2VuZEVuYWJsZWQpXG4gICAgICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5zZW5kRW5hYmxlZCkge1xuICAgICAgICAgICAgb2JqLnNlbmRFbmFibGVkID0gbWVzc2FnZS5zZW5kRW5hYmxlZC5tYXAoKGUpID0+IGUgPyBleHBvcnRzLlNlbmRFbmFibGVkLnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouc2VuZEVuYWJsZWQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLmRlZmF1bHRTZW5kRW5hYmxlZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmRlZmF1bHRTZW5kRW5hYmxlZCA9IG1lc3NhZ2UuZGVmYXVsdFNlbmRFbmFibGVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVBhcmFtcygpO1xuICAgICAgICBtZXNzYWdlLnNlbmRFbmFibGVkID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3Quc2VuZEVuYWJsZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IGV4cG9ydHMuU2VuZEVuYWJsZWQuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgbWVzc2FnZS5kZWZhdWx0U2VuZEVuYWJsZWQgPSAoX2IgPSBvYmplY3QuZGVmYXVsdFNlbmRFbmFibGVkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2VuZEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHsgZGVub206IFwiXCIsIGVuYWJsZWQ6IGZhbHNlIH07XG59XG5leHBvcnRzLlNlbmRFbmFibGVkID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZGVub20gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmRlbm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS5ib29sKG1lc3NhZ2UuZW5hYmxlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2VuZEVuYWJsZWQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRlbm9tID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZW5hYmxlZCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbm9tOiBpc1NldChvYmplY3QuZGVub20pID8gU3RyaW5nKG9iamVjdC5kZW5vbSkgOiBcIlwiLFxuICAgICAgICAgICAgZW5hYmxlZDogaXNTZXQob2JqZWN0LmVuYWJsZWQpID8gQm9vbGVhbihvYmplY3QuZW5hYmxlZCkgOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmRlbm9tICE9PSB1bmRlZmluZWQgJiYgKG9iai5kZW5vbSA9IG1lc3NhZ2UuZGVub20pO1xuICAgICAgICBtZXNzYWdlLmVuYWJsZWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmVuYWJsZWQgPSBtZXNzYWdlLmVuYWJsZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2VuZEVuYWJsZWQoKTtcbiAgICAgICAgbWVzc2FnZS5kZW5vbSA9IChfYSA9IG9iamVjdC5kZW5vbSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5lbmFibGVkID0gKF9iID0gb2JqZWN0LmVuYWJsZWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VJbnB1dCgpIHtcbiAgICByZXR1cm4geyBhZGRyZXNzOiBcIlwiLCBjb2luczogW10gfTtcbn1cbmV4cG9ydHMuSW5wdXQgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5hZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5hZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5jb2lucykge1xuICAgICAgICAgICAgY29pbl8xLkNvaW4uZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSW5wdXQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb2lucy5wdXNoKGNvaW5fMS5Db2luLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzOiBpc1NldChvYmplY3QuYWRkcmVzcykgPyBTdHJpbmcob2JqZWN0LmFkZHJlc3MpIDogXCJcIixcbiAgICAgICAgICAgIGNvaW5zOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5jb2lucylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5jb2lucy5tYXAoKGUpID0+IGNvaW5fMS5Db2luLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5hZGRyZXNzICE9PSB1bmRlZmluZWQgJiYgKG9iai5hZGRyZXNzID0gbWVzc2FnZS5hZGRyZXNzKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuY29pbnMpIHtcbiAgICAgICAgICAgIG9iai5jb2lucyA9IG1lc3NhZ2UuY29pbnMubWFwKChlKSA9PiAoZSA/IGNvaW5fMS5Db2luLnRvSlNPTihlKSA6IHVuZGVmaW5lZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLmNvaW5zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUlucHV0KCk7XG4gICAgICAgIG1lc3NhZ2UuYWRkcmVzcyA9IChfYSA9IG9iamVjdC5hZGRyZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmNvaW5zID0gKChfYiA9IG9iamVjdC5jb2lucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1hcCgoZSkgPT4gY29pbl8xLkNvaW4uZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlT3V0cHV0KCkge1xuICAgIHJldHVybiB7IGFkZHJlc3M6IFwiXCIsIGNvaW5zOiBbXSB9O1xufVxuZXhwb3J0cy5PdXRwdXQgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5hZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5hZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5jb2lucykge1xuICAgICAgICAgICAgY29pbl8xLkNvaW4uZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlT3V0cHV0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29pbnMucHVzaChjb2luXzEuQ29pbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzczogaXNTZXQob2JqZWN0LmFkZHJlc3MpID8gU3RyaW5nKG9iamVjdC5hZGRyZXNzKSA6IFwiXCIsXG4gICAgICAgICAgICBjb2luczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QuY29pbnMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QuY29pbnMubWFwKChlKSA9PiBjb2luXzEuQ29pbi5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuYWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmIChvYmouYWRkcmVzcyA9IG1lc3NhZ2UuYWRkcmVzcyk7XG4gICAgICAgIGlmIChtZXNzYWdlLmNvaW5zKSB7XG4gICAgICAgICAgICBvYmouY29pbnMgPSBtZXNzYWdlLmNvaW5zLm1hcCgoZSkgPT4gKGUgPyBjb2luXzEuQ29pbi50b0pTT04oZSkgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5jb2lucyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VPdXRwdXQoKTtcbiAgICAgICAgbWVzc2FnZS5hZGRyZXNzID0gKF9hID0gb2JqZWN0LmFkZHJlc3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuY29pbnMgPSAoKF9iID0gb2JqZWN0LmNvaW5zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWFwKChlKSA9PiBjb2luXzEuQ29pbi5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTdXBwbHkoKSB7XG4gICAgcmV0dXJuIHsgdG90YWw6IFtdIH07XG59XG5leHBvcnRzLlN1cHBseSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnRvdGFsKSB7XG4gICAgICAgICAgICBjb2luXzEuQ29pbi5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTdXBwbHkoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRvdGFsLnB1c2goY29pbl8xLkNvaW4uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvdGFsOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC50b3RhbClcbiAgICAgICAgICAgICAgICA/IG9iamVjdC50b3RhbC5tYXAoKGUpID0+IGNvaW5fMS5Db2luLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UudG90YWwpIHtcbiAgICAgICAgICAgIG9iai50b3RhbCA9IG1lc3NhZ2UudG90YWwubWFwKChlKSA9PiAoZSA/IGNvaW5fMS5Db2luLnRvSlNPTihlKSA6IHVuZGVmaW5lZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnRvdGFsID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU3VwcGx5KCk7XG4gICAgICAgIG1lc3NhZ2UudG90YWwgPSAoKF9hID0gb2JqZWN0LnRvdGFsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBjb2luXzEuQ29pbi5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VEZW5vbVVuaXQoKSB7XG4gICAgcmV0dXJuIHsgZGVub206IFwiXCIsIGV4cG9uZW50OiAwLCBhbGlhc2VzOiBbXSB9O1xufVxuZXhwb3J0cy5EZW5vbVVuaXQgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5kZW5vbSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuZGVub20pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmV4cG9uZW50ICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS51aW50MzIobWVzc2FnZS5leHBvbmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuYWxpYXNlcykge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuc3RyaW5nKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlbm9tVW5pdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVub20gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5leHBvbmVudCA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFsaWFzZXMucHVzaChyZWFkZXIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZW5vbTogaXNTZXQob2JqZWN0LmRlbm9tKSA/IFN0cmluZyhvYmplY3QuZGVub20pIDogXCJcIixcbiAgICAgICAgICAgIGV4cG9uZW50OiBpc1NldChvYmplY3QuZXhwb25lbnQpID8gTnVtYmVyKG9iamVjdC5leHBvbmVudCkgOiAwLFxuICAgICAgICAgICAgYWxpYXNlczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QuYWxpYXNlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5hbGlhc2VzLm1hcCgoZSkgPT4gU3RyaW5nKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5kZW5vbSAhPT0gdW5kZWZpbmVkICYmIChvYmouZGVub20gPSBtZXNzYWdlLmRlbm9tKTtcbiAgICAgICAgbWVzc2FnZS5leHBvbmVudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmV4cG9uZW50ID0gTWF0aC5yb3VuZChtZXNzYWdlLmV4cG9uZW50KSk7XG4gICAgICAgIGlmIChtZXNzYWdlLmFsaWFzZXMpIHtcbiAgICAgICAgICAgIG9iai5hbGlhc2VzID0gbWVzc2FnZS5hbGlhc2VzLm1hcCgoZSkgPT4gZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouYWxpYXNlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRGVub21Vbml0KCk7XG4gICAgICAgIG1lc3NhZ2UuZGVub20gPSAoX2EgPSBvYmplY3QuZGVub20pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuZXhwb25lbnQgPSAoX2IgPSBvYmplY3QuZXhwb25lbnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG4gICAgICAgIG1lc3NhZ2UuYWxpYXNlcyA9ICgoX2MgPSBvYmplY3QuYWxpYXNlcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1hcCgoZSkgPT4gZSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgZGVub21Vbml0czogW10sXG4gICAgICAgIGJhc2U6IFwiXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiXCIsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHN5bWJvbDogXCJcIixcbiAgICB9O1xufVxuZXhwb3J0cy5NZXRhZGF0YSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmRlc2NyaXB0aW9uICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5kZXNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuZGVub21Vbml0cykge1xuICAgICAgICAgICAgZXhwb3J0cy5EZW5vbVVuaXQuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYmFzZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuc3RyaW5nKG1lc3NhZ2UuYmFzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGlzcGxheSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzNCkuc3RyaW5nKG1lc3NhZ2UuZGlzcGxheSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig0Mikuc3RyaW5nKG1lc3NhZ2UubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3ltYm9sICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDUwKS5zdHJpbmcobWVzc2FnZS5zeW1ib2wpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1ldGFkYXRhKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kZXNjcmlwdGlvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRlbm9tVW5pdHMucHVzaChleHBvcnRzLkRlbm9tVW5pdC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJhc2UgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaXNwbGF5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN5bWJvbCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IGlzU2V0KG9iamVjdC5kZXNjcmlwdGlvbikgPyBTdHJpbmcob2JqZWN0LmRlc2NyaXB0aW9uKSA6IFwiXCIsXG4gICAgICAgICAgICBkZW5vbVVuaXRzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5kZW5vbVVuaXRzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LmRlbm9tVW5pdHMubWFwKChlKSA9PiBleHBvcnRzLkRlbm9tVW5pdC5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgYmFzZTogaXNTZXQob2JqZWN0LmJhc2UpID8gU3RyaW5nKG9iamVjdC5iYXNlKSA6IFwiXCIsXG4gICAgICAgICAgICBkaXNwbGF5OiBpc1NldChvYmplY3QuZGlzcGxheSkgPyBTdHJpbmcob2JqZWN0LmRpc3BsYXkpIDogXCJcIixcbiAgICAgICAgICAgIG5hbWU6IGlzU2V0KG9iamVjdC5uYW1lKSA/IFN0cmluZyhvYmplY3QubmFtZSkgOiBcIlwiLFxuICAgICAgICAgICAgc3ltYm9sOiBpc1NldChvYmplY3Quc3ltYm9sKSA/IFN0cmluZyhvYmplY3Quc3ltYm9sKSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmRlc2NyaXB0aW9uID0gbWVzc2FnZS5kZXNjcmlwdGlvbik7XG4gICAgICAgIGlmIChtZXNzYWdlLmRlbm9tVW5pdHMpIHtcbiAgICAgICAgICAgIG9iai5kZW5vbVVuaXRzID0gbWVzc2FnZS5kZW5vbVVuaXRzLm1hcCgoZSkgPT4gZSA/IGV4cG9ydHMuRGVub21Vbml0LnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouZGVub21Vbml0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UuYmFzZSAhPT0gdW5kZWZpbmVkICYmIChvYmouYmFzZSA9IG1lc3NhZ2UuYmFzZSk7XG4gICAgICAgIG1lc3NhZ2UuZGlzcGxheSAhPT0gdW5kZWZpbmVkICYmIChvYmouZGlzcGxheSA9IG1lc3NhZ2UuZGlzcGxheSk7XG4gICAgICAgIG1lc3NhZ2UubmFtZSAhPT0gdW5kZWZpbmVkICYmIChvYmoubmFtZSA9IG1lc3NhZ2UubmFtZSk7XG4gICAgICAgIG1lc3NhZ2Uuc3ltYm9sICE9PSB1bmRlZmluZWQgJiYgKG9iai5zeW1ib2wgPSBtZXNzYWdlLnN5bWJvbCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTWV0YWRhdGEoKTtcbiAgICAgICAgbWVzc2FnZS5kZXNjcmlwdGlvbiA9IChfYSA9IG9iamVjdC5kZXNjcmlwdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5kZW5vbVVuaXRzID1cbiAgICAgICAgICAgICgoX2IgPSBvYmplY3QuZGVub21Vbml0cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1hcCgoZSkgPT4gZXhwb3J0cy5EZW5vbVVuaXQuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgbWVzc2FnZS5iYXNlID0gKF9jID0gb2JqZWN0LmJhc2UpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuZGlzcGxheSA9IChfZCA9IG9iamVjdC5kaXNwbGF5KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLm5hbWUgPSAoX2UgPSBvYmplY3QubmFtZSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5zeW1ib2wgPSAoX2YgPSBvYmplY3Quc3ltYm9sKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmlmIChtaW5pbWFsXzEuZGVmYXVsdC51dGlsLkxvbmcgIT09IGxvbmdfMS5kZWZhdWx0KSB7XG4gICAgbWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nID0gbG9uZ18xLmRlZmF1bHQ7XG4gICAgbWluaW1hbF8xLmRlZmF1bHQuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFuay5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/bank.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/tx.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/tx.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MsgMultiSendResponse = exports.MsgMultiSend = exports.MsgSendResponse = exports.MsgSend = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nconst coin_1 = __webpack_require__(/*! ../../../cosmos/base/v1beta1/coin */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/base/v1beta1/coin.js\");\nconst bank_1 = __webpack_require__(/*! ../../../cosmos/bank/v1beta1/bank */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/bank.js\");\nexports.protobufPackage = \"cosmos.bank.v1beta1\";\nfunction createBaseMsgSend() {\n    return { fromAddress: \"\", toAddress: \"\", amount: [] };\n}\nexports.MsgSend = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.fromAddress !== \"\") {\n            writer.uint32(10).string(message.fromAddress);\n        }\n        if (message.toAddress !== \"\") {\n            writer.uint32(18).string(message.toAddress);\n        }\n        for (const v of message.amount) {\n            coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgSend();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.fromAddress = reader.string();\n                    break;\n                case 2:\n                    message.toAddress = reader.string();\n                    break;\n                case 3:\n                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            fromAddress: isSet(object.fromAddress) ? String(object.fromAddress) : \"\",\n            toAddress: isSet(object.toAddress) ? String(object.toAddress) : \"\",\n            amount: Array.isArray(object === null || object === void 0 ? void 0 : object.amount)\n                ? object.amount.map((e) => coin_1.Coin.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.fromAddress !== undefined &&\n            (obj.fromAddress = message.fromAddress);\n        message.toAddress !== undefined && (obj.toAddress = message.toAddress);\n        if (message.amount) {\n            obj.amount = message.amount.map((e) => (e ? coin_1.Coin.toJSON(e) : undefined));\n        }\n        else {\n            obj.amount = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseMsgSend();\n        message.fromAddress = (_a = object.fromAddress) !== null && _a !== void 0 ? _a : \"\";\n        message.toAddress = (_b = object.toAddress) !== null && _b !== void 0 ? _b : \"\";\n        message.amount = ((_c = object.amount) === null || _c === void 0 ? void 0 : _c.map((e) => coin_1.Coin.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseMsgSendResponse() {\n    return {};\n}\nexports.MsgSendResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgSendResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgSendResponse();\n        return message;\n    },\n};\nfunction createBaseMsgMultiSend() {\n    return { inputs: [], outputs: [] };\n}\nexports.MsgMultiSend = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.inputs) {\n            bank_1.Input.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.outputs) {\n            bank_1.Output.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgMultiSend();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.inputs.push(bank_1.Input.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.outputs.push(bank_1.Output.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            inputs: Array.isArray(object === null || object === void 0 ? void 0 : object.inputs)\n                ? object.inputs.map((e) => bank_1.Input.fromJSON(e))\n                : [],\n            outputs: Array.isArray(object === null || object === void 0 ? void 0 : object.outputs)\n                ? object.outputs.map((e) => bank_1.Output.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.inputs) {\n            obj.inputs = message.inputs.map((e) => (e ? bank_1.Input.toJSON(e) : undefined));\n        }\n        else {\n            obj.inputs = [];\n        }\n        if (message.outputs) {\n            obj.outputs = message.outputs.map((e) => e ? bank_1.Output.toJSON(e) : undefined);\n        }\n        else {\n            obj.outputs = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseMsgMultiSend();\n        message.inputs = ((_a = object.inputs) === null || _a === void 0 ? void 0 : _a.map((e) => bank_1.Input.fromPartial(e))) || [];\n        message.outputs = ((_b = object.outputs) === null || _b === void 0 ? void 0 : _b.map((e) => bank_1.Output.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseMsgMultiSendResponse() {\n    return {};\n}\nexports.MsgMultiSendResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgMultiSendResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgMultiSendResponse();\n        return message;\n    },\n};\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=tx.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3MvYmFuay92MWJldGExL3R4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsb0JBQW9CLEdBQUcsdUJBQXVCLEdBQUcsZUFBZSxHQUFHLHVCQUF1QjtBQUN6SDtBQUNBLCtCQUErQixtQkFBTyxDQUFDLG1EQUFNO0FBQzdDLGtDQUFrQyxtQkFBTyxDQUFDLHNFQUFvQjtBQUM5RCxlQUFlLG1CQUFPLENBQUMscUhBQW1DO0FBQzFELGVBQWUsbUJBQU8sQ0FBQyxxSEFBbUM7QUFDMUQsdUJBQXVCO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvcHJvdG8tdHlwZXMvY29zbW9zL2JhbmsvdjFiZXRhMS90eC5qcz9mZGI0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Nc2dNdWx0aVNlbmRSZXNwb25zZSA9IGV4cG9ydHMuTXNnTXVsdGlTZW5kID0gZXhwb3J0cy5Nc2dTZW5kUmVzcG9uc2UgPSBleHBvcnRzLk1zZ1NlbmQgPSBleHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlICovXG5jb25zdCBsb25nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvbmdcIikpO1xuY29uc3QgbWluaW1hbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwcm90b2J1ZmpzL21pbmltYWxcIikpO1xuY29uc3QgY29pbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2Nvc21vcy9iYXNlL3YxYmV0YTEvY29pblwiKTtcbmNvbnN0IGJhbmtfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3Ntb3MvYmFuay92MWJldGExL2JhbmtcIik7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwiY29zbW9zLmJhbmsudjFiZXRhMVwiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ1NlbmQoKSB7XG4gICAgcmV0dXJuIHsgZnJvbUFkZHJlc3M6IFwiXCIsIHRvQWRkcmVzczogXCJcIiwgYW1vdW50OiBbXSB9O1xufVxuZXhwb3J0cy5Nc2dTZW5kID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZnJvbUFkZHJlc3MgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmZyb21BZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50b0FkZHJlc3MgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnRvQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuYW1vdW50KSB7XG4gICAgICAgICAgICBjb2luXzEuQ29pbi5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dTZW5kKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mcm9tQWRkcmVzcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRvQWRkcmVzcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFtb3VudC5wdXNoKGNvaW5fMS5Db2luLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm9tQWRkcmVzczogaXNTZXQob2JqZWN0LmZyb21BZGRyZXNzKSA/IFN0cmluZyhvYmplY3QuZnJvbUFkZHJlc3MpIDogXCJcIixcbiAgICAgICAgICAgIHRvQWRkcmVzczogaXNTZXQob2JqZWN0LnRvQWRkcmVzcykgPyBTdHJpbmcob2JqZWN0LnRvQWRkcmVzcykgOiBcIlwiLFxuICAgICAgICAgICAgYW1vdW50OiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5hbW91bnQpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QuYW1vdW50Lm1hcCgoZSkgPT4gY29pbl8xLkNvaW4uZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmZyb21BZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZnJvbUFkZHJlc3MgPSBtZXNzYWdlLmZyb21BZGRyZXNzKTtcbiAgICAgICAgbWVzc2FnZS50b0FkZHJlc3MgIT09IHVuZGVmaW5lZCAmJiAob2JqLnRvQWRkcmVzcyA9IG1lc3NhZ2UudG9BZGRyZXNzKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYW1vdW50KSB7XG4gICAgICAgICAgICBvYmouYW1vdW50ID0gbWVzc2FnZS5hbW91bnQubWFwKChlKSA9PiAoZSA/IGNvaW5fMS5Db2luLnRvSlNPTihlKSA6IHVuZGVmaW5lZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLmFtb3VudCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnU2VuZCgpO1xuICAgICAgICBtZXNzYWdlLmZyb21BZGRyZXNzID0gKF9hID0gb2JqZWN0LmZyb21BZGRyZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnRvQWRkcmVzcyA9IChfYiA9IG9iamVjdC50b0FkZHJlc3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuYW1vdW50ID0gKChfYyA9IG9iamVjdC5hbW91bnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5tYXAoKGUpID0+IGNvaW5fMS5Db2luLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ1NlbmRSZXNwb25zZSgpIHtcbiAgICByZXR1cm4ge307XG59XG5leHBvcnRzLk1zZ1NlbmRSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUoXywgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ1NlbmRSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04oXykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcbiAgICB0b0pTT04oXykge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKF8pIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dTZW5kUmVzcG9uc2UoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlTXNnTXVsdGlTZW5kKCkge1xuICAgIHJldHVybiB7IGlucHV0czogW10sIG91dHB1dHM6IFtdIH07XG59XG5leHBvcnRzLk1zZ011bHRpU2VuZCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLmlucHV0cykge1xuICAgICAgICAgICAgYmFua18xLklucHV0LmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLm91dHB1dHMpIHtcbiAgICAgICAgICAgIGJhbmtfMS5PdXRwdXQuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnTXVsdGlTZW5kKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnB1dHMucHVzaChiYW5rXzEuSW5wdXQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vdXRwdXRzLnB1c2goYmFua18xLk91dHB1dC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXRzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5pbnB1dHMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QuaW5wdXRzLm1hcCgoZSkgPT4gYmFua18xLklucHV0LmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgICAgICBvdXRwdXRzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5vdXRwdXRzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0Lm91dHB1dHMubWFwKChlKSA9PiBiYW5rXzEuT3V0cHV0LmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5wdXRzKSB7XG4gICAgICAgICAgICBvYmouaW5wdXRzID0gbWVzc2FnZS5pbnB1dHMubWFwKChlKSA9PiAoZSA/IGJhbmtfMS5JbnB1dC50b0pTT04oZSkgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5pbnB1dHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5vdXRwdXRzKSB7XG4gICAgICAgICAgICBvYmoub3V0cHV0cyA9IG1lc3NhZ2Uub3V0cHV0cy5tYXAoKGUpID0+IGUgPyBiYW5rXzEuT3V0cHV0LnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoub3V0cHV0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dNdWx0aVNlbmQoKTtcbiAgICAgICAgbWVzc2FnZS5pbnB1dHMgPSAoKF9hID0gb2JqZWN0LmlucHV0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gYmFua18xLklucHV0LmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIG1lc3NhZ2Uub3V0cHV0cyA9ICgoX2IgPSBvYmplY3Qub3V0cHV0cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1hcCgoZSkgPT4gYmFua18xLk91dHB1dC5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dNdWx0aVNlbmRSZXNwb25zZSgpIHtcbiAgICByZXR1cm4ge307XG59XG5leHBvcnRzLk1zZ011bHRpU2VuZFJlc3BvbnNlID0ge1xuICAgIGVuY29kZShfLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnTXVsdGlTZW5kUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKF8pIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH0sXG4gICAgdG9KU09OKF8pIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChfKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnTXVsdGlTZW5kUmVzcG9uc2UoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5pZiAobWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nICE9PSBsb25nXzEuZGVmYXVsdCkge1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyA9IGxvbmdfMS5kZWZhdWx0O1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/bank/v1beta1/tx.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/base/v1beta1/coin.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/cosmos/base/v1beta1/coin.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DecProto = exports.IntProto = exports.DecCoin = exports.Coin = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nexports.protobufPackage = \"cosmos.base.v1beta1\";\nfunction createBaseCoin() {\n    return { denom: \"\", amount: \"\" };\n}\nexports.Coin = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.denom !== \"\") {\n            writer.uint32(10).string(message.denom);\n        }\n        if (message.amount !== \"\") {\n            writer.uint32(18).string(message.amount);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCoin();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.denom = reader.string();\n                    break;\n                case 2:\n                    message.amount = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            denom: isSet(object.denom) ? String(object.denom) : \"\",\n            amount: isSet(object.amount) ? String(object.amount) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.denom !== undefined && (obj.denom = message.denom);\n        message.amount !== undefined && (obj.amount = message.amount);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseCoin();\n        message.denom = (_a = object.denom) !== null && _a !== void 0 ? _a : \"\";\n        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseDecCoin() {\n    return { denom: \"\", amount: \"\" };\n}\nexports.DecCoin = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.denom !== \"\") {\n            writer.uint32(10).string(message.denom);\n        }\n        if (message.amount !== \"\") {\n            writer.uint32(18).string(message.amount);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDecCoin();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.denom = reader.string();\n                    break;\n                case 2:\n                    message.amount = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            denom: isSet(object.denom) ? String(object.denom) : \"\",\n            amount: isSet(object.amount) ? String(object.amount) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.denom !== undefined && (obj.denom = message.denom);\n        message.amount !== undefined && (obj.amount = message.amount);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseDecCoin();\n        message.denom = (_a = object.denom) !== null && _a !== void 0 ? _a : \"\";\n        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseIntProto() {\n    return { int: \"\" };\n}\nexports.IntProto = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.int !== \"\") {\n            writer.uint32(10).string(message.int);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseIntProto();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.int = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            int: isSet(object.int) ? String(object.int) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.int !== undefined && (obj.int = message.int);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseIntProto();\n        message.int = (_a = object.int) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseDecProto() {\n    return { dec: \"\" };\n}\nexports.DecProto = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.dec !== \"\") {\n            writer.uint32(10).string(message.dec);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDecProto();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.dec = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            dec: isSet(object.dec) ? String(object.dec) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.dec !== undefined && (obj.dec = message.dec);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseDecProto();\n        message.dec = (_a = object.dec) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=coin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3MvYmFzZS92MWJldGExL2NvaW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsWUFBWSxHQUFHLHVCQUF1QjtBQUM5RjtBQUNBLCtCQUErQixtQkFBTyxDQUFDLG1EQUFNO0FBQzdDLGtDQUFrQyxtQkFBTyxDQUFDLHNFQUFvQjtBQUM5RCx1QkFBdUI7QUFDdkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvcHJvdG8tdHlwZXMvY29zbW9zL2Jhc2UvdjFiZXRhMS9jb2luLmpzPzIzMjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlY1Byb3RvID0gZXhwb3J0cy5JbnRQcm90byA9IGV4cG9ydHMuRGVjQ29pbiA9IGV4cG9ydHMuQ29pbiA9IGV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGxvbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9uZ1wiKSk7XG5jb25zdCBtaW5pbWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKSk7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwiY29zbW9zLmJhc2UudjFiZXRhMVwiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZUNvaW4oKSB7XG4gICAgcmV0dXJuIHsgZGVub206IFwiXCIsIGFtb3VudDogXCJcIiB9O1xufVxuZXhwb3J0cy5Db2luID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZGVub20gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmRlbm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5hbW91bnQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLmFtb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29pbigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVub20gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hbW91bnQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbm9tOiBpc1NldChvYmplY3QuZGVub20pID8gU3RyaW5nKG9iamVjdC5kZW5vbSkgOiBcIlwiLFxuICAgICAgICAgICAgYW1vdW50OiBpc1NldChvYmplY3QuYW1vdW50KSA/IFN0cmluZyhvYmplY3QuYW1vdW50KSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5kZW5vbSAhPT0gdW5kZWZpbmVkICYmIChvYmouZGVub20gPSBtZXNzYWdlLmRlbm9tKTtcbiAgICAgICAgbWVzc2FnZS5hbW91bnQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmFtb3VudCA9IG1lc3NhZ2UuYW1vdW50KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNvaW4oKTtcbiAgICAgICAgbWVzc2FnZS5kZW5vbSA9IChfYSA9IG9iamVjdC5kZW5vbSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5hbW91bnQgPSAoX2IgPSBvYmplY3QuYW1vdW50KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VEZWNDb2luKCkge1xuICAgIHJldHVybiB7IGRlbm9tOiBcIlwiLCBhbW91bnQ6IFwiXCIgfTtcbn1cbmV4cG9ydHMuRGVjQ29pbiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmRlbm9tICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5kZW5vbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYW1vdW50ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS5hbW91bnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlY0NvaW4oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRlbm9tID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYW1vdW50ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZW5vbTogaXNTZXQob2JqZWN0LmRlbm9tKSA/IFN0cmluZyhvYmplY3QuZGVub20pIDogXCJcIixcbiAgICAgICAgICAgIGFtb3VudDogaXNTZXQob2JqZWN0LmFtb3VudCkgPyBTdHJpbmcob2JqZWN0LmFtb3VudCkgOiBcIlwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuZGVub20gIT09IHVuZGVmaW5lZCAmJiAob2JqLmRlbm9tID0gbWVzc2FnZS5kZW5vbSk7XG4gICAgICAgIG1lc3NhZ2UuYW1vdW50ICE9PSB1bmRlZmluZWQgJiYgKG9iai5hbW91bnQgPSBtZXNzYWdlLmFtb3VudCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEZWNDb2luKCk7XG4gICAgICAgIG1lc3NhZ2UuZGVub20gPSAoX2EgPSBvYmplY3QuZGVub20pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuYW1vdW50ID0gKF9iID0gb2JqZWN0LmFtb3VudCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlSW50UHJvdG8oKSB7XG4gICAgcmV0dXJuIHsgaW50OiBcIlwiIH07XG59XG5leHBvcnRzLkludFByb3RvID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaW50ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5pbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUludFByb3RvKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludDogaXNTZXQob2JqZWN0LmludCkgPyBTdHJpbmcob2JqZWN0LmludCkgOiBcIlwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuaW50ICE9PSB1bmRlZmluZWQgJiYgKG9iai5pbnQgPSBtZXNzYWdlLmludCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUludFByb3RvKCk7XG4gICAgICAgIG1lc3NhZ2UuaW50ID0gKF9hID0gb2JqZWN0LmludCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRGVjUHJvdG8oKSB7XG4gICAgcmV0dXJuIHsgZGVjOiBcIlwiIH07XG59XG5leHBvcnRzLkRlY1Byb3RvID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZGVjICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5kZWMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlY1Byb3RvKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kZWMgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlYzogaXNTZXQob2JqZWN0LmRlYykgPyBTdHJpbmcob2JqZWN0LmRlYykgOiBcIlwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuZGVjICE9PSB1bmRlZmluZWQgJiYgKG9iai5kZWMgPSBtZXNzYWdlLmRlYyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlY1Byb3RvKCk7XG4gICAgICAgIG1lc3NhZ2UuZGVjID0gKF9hID0gb2JqZWN0LmRlYykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5pZiAobWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nICE9PSBsb25nXzEuZGVmYXVsdCkge1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyA9IGxvbmdfMS5kZWZhdWx0O1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvaW4uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/base/v1beta1/coin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/crypto/multisig/v1beta1/multisig.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/cosmos/crypto/multisig/v1beta1/multisig.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CompactBitArray = exports.MultiSignature = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nexports.protobufPackage = \"cosmos.crypto.multisig.v1beta1\";\nfunction createBaseMultiSignature() {\n    return { signatures: [] };\n}\nexports.MultiSignature = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.signatures) {\n            writer.uint32(10).bytes(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMultiSignature();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.signatures.push(reader.bytes());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            signatures: Array.isArray(object === null || object === void 0 ? void 0 : object.signatures)\n                ? object.signatures.map((e) => bytesFromBase64(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.signatures) {\n            obj.signatures = message.signatures.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));\n        }\n        else {\n            obj.signatures = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseMultiSignature();\n        message.signatures = ((_a = object.signatures) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBaseCompactBitArray() {\n    return { extraBitsStored: 0, elems: new Uint8Array() };\n}\nexports.CompactBitArray = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.extraBitsStored !== 0) {\n            writer.uint32(8).uint32(message.extraBitsStored);\n        }\n        if (message.elems.length !== 0) {\n            writer.uint32(18).bytes(message.elems);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCompactBitArray();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.extraBitsStored = reader.uint32();\n                    break;\n                case 2:\n                    message.elems = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            extraBitsStored: isSet(object.extraBitsStored)\n                ? Number(object.extraBitsStored)\n                : 0,\n            elems: isSet(object.elems)\n                ? bytesFromBase64(object.elems)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.extraBitsStored !== undefined &&\n            (obj.extraBitsStored = Math.round(message.extraBitsStored));\n        message.elems !== undefined &&\n            (obj.elems = base64FromBytes(message.elems !== undefined ? message.elems : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseCompactBitArray();\n        message.extraBitsStored = (_a = object.extraBitsStored) !== null && _a !== void 0 ? _a : 0;\n        message.elems = (_b = object.elems) !== null && _b !== void 0 ? _b : new Uint8Array();\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob ||\n    ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa ||\n    ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (const byte of arr) {\n        bin.push(String.fromCharCode(byte));\n    }\n    return btoa(bin.join(\"\"));\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=multisig.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3MvY3J5cHRvL211bHRpc2lnL3YxYmV0YTEvbXVsdGlzaWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyxzQkFBc0IsR0FBRyx1QkFBdUI7QUFDMUU7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyxtREFBTTtBQUM3QyxrQ0FBa0MsbUJBQU8sQ0FBQyxzRUFBb0I7QUFDOUQsdUJBQXVCO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3MvY3J5cHRvL211bHRpc2lnL3YxYmV0YTEvbXVsdGlzaWcuanM/OGUxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tcGFjdEJpdEFycmF5ID0gZXhwb3J0cy5NdWx0aVNpZ25hdHVyZSA9IGV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGxvbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9uZ1wiKSk7XG5jb25zdCBtaW5pbWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKSk7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwiY29zbW9zLmNyeXB0by5tdWx0aXNpZy52MWJldGExXCI7XG5mdW5jdGlvbiBjcmVhdGVCYXNlTXVsdGlTaWduYXR1cmUoKSB7XG4gICAgcmV0dXJuIHsgc2lnbmF0dXJlczogW10gfTtcbn1cbmV4cG9ydHMuTXVsdGlTaWduYXR1cmUgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5zaWduYXR1cmVzKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNdWx0aVNpZ25hdHVyZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlcy5wdXNoKHJlYWRlci5ieXRlcygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2lnbmF0dXJlczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3Quc2lnbmF0dXJlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5zaWduYXR1cmVzLm1hcCgoZSkgPT4gYnl0ZXNGcm9tQmFzZTY0KGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2lnbmF0dXJlcykge1xuICAgICAgICAgICAgb2JqLnNpZ25hdHVyZXMgPSBtZXNzYWdlLnNpZ25hdHVyZXMubWFwKChlKSA9PiBiYXNlNjRGcm9tQnl0ZXMoZSAhPT0gdW5kZWZpbmVkID8gZSA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5zaWduYXR1cmVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXVsdGlTaWduYXR1cmUoKTtcbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmVzID0gKChfYSA9IG9iamVjdC5zaWduYXR1cmVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBlKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUNvbXBhY3RCaXRBcnJheSgpIHtcbiAgICByZXR1cm4geyBleHRyYUJpdHNTdG9yZWQ6IDAsIGVsZW1zOiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnRzLkNvbXBhY3RCaXRBcnJheSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmV4dHJhQml0c1N0b3JlZCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS51aW50MzIobWVzc2FnZS5leHRyYUJpdHNTdG9yZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmVsZW1zLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuYnl0ZXMobWVzc2FnZS5lbGVtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29tcGFjdEJpdEFycmF5KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5leHRyYUJpdHNTdG9yZWQgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5lbGVtcyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBleHRyYUJpdHNTdG9yZWQ6IGlzU2V0KG9iamVjdC5leHRyYUJpdHNTdG9yZWQpXG4gICAgICAgICAgICAgICAgPyBOdW1iZXIob2JqZWN0LmV4dHJhQml0c1N0b3JlZClcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBlbGVtczogaXNTZXQob2JqZWN0LmVsZW1zKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5lbGVtcylcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5leHRyYUJpdHNTdG9yZWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5leHRyYUJpdHNTdG9yZWQgPSBNYXRoLnJvdW5kKG1lc3NhZ2UuZXh0cmFCaXRzU3RvcmVkKSk7XG4gICAgICAgIG1lc3NhZ2UuZWxlbXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5lbGVtcyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmVsZW1zICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmVsZW1zIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29tcGFjdEJpdEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UuZXh0cmFCaXRzU3RvcmVkID0gKF9hID0gb2JqZWN0LmV4dHJhQml0c1N0b3JlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgbWVzc2FnZS5lbGVtcyA9IChfYiA9IG9iamVjdC5lbGVtcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG52YXIgZ2xvYmFsVGhpcyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIHRocm93IFwiVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0XCI7XG59KSgpO1xuY29uc3QgYXRvYiA9IGdsb2JhbFRoaXMuYXRvYiB8fFxuICAgICgoYjY0KSA9PiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikudG9TdHJpbmcoXCJiaW5hcnlcIikpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NCkge1xuICAgIGNvbnN0IGJpbiA9IGF0b2IoYjY0KTtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmNvbnN0IGJ0b2EgPSBnbG9iYWxUaGlzLmJ0b2EgfHxcbiAgICAoKGJpbikgPT4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiaW4sIFwiYmluYXJ5XCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpKTtcbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnIpIHtcbiAgICBjb25zdCBiaW4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGJ5dGUgb2YgYXJyKSB7XG4gICAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYShiaW4uam9pbihcIlwiKSk7XG59XG5pZiAobWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nICE9PSBsb25nXzEuZGVmYXVsdCkge1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyA9IGxvbmdfMS5kZWZhdWx0O1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpc2lnLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/crypto/multisig/v1beta1/multisig.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/distribution/v1beta1/tx.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/cosmos/distribution/v1beta1/tx.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MsgFundCommunityPoolResponse = exports.MsgFundCommunityPool = exports.MsgWithdrawValidatorCommissionResponse = exports.MsgWithdrawValidatorCommission = exports.MsgWithdrawDelegatorRewardResponse = exports.MsgWithdrawDelegatorReward = exports.MsgSetWithdrawAddressResponse = exports.MsgSetWithdrawAddress = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nconst coin_1 = __webpack_require__(/*! ../../../cosmos/base/v1beta1/coin */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/base/v1beta1/coin.js\");\nexports.protobufPackage = \"cosmos.distribution.v1beta1\";\nfunction createBaseMsgSetWithdrawAddress() {\n    return { delegatorAddress: \"\", withdrawAddress: \"\" };\n}\nexports.MsgSetWithdrawAddress = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.delegatorAddress !== \"\") {\n            writer.uint32(10).string(message.delegatorAddress);\n        }\n        if (message.withdrawAddress !== \"\") {\n            writer.uint32(18).string(message.withdrawAddress);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgSetWithdrawAddress();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.delegatorAddress = reader.string();\n                    break;\n                case 2:\n                    message.withdrawAddress = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            delegatorAddress: isSet(object.delegatorAddress)\n                ? String(object.delegatorAddress)\n                : \"\",\n            withdrawAddress: isSet(object.withdrawAddress)\n                ? String(object.withdrawAddress)\n                : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.delegatorAddress !== undefined &&\n            (obj.delegatorAddress = message.delegatorAddress);\n        message.withdrawAddress !== undefined &&\n            (obj.withdrawAddress = message.withdrawAddress);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseMsgSetWithdrawAddress();\n        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : \"\";\n        message.withdrawAddress = (_b = object.withdrawAddress) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseMsgSetWithdrawAddressResponse() {\n    return {};\n}\nexports.MsgSetWithdrawAddressResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgSetWithdrawAddressResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgSetWithdrawAddressResponse();\n        return message;\n    },\n};\nfunction createBaseMsgWithdrawDelegatorReward() {\n    return { delegatorAddress: \"\", validatorAddress: \"\" };\n}\nexports.MsgWithdrawDelegatorReward = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.delegatorAddress !== \"\") {\n            writer.uint32(10).string(message.delegatorAddress);\n        }\n        if (message.validatorAddress !== \"\") {\n            writer.uint32(18).string(message.validatorAddress);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgWithdrawDelegatorReward();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.delegatorAddress = reader.string();\n                    break;\n                case 2:\n                    message.validatorAddress = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            delegatorAddress: isSet(object.delegatorAddress)\n                ? String(object.delegatorAddress)\n                : \"\",\n            validatorAddress: isSet(object.validatorAddress)\n                ? String(object.validatorAddress)\n                : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.delegatorAddress !== undefined &&\n            (obj.delegatorAddress = message.delegatorAddress);\n        message.validatorAddress !== undefined &&\n            (obj.validatorAddress = message.validatorAddress);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseMsgWithdrawDelegatorReward();\n        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : \"\";\n        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseMsgWithdrawDelegatorRewardResponse() {\n    return {};\n}\nexports.MsgWithdrawDelegatorRewardResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgWithdrawDelegatorRewardResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgWithdrawDelegatorRewardResponse();\n        return message;\n    },\n};\nfunction createBaseMsgWithdrawValidatorCommission() {\n    return { validatorAddress: \"\" };\n}\nexports.MsgWithdrawValidatorCommission = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.validatorAddress !== \"\") {\n            writer.uint32(10).string(message.validatorAddress);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgWithdrawValidatorCommission();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.validatorAddress = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            validatorAddress: isSet(object.validatorAddress)\n                ? String(object.validatorAddress)\n                : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.validatorAddress !== undefined &&\n            (obj.validatorAddress = message.validatorAddress);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseMsgWithdrawValidatorCommission();\n        message.validatorAddress = (_a = object.validatorAddress) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseMsgWithdrawValidatorCommissionResponse() {\n    return {};\n}\nexports.MsgWithdrawValidatorCommissionResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgWithdrawValidatorCommissionResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgWithdrawValidatorCommissionResponse();\n        return message;\n    },\n};\nfunction createBaseMsgFundCommunityPool() {\n    return { amount: [], depositor: \"\" };\n}\nexports.MsgFundCommunityPool = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.amount) {\n            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.depositor !== \"\") {\n            writer.uint32(18).string(message.depositor);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgFundCommunityPool();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.depositor = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            amount: Array.isArray(object === null || object === void 0 ? void 0 : object.amount)\n                ? object.amount.map((e) => coin_1.Coin.fromJSON(e))\n                : [],\n            depositor: isSet(object.depositor) ? String(object.depositor) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.amount) {\n            obj.amount = message.amount.map((e) => (e ? coin_1.Coin.toJSON(e) : undefined));\n        }\n        else {\n            obj.amount = [];\n        }\n        message.depositor !== undefined && (obj.depositor = message.depositor);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseMsgFundCommunityPool();\n        message.amount = ((_a = object.amount) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];\n        message.depositor = (_b = object.depositor) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseMsgFundCommunityPoolResponse() {\n    return {};\n}\nexports.MsgFundCommunityPoolResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgFundCommunityPoolResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgFundCommunityPoolResponse();\n        return message;\n    },\n};\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=tx.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3MvZGlzdHJpYnV0aW9uL3YxYmV0YTEvdHguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQ0FBb0MsR0FBRyw0QkFBNEIsR0FBRyw4Q0FBOEMsR0FBRyxzQ0FBc0MsR0FBRywwQ0FBMEMsR0FBRyxrQ0FBa0MsR0FBRyxxQ0FBcUMsR0FBRyw2QkFBNkIsR0FBRyx1QkFBdUI7QUFDalY7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyxtREFBTTtBQUM3QyxrQ0FBa0MsbUJBQU8sQ0FBQyxzRUFBb0I7QUFDOUQsZUFBZSxtQkFBTyxDQUFDLHFIQUFtQztBQUMxRCx1QkFBdUI7QUFDdkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3MvZGlzdHJpYnV0aW9uL3YxYmV0YTEvdHguanM/YTUxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTXNnRnVuZENvbW11bml0eVBvb2xSZXNwb25zZSA9IGV4cG9ydHMuTXNnRnVuZENvbW11bml0eVBvb2wgPSBleHBvcnRzLk1zZ1dpdGhkcmF3VmFsaWRhdG9yQ29tbWlzc2lvblJlc3BvbnNlID0gZXhwb3J0cy5Nc2dXaXRoZHJhd1ZhbGlkYXRvckNvbW1pc3Npb24gPSBleHBvcnRzLk1zZ1dpdGhkcmF3RGVsZWdhdG9yUmV3YXJkUmVzcG9uc2UgPSBleHBvcnRzLk1zZ1dpdGhkcmF3RGVsZWdhdG9yUmV3YXJkID0gZXhwb3J0cy5Nc2dTZXRXaXRoZHJhd0FkZHJlc3NSZXNwb25zZSA9IGV4cG9ydHMuTXNnU2V0V2l0aGRyYXdBZGRyZXNzID0gZXhwb3J0cy5wcm90b2J1ZlBhY2thZ2UgPSB2b2lkIDA7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuY29uc3QgbG9uZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb25nXCIpKTtcbmNvbnN0IG1pbmltYWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicHJvdG9idWZqcy9taW5pbWFsXCIpKTtcbmNvbnN0IGNvaW5fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3Ntb3MvYmFzZS92MWJldGExL2NvaW5cIik7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwiY29zbW9zLmRpc3RyaWJ1dGlvbi52MWJldGExXCI7XG5mdW5jdGlvbiBjcmVhdGVCYXNlTXNnU2V0V2l0aGRyYXdBZGRyZXNzKCkge1xuICAgIHJldHVybiB7IGRlbGVnYXRvckFkZHJlc3M6IFwiXCIsIHdpdGhkcmF3QWRkcmVzczogXCJcIiB9O1xufVxuZXhwb3J0cy5Nc2dTZXRXaXRoZHJhd0FkZHJlc3MgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS53aXRoZHJhd0FkZHJlc3MgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLndpdGhkcmF3QWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnU2V0V2l0aGRyYXdBZGRyZXNzKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uud2l0aGRyYXdBZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxlZ2F0b3JBZGRyZXNzOiBpc1NldChvYmplY3QuZGVsZWdhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QuZGVsZWdhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICB3aXRoZHJhd0FkZHJlc3M6IGlzU2V0KG9iamVjdC53aXRoZHJhd0FkZHJlc3MpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LndpdGhkcmF3QWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZGVsZWdhdG9yQWRkcmVzcyA9IG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyk7XG4gICAgICAgIG1lc3NhZ2Uud2l0aGRyYXdBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoud2l0aGRyYXdBZGRyZXNzID0gbWVzc2FnZS53aXRoZHJhd0FkZHJlc3MpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnU2V0V2l0aGRyYXdBZGRyZXNzKCk7XG4gICAgICAgIG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyA9IChfYSA9IG9iamVjdC5kZWxlZ2F0b3JBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLndpdGhkcmF3QWRkcmVzcyA9IChfYiA9IG9iamVjdC53aXRoZHJhd0FkZHJlc3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ1NldFdpdGhkcmF3QWRkcmVzc1Jlc3BvbnNlKCkge1xuICAgIHJldHVybiB7fTtcbn1cbmV4cG9ydHMuTXNnU2V0V2l0aGRyYXdBZGRyZXNzUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKF8sIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dTZXRXaXRoZHJhd0FkZHJlc3NSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04oXykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcbiAgICB0b0pTT04oXykge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKF8pIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dTZXRXaXRoZHJhd0FkZHJlc3NSZXNwb25zZSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dXaXRoZHJhd0RlbGVnYXRvclJld2FyZCgpIHtcbiAgICByZXR1cm4geyBkZWxlZ2F0b3JBZGRyZXNzOiBcIlwiLCB2YWxpZGF0b3JBZGRyZXNzOiBcIlwiIH07XG59XG5leHBvcnRzLk1zZ1dpdGhkcmF3RGVsZWdhdG9yUmV3YXJkID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnV2l0aGRyYXdEZWxlZ2F0b3JSZXdhcmQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWxpZGF0b3JBZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxlZ2F0b3JBZGRyZXNzOiBpc1NldChvYmplY3QuZGVsZWdhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QuZGVsZWdhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICB2YWxpZGF0b3JBZGRyZXNzOiBpc1NldChvYmplY3QudmFsaWRhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QudmFsaWRhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZGVsZWdhdG9yQWRkcmVzcyA9IG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyk7XG4gICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnZhbGlkYXRvckFkZHJlc3MgPSBtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnV2l0aGRyYXdEZWxlZ2F0b3JSZXdhcmQoKTtcbiAgICAgICAgbWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzID0gKF9hID0gb2JqZWN0LmRlbGVnYXRvckFkZHJlc3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyA9IChfYiA9IG9iamVjdC52YWxpZGF0b3JBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dXaXRoZHJhd0RlbGVnYXRvclJld2FyZFJlc3BvbnNlKCkge1xuICAgIHJldHVybiB7fTtcbn1cbmV4cG9ydHMuTXNnV2l0aGRyYXdEZWxlZ2F0b3JSZXdhcmRSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUoXywgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ1dpdGhkcmF3RGVsZWdhdG9yUmV3YXJkUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKF8pIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH0sXG4gICAgdG9KU09OKF8pIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChfKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnV2l0aGRyYXdEZWxlZ2F0b3JSZXdhcmRSZXNwb25zZSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dXaXRoZHJhd1ZhbGlkYXRvckNvbW1pc3Npb24oKSB7XG4gICAgcmV0dXJuIHsgdmFsaWRhdG9yQWRkcmVzczogXCJcIiB9O1xufVxuZXhwb3J0cy5Nc2dXaXRoZHJhd1ZhbGlkYXRvckNvbW1pc3Npb24gPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS52YWxpZGF0b3JBZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS52YWxpZGF0b3JBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dXaXRoZHJhd1ZhbGlkYXRvckNvbW1pc3Npb24oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbGlkYXRvckFkZHJlc3M6IGlzU2V0KG9iamVjdC52YWxpZGF0b3JBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC52YWxpZGF0b3JBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52YWxpZGF0b3JBZGRyZXNzID0gbWVzc2FnZS52YWxpZGF0b3JBZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnV2l0aGRyYXdWYWxpZGF0b3JDb21taXNzaW9uKCk7XG4gICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyA9IChfYSA9IG9iamVjdC52YWxpZGF0b3JBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dXaXRoZHJhd1ZhbGlkYXRvckNvbW1pc3Npb25SZXNwb25zZSgpIHtcbiAgICByZXR1cm4ge307XG59XG5leHBvcnRzLk1zZ1dpdGhkcmF3VmFsaWRhdG9yQ29tbWlzc2lvblJlc3BvbnNlID0ge1xuICAgIGVuY29kZShfLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnV2l0aGRyYXdWYWxpZGF0b3JDb21taXNzaW9uUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKF8pIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH0sXG4gICAgdG9KU09OKF8pIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChfKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnV2l0aGRyYXdWYWxpZGF0b3JDb21taXNzaW9uUmVzcG9uc2UoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlTXNnRnVuZENvbW11bml0eVBvb2woKSB7XG4gICAgcmV0dXJuIHsgYW1vdW50OiBbXSwgZGVwb3NpdG9yOiBcIlwiIH07XG59XG5leHBvcnRzLk1zZ0Z1bmRDb21tdW5pdHlQb29sID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuYW1vdW50KSB7XG4gICAgICAgICAgICBjb2luXzEuQ29pbi5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5kZXBvc2l0b3IgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLmRlcG9zaXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnRnVuZENvbW11bml0eVBvb2woKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFtb3VudC5wdXNoKGNvaW5fMS5Db2luLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVwb3NpdG9yID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbW91bnQ6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LmFtb3VudClcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5hbW91bnQubWFwKChlKSA9PiBjb2luXzEuQ29pbi5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgZGVwb3NpdG9yOiBpc1NldChvYmplY3QuZGVwb3NpdG9yKSA/IFN0cmluZyhvYmplY3QuZGVwb3NpdG9yKSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYW1vdW50KSB7XG4gICAgICAgICAgICBvYmouYW1vdW50ID0gbWVzc2FnZS5hbW91bnQubWFwKChlKSA9PiAoZSA/IGNvaW5fMS5Db2luLnRvSlNPTihlKSA6IHVuZGVmaW5lZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLmFtb3VudCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UuZGVwb3NpdG9yICE9PSB1bmRlZmluZWQgJiYgKG9iai5kZXBvc2l0b3IgPSBtZXNzYWdlLmRlcG9zaXRvcik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dGdW5kQ29tbXVuaXR5UG9vbCgpO1xuICAgICAgICBtZXNzYWdlLmFtb3VudCA9ICgoX2EgPSBvYmplY3QuYW1vdW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBjb2luXzEuQ29pbi5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICBtZXNzYWdlLmRlcG9zaXRvciA9IChfYiA9IG9iamVjdC5kZXBvc2l0b3IpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ0Z1bmRDb21tdW5pdHlQb29sUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHt9O1xufVxuZXhwb3J0cy5Nc2dGdW5kQ29tbXVuaXR5UG9vbFJlc3BvbnNlID0ge1xuICAgIGVuY29kZShfLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnRnVuZENvbW11bml0eVBvb2xSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04oXykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcbiAgICB0b0pTT04oXykge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKF8pIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dGdW5kQ29tbXVuaXR5UG9vbFJlc3BvbnNlKCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuaWYgKG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyAhPT0gbG9uZ18xLmRlZmF1bHQpIHtcbiAgICBtaW5pbWFsXzEuZGVmYXVsdC51dGlsLkxvbmcgPSBsb25nXzEuZGVmYXVsdDtcbiAgICBtaW5pbWFsXzEuZGVmYXVsdC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/distribution/v1beta1/tx.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/gov/v1beta1/gov.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/cosmos/gov/v1beta1/gov.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TallyParams = exports.VotingParams = exports.DepositParams = exports.Vote = exports.TallyResult = exports.Proposal = exports.Deposit = exports.TextProposal = exports.WeightedVoteOption = exports.proposalStatusToJSON = exports.proposalStatusFromJSON = exports.ProposalStatus = exports.voteOptionToJSON = exports.voteOptionFromJSON = exports.VoteOption = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nconst timestamp_1 = __webpack_require__(/*! ../../../google/protobuf/timestamp */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/timestamp.js\");\nconst coin_1 = __webpack_require__(/*! ../../../cosmos/base/v1beta1/coin */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/base/v1beta1/coin.js\");\nconst any_1 = __webpack_require__(/*! ../../../google/protobuf/any */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/any.js\");\nconst duration_1 = __webpack_require__(/*! ../../../google/protobuf/duration */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/duration.js\");\nexports.protobufPackage = \"cosmos.gov.v1beta1\";\n/** VoteOption enumerates the valid vote options for a given governance proposal. */\nvar VoteOption;\n(function (VoteOption) {\n    /** VOTE_OPTION_UNSPECIFIED - VOTE_OPTION_UNSPECIFIED defines a no-op vote option. */\n    VoteOption[VoteOption[\"VOTE_OPTION_UNSPECIFIED\"] = 0] = \"VOTE_OPTION_UNSPECIFIED\";\n    /** VOTE_OPTION_YES - VOTE_OPTION_YES defines a yes vote option. */\n    VoteOption[VoteOption[\"VOTE_OPTION_YES\"] = 1] = \"VOTE_OPTION_YES\";\n    /** VOTE_OPTION_ABSTAIN - VOTE_OPTION_ABSTAIN defines an abstain vote option. */\n    VoteOption[VoteOption[\"VOTE_OPTION_ABSTAIN\"] = 2] = \"VOTE_OPTION_ABSTAIN\";\n    /** VOTE_OPTION_NO - VOTE_OPTION_NO defines a no vote option. */\n    VoteOption[VoteOption[\"VOTE_OPTION_NO\"] = 3] = \"VOTE_OPTION_NO\";\n    /** VOTE_OPTION_NO_WITH_VETO - VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option. */\n    VoteOption[VoteOption[\"VOTE_OPTION_NO_WITH_VETO\"] = 4] = \"VOTE_OPTION_NO_WITH_VETO\";\n    VoteOption[VoteOption[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(VoteOption = exports.VoteOption || (exports.VoteOption = {}));\nfunction voteOptionFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"VOTE_OPTION_UNSPECIFIED\":\n            return VoteOption.VOTE_OPTION_UNSPECIFIED;\n        case 1:\n        case \"VOTE_OPTION_YES\":\n            return VoteOption.VOTE_OPTION_YES;\n        case 2:\n        case \"VOTE_OPTION_ABSTAIN\":\n            return VoteOption.VOTE_OPTION_ABSTAIN;\n        case 3:\n        case \"VOTE_OPTION_NO\":\n            return VoteOption.VOTE_OPTION_NO;\n        case 4:\n        case \"VOTE_OPTION_NO_WITH_VETO\":\n            return VoteOption.VOTE_OPTION_NO_WITH_VETO;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return VoteOption.UNRECOGNIZED;\n    }\n}\nexports.voteOptionFromJSON = voteOptionFromJSON;\nfunction voteOptionToJSON(object) {\n    switch (object) {\n        case VoteOption.VOTE_OPTION_UNSPECIFIED:\n            return \"VOTE_OPTION_UNSPECIFIED\";\n        case VoteOption.VOTE_OPTION_YES:\n            return \"VOTE_OPTION_YES\";\n        case VoteOption.VOTE_OPTION_ABSTAIN:\n            return \"VOTE_OPTION_ABSTAIN\";\n        case VoteOption.VOTE_OPTION_NO:\n            return \"VOTE_OPTION_NO\";\n        case VoteOption.VOTE_OPTION_NO_WITH_VETO:\n            return \"VOTE_OPTION_NO_WITH_VETO\";\n        default:\n            return \"UNKNOWN\";\n    }\n}\nexports.voteOptionToJSON = voteOptionToJSON;\n/** ProposalStatus enumerates the valid statuses of a proposal. */\nvar ProposalStatus;\n(function (ProposalStatus) {\n    /** PROPOSAL_STATUS_UNSPECIFIED - PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status. */\n    ProposalStatus[ProposalStatus[\"PROPOSAL_STATUS_UNSPECIFIED\"] = 0] = \"PROPOSAL_STATUS_UNSPECIFIED\";\n    /**\n     * PROPOSAL_STATUS_DEPOSIT_PERIOD - PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\n     * period.\n     */\n    ProposalStatus[ProposalStatus[\"PROPOSAL_STATUS_DEPOSIT_PERIOD\"] = 1] = \"PROPOSAL_STATUS_DEPOSIT_PERIOD\";\n    /**\n     * PROPOSAL_STATUS_VOTING_PERIOD - PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\n     * period.\n     */\n    ProposalStatus[ProposalStatus[\"PROPOSAL_STATUS_VOTING_PERIOD\"] = 2] = \"PROPOSAL_STATUS_VOTING_PERIOD\";\n    /**\n     * PROPOSAL_STATUS_PASSED - PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\n     * passed.\n     */\n    ProposalStatus[ProposalStatus[\"PROPOSAL_STATUS_PASSED\"] = 3] = \"PROPOSAL_STATUS_PASSED\";\n    /**\n     * PROPOSAL_STATUS_REJECTED - PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\n     * been rejected.\n     */\n    ProposalStatus[ProposalStatus[\"PROPOSAL_STATUS_REJECTED\"] = 4] = \"PROPOSAL_STATUS_REJECTED\";\n    /**\n     * PROPOSAL_STATUS_FAILED - PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\n     * failed.\n     */\n    ProposalStatus[ProposalStatus[\"PROPOSAL_STATUS_FAILED\"] = 5] = \"PROPOSAL_STATUS_FAILED\";\n    ProposalStatus[ProposalStatus[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ProposalStatus = exports.ProposalStatus || (exports.ProposalStatus = {}));\nfunction proposalStatusFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"PROPOSAL_STATUS_UNSPECIFIED\":\n            return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;\n        case 1:\n        case \"PROPOSAL_STATUS_DEPOSIT_PERIOD\":\n            return ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD;\n        case 2:\n        case \"PROPOSAL_STATUS_VOTING_PERIOD\":\n            return ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD;\n        case 3:\n        case \"PROPOSAL_STATUS_PASSED\":\n            return ProposalStatus.PROPOSAL_STATUS_PASSED;\n        case 4:\n        case \"PROPOSAL_STATUS_REJECTED\":\n            return ProposalStatus.PROPOSAL_STATUS_REJECTED;\n        case 5:\n        case \"PROPOSAL_STATUS_FAILED\":\n            return ProposalStatus.PROPOSAL_STATUS_FAILED;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return ProposalStatus.UNRECOGNIZED;\n    }\n}\nexports.proposalStatusFromJSON = proposalStatusFromJSON;\nfunction proposalStatusToJSON(object) {\n    switch (object) {\n        case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:\n            return \"PROPOSAL_STATUS_UNSPECIFIED\";\n        case ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD:\n            return \"PROPOSAL_STATUS_DEPOSIT_PERIOD\";\n        case ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD:\n            return \"PROPOSAL_STATUS_VOTING_PERIOD\";\n        case ProposalStatus.PROPOSAL_STATUS_PASSED:\n            return \"PROPOSAL_STATUS_PASSED\";\n        case ProposalStatus.PROPOSAL_STATUS_REJECTED:\n            return \"PROPOSAL_STATUS_REJECTED\";\n        case ProposalStatus.PROPOSAL_STATUS_FAILED:\n            return \"PROPOSAL_STATUS_FAILED\";\n        default:\n            return \"UNKNOWN\";\n    }\n}\nexports.proposalStatusToJSON = proposalStatusToJSON;\nfunction createBaseWeightedVoteOption() {\n    return { option: 0, weight: \"\" };\n}\nexports.WeightedVoteOption = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.option !== 0) {\n            writer.uint32(8).int32(message.option);\n        }\n        if (message.weight !== \"\") {\n            writer.uint32(18).string(message.weight);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseWeightedVoteOption();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.option = reader.int32();\n                    break;\n                case 2:\n                    message.weight = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            option: isSet(object.option) ? voteOptionFromJSON(object.option) : 0,\n            weight: isSet(object.weight) ? String(object.weight) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.option !== undefined &&\n            (obj.option = voteOptionToJSON(message.option));\n        message.weight !== undefined && (obj.weight = message.weight);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseWeightedVoteOption();\n        message.option = (_a = object.option) !== null && _a !== void 0 ? _a : 0;\n        message.weight = (_b = object.weight) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseTextProposal() {\n    return { title: \"\", description: \"\" };\n}\nexports.TextProposal = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.title !== \"\") {\n            writer.uint32(10).string(message.title);\n        }\n        if (message.description !== \"\") {\n            writer.uint32(18).string(message.description);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTextProposal();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.title = reader.string();\n                    break;\n                case 2:\n                    message.description = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            title: isSet(object.title) ? String(object.title) : \"\",\n            description: isSet(object.description) ? String(object.description) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.title !== undefined && (obj.title = message.title);\n        message.description !== undefined &&\n            (obj.description = message.description);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseTextProposal();\n        message.title = (_a = object.title) !== null && _a !== void 0 ? _a : \"\";\n        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseDeposit() {\n    return { proposalId: \"0\", depositor: \"\", amount: [] };\n}\nexports.Deposit = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.proposalId !== \"0\") {\n            writer.uint32(8).uint64(message.proposalId);\n        }\n        if (message.depositor !== \"\") {\n            writer.uint32(18).string(message.depositor);\n        }\n        for (const v of message.amount) {\n            coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDeposit();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.proposalId = longToString(reader.uint64());\n                    break;\n                case 2:\n                    message.depositor = reader.string();\n                    break;\n                case 3:\n                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            proposalId: isSet(object.proposalId) ? String(object.proposalId) : \"0\",\n            depositor: isSet(object.depositor) ? String(object.depositor) : \"\",\n            amount: Array.isArray(object === null || object === void 0 ? void 0 : object.amount)\n                ? object.amount.map((e) => coin_1.Coin.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.proposalId !== undefined && (obj.proposalId = message.proposalId);\n        message.depositor !== undefined && (obj.depositor = message.depositor);\n        if (message.amount) {\n            obj.amount = message.amount.map((e) => (e ? coin_1.Coin.toJSON(e) : undefined));\n        }\n        else {\n            obj.amount = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseDeposit();\n        message.proposalId = (_a = object.proposalId) !== null && _a !== void 0 ? _a : \"0\";\n        message.depositor = (_b = object.depositor) !== null && _b !== void 0 ? _b : \"\";\n        message.amount = ((_c = object.amount) === null || _c === void 0 ? void 0 : _c.map((e) => coin_1.Coin.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseProposal() {\n    return {\n        proposalId: \"0\",\n        content: undefined,\n        status: 0,\n        finalTallyResult: undefined,\n        submitTime: undefined,\n        depositEndTime: undefined,\n        totalDeposit: [],\n        votingStartTime: undefined,\n        votingEndTime: undefined,\n    };\n}\nexports.Proposal = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.proposalId !== \"0\") {\n            writer.uint32(8).uint64(message.proposalId);\n        }\n        if (message.content !== undefined) {\n            any_1.Any.encode(message.content, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.status !== 0) {\n            writer.uint32(24).int32(message.status);\n        }\n        if (message.finalTallyResult !== undefined) {\n            exports.TallyResult.encode(message.finalTallyResult, writer.uint32(34).fork()).ldelim();\n        }\n        if (message.submitTime !== undefined) {\n            timestamp_1.Timestamp.encode(toTimestamp(message.submitTime), writer.uint32(42).fork()).ldelim();\n        }\n        if (message.depositEndTime !== undefined) {\n            timestamp_1.Timestamp.encode(toTimestamp(message.depositEndTime), writer.uint32(50).fork()).ldelim();\n        }\n        for (const v of message.totalDeposit) {\n            coin_1.Coin.encode(v, writer.uint32(58).fork()).ldelim();\n        }\n        if (message.votingStartTime !== undefined) {\n            timestamp_1.Timestamp.encode(toTimestamp(message.votingStartTime), writer.uint32(66).fork()).ldelim();\n        }\n        if (message.votingEndTime !== undefined) {\n            timestamp_1.Timestamp.encode(toTimestamp(message.votingEndTime), writer.uint32(74).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseProposal();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.proposalId = longToString(reader.uint64());\n                    break;\n                case 2:\n                    message.content = any_1.Any.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.status = reader.int32();\n                    break;\n                case 4:\n                    message.finalTallyResult = exports.TallyResult.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.submitTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n                    break;\n                case 6:\n                    message.depositEndTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n                    break;\n                case 7:\n                    message.totalDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));\n                    break;\n                case 8:\n                    message.votingStartTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n                    break;\n                case 9:\n                    message.votingEndTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            proposalId: isSet(object.proposalId) ? String(object.proposalId) : \"0\",\n            content: isSet(object.content) ? any_1.Any.fromJSON(object.content) : undefined,\n            status: isSet(object.status) ? proposalStatusFromJSON(object.status) : 0,\n            finalTallyResult: isSet(object.finalTallyResult)\n                ? exports.TallyResult.fromJSON(object.finalTallyResult)\n                : undefined,\n            submitTime: isSet(object.submitTime)\n                ? fromJsonTimestamp(object.submitTime)\n                : undefined,\n            depositEndTime: isSet(object.depositEndTime)\n                ? fromJsonTimestamp(object.depositEndTime)\n                : undefined,\n            totalDeposit: Array.isArray(object === null || object === void 0 ? void 0 : object.totalDeposit)\n                ? object.totalDeposit.map((e) => coin_1.Coin.fromJSON(e))\n                : [],\n            votingStartTime: isSet(object.votingStartTime)\n                ? fromJsonTimestamp(object.votingStartTime)\n                : undefined,\n            votingEndTime: isSet(object.votingEndTime)\n                ? fromJsonTimestamp(object.votingEndTime)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.proposalId !== undefined && (obj.proposalId = message.proposalId);\n        message.content !== undefined &&\n            (obj.content = message.content ? any_1.Any.toJSON(message.content) : undefined);\n        message.status !== undefined &&\n            (obj.status = proposalStatusToJSON(message.status));\n        message.finalTallyResult !== undefined &&\n            (obj.finalTallyResult = message.finalTallyResult\n                ? exports.TallyResult.toJSON(message.finalTallyResult)\n                : undefined);\n        message.submitTime !== undefined &&\n            (obj.submitTime = message.submitTime.toISOString());\n        message.depositEndTime !== undefined &&\n            (obj.depositEndTime = message.depositEndTime.toISOString());\n        if (message.totalDeposit) {\n            obj.totalDeposit = message.totalDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : undefined);\n        }\n        else {\n            obj.totalDeposit = [];\n        }\n        message.votingStartTime !== undefined &&\n            (obj.votingStartTime = message.votingStartTime.toISOString());\n        message.votingEndTime !== undefined &&\n            (obj.votingEndTime = message.votingEndTime.toISOString());\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        const message = createBaseProposal();\n        message.proposalId = (_a = object.proposalId) !== null && _a !== void 0 ? _a : \"0\";\n        message.content =\n            object.content !== undefined && object.content !== null\n                ? any_1.Any.fromPartial(object.content)\n                : undefined;\n        message.status = (_b = object.status) !== null && _b !== void 0 ? _b : 0;\n        message.finalTallyResult =\n            object.finalTallyResult !== undefined && object.finalTallyResult !== null\n                ? exports.TallyResult.fromPartial(object.finalTallyResult)\n                : undefined;\n        message.submitTime = (_c = object.submitTime) !== null && _c !== void 0 ? _c : undefined;\n        message.depositEndTime = (_d = object.depositEndTime) !== null && _d !== void 0 ? _d : undefined;\n        message.totalDeposit =\n            ((_e = object.totalDeposit) === null || _e === void 0 ? void 0 : _e.map((e) => coin_1.Coin.fromPartial(e))) || [];\n        message.votingStartTime = (_f = object.votingStartTime) !== null && _f !== void 0 ? _f : undefined;\n        message.votingEndTime = (_g = object.votingEndTime) !== null && _g !== void 0 ? _g : undefined;\n        return message;\n    },\n};\nfunction createBaseTallyResult() {\n    return { yes: \"\", abstain: \"\", no: \"\", noWithVeto: \"\" };\n}\nexports.TallyResult = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.yes !== \"\") {\n            writer.uint32(10).string(message.yes);\n        }\n        if (message.abstain !== \"\") {\n            writer.uint32(18).string(message.abstain);\n        }\n        if (message.no !== \"\") {\n            writer.uint32(26).string(message.no);\n        }\n        if (message.noWithVeto !== \"\") {\n            writer.uint32(34).string(message.noWithVeto);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTallyResult();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.yes = reader.string();\n                    break;\n                case 2:\n                    message.abstain = reader.string();\n                    break;\n                case 3:\n                    message.no = reader.string();\n                    break;\n                case 4:\n                    message.noWithVeto = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            yes: isSet(object.yes) ? String(object.yes) : \"\",\n            abstain: isSet(object.abstain) ? String(object.abstain) : \"\",\n            no: isSet(object.no) ? String(object.no) : \"\",\n            noWithVeto: isSet(object.noWithVeto) ? String(object.noWithVeto) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.yes !== undefined && (obj.yes = message.yes);\n        message.abstain !== undefined && (obj.abstain = message.abstain);\n        message.no !== undefined && (obj.no = message.no);\n        message.noWithVeto !== undefined && (obj.noWithVeto = message.noWithVeto);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseTallyResult();\n        message.yes = (_a = object.yes) !== null && _a !== void 0 ? _a : \"\";\n        message.abstain = (_b = object.abstain) !== null && _b !== void 0 ? _b : \"\";\n        message.no = (_c = object.no) !== null && _c !== void 0 ? _c : \"\";\n        message.noWithVeto = (_d = object.noWithVeto) !== null && _d !== void 0 ? _d : \"\";\n        return message;\n    },\n};\nfunction createBaseVote() {\n    return { proposalId: \"0\", voter: \"\", option: 0, options: [] };\n}\nexports.Vote = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.proposalId !== \"0\") {\n            writer.uint32(8).uint64(message.proposalId);\n        }\n        if (message.voter !== \"\") {\n            writer.uint32(18).string(message.voter);\n        }\n        if (message.option !== 0) {\n            writer.uint32(24).int32(message.option);\n        }\n        for (const v of message.options) {\n            exports.WeightedVoteOption.encode(v, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseVote();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.proposalId = longToString(reader.uint64());\n                    break;\n                case 2:\n                    message.voter = reader.string();\n                    break;\n                case 3:\n                    message.option = reader.int32();\n                    break;\n                case 4:\n                    message.options.push(exports.WeightedVoteOption.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            proposalId: isSet(object.proposalId) ? String(object.proposalId) : \"0\",\n            voter: isSet(object.voter) ? String(object.voter) : \"\",\n            option: isSet(object.option) ? voteOptionFromJSON(object.option) : 0,\n            options: Array.isArray(object === null || object === void 0 ? void 0 : object.options)\n                ? object.options.map((e) => exports.WeightedVoteOption.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.proposalId !== undefined && (obj.proposalId = message.proposalId);\n        message.voter !== undefined && (obj.voter = message.voter);\n        message.option !== undefined &&\n            (obj.option = voteOptionToJSON(message.option));\n        if (message.options) {\n            obj.options = message.options.map((e) => e ? exports.WeightedVoteOption.toJSON(e) : undefined);\n        }\n        else {\n            obj.options = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseVote();\n        message.proposalId = (_a = object.proposalId) !== null && _a !== void 0 ? _a : \"0\";\n        message.voter = (_b = object.voter) !== null && _b !== void 0 ? _b : \"\";\n        message.option = (_c = object.option) !== null && _c !== void 0 ? _c : 0;\n        message.options =\n            ((_d = object.options) === null || _d === void 0 ? void 0 : _d.map((e) => exports.WeightedVoteOption.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseDepositParams() {\n    return { minDeposit: [], maxDepositPeriod: undefined };\n}\nexports.DepositParams = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.minDeposit) {\n            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.maxDepositPeriod !== undefined) {\n            duration_1.Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDepositParams();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.minDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.maxDepositPeriod = duration_1.Duration.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            minDeposit: Array.isArray(object === null || object === void 0 ? void 0 : object.minDeposit)\n                ? object.minDeposit.map((e) => coin_1.Coin.fromJSON(e))\n                : [],\n            maxDepositPeriod: isSet(object.maxDepositPeriod)\n                ? duration_1.Duration.fromJSON(object.maxDepositPeriod)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.minDeposit) {\n            obj.minDeposit = message.minDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : undefined);\n        }\n        else {\n            obj.minDeposit = [];\n        }\n        message.maxDepositPeriod !== undefined &&\n            (obj.maxDepositPeriod = message.maxDepositPeriod\n                ? duration_1.Duration.toJSON(message.maxDepositPeriod)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseDepositParams();\n        message.minDeposit =\n            ((_a = object.minDeposit) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];\n        message.maxDepositPeriod =\n            object.maxDepositPeriod !== undefined && object.maxDepositPeriod !== null\n                ? duration_1.Duration.fromPartial(object.maxDepositPeriod)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseVotingParams() {\n    return { votingPeriod: undefined };\n}\nexports.VotingParams = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.votingPeriod !== undefined) {\n            duration_1.Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseVotingParams();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.votingPeriod = duration_1.Duration.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            votingPeriod: isSet(object.votingPeriod)\n                ? duration_1.Duration.fromJSON(object.votingPeriod)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.votingPeriod !== undefined &&\n            (obj.votingPeriod = message.votingPeriod\n                ? duration_1.Duration.toJSON(message.votingPeriod)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseVotingParams();\n        message.votingPeriod =\n            object.votingPeriod !== undefined && object.votingPeriod !== null\n                ? duration_1.Duration.fromPartial(object.votingPeriod)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseTallyParams() {\n    return {\n        quorum: new Uint8Array(),\n        threshold: new Uint8Array(),\n        vetoThreshold: new Uint8Array(),\n    };\n}\nexports.TallyParams = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.quorum.length !== 0) {\n            writer.uint32(10).bytes(message.quorum);\n        }\n        if (message.threshold.length !== 0) {\n            writer.uint32(18).bytes(message.threshold);\n        }\n        if (message.vetoThreshold.length !== 0) {\n            writer.uint32(26).bytes(message.vetoThreshold);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTallyParams();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.quorum = reader.bytes();\n                    break;\n                case 2:\n                    message.threshold = reader.bytes();\n                    break;\n                case 3:\n                    message.vetoThreshold = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            quorum: isSet(object.quorum)\n                ? bytesFromBase64(object.quorum)\n                : new Uint8Array(),\n            threshold: isSet(object.threshold)\n                ? bytesFromBase64(object.threshold)\n                : new Uint8Array(),\n            vetoThreshold: isSet(object.vetoThreshold)\n                ? bytesFromBase64(object.vetoThreshold)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.quorum !== undefined &&\n            (obj.quorum = base64FromBytes(message.quorum !== undefined ? message.quorum : new Uint8Array()));\n        message.threshold !== undefined &&\n            (obj.threshold = base64FromBytes(message.threshold !== undefined ? message.threshold : new Uint8Array()));\n        message.vetoThreshold !== undefined &&\n            (obj.vetoThreshold = base64FromBytes(message.vetoThreshold !== undefined\n                ? message.vetoThreshold\n                : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseTallyParams();\n        message.quorum = (_a = object.quorum) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.threshold = (_b = object.threshold) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.vetoThreshold = (_c = object.vetoThreshold) !== null && _c !== void 0 ? _c : new Uint8Array();\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob ||\n    ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa ||\n    ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (const byte of arr) {\n        bin.push(String.fromCharCode(byte));\n    }\n    return btoa(bin.join(\"\"));\n}\nfunction toTimestamp(date) {\n    const seconds = Math.trunc(date.getTime() / 1000).toString();\n    const nanos = (date.getTime() % 1000) * 1000000;\n    return { seconds, nanos };\n}\nfunction fromTimestamp(t) {\n    let millis = Number(t.seconds) * 1000;\n    millis += t.nanos / 1000000;\n    return new Date(millis);\n}\nfunction fromJsonTimestamp(o) {\n    if (o instanceof Date) {\n        return o;\n    }\n    else if (typeof o === \"string\") {\n        return new Date(o);\n    }\n    else {\n        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));\n    }\n}\nfunction longToString(long) {\n    return long.toString();\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=gov.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3MvZ292L3YxYmV0YTEvZ292LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsb0JBQW9CLEdBQUcscUJBQXFCLEdBQUcsWUFBWSxHQUFHLG1CQUFtQixHQUFHLGdCQUFnQixHQUFHLGVBQWUsR0FBRyxvQkFBb0IsR0FBRywwQkFBMEIsR0FBRyw0QkFBNEIsR0FBRyw4QkFBOEIsR0FBRyxzQkFBc0IsR0FBRyx3QkFBd0IsR0FBRywwQkFBMEIsR0FBRyxrQkFBa0IsR0FBRyx1QkFBdUI7QUFDaFk7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyxtREFBTTtBQUM3QyxrQ0FBa0MsbUJBQU8sQ0FBQyxzRUFBb0I7QUFDOUQsb0JBQW9CLG1CQUFPLENBQUMsdUhBQW9DO0FBQ2hFLGVBQWUsbUJBQU8sQ0FBQyxxSEFBbUM7QUFDMUQsY0FBYyxtQkFBTyxDQUFDLDJHQUE4QjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQyxxSEFBbUM7QUFDOUQsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQyxrQkFBa0IsS0FBSztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEMsc0JBQXNCLEtBQUs7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxhQUFhO0FBQ2I7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvcHJvdG8tdHlwZXMvY29zbW9zL2dvdi92MWJldGExL2dvdi5qcz9lOTVmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UYWxseVBhcmFtcyA9IGV4cG9ydHMuVm90aW5nUGFyYW1zID0gZXhwb3J0cy5EZXBvc2l0UGFyYW1zID0gZXhwb3J0cy5Wb3RlID0gZXhwb3J0cy5UYWxseVJlc3VsdCA9IGV4cG9ydHMuUHJvcG9zYWwgPSBleHBvcnRzLkRlcG9zaXQgPSBleHBvcnRzLlRleHRQcm9wb3NhbCA9IGV4cG9ydHMuV2VpZ2h0ZWRWb3RlT3B0aW9uID0gZXhwb3J0cy5wcm9wb3NhbFN0YXR1c1RvSlNPTiA9IGV4cG9ydHMucHJvcG9zYWxTdGF0dXNGcm9tSlNPTiA9IGV4cG9ydHMuUHJvcG9zYWxTdGF0dXMgPSBleHBvcnRzLnZvdGVPcHRpb25Ub0pTT04gPSBleHBvcnRzLnZvdGVPcHRpb25Gcm9tSlNPTiA9IGV4cG9ydHMuVm90ZU9wdGlvbiA9IGV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGxvbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9uZ1wiKSk7XG5jb25zdCBtaW5pbWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKSk7XG5jb25zdCB0aW1lc3RhbXBfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9nb29nbGUvcHJvdG9idWYvdGltZXN0YW1wXCIpO1xuY29uc3QgY29pbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2Nvc21vcy9iYXNlL3YxYmV0YTEvY29pblwiKTtcbmNvbnN0IGFueV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2dvb2dsZS9wcm90b2J1Zi9hbnlcIik7XG5jb25zdCBkdXJhdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2dvb2dsZS9wcm90b2J1Zi9kdXJhdGlvblwiKTtcbmV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gXCJjb3Ntb3MuZ292LnYxYmV0YTFcIjtcbi8qKiBWb3RlT3B0aW9uIGVudW1lcmF0ZXMgdGhlIHZhbGlkIHZvdGUgb3B0aW9ucyBmb3IgYSBnaXZlbiBnb3Zlcm5hbmNlIHByb3Bvc2FsLiAqL1xudmFyIFZvdGVPcHRpb247XG4oZnVuY3Rpb24gKFZvdGVPcHRpb24pIHtcbiAgICAvKiogVk9URV9PUFRJT05fVU5TUEVDSUZJRUQgLSBWT1RFX09QVElPTl9VTlNQRUNJRklFRCBkZWZpbmVzIGEgbm8tb3Agdm90ZSBvcHRpb24uICovXG4gICAgVm90ZU9wdGlvbltWb3RlT3B0aW9uW1wiVk9URV9PUFRJT05fVU5TUEVDSUZJRURcIl0gPSAwXSA9IFwiVk9URV9PUFRJT05fVU5TUEVDSUZJRURcIjtcbiAgICAvKiogVk9URV9PUFRJT05fWUVTIC0gVk9URV9PUFRJT05fWUVTIGRlZmluZXMgYSB5ZXMgdm90ZSBvcHRpb24uICovXG4gICAgVm90ZU9wdGlvbltWb3RlT3B0aW9uW1wiVk9URV9PUFRJT05fWUVTXCJdID0gMV0gPSBcIlZPVEVfT1BUSU9OX1lFU1wiO1xuICAgIC8qKiBWT1RFX09QVElPTl9BQlNUQUlOIC0gVk9URV9PUFRJT05fQUJTVEFJTiBkZWZpbmVzIGFuIGFic3RhaW4gdm90ZSBvcHRpb24uICovXG4gICAgVm90ZU9wdGlvbltWb3RlT3B0aW9uW1wiVk9URV9PUFRJT05fQUJTVEFJTlwiXSA9IDJdID0gXCJWT1RFX09QVElPTl9BQlNUQUlOXCI7XG4gICAgLyoqIFZPVEVfT1BUSU9OX05PIC0gVk9URV9PUFRJT05fTk8gZGVmaW5lcyBhIG5vIHZvdGUgb3B0aW9uLiAqL1xuICAgIFZvdGVPcHRpb25bVm90ZU9wdGlvbltcIlZPVEVfT1BUSU9OX05PXCJdID0gM10gPSBcIlZPVEVfT1BUSU9OX05PXCI7XG4gICAgLyoqIFZPVEVfT1BUSU9OX05PX1dJVEhfVkVUTyAtIFZPVEVfT1BUSU9OX05PX1dJVEhfVkVUTyBkZWZpbmVzIGEgbm8gd2l0aCB2ZXRvIHZvdGUgb3B0aW9uLiAqL1xuICAgIFZvdGVPcHRpb25bVm90ZU9wdGlvbltcIlZPVEVfT1BUSU9OX05PX1dJVEhfVkVUT1wiXSA9IDRdID0gXCJWT1RFX09QVElPTl9OT19XSVRIX1ZFVE9cIjtcbiAgICBWb3RlT3B0aW9uW1ZvdGVPcHRpb25bXCJVTlJFQ09HTklaRURcIl0gPSAtMV0gPSBcIlVOUkVDT0dOSVpFRFwiO1xufSkoVm90ZU9wdGlvbiA9IGV4cG9ydHMuVm90ZU9wdGlvbiB8fCAoZXhwb3J0cy5Wb3RlT3B0aW9uID0ge30pKTtcbmZ1bmN0aW9uIHZvdGVPcHRpb25Gcm9tSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgXCJWT1RFX09QVElPTl9VTlNQRUNJRklFRFwiOlxuICAgICAgICAgICAgcmV0dXJuIFZvdGVPcHRpb24uVk9URV9PUFRJT05fVU5TUEVDSUZJRUQ7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSBcIlZPVEVfT1BUSU9OX1lFU1wiOlxuICAgICAgICAgICAgcmV0dXJuIFZvdGVPcHRpb24uVk9URV9PUFRJT05fWUVTO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgXCJWT1RFX09QVElPTl9BQlNUQUlOXCI6XG4gICAgICAgICAgICByZXR1cm4gVm90ZU9wdGlvbi5WT1RFX09QVElPTl9BQlNUQUlOO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGNhc2UgXCJWT1RFX09QVElPTl9OT1wiOlxuICAgICAgICAgICAgcmV0dXJuIFZvdGVPcHRpb24uVk9URV9PUFRJT05fTk87XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgY2FzZSBcIlZPVEVfT1BUSU9OX05PX1dJVEhfVkVUT1wiOlxuICAgICAgICAgICAgcmV0dXJuIFZvdGVPcHRpb24uVk9URV9PUFRJT05fTk9fV0lUSF9WRVRPO1xuICAgICAgICBjYXNlIC0xOlxuICAgICAgICBjYXNlIFwiVU5SRUNPR05JWkVEXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gVm90ZU9wdGlvbi5VTlJFQ09HTklaRUQ7XG4gICAgfVxufVxuZXhwb3J0cy52b3RlT3B0aW9uRnJvbUpTT04gPSB2b3RlT3B0aW9uRnJvbUpTT047XG5mdW5jdGlvbiB2b3RlT3B0aW9uVG9KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgVm90ZU9wdGlvbi5WT1RFX09QVElPTl9VTlNQRUNJRklFRDpcbiAgICAgICAgICAgIHJldHVybiBcIlZPVEVfT1BUSU9OX1VOU1BFQ0lGSUVEXCI7XG4gICAgICAgIGNhc2UgVm90ZU9wdGlvbi5WT1RFX09QVElPTl9ZRVM6XG4gICAgICAgICAgICByZXR1cm4gXCJWT1RFX09QVElPTl9ZRVNcIjtcbiAgICAgICAgY2FzZSBWb3RlT3B0aW9uLlZPVEVfT1BUSU9OX0FCU1RBSU46XG4gICAgICAgICAgICByZXR1cm4gXCJWT1RFX09QVElPTl9BQlNUQUlOXCI7XG4gICAgICAgIGNhc2UgVm90ZU9wdGlvbi5WT1RFX09QVElPTl9OTzpcbiAgICAgICAgICAgIHJldHVybiBcIlZPVEVfT1BUSU9OX05PXCI7XG4gICAgICAgIGNhc2UgVm90ZU9wdGlvbi5WT1RFX09QVElPTl9OT19XSVRIX1ZFVE86XG4gICAgICAgICAgICByZXR1cm4gXCJWT1RFX09QVElPTl9OT19XSVRIX1ZFVE9cIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIlVOS05PV05cIjtcbiAgICB9XG59XG5leHBvcnRzLnZvdGVPcHRpb25Ub0pTT04gPSB2b3RlT3B0aW9uVG9KU09OO1xuLyoqIFByb3Bvc2FsU3RhdHVzIGVudW1lcmF0ZXMgdGhlIHZhbGlkIHN0YXR1c2VzIG9mIGEgcHJvcG9zYWwuICovXG52YXIgUHJvcG9zYWxTdGF0dXM7XG4oZnVuY3Rpb24gKFByb3Bvc2FsU3RhdHVzKSB7XG4gICAgLyoqIFBST1BPU0FMX1NUQVRVU19VTlNQRUNJRklFRCAtIFBST1BPU0FMX1NUQVRVU19VTlNQRUNJRklFRCBkZWZpbmVzIHRoZSBkZWZhdWx0IHByb3BvcHNhbCBzdGF0dXMuICovXG4gICAgUHJvcG9zYWxTdGF0dXNbUHJvcG9zYWxTdGF0dXNbXCJQUk9QT1NBTF9TVEFUVVNfVU5TUEVDSUZJRURcIl0gPSAwXSA9IFwiUFJPUE9TQUxfU1RBVFVTX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogUFJPUE9TQUxfU1RBVFVTX0RFUE9TSVRfUEVSSU9EIC0gUFJPUE9TQUxfU1RBVFVTX0RFUE9TSVRfUEVSSU9EIGRlZmluZXMgYSBwcm9wb3NhbCBzdGF0dXMgZHVyaW5nIHRoZSBkZXBvc2l0XG4gICAgICogcGVyaW9kLlxuICAgICAqL1xuICAgIFByb3Bvc2FsU3RhdHVzW1Byb3Bvc2FsU3RhdHVzW1wiUFJPUE9TQUxfU1RBVFVTX0RFUE9TSVRfUEVSSU9EXCJdID0gMV0gPSBcIlBST1BPU0FMX1NUQVRVU19ERVBPU0lUX1BFUklPRFwiO1xuICAgIC8qKlxuICAgICAqIFBST1BPU0FMX1NUQVRVU19WT1RJTkdfUEVSSU9EIC0gUFJPUE9TQUxfU1RBVFVTX1ZPVElOR19QRVJJT0QgZGVmaW5lcyBhIHByb3Bvc2FsIHN0YXR1cyBkdXJpbmcgdGhlIHZvdGluZ1xuICAgICAqIHBlcmlvZC5cbiAgICAgKi9cbiAgICBQcm9wb3NhbFN0YXR1c1tQcm9wb3NhbFN0YXR1c1tcIlBST1BPU0FMX1NUQVRVU19WT1RJTkdfUEVSSU9EXCJdID0gMl0gPSBcIlBST1BPU0FMX1NUQVRVU19WT1RJTkdfUEVSSU9EXCI7XG4gICAgLyoqXG4gICAgICogUFJPUE9TQUxfU1RBVFVTX1BBU1NFRCAtIFBST1BPU0FMX1NUQVRVU19QQVNTRUQgZGVmaW5lcyBhIHByb3Bvc2FsIHN0YXR1cyBvZiBhIHByb3Bvc2FsIHRoYXQgaGFzXG4gICAgICogcGFzc2VkLlxuICAgICAqL1xuICAgIFByb3Bvc2FsU3RhdHVzW1Byb3Bvc2FsU3RhdHVzW1wiUFJPUE9TQUxfU1RBVFVTX1BBU1NFRFwiXSA9IDNdID0gXCJQUk9QT1NBTF9TVEFUVVNfUEFTU0VEXCI7XG4gICAgLyoqXG4gICAgICogUFJPUE9TQUxfU1RBVFVTX1JFSkVDVEVEIC0gUFJPUE9TQUxfU1RBVFVTX1JFSkVDVEVEIGRlZmluZXMgYSBwcm9wb3NhbCBzdGF0dXMgb2YgYSBwcm9wb3NhbCB0aGF0IGhhc1xuICAgICAqIGJlZW4gcmVqZWN0ZWQuXG4gICAgICovXG4gICAgUHJvcG9zYWxTdGF0dXNbUHJvcG9zYWxTdGF0dXNbXCJQUk9QT1NBTF9TVEFUVVNfUkVKRUNURURcIl0gPSA0XSA9IFwiUFJPUE9TQUxfU1RBVFVTX1JFSkVDVEVEXCI7XG4gICAgLyoqXG4gICAgICogUFJPUE9TQUxfU1RBVFVTX0ZBSUxFRCAtIFBST1BPU0FMX1NUQVRVU19GQUlMRUQgZGVmaW5lcyBhIHByb3Bvc2FsIHN0YXR1cyBvZiBhIHByb3Bvc2FsIHRoYXQgaGFzXG4gICAgICogZmFpbGVkLlxuICAgICAqL1xuICAgIFByb3Bvc2FsU3RhdHVzW1Byb3Bvc2FsU3RhdHVzW1wiUFJPUE9TQUxfU1RBVFVTX0ZBSUxFRFwiXSA9IDVdID0gXCJQUk9QT1NBTF9TVEFUVVNfRkFJTEVEXCI7XG4gICAgUHJvcG9zYWxTdGF0dXNbUHJvcG9zYWxTdGF0dXNbXCJVTlJFQ09HTklaRURcIl0gPSAtMV0gPSBcIlVOUkVDT0dOSVpFRFwiO1xufSkoUHJvcG9zYWxTdGF0dXMgPSBleHBvcnRzLlByb3Bvc2FsU3RhdHVzIHx8IChleHBvcnRzLlByb3Bvc2FsU3RhdHVzID0ge30pKTtcbmZ1bmN0aW9uIHByb3Bvc2FsU3RhdHVzRnJvbUpTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIFwiUFJPUE9TQUxfU1RBVFVTX1VOU1BFQ0lGSUVEXCI6XG4gICAgICAgICAgICByZXR1cm4gUHJvcG9zYWxTdGF0dXMuUFJPUE9TQUxfU1RBVFVTX1VOU1BFQ0lGSUVEO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgXCJQUk9QT1NBTF9TVEFUVVNfREVQT1NJVF9QRVJJT0RcIjpcbiAgICAgICAgICAgIHJldHVybiBQcm9wb3NhbFN0YXR1cy5QUk9QT1NBTF9TVEFUVVNfREVQT1NJVF9QRVJJT0Q7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgY2FzZSBcIlBST1BPU0FMX1NUQVRVU19WT1RJTkdfUEVSSU9EXCI6XG4gICAgICAgICAgICByZXR1cm4gUHJvcG9zYWxTdGF0dXMuUFJPUE9TQUxfU1RBVFVTX1ZPVElOR19QRVJJT0Q7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSBcIlBST1BPU0FMX1NUQVRVU19QQVNTRURcIjpcbiAgICAgICAgICAgIHJldHVybiBQcm9wb3NhbFN0YXR1cy5QUk9QT1NBTF9TVEFUVVNfUEFTU0VEO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgXCJQUk9QT1NBTF9TVEFUVVNfUkVKRUNURURcIjpcbiAgICAgICAgICAgIHJldHVybiBQcm9wb3NhbFN0YXR1cy5QUk9QT1NBTF9TVEFUVVNfUkVKRUNURUQ7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgY2FzZSBcIlBST1BPU0FMX1NUQVRVU19GQUlMRURcIjpcbiAgICAgICAgICAgIHJldHVybiBQcm9wb3NhbFN0YXR1cy5QUk9QT1NBTF9TVEFUVVNfRkFJTEVEO1xuICAgICAgICBjYXNlIC0xOlxuICAgICAgICBjYXNlIFwiVU5SRUNPR05JWkVEXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gUHJvcG9zYWxTdGF0dXMuVU5SRUNPR05JWkVEO1xuICAgIH1cbn1cbmV4cG9ydHMucHJvcG9zYWxTdGF0dXNGcm9tSlNPTiA9IHByb3Bvc2FsU3RhdHVzRnJvbUpTT047XG5mdW5jdGlvbiBwcm9wb3NhbFN0YXR1c1RvSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIFByb3Bvc2FsU3RhdHVzLlBST1BPU0FMX1NUQVRVU19VTlNQRUNJRklFRDpcbiAgICAgICAgICAgIHJldHVybiBcIlBST1BPU0FMX1NUQVRVU19VTlNQRUNJRklFRFwiO1xuICAgICAgICBjYXNlIFByb3Bvc2FsU3RhdHVzLlBST1BPU0FMX1NUQVRVU19ERVBPU0lUX1BFUklPRDpcbiAgICAgICAgICAgIHJldHVybiBcIlBST1BPU0FMX1NUQVRVU19ERVBPU0lUX1BFUklPRFwiO1xuICAgICAgICBjYXNlIFByb3Bvc2FsU3RhdHVzLlBST1BPU0FMX1NUQVRVU19WT1RJTkdfUEVSSU9EOlxuICAgICAgICAgICAgcmV0dXJuIFwiUFJPUE9TQUxfU1RBVFVTX1ZPVElOR19QRVJJT0RcIjtcbiAgICAgICAgY2FzZSBQcm9wb3NhbFN0YXR1cy5QUk9QT1NBTF9TVEFUVVNfUEFTU0VEOlxuICAgICAgICAgICAgcmV0dXJuIFwiUFJPUE9TQUxfU1RBVFVTX1BBU1NFRFwiO1xuICAgICAgICBjYXNlIFByb3Bvc2FsU3RhdHVzLlBST1BPU0FMX1NUQVRVU19SRUpFQ1RFRDpcbiAgICAgICAgICAgIHJldHVybiBcIlBST1BPU0FMX1NUQVRVU19SRUpFQ1RFRFwiO1xuICAgICAgICBjYXNlIFByb3Bvc2FsU3RhdHVzLlBST1BPU0FMX1NUQVRVU19GQUlMRUQ6XG4gICAgICAgICAgICByZXR1cm4gXCJQUk9QT1NBTF9TVEFUVVNfRkFJTEVEXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJVTktOT1dOXCI7XG4gICAgfVxufVxuZXhwb3J0cy5wcm9wb3NhbFN0YXR1c1RvSlNPTiA9IHByb3Bvc2FsU3RhdHVzVG9KU09OO1xuZnVuY3Rpb24gY3JlYXRlQmFzZVdlaWdodGVkVm90ZU9wdGlvbigpIHtcbiAgICByZXR1cm4geyBvcHRpb246IDAsIHdlaWdodDogXCJcIiB9O1xufVxuZXhwb3J0cy5XZWlnaHRlZFZvdGVPcHRpb24gPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5vcHRpb24gIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkuaW50MzIobWVzc2FnZS5vcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLndlaWdodCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2Uud2VpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VXZWlnaHRlZFZvdGVPcHRpb24oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9wdGlvbiA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uud2VpZ2h0ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcHRpb246IGlzU2V0KG9iamVjdC5vcHRpb24pID8gdm90ZU9wdGlvbkZyb21KU09OKG9iamVjdC5vcHRpb24pIDogMCxcbiAgICAgICAgICAgIHdlaWdodDogaXNTZXQob2JqZWN0LndlaWdodCkgPyBTdHJpbmcob2JqZWN0LndlaWdodCkgOiBcIlwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uub3B0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoub3B0aW9uID0gdm90ZU9wdGlvblRvSlNPTihtZXNzYWdlLm9wdGlvbikpO1xuICAgICAgICBtZXNzYWdlLndlaWdodCAhPT0gdW5kZWZpbmVkICYmIChvYmoud2VpZ2h0ID0gbWVzc2FnZS53ZWlnaHQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlV2VpZ2h0ZWRWb3RlT3B0aW9uKCk7XG4gICAgICAgIG1lc3NhZ2Uub3B0aW9uID0gKF9hID0gb2JqZWN0Lm9wdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgbWVzc2FnZS53ZWlnaHQgPSAoX2IgPSBvYmplY3Qud2VpZ2h0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUZXh0UHJvcG9zYWwoKSB7XG4gICAgcmV0dXJuIHsgdGl0bGU6IFwiXCIsIGRlc2NyaXB0aW9uOiBcIlwiIH07XG59XG5leHBvcnRzLlRleHRQcm9wb3NhbCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnRpdGxlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS50aXRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLmRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUZXh0UHJvcG9zYWwoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRpdGxlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVzY3JpcHRpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpdGxlOiBpc1NldChvYmplY3QudGl0bGUpID8gU3RyaW5nKG9iamVjdC50aXRsZSkgOiBcIlwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGlzU2V0KG9iamVjdC5kZXNjcmlwdGlvbikgPyBTdHJpbmcob2JqZWN0LmRlc2NyaXB0aW9uKSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS50aXRsZSAhPT0gdW5kZWZpbmVkICYmIChvYmoudGl0bGUgPSBtZXNzYWdlLnRpdGxlKTtcbiAgICAgICAgbWVzc2FnZS5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmRlc2NyaXB0aW9uID0gbWVzc2FnZS5kZXNjcmlwdGlvbik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUZXh0UHJvcG9zYWwoKTtcbiAgICAgICAgbWVzc2FnZS50aXRsZSA9IChfYSA9IG9iamVjdC50aXRsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5kZXNjcmlwdGlvbiA9IChfYiA9IG9iamVjdC5kZXNjcmlwdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRGVwb3NpdCgpIHtcbiAgICByZXR1cm4geyBwcm9wb3NhbElkOiBcIjBcIiwgZGVwb3NpdG9yOiBcIlwiLCBhbW91bnQ6IFtdIH07XG59XG5leHBvcnRzLkRlcG9zaXQgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5wcm9wb3NhbElkICE9PSBcIjBcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS51aW50NjQobWVzc2FnZS5wcm9wb3NhbElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5kZXBvc2l0b3IgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLmRlcG9zaXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuYW1vdW50KSB7XG4gICAgICAgICAgICBjb2luXzEuQ29pbi5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEZXBvc2l0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcm9wb3NhbElkID0gbG9uZ1RvU3RyaW5nKHJlYWRlci51aW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kZXBvc2l0b3IgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hbW91bnQucHVzaChjb2luXzEuQ29pbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvcG9zYWxJZDogaXNTZXQob2JqZWN0LnByb3Bvc2FsSWQpID8gU3RyaW5nKG9iamVjdC5wcm9wb3NhbElkKSA6IFwiMFwiLFxuICAgICAgICAgICAgZGVwb3NpdG9yOiBpc1NldChvYmplY3QuZGVwb3NpdG9yKSA/IFN0cmluZyhvYmplY3QuZGVwb3NpdG9yKSA6IFwiXCIsXG4gICAgICAgICAgICBhbW91bnQ6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LmFtb3VudClcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5hbW91bnQubWFwKChlKSA9PiBjb2luXzEuQ29pbi5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UucHJvcG9zYWxJZCAhPT0gdW5kZWZpbmVkICYmIChvYmoucHJvcG9zYWxJZCA9IG1lc3NhZ2UucHJvcG9zYWxJZCk7XG4gICAgICAgIG1lc3NhZ2UuZGVwb3NpdG9yICE9PSB1bmRlZmluZWQgJiYgKG9iai5kZXBvc2l0b3IgPSBtZXNzYWdlLmRlcG9zaXRvcik7XG4gICAgICAgIGlmIChtZXNzYWdlLmFtb3VudCkge1xuICAgICAgICAgICAgb2JqLmFtb3VudCA9IG1lc3NhZ2UuYW1vdW50Lm1hcCgoZSkgPT4gKGUgPyBjb2luXzEuQ29pbi50b0pTT04oZSkgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5hbW91bnQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlcG9zaXQoKTtcbiAgICAgICAgbWVzc2FnZS5wcm9wb3NhbElkID0gKF9hID0gb2JqZWN0LnByb3Bvc2FsSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiMFwiO1xuICAgICAgICBtZXNzYWdlLmRlcG9zaXRvciA9IChfYiA9IG9iamVjdC5kZXBvc2l0b3IpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuYW1vdW50ID0gKChfYyA9IG9iamVjdC5hbW91bnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5tYXAoKGUpID0+IGNvaW5fMS5Db2luLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVByb3Bvc2FsKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb3Bvc2FsSWQ6IFwiMFwiLFxuICAgICAgICBjb250ZW50OiB1bmRlZmluZWQsXG4gICAgICAgIHN0YXR1czogMCxcbiAgICAgICAgZmluYWxUYWxseVJlc3VsdDogdW5kZWZpbmVkLFxuICAgICAgICBzdWJtaXRUaW1lOiB1bmRlZmluZWQsXG4gICAgICAgIGRlcG9zaXRFbmRUaW1lOiB1bmRlZmluZWQsXG4gICAgICAgIHRvdGFsRGVwb3NpdDogW10sXG4gICAgICAgIHZvdGluZ1N0YXJ0VGltZTogdW5kZWZpbmVkLFxuICAgICAgICB2b3RpbmdFbmRUaW1lOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydHMuUHJvcG9zYWwgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5wcm9wb3NhbElkICE9PSBcIjBcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS51aW50NjQobWVzc2FnZS5wcm9wb3NhbElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFueV8xLkFueS5lbmNvZGUobWVzc2FnZS5jb250ZW50LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnN0YXR1cyAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkuaW50MzIobWVzc2FnZS5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmZpbmFsVGFsbHlSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5UYWxseVJlc3VsdC5lbmNvZGUobWVzc2FnZS5maW5hbFRhbGx5UmVzdWx0LCB3cml0ZXIudWludDMyKDM0KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnN1Ym1pdFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGltZXN0YW1wXzEuVGltZXN0YW1wLmVuY29kZSh0b1RpbWVzdGFtcChtZXNzYWdlLnN1Ym1pdFRpbWUpLCB3cml0ZXIudWludDMyKDQyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmRlcG9zaXRFbmRUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcF8xLlRpbWVzdGFtcC5lbmNvZGUodG9UaW1lc3RhbXAobWVzc2FnZS5kZXBvc2l0RW5kVGltZSksIHdyaXRlci51aW50MzIoNTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UudG90YWxEZXBvc2l0KSB7XG4gICAgICAgICAgICBjb2luXzEuQ29pbi5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMig1OCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52b3RpbmdTdGFydFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGltZXN0YW1wXzEuVGltZXN0YW1wLmVuY29kZSh0b1RpbWVzdGFtcChtZXNzYWdlLnZvdGluZ1N0YXJ0VGltZSksIHdyaXRlci51aW50MzIoNjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uudm90aW5nRW5kVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aW1lc3RhbXBfMS5UaW1lc3RhbXAuZW5jb2RlKHRvVGltZXN0YW1wKG1lc3NhZ2Uudm90aW5nRW5kVGltZSksIHdyaXRlci51aW50MzIoNzQpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHJvcG9zYWwoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByb3Bvc2FsSWQgPSBsb25nVG9TdHJpbmcocmVhZGVyLnVpbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnRlbnQgPSBhbnlfMS5BbnkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN0YXR1cyA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmluYWxUYWxseVJlc3VsdCA9IGV4cG9ydHMuVGFsbHlSZXN1bHQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN1Ym1pdFRpbWUgPSBmcm9tVGltZXN0YW1wKHRpbWVzdGFtcF8xLlRpbWVzdGFtcC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRlcG9zaXRFbmRUaW1lID0gZnJvbVRpbWVzdGFtcCh0aW1lc3RhbXBfMS5UaW1lc3RhbXAuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50b3RhbERlcG9zaXQucHVzaChjb2luXzEuQ29pbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZvdGluZ1N0YXJ0VGltZSA9IGZyb21UaW1lc3RhbXAodGltZXN0YW1wXzEuVGltZXN0YW1wLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uudm90aW5nRW5kVGltZSA9IGZyb21UaW1lc3RhbXAodGltZXN0YW1wXzEuVGltZXN0YW1wLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9wb3NhbElkOiBpc1NldChvYmplY3QucHJvcG9zYWxJZCkgPyBTdHJpbmcob2JqZWN0LnByb3Bvc2FsSWQpIDogXCIwXCIsXG4gICAgICAgICAgICBjb250ZW50OiBpc1NldChvYmplY3QuY29udGVudCkgPyBhbnlfMS5BbnkuZnJvbUpTT04ob2JqZWN0LmNvbnRlbnQpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3RhdHVzOiBpc1NldChvYmplY3Quc3RhdHVzKSA/IHByb3Bvc2FsU3RhdHVzRnJvbUpTT04ob2JqZWN0LnN0YXR1cykgOiAwLFxuICAgICAgICAgICAgZmluYWxUYWxseVJlc3VsdDogaXNTZXQob2JqZWN0LmZpbmFsVGFsbHlSZXN1bHQpXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlRhbGx5UmVzdWx0LmZyb21KU09OKG9iamVjdC5maW5hbFRhbGx5UmVzdWx0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc3VibWl0VGltZTogaXNTZXQob2JqZWN0LnN1Ym1pdFRpbWUpXG4gICAgICAgICAgICAgICAgPyBmcm9tSnNvblRpbWVzdGFtcChvYmplY3Quc3VibWl0VGltZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRlcG9zaXRFbmRUaW1lOiBpc1NldChvYmplY3QuZGVwb3NpdEVuZFRpbWUpXG4gICAgICAgICAgICAgICAgPyBmcm9tSnNvblRpbWVzdGFtcChvYmplY3QuZGVwb3NpdEVuZFRpbWUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0b3RhbERlcG9zaXQ6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnRvdGFsRGVwb3NpdClcbiAgICAgICAgICAgICAgICA/IG9iamVjdC50b3RhbERlcG9zaXQubWFwKChlKSA9PiBjb2luXzEuQ29pbi5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgdm90aW5nU3RhcnRUaW1lOiBpc1NldChvYmplY3Qudm90aW5nU3RhcnRUaW1lKVxuICAgICAgICAgICAgICAgID8gZnJvbUpzb25UaW1lc3RhbXAob2JqZWN0LnZvdGluZ1N0YXJ0VGltZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZvdGluZ0VuZFRpbWU6IGlzU2V0KG9iamVjdC52b3RpbmdFbmRUaW1lKVxuICAgICAgICAgICAgICAgID8gZnJvbUpzb25UaW1lc3RhbXAob2JqZWN0LnZvdGluZ0VuZFRpbWUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5wcm9wb3NhbElkICE9PSB1bmRlZmluZWQgJiYgKG9iai5wcm9wb3NhbElkID0gbWVzc2FnZS5wcm9wb3NhbElkKTtcbiAgICAgICAgbWVzc2FnZS5jb250ZW50ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY29udGVudCA9IG1lc3NhZ2UuY29udGVudCA/IGFueV8xLkFueS50b0pTT04obWVzc2FnZS5jb250ZW50KSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2Uuc3RhdHVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc3RhdHVzID0gcHJvcG9zYWxTdGF0dXNUb0pTT04obWVzc2FnZS5zdGF0dXMpKTtcbiAgICAgICAgbWVzc2FnZS5maW5hbFRhbGx5UmVzdWx0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZmluYWxUYWxseVJlc3VsdCA9IG1lc3NhZ2UuZmluYWxUYWxseVJlc3VsdFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5UYWxseVJlc3VsdC50b0pTT04obWVzc2FnZS5maW5hbFRhbGx5UmVzdWx0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5zdWJtaXRUaW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc3VibWl0VGltZSA9IG1lc3NhZ2Uuc3VibWl0VGltZS50b0lTT1N0cmluZygpKTtcbiAgICAgICAgbWVzc2FnZS5kZXBvc2l0RW5kVGltZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmRlcG9zaXRFbmRUaW1lID0gbWVzc2FnZS5kZXBvc2l0RW5kVGltZS50b0lTT1N0cmluZygpKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UudG90YWxEZXBvc2l0KSB7XG4gICAgICAgICAgICBvYmoudG90YWxEZXBvc2l0ID0gbWVzc2FnZS50b3RhbERlcG9zaXQubWFwKChlKSA9PiBlID8gY29pbl8xLkNvaW4udG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai50b3RhbERlcG9zaXQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLnZvdGluZ1N0YXJ0VGltZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnZvdGluZ1N0YXJ0VGltZSA9IG1lc3NhZ2Uudm90aW5nU3RhcnRUaW1lLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICBtZXNzYWdlLnZvdGluZ0VuZFRpbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52b3RpbmdFbmRUaW1lID0gbWVzc2FnZS52b3RpbmdFbmRUaW1lLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcm9wb3NhbCgpO1xuICAgICAgICBtZXNzYWdlLnByb3Bvc2FsSWQgPSAoX2EgPSBvYmplY3QucHJvcG9zYWxJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCIwXCI7XG4gICAgICAgIG1lc3NhZ2UuY29udGVudCA9XG4gICAgICAgICAgICBvYmplY3QuY29udGVudCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jb250ZW50ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBhbnlfMS5BbnkuZnJvbVBhcnRpYWwob2JqZWN0LmNvbnRlbnQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2Uuc3RhdHVzID0gKF9iID0gb2JqZWN0LnN0YXR1cykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICAgICAgbWVzc2FnZS5maW5hbFRhbGx5UmVzdWx0ID1cbiAgICAgICAgICAgIG9iamVjdC5maW5hbFRhbGx5UmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmZpbmFsVGFsbHlSZXN1bHQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuVGFsbHlSZXN1bHQuZnJvbVBhcnRpYWwob2JqZWN0LmZpbmFsVGFsbHlSZXN1bHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2Uuc3VibWl0VGltZSA9IChfYyA9IG9iamVjdC5zdWJtaXRUaW1lKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuZGVwb3NpdEVuZFRpbWUgPSAoX2QgPSBvYmplY3QuZGVwb3NpdEVuZFRpbWUpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS50b3RhbERlcG9zaXQgPVxuICAgICAgICAgICAgKChfZSA9IG9iamVjdC50b3RhbERlcG9zaXQpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5tYXAoKGUpID0+IGNvaW5fMS5Db2luLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIG1lc3NhZ2Uudm90aW5nU3RhcnRUaW1lID0gKF9mID0gb2JqZWN0LnZvdGluZ1N0YXJ0VGltZSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnZvdGluZ0VuZFRpbWUgPSAoX2cgPSBvYmplY3Qudm90aW5nRW5kVGltZSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUYWxseVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB5ZXM6IFwiXCIsIGFic3RhaW46IFwiXCIsIG5vOiBcIlwiLCBub1dpdGhWZXRvOiBcIlwiIH07XG59XG5leHBvcnRzLlRhbGx5UmVzdWx0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UueWVzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS55ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmFic3RhaW4gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLmFic3RhaW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm5vICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5zdHJpbmcobWVzc2FnZS5ubyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uubm9XaXRoVmV0byAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzNCkuc3RyaW5nKG1lc3NhZ2Uubm9XaXRoVmV0byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVGFsbHlSZXN1bHQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnllcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFic3RhaW4gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ubyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5vV2l0aFZldG8gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllczogaXNTZXQob2JqZWN0LnllcykgPyBTdHJpbmcob2JqZWN0LnllcykgOiBcIlwiLFxuICAgICAgICAgICAgYWJzdGFpbjogaXNTZXQob2JqZWN0LmFic3RhaW4pID8gU3RyaW5nKG9iamVjdC5hYnN0YWluKSA6IFwiXCIsXG4gICAgICAgICAgICBubzogaXNTZXQob2JqZWN0Lm5vKSA/IFN0cmluZyhvYmplY3Qubm8pIDogXCJcIixcbiAgICAgICAgICAgIG5vV2l0aFZldG86IGlzU2V0KG9iamVjdC5ub1dpdGhWZXRvKSA/IFN0cmluZyhvYmplY3Qubm9XaXRoVmV0bykgOiBcIlwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UueWVzICE9PSB1bmRlZmluZWQgJiYgKG9iai55ZXMgPSBtZXNzYWdlLnllcyk7XG4gICAgICAgIG1lc3NhZ2UuYWJzdGFpbiAhPT0gdW5kZWZpbmVkICYmIChvYmouYWJzdGFpbiA9IG1lc3NhZ2UuYWJzdGFpbik7XG4gICAgICAgIG1lc3NhZ2Uubm8gIT09IHVuZGVmaW5lZCAmJiAob2JqLm5vID0gbWVzc2FnZS5ubyk7XG4gICAgICAgIG1lc3NhZ2Uubm9XaXRoVmV0byAhPT0gdW5kZWZpbmVkICYmIChvYmoubm9XaXRoVmV0byA9IG1lc3NhZ2Uubm9XaXRoVmV0byk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVRhbGx5UmVzdWx0KCk7XG4gICAgICAgIG1lc3NhZ2UueWVzID0gKF9hID0gb2JqZWN0LnllcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5hYnN0YWluID0gKF9iID0gb2JqZWN0LmFic3RhaW4pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2Uubm8gPSAoX2MgPSBvYmplY3Qubm8pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2Uubm9XaXRoVmV0byA9IChfZCA9IG9iamVjdC5ub1dpdGhWZXRvKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWb3RlKCkge1xuICAgIHJldHVybiB7IHByb3Bvc2FsSWQ6IFwiMFwiLCB2b3RlcjogXCJcIiwgb3B0aW9uOiAwLCBvcHRpb25zOiBbXSB9O1xufVxuZXhwb3J0cy5Wb3RlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UucHJvcG9zYWxJZCAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkudWludDY0KG1lc3NhZ2UucHJvcG9zYWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uudm90ZXIgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnZvdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5vcHRpb24gIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjQpLmludDMyKG1lc3NhZ2Uub3B0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5vcHRpb25zKSB7XG4gICAgICAgICAgICBleHBvcnRzLldlaWdodGVkVm90ZU9wdGlvbi5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigzNCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VWb3RlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcm9wb3NhbElkID0gbG9uZ1RvU3RyaW5nKHJlYWRlci51aW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52b3RlciA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9wdGlvbiA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3B0aW9ucy5wdXNoKGV4cG9ydHMuV2VpZ2h0ZWRWb3RlT3B0aW9uLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9wb3NhbElkOiBpc1NldChvYmplY3QucHJvcG9zYWxJZCkgPyBTdHJpbmcob2JqZWN0LnByb3Bvc2FsSWQpIDogXCIwXCIsXG4gICAgICAgICAgICB2b3RlcjogaXNTZXQob2JqZWN0LnZvdGVyKSA/IFN0cmluZyhvYmplY3Qudm90ZXIpIDogXCJcIixcbiAgICAgICAgICAgIG9wdGlvbjogaXNTZXQob2JqZWN0Lm9wdGlvbikgPyB2b3RlT3B0aW9uRnJvbUpTT04ob2JqZWN0Lm9wdGlvbikgOiAwLFxuICAgICAgICAgICAgb3B0aW9uczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3Qub3B0aW9ucylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5vcHRpb25zLm1hcCgoZSkgPT4gZXhwb3J0cy5XZWlnaHRlZFZvdGVPcHRpb24uZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnByb3Bvc2FsSWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLnByb3Bvc2FsSWQgPSBtZXNzYWdlLnByb3Bvc2FsSWQpO1xuICAgICAgICBtZXNzYWdlLnZvdGVyICE9PSB1bmRlZmluZWQgJiYgKG9iai52b3RlciA9IG1lc3NhZ2Uudm90ZXIpO1xuICAgICAgICBtZXNzYWdlLm9wdGlvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLm9wdGlvbiA9IHZvdGVPcHRpb25Ub0pTT04obWVzc2FnZS5vcHRpb24pKTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uub3B0aW9ucykge1xuICAgICAgICAgICAgb2JqLm9wdGlvbnMgPSBtZXNzYWdlLm9wdGlvbnMubWFwKChlKSA9PiBlID8gZXhwb3J0cy5XZWlnaHRlZFZvdGVPcHRpb24udG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5vcHRpb25zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVm90ZSgpO1xuICAgICAgICBtZXNzYWdlLnByb3Bvc2FsSWQgPSAoX2EgPSBvYmplY3QucHJvcG9zYWxJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCIwXCI7XG4gICAgICAgIG1lc3NhZ2Uudm90ZXIgPSAoX2IgPSBvYmplY3Qudm90ZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2Uub3B0aW9uID0gKF9jID0gb2JqZWN0Lm9wdGlvbikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMDtcbiAgICAgICAgbWVzc2FnZS5vcHRpb25zID1cbiAgICAgICAgICAgICgoX2QgPSBvYmplY3Qub3B0aW9ucykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLm1hcCgoZSkgPT4gZXhwb3J0cy5XZWlnaHRlZFZvdGVPcHRpb24uZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRGVwb3NpdFBhcmFtcygpIHtcbiAgICByZXR1cm4geyBtaW5EZXBvc2l0OiBbXSwgbWF4RGVwb3NpdFBlcmlvZDogdW5kZWZpbmVkIH07XG59XG5leHBvcnRzLkRlcG9zaXRQYXJhbXMgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5taW5EZXBvc2l0KSB7XG4gICAgICAgICAgICBjb2luXzEuQ29pbi5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5tYXhEZXBvc2l0UGVyaW9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uXzEuRHVyYXRpb24uZW5jb2RlKG1lc3NhZ2UubWF4RGVwb3NpdFBlcmlvZCwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEZXBvc2l0UGFyYW1zKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5taW5EZXBvc2l0LnB1c2goY29pbl8xLkNvaW4uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tYXhEZXBvc2l0UGVyaW9kID0gZHVyYXRpb25fMS5EdXJhdGlvbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW5EZXBvc2l0OiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5taW5EZXBvc2l0KVxuICAgICAgICAgICAgICAgID8gb2JqZWN0Lm1pbkRlcG9zaXQubWFwKChlKSA9PiBjb2luXzEuQ29pbi5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgbWF4RGVwb3NpdFBlcmlvZDogaXNTZXQob2JqZWN0Lm1heERlcG9zaXRQZXJpb2QpXG4gICAgICAgICAgICAgICAgPyBkdXJhdGlvbl8xLkR1cmF0aW9uLmZyb21KU09OKG9iamVjdC5tYXhEZXBvc2l0UGVyaW9kKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLm1pbkRlcG9zaXQpIHtcbiAgICAgICAgICAgIG9iai5taW5EZXBvc2l0ID0gbWVzc2FnZS5taW5EZXBvc2l0Lm1hcCgoZSkgPT4gZSA/IGNvaW5fMS5Db2luLnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoubWluRGVwb3NpdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UubWF4RGVwb3NpdFBlcmlvZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLm1heERlcG9zaXRQZXJpb2QgPSBtZXNzYWdlLm1heERlcG9zaXRQZXJpb2RcbiAgICAgICAgICAgICAgICA/IGR1cmF0aW9uXzEuRHVyYXRpb24udG9KU09OKG1lc3NhZ2UubWF4RGVwb3NpdFBlcmlvZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlcG9zaXRQYXJhbXMoKTtcbiAgICAgICAgbWVzc2FnZS5taW5EZXBvc2l0ID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3QubWluRGVwb3NpdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gY29pbl8xLkNvaW4uZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgbWVzc2FnZS5tYXhEZXBvc2l0UGVyaW9kID1cbiAgICAgICAgICAgIG9iamVjdC5tYXhEZXBvc2l0UGVyaW9kICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0Lm1heERlcG9zaXRQZXJpb2QgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGR1cmF0aW9uXzEuRHVyYXRpb24uZnJvbVBhcnRpYWwob2JqZWN0Lm1heERlcG9zaXRQZXJpb2QpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVZvdGluZ1BhcmFtcygpIHtcbiAgICByZXR1cm4geyB2b3RpbmdQZXJpb2Q6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0cy5Wb3RpbmdQYXJhbXMgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS52b3RpbmdQZXJpb2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZHVyYXRpb25fMS5EdXJhdGlvbi5lbmNvZGUobWVzc2FnZS52b3RpbmdQZXJpb2QsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVm90aW5nUGFyYW1zKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52b3RpbmdQZXJpb2QgPSBkdXJhdGlvbl8xLkR1cmF0aW9uLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZvdGluZ1BlcmlvZDogaXNTZXQob2JqZWN0LnZvdGluZ1BlcmlvZClcbiAgICAgICAgICAgICAgICA/IGR1cmF0aW9uXzEuRHVyYXRpb24uZnJvbUpTT04ob2JqZWN0LnZvdGluZ1BlcmlvZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnZvdGluZ1BlcmlvZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnZvdGluZ1BlcmlvZCA9IG1lc3NhZ2Uudm90aW5nUGVyaW9kXG4gICAgICAgICAgICAgICAgPyBkdXJhdGlvbl8xLkR1cmF0aW9uLnRvSlNPTihtZXNzYWdlLnZvdGluZ1BlcmlvZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VWb3RpbmdQYXJhbXMoKTtcbiAgICAgICAgbWVzc2FnZS52b3RpbmdQZXJpb2QgPVxuICAgICAgICAgICAgb2JqZWN0LnZvdGluZ1BlcmlvZCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC52b3RpbmdQZXJpb2QgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGR1cmF0aW9uXzEuRHVyYXRpb24uZnJvbVBhcnRpYWwob2JqZWN0LnZvdGluZ1BlcmlvZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVGFsbHlQYXJhbXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcXVvcnVtOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB0aHJlc2hvbGQ6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIHZldG9UaHJlc2hvbGQ6IG5ldyBVaW50OEFycmF5KCksXG4gICAgfTtcbn1cbmV4cG9ydHMuVGFsbHlQYXJhbXMgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5xdW9ydW0ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLnF1b3J1bSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudGhyZXNob2xkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuYnl0ZXMobWVzc2FnZS50aHJlc2hvbGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnZldG9UaHJlc2hvbGQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5ieXRlcyhtZXNzYWdlLnZldG9UaHJlc2hvbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVRhbGx5UGFyYW1zKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5xdW9ydW0gPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRocmVzaG9sZCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmV0b1RocmVzaG9sZCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBxdW9ydW06IGlzU2V0KG9iamVjdC5xdW9ydW0pXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnF1b3J1bSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICB0aHJlc2hvbGQ6IGlzU2V0KG9iamVjdC50aHJlc2hvbGQpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnRocmVzaG9sZClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICB2ZXRvVGhyZXNob2xkOiBpc1NldChvYmplY3QudmV0b1RocmVzaG9sZClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QudmV0b1RocmVzaG9sZClcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5xdW9ydW0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5xdW9ydW0gPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5xdW9ydW0gIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UucXVvcnVtIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnRocmVzaG9sZCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS50aHJlc2hvbGQgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UudmV0b1RocmVzaG9sZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnZldG9UaHJlc2hvbGQgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS52ZXRvVGhyZXNob2xkICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2UudmV0b1RocmVzaG9sZFxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVRhbGx5UGFyYW1zKCk7XG4gICAgICAgIG1lc3NhZ2UucXVvcnVtID0gKF9hID0gb2JqZWN0LnF1b3J1bSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS50aHJlc2hvbGQgPSAoX2IgPSBvYmplY3QudGhyZXNob2xkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLnZldG9UaHJlc2hvbGQgPSAoX2MgPSBvYmplY3QudmV0b1RocmVzaG9sZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG52YXIgZ2xvYmFsVGhpcyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIHRocm93IFwiVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0XCI7XG59KSgpO1xuY29uc3QgYXRvYiA9IGdsb2JhbFRoaXMuYXRvYiB8fFxuICAgICgoYjY0KSA9PiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikudG9TdHJpbmcoXCJiaW5hcnlcIikpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NCkge1xuICAgIGNvbnN0IGJpbiA9IGF0b2IoYjY0KTtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmNvbnN0IGJ0b2EgPSBnbG9iYWxUaGlzLmJ0b2EgfHxcbiAgICAoKGJpbikgPT4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiaW4sIFwiYmluYXJ5XCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpKTtcbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnIpIHtcbiAgICBjb25zdCBiaW4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGJ5dGUgb2YgYXJyKSB7XG4gICAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYShiaW4uam9pbihcIlwiKSk7XG59XG5mdW5jdGlvbiB0b1RpbWVzdGFtcChkYXRlKSB7XG4gICAgY29uc3Qgc2Vjb25kcyA9IE1hdGgudHJ1bmMoZGF0ZS5nZXRUaW1lKCkgLyAxMDAwKS50b1N0cmluZygpO1xuICAgIGNvbnN0IG5hbm9zID0gKGRhdGUuZ2V0VGltZSgpICUgMTAwMCkgKiAxMDAwMDAwO1xuICAgIHJldHVybiB7IHNlY29uZHMsIG5hbm9zIH07XG59XG5mdW5jdGlvbiBmcm9tVGltZXN0YW1wKHQpIHtcbiAgICBsZXQgbWlsbGlzID0gTnVtYmVyKHQuc2Vjb25kcykgKiAxMDAwO1xuICAgIG1pbGxpcyArPSB0Lm5hbm9zIC8gMTAwMDAwMDtcbiAgICByZXR1cm4gbmV3IERhdGUobWlsbGlzKTtcbn1cbmZ1bmN0aW9uIGZyb21Kc29uVGltZXN0YW1wKG8pIHtcbiAgICBpZiAobyBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShvKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmcm9tVGltZXN0YW1wKHRpbWVzdGFtcF8xLlRpbWVzdGFtcC5mcm9tSlNPTihvKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbG9uZ1RvU3RyaW5nKGxvbmcpIHtcbiAgICByZXR1cm4gbG9uZy50b1N0cmluZygpO1xufVxuaWYgKG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyAhPT0gbG9uZ18xLmRlZmF1bHQpIHtcbiAgICBtaW5pbWFsXzEuZGVmYXVsdC51dGlsLkxvbmcgPSBsb25nXzEuZGVmYXVsdDtcbiAgICBtaW5pbWFsXzEuZGVmYXVsdC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nb3YuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/gov/v1beta1/gov.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/gov/v1beta1/tx.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/cosmos/gov/v1beta1/tx.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MsgDepositResponse = exports.MsgDeposit = exports.MsgVoteWeightedResponse = exports.MsgVoteWeighted = exports.MsgVoteResponse = exports.MsgVote = exports.MsgSubmitProposalResponse = exports.MsgSubmitProposal = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nconst gov_1 = __webpack_require__(/*! ../../../cosmos/gov/v1beta1/gov */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/gov/v1beta1/gov.js\");\nconst any_1 = __webpack_require__(/*! ../../../google/protobuf/any */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/any.js\");\nconst coin_1 = __webpack_require__(/*! ../../../cosmos/base/v1beta1/coin */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/base/v1beta1/coin.js\");\nexports.protobufPackage = \"cosmos.gov.v1beta1\";\nfunction createBaseMsgSubmitProposal() {\n    return { content: undefined, initialDeposit: [], proposer: \"\" };\n}\nexports.MsgSubmitProposal = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.content !== undefined) {\n            any_1.Any.encode(message.content, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.initialDeposit) {\n            coin_1.Coin.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.proposer !== \"\") {\n            writer.uint32(26).string(message.proposer);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgSubmitProposal();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.content = any_1.Any.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.initialDeposit.push(coin_1.Coin.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.proposer = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            content: isSet(object.content) ? any_1.Any.fromJSON(object.content) : undefined,\n            initialDeposit: Array.isArray(object === null || object === void 0 ? void 0 : object.initialDeposit)\n                ? object.initialDeposit.map((e) => coin_1.Coin.fromJSON(e))\n                : [],\n            proposer: isSet(object.proposer) ? String(object.proposer) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.content !== undefined &&\n            (obj.content = message.content ? any_1.Any.toJSON(message.content) : undefined);\n        if (message.initialDeposit) {\n            obj.initialDeposit = message.initialDeposit.map((e) => e ? coin_1.Coin.toJSON(e) : undefined);\n        }\n        else {\n            obj.initialDeposit = [];\n        }\n        message.proposer !== undefined && (obj.proposer = message.proposer);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseMsgSubmitProposal();\n        message.content =\n            object.content !== undefined && object.content !== null\n                ? any_1.Any.fromPartial(object.content)\n                : undefined;\n        message.initialDeposit =\n            ((_a = object.initialDeposit) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];\n        message.proposer = (_b = object.proposer) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseMsgSubmitProposalResponse() {\n    return { proposalId: \"0\" };\n}\nexports.MsgSubmitProposalResponse = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.proposalId !== \"0\") {\n            writer.uint32(8).uint64(message.proposalId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgSubmitProposalResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.proposalId = longToString(reader.uint64());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            proposalId: isSet(object.proposalId) ? String(object.proposalId) : \"0\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.proposalId !== undefined && (obj.proposalId = message.proposalId);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseMsgSubmitProposalResponse();\n        message.proposalId = (_a = object.proposalId) !== null && _a !== void 0 ? _a : \"0\";\n        return message;\n    },\n};\nfunction createBaseMsgVote() {\n    return { proposalId: \"0\", voter: \"\", option: 0 };\n}\nexports.MsgVote = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.proposalId !== \"0\") {\n            writer.uint32(8).uint64(message.proposalId);\n        }\n        if (message.voter !== \"\") {\n            writer.uint32(18).string(message.voter);\n        }\n        if (message.option !== 0) {\n            writer.uint32(24).int32(message.option);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgVote();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.proposalId = longToString(reader.uint64());\n                    break;\n                case 2:\n                    message.voter = reader.string();\n                    break;\n                case 3:\n                    message.option = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            proposalId: isSet(object.proposalId) ? String(object.proposalId) : \"0\",\n            voter: isSet(object.voter) ? String(object.voter) : \"\",\n            option: isSet(object.option) ? (0, gov_1.voteOptionFromJSON)(object.option) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.proposalId !== undefined && (obj.proposalId = message.proposalId);\n        message.voter !== undefined && (obj.voter = message.voter);\n        message.option !== undefined &&\n            (obj.option = (0, gov_1.voteOptionToJSON)(message.option));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseMsgVote();\n        message.proposalId = (_a = object.proposalId) !== null && _a !== void 0 ? _a : \"0\";\n        message.voter = (_b = object.voter) !== null && _b !== void 0 ? _b : \"\";\n        message.option = (_c = object.option) !== null && _c !== void 0 ? _c : 0;\n        return message;\n    },\n};\nfunction createBaseMsgVoteResponse() {\n    return {};\n}\nexports.MsgVoteResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgVoteResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgVoteResponse();\n        return message;\n    },\n};\nfunction createBaseMsgVoteWeighted() {\n    return { proposalId: \"0\", voter: \"\", options: [] };\n}\nexports.MsgVoteWeighted = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.proposalId !== \"0\") {\n            writer.uint32(8).uint64(message.proposalId);\n        }\n        if (message.voter !== \"\") {\n            writer.uint32(18).string(message.voter);\n        }\n        for (const v of message.options) {\n            gov_1.WeightedVoteOption.encode(v, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgVoteWeighted();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.proposalId = longToString(reader.uint64());\n                    break;\n                case 2:\n                    message.voter = reader.string();\n                    break;\n                case 3:\n                    message.options.push(gov_1.WeightedVoteOption.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            proposalId: isSet(object.proposalId) ? String(object.proposalId) : \"0\",\n            voter: isSet(object.voter) ? String(object.voter) : \"\",\n            options: Array.isArray(object === null || object === void 0 ? void 0 : object.options)\n                ? object.options.map((e) => gov_1.WeightedVoteOption.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.proposalId !== undefined && (obj.proposalId = message.proposalId);\n        message.voter !== undefined && (obj.voter = message.voter);\n        if (message.options) {\n            obj.options = message.options.map((e) => e ? gov_1.WeightedVoteOption.toJSON(e) : undefined);\n        }\n        else {\n            obj.options = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseMsgVoteWeighted();\n        message.proposalId = (_a = object.proposalId) !== null && _a !== void 0 ? _a : \"0\";\n        message.voter = (_b = object.voter) !== null && _b !== void 0 ? _b : \"\";\n        message.options =\n            ((_c = object.options) === null || _c === void 0 ? void 0 : _c.map((e) => gov_1.WeightedVoteOption.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseMsgVoteWeightedResponse() {\n    return {};\n}\nexports.MsgVoteWeightedResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgVoteWeightedResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgVoteWeightedResponse();\n        return message;\n    },\n};\nfunction createBaseMsgDeposit() {\n    return { proposalId: \"0\", depositor: \"\", amount: [] };\n}\nexports.MsgDeposit = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.proposalId !== \"0\") {\n            writer.uint32(8).uint64(message.proposalId);\n        }\n        if (message.depositor !== \"\") {\n            writer.uint32(18).string(message.depositor);\n        }\n        for (const v of message.amount) {\n            coin_1.Coin.encode(v, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgDeposit();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.proposalId = longToString(reader.uint64());\n                    break;\n                case 2:\n                    message.depositor = reader.string();\n                    break;\n                case 3:\n                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            proposalId: isSet(object.proposalId) ? String(object.proposalId) : \"0\",\n            depositor: isSet(object.depositor) ? String(object.depositor) : \"\",\n            amount: Array.isArray(object === null || object === void 0 ? void 0 : object.amount)\n                ? object.amount.map((e) => coin_1.Coin.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.proposalId !== undefined && (obj.proposalId = message.proposalId);\n        message.depositor !== undefined && (obj.depositor = message.depositor);\n        if (message.amount) {\n            obj.amount = message.amount.map((e) => (e ? coin_1.Coin.toJSON(e) : undefined));\n        }\n        else {\n            obj.amount = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseMsgDeposit();\n        message.proposalId = (_a = object.proposalId) !== null && _a !== void 0 ? _a : \"0\";\n        message.depositor = (_b = object.depositor) !== null && _b !== void 0 ? _b : \"\";\n        message.amount = ((_c = object.amount) === null || _c === void 0 ? void 0 : _c.map((e) => coin_1.Coin.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseMsgDepositResponse() {\n    return {};\n}\nexports.MsgDepositResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgDepositResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgDepositResponse();\n        return message;\n    },\n};\nfunction longToString(long) {\n    return long.toString();\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=tx.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3MvZ292L3YxYmV0YTEvdHguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyxrQkFBa0IsR0FBRywrQkFBK0IsR0FBRyx1QkFBdUIsR0FBRyx1QkFBdUIsR0FBRyxlQUFlLEdBQUcsaUNBQWlDLEdBQUcseUJBQXlCLEdBQUcsdUJBQXVCO0FBQ2pQO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMsbURBQU07QUFDN0Msa0NBQWtDLG1CQUFPLENBQUMsc0VBQW9CO0FBQzlELGNBQWMsbUJBQU8sQ0FBQyxpSEFBaUM7QUFDdkQsY0FBYyxtQkFBTyxDQUFDLDJHQUE4QjtBQUNwRCxlQUFlLG1CQUFPLENBQUMscUhBQW1DO0FBQzFELHVCQUF1QjtBQUN2QjtBQUNBLGFBQWE7QUFDYjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L3Byb3RvLXR5cGVzL2Nvc21vcy9nb3YvdjFiZXRhMS90eC5qcz8xZGE0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Nc2dEZXBvc2l0UmVzcG9uc2UgPSBleHBvcnRzLk1zZ0RlcG9zaXQgPSBleHBvcnRzLk1zZ1ZvdGVXZWlnaHRlZFJlc3BvbnNlID0gZXhwb3J0cy5Nc2dWb3RlV2VpZ2h0ZWQgPSBleHBvcnRzLk1zZ1ZvdGVSZXNwb25zZSA9IGV4cG9ydHMuTXNnVm90ZSA9IGV4cG9ydHMuTXNnU3VibWl0UHJvcG9zYWxSZXNwb25zZSA9IGV4cG9ydHMuTXNnU3VibWl0UHJvcG9zYWwgPSBleHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlICovXG5jb25zdCBsb25nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvbmdcIikpO1xuY29uc3QgbWluaW1hbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwcm90b2J1ZmpzL21pbmltYWxcIikpO1xuY29uc3QgZ292XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29zbW9zL2dvdi92MWJldGExL2dvdlwiKTtcbmNvbnN0IGFueV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2dvb2dsZS9wcm90b2J1Zi9hbnlcIik7XG5jb25zdCBjb2luXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29zbW9zL2Jhc2UvdjFiZXRhMS9jb2luXCIpO1xuZXhwb3J0cy5wcm90b2J1ZlBhY2thZ2UgPSBcImNvc21vcy5nb3YudjFiZXRhMVwiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ1N1Ym1pdFByb3Bvc2FsKCkge1xuICAgIHJldHVybiB7IGNvbnRlbnQ6IHVuZGVmaW5lZCwgaW5pdGlhbERlcG9zaXQ6IFtdLCBwcm9wb3NlcjogXCJcIiB9O1xufVxuZXhwb3J0cy5Nc2dTdWJtaXRQcm9wb3NhbCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbnRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYW55XzEuQW55LmVuY29kZShtZXNzYWdlLmNvbnRlbnQsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuaW5pdGlhbERlcG9zaXQpIHtcbiAgICAgICAgICAgIGNvaW5fMS5Db2luLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnByb3Bvc2VyICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5zdHJpbmcobWVzc2FnZS5wcm9wb3Nlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnU3VibWl0UHJvcG9zYWwoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnRlbnQgPSBhbnlfMS5BbnkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluaXRpYWxEZXBvc2l0LnB1c2goY29pbl8xLkNvaW4uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcm9wb3NlciA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGVudDogaXNTZXQob2JqZWN0LmNvbnRlbnQpID8gYW55XzEuQW55LmZyb21KU09OKG9iamVjdC5jb250ZW50KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGluaXRpYWxEZXBvc2l0OiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5pbml0aWFsRGVwb3NpdClcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5pbml0aWFsRGVwb3NpdC5tYXAoKGUpID0+IGNvaW5fMS5Db2luLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgICAgICBwcm9wb3NlcjogaXNTZXQob2JqZWN0LnByb3Bvc2VyKSA/IFN0cmluZyhvYmplY3QucHJvcG9zZXIpIDogXCJcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmNvbnRlbnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb250ZW50ID0gbWVzc2FnZS5jb250ZW50ID8gYW55XzEuQW55LnRvSlNPTihtZXNzYWdlLmNvbnRlbnQpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5pdGlhbERlcG9zaXQpIHtcbiAgICAgICAgICAgIG9iai5pbml0aWFsRGVwb3NpdCA9IG1lc3NhZ2UuaW5pdGlhbERlcG9zaXQubWFwKChlKSA9PiBlID8gY29pbl8xLkNvaW4udG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5pbml0aWFsRGVwb3NpdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UucHJvcG9zZXIgIT09IHVuZGVmaW5lZCAmJiAob2JqLnByb3Bvc2VyID0gbWVzc2FnZS5wcm9wb3Nlcik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dTdWJtaXRQcm9wb3NhbCgpO1xuICAgICAgICBtZXNzYWdlLmNvbnRlbnQgPVxuICAgICAgICAgICAgb2JqZWN0LmNvbnRlbnQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY29udGVudCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gYW55XzEuQW55LmZyb21QYXJ0aWFsKG9iamVjdC5jb250ZW50KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmluaXRpYWxEZXBvc2l0ID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3QuaW5pdGlhbERlcG9zaXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IGNvaW5fMS5Db2luLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIG1lc3NhZ2UucHJvcG9zZXIgPSAoX2IgPSBvYmplY3QucHJvcG9zZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ1N1Ym1pdFByb3Bvc2FsUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHsgcHJvcG9zYWxJZDogXCIwXCIgfTtcbn1cbmV4cG9ydHMuTXNnU3VibWl0UHJvcG9zYWxSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnByb3Bvc2FsSWQgIT09IFwiMFwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLnVpbnQ2NChtZXNzYWdlLnByb3Bvc2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ1N1Ym1pdFByb3Bvc2FsUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByb3Bvc2FsSWQgPSBsb25nVG9TdHJpbmcocmVhZGVyLnVpbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvcG9zYWxJZDogaXNTZXQob2JqZWN0LnByb3Bvc2FsSWQpID8gU3RyaW5nKG9iamVjdC5wcm9wb3NhbElkKSA6IFwiMFwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UucHJvcG9zYWxJZCAhPT0gdW5kZWZpbmVkICYmIChvYmoucHJvcG9zYWxJZCA9IG1lc3NhZ2UucHJvcG9zYWxJZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ1N1Ym1pdFByb3Bvc2FsUmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5wcm9wb3NhbElkID0gKF9hID0gb2JqZWN0LnByb3Bvc2FsSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiMFwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dWb3RlKCkge1xuICAgIHJldHVybiB7IHByb3Bvc2FsSWQ6IFwiMFwiLCB2b3RlcjogXCJcIiwgb3B0aW9uOiAwIH07XG59XG5leHBvcnRzLk1zZ1ZvdGUgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5wcm9wb3NhbElkICE9PSBcIjBcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS51aW50NjQobWVzc2FnZS5wcm9wb3NhbElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52b3RlciAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2Uudm90ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm9wdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkuaW50MzIobWVzc2FnZS5vcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ1ZvdGUoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByb3Bvc2FsSWQgPSBsb25nVG9TdHJpbmcocmVhZGVyLnVpbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZvdGVyID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3B0aW9uID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb3Bvc2FsSWQ6IGlzU2V0KG9iamVjdC5wcm9wb3NhbElkKSA/IFN0cmluZyhvYmplY3QucHJvcG9zYWxJZCkgOiBcIjBcIixcbiAgICAgICAgICAgIHZvdGVyOiBpc1NldChvYmplY3Qudm90ZXIpID8gU3RyaW5nKG9iamVjdC52b3RlcikgOiBcIlwiLFxuICAgICAgICAgICAgb3B0aW9uOiBpc1NldChvYmplY3Qub3B0aW9uKSA/ICgwLCBnb3ZfMS52b3RlT3B0aW9uRnJvbUpTT04pKG9iamVjdC5vcHRpb24pIDogMCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnByb3Bvc2FsSWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLnByb3Bvc2FsSWQgPSBtZXNzYWdlLnByb3Bvc2FsSWQpO1xuICAgICAgICBtZXNzYWdlLnZvdGVyICE9PSB1bmRlZmluZWQgJiYgKG9iai52b3RlciA9IG1lc3NhZ2Uudm90ZXIpO1xuICAgICAgICBtZXNzYWdlLm9wdGlvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLm9wdGlvbiA9ICgwLCBnb3ZfMS52b3RlT3B0aW9uVG9KU09OKShtZXNzYWdlLm9wdGlvbikpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ1ZvdGUoKTtcbiAgICAgICAgbWVzc2FnZS5wcm9wb3NhbElkID0gKF9hID0gb2JqZWN0LnByb3Bvc2FsSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiMFwiO1xuICAgICAgICBtZXNzYWdlLnZvdGVyID0gKF9iID0gb2JqZWN0LnZvdGVyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLm9wdGlvbiA9IChfYyA9IG9iamVjdC5vcHRpb24pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDA7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ1ZvdGVSZXNwb25zZSgpIHtcbiAgICByZXR1cm4ge307XG59XG5leHBvcnRzLk1zZ1ZvdGVSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUoXywgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ1ZvdGVSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04oXykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcbiAgICB0b0pTT04oXykge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKF8pIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dWb3RlUmVzcG9uc2UoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlTXNnVm90ZVdlaWdodGVkKCkge1xuICAgIHJldHVybiB7IHByb3Bvc2FsSWQ6IFwiMFwiLCB2b3RlcjogXCJcIiwgb3B0aW9uczogW10gfTtcbn1cbmV4cG9ydHMuTXNnVm90ZVdlaWdodGVkID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UucHJvcG9zYWxJZCAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkudWludDY0KG1lc3NhZ2UucHJvcG9zYWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uudm90ZXIgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnZvdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5vcHRpb25zKSB7XG4gICAgICAgICAgICBnb3ZfMS5XZWlnaHRlZFZvdGVPcHRpb24uZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnVm90ZVdlaWdodGVkKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcm9wb3NhbElkID0gbG9uZ1RvU3RyaW5nKHJlYWRlci51aW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52b3RlciA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9wdGlvbnMucHVzaChnb3ZfMS5XZWlnaHRlZFZvdGVPcHRpb24uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb3Bvc2FsSWQ6IGlzU2V0KG9iamVjdC5wcm9wb3NhbElkKSA/IFN0cmluZyhvYmplY3QucHJvcG9zYWxJZCkgOiBcIjBcIixcbiAgICAgICAgICAgIHZvdGVyOiBpc1NldChvYmplY3Qudm90ZXIpID8gU3RyaW5nKG9iamVjdC52b3RlcikgOiBcIlwiLFxuICAgICAgICAgICAgb3B0aW9uczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3Qub3B0aW9ucylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5vcHRpb25zLm1hcCgoZSkgPT4gZ292XzEuV2VpZ2h0ZWRWb3RlT3B0aW9uLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5wcm9wb3NhbElkICE9PSB1bmRlZmluZWQgJiYgKG9iai5wcm9wb3NhbElkID0gbWVzc2FnZS5wcm9wb3NhbElkKTtcbiAgICAgICAgbWVzc2FnZS52b3RlciAhPT0gdW5kZWZpbmVkICYmIChvYmoudm90ZXIgPSBtZXNzYWdlLnZvdGVyKTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uub3B0aW9ucykge1xuICAgICAgICAgICAgb2JqLm9wdGlvbnMgPSBtZXNzYWdlLm9wdGlvbnMubWFwKChlKSA9PiBlID8gZ292XzEuV2VpZ2h0ZWRWb3RlT3B0aW9uLnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoub3B0aW9ucyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnVm90ZVdlaWdodGVkKCk7XG4gICAgICAgIG1lc3NhZ2UucHJvcG9zYWxJZCA9IChfYSA9IG9iamVjdC5wcm9wb3NhbElkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIjBcIjtcbiAgICAgICAgbWVzc2FnZS52b3RlciA9IChfYiA9IG9iamVjdC52b3RlcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5vcHRpb25zID1cbiAgICAgICAgICAgICgoX2MgPSBvYmplY3Qub3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1hcCgoZSkgPT4gZ292XzEuV2VpZ2h0ZWRWb3RlT3B0aW9uLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ1ZvdGVXZWlnaHRlZFJlc3BvbnNlKCkge1xuICAgIHJldHVybiB7fTtcbn1cbmV4cG9ydHMuTXNnVm90ZVdlaWdodGVkUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKF8sIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dWb3RlV2VpZ2h0ZWRSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04oXykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfSxcbiAgICB0b0pTT04oXykge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKF8pIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dWb3RlV2VpZ2h0ZWRSZXNwb25zZSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dEZXBvc2l0KCkge1xuICAgIHJldHVybiB7IHByb3Bvc2FsSWQ6IFwiMFwiLCBkZXBvc2l0b3I6IFwiXCIsIGFtb3VudDogW10gfTtcbn1cbmV4cG9ydHMuTXNnRGVwb3NpdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnByb3Bvc2FsSWQgIT09IFwiMFwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLnVpbnQ2NChtZXNzYWdlLnByb3Bvc2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmRlcG9zaXRvciAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UuZGVwb3NpdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5hbW91bnQpIHtcbiAgICAgICAgICAgIGNvaW5fMS5Db2luLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ0RlcG9zaXQoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByb3Bvc2FsSWQgPSBsb25nVG9TdHJpbmcocmVhZGVyLnVpbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRlcG9zaXRvciA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFtb3VudC5wdXNoKGNvaW5fMS5Db2luLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9wb3NhbElkOiBpc1NldChvYmplY3QucHJvcG9zYWxJZCkgPyBTdHJpbmcob2JqZWN0LnByb3Bvc2FsSWQpIDogXCIwXCIsXG4gICAgICAgICAgICBkZXBvc2l0b3I6IGlzU2V0KG9iamVjdC5kZXBvc2l0b3IpID8gU3RyaW5nKG9iamVjdC5kZXBvc2l0b3IpIDogXCJcIixcbiAgICAgICAgICAgIGFtb3VudDogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QuYW1vdW50KVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LmFtb3VudC5tYXAoKGUpID0+IGNvaW5fMS5Db2luLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5wcm9wb3NhbElkICE9PSB1bmRlZmluZWQgJiYgKG9iai5wcm9wb3NhbElkID0gbWVzc2FnZS5wcm9wb3NhbElkKTtcbiAgICAgICAgbWVzc2FnZS5kZXBvc2l0b3IgIT09IHVuZGVmaW5lZCAmJiAob2JqLmRlcG9zaXRvciA9IG1lc3NhZ2UuZGVwb3NpdG9yKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYW1vdW50KSB7XG4gICAgICAgICAgICBvYmouYW1vdW50ID0gbWVzc2FnZS5hbW91bnQubWFwKChlKSA9PiAoZSA/IGNvaW5fMS5Db2luLnRvSlNPTihlKSA6IHVuZGVmaW5lZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLmFtb3VudCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnRGVwb3NpdCgpO1xuICAgICAgICBtZXNzYWdlLnByb3Bvc2FsSWQgPSAoX2EgPSBvYmplY3QucHJvcG9zYWxJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCIwXCI7XG4gICAgICAgIG1lc3NhZ2UuZGVwb3NpdG9yID0gKF9iID0gb2JqZWN0LmRlcG9zaXRvcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5hbW91bnQgPSAoKF9jID0gb2JqZWN0LmFtb3VudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1hcCgoZSkgPT4gY29pbl8xLkNvaW4uZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlTXNnRGVwb3NpdFJlc3BvbnNlKCkge1xuICAgIHJldHVybiB7fTtcbn1cbmV4cG9ydHMuTXNnRGVwb3NpdFJlc3BvbnNlID0ge1xuICAgIGVuY29kZShfLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnRGVwb3NpdFJlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihfKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9LFxuICAgIHRvSlNPTihfKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwoXykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ0RlcG9zaXRSZXNwb25zZSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGxvbmdUb1N0cmluZyhsb25nKSB7XG4gICAgcmV0dXJuIGxvbmcudG9TdHJpbmcoKTtcbn1cbmlmIChtaW5pbWFsXzEuZGVmYXVsdC51dGlsLkxvbmcgIT09IGxvbmdfMS5kZWZhdWx0KSB7XG4gICAgbWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nID0gbG9uZ18xLmRlZmF1bHQ7XG4gICAgbWluaW1hbF8xLmRlZmF1bHQuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/gov/v1beta1/tx.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/authz.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/authz.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StakeAuthorization_Validators = exports.StakeAuthorization = exports.authorizationTypeToJSON = exports.authorizationTypeFromJSON = exports.AuthorizationType = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nconst coin_1 = __webpack_require__(/*! ../../../cosmos/base/v1beta1/coin */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/base/v1beta1/coin.js\");\nexports.protobufPackage = \"cosmos.staking.v1beta1\";\n/** AuthorizationType defines the type of staking module authorization type */\nvar AuthorizationType;\n(function (AuthorizationType) {\n    /** AUTHORIZATION_TYPE_UNSPECIFIED - AUTHORIZATION_TYPE_UNSPECIFIED specifies an unknown authorization type */\n    AuthorizationType[AuthorizationType[\"AUTHORIZATION_TYPE_UNSPECIFIED\"] = 0] = \"AUTHORIZATION_TYPE_UNSPECIFIED\";\n    /** AUTHORIZATION_TYPE_DELEGATE - AUTHORIZATION_TYPE_DELEGATE defines an authorization type for Msg/Delegate */\n    AuthorizationType[AuthorizationType[\"AUTHORIZATION_TYPE_DELEGATE\"] = 1] = \"AUTHORIZATION_TYPE_DELEGATE\";\n    /** AUTHORIZATION_TYPE_UNDELEGATE - AUTHORIZATION_TYPE_UNDELEGATE defines an authorization type for Msg/Undelegate */\n    AuthorizationType[AuthorizationType[\"AUTHORIZATION_TYPE_UNDELEGATE\"] = 2] = \"AUTHORIZATION_TYPE_UNDELEGATE\";\n    /** AUTHORIZATION_TYPE_REDELEGATE - AUTHORIZATION_TYPE_REDELEGATE defines an authorization type for Msg/BeginRedelegate */\n    AuthorizationType[AuthorizationType[\"AUTHORIZATION_TYPE_REDELEGATE\"] = 3] = \"AUTHORIZATION_TYPE_REDELEGATE\";\n    AuthorizationType[AuthorizationType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(AuthorizationType = exports.AuthorizationType || (exports.AuthorizationType = {}));\nfunction authorizationTypeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"AUTHORIZATION_TYPE_UNSPECIFIED\":\n            return AuthorizationType.AUTHORIZATION_TYPE_UNSPECIFIED;\n        case 1:\n        case \"AUTHORIZATION_TYPE_DELEGATE\":\n            return AuthorizationType.AUTHORIZATION_TYPE_DELEGATE;\n        case 2:\n        case \"AUTHORIZATION_TYPE_UNDELEGATE\":\n            return AuthorizationType.AUTHORIZATION_TYPE_UNDELEGATE;\n        case 3:\n        case \"AUTHORIZATION_TYPE_REDELEGATE\":\n            return AuthorizationType.AUTHORIZATION_TYPE_REDELEGATE;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return AuthorizationType.UNRECOGNIZED;\n    }\n}\nexports.authorizationTypeFromJSON = authorizationTypeFromJSON;\nfunction authorizationTypeToJSON(object) {\n    switch (object) {\n        case AuthorizationType.AUTHORIZATION_TYPE_UNSPECIFIED:\n            return \"AUTHORIZATION_TYPE_UNSPECIFIED\";\n        case AuthorizationType.AUTHORIZATION_TYPE_DELEGATE:\n            return \"AUTHORIZATION_TYPE_DELEGATE\";\n        case AuthorizationType.AUTHORIZATION_TYPE_UNDELEGATE:\n            return \"AUTHORIZATION_TYPE_UNDELEGATE\";\n        case AuthorizationType.AUTHORIZATION_TYPE_REDELEGATE:\n            return \"AUTHORIZATION_TYPE_REDELEGATE\";\n        default:\n            return \"UNKNOWN\";\n    }\n}\nexports.authorizationTypeToJSON = authorizationTypeToJSON;\nfunction createBaseStakeAuthorization() {\n    return {\n        maxTokens: undefined,\n        allowList: undefined,\n        denyList: undefined,\n        authorizationType: 0,\n    };\n}\nexports.StakeAuthorization = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.maxTokens !== undefined) {\n            coin_1.Coin.encode(message.maxTokens, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.allowList !== undefined) {\n            exports.StakeAuthorization_Validators.encode(message.allowList, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.denyList !== undefined) {\n            exports.StakeAuthorization_Validators.encode(message.denyList, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.authorizationType !== 0) {\n            writer.uint32(32).int32(message.authorizationType);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseStakeAuthorization();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.maxTokens = coin_1.Coin.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.allowList = exports.StakeAuthorization_Validators.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.denyList = exports.StakeAuthorization_Validators.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.authorizationType = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            maxTokens: isSet(object.maxTokens)\n                ? coin_1.Coin.fromJSON(object.maxTokens)\n                : undefined,\n            allowList: isSet(object.allowList)\n                ? exports.StakeAuthorization_Validators.fromJSON(object.allowList)\n                : undefined,\n            denyList: isSet(object.denyList)\n                ? exports.StakeAuthorization_Validators.fromJSON(object.denyList)\n                : undefined,\n            authorizationType: isSet(object.authorizationType)\n                ? authorizationTypeFromJSON(object.authorizationType)\n                : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.maxTokens !== undefined &&\n            (obj.maxTokens = message.maxTokens\n                ? coin_1.Coin.toJSON(message.maxTokens)\n                : undefined);\n        message.allowList !== undefined &&\n            (obj.allowList = message.allowList\n                ? exports.StakeAuthorization_Validators.toJSON(message.allowList)\n                : undefined);\n        message.denyList !== undefined &&\n            (obj.denyList = message.denyList\n                ? exports.StakeAuthorization_Validators.toJSON(message.denyList)\n                : undefined);\n        message.authorizationType !== undefined &&\n            (obj.authorizationType = authorizationTypeToJSON(message.authorizationType));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseStakeAuthorization();\n        message.maxTokens =\n            object.maxTokens !== undefined && object.maxTokens !== null\n                ? coin_1.Coin.fromPartial(object.maxTokens)\n                : undefined;\n        message.allowList =\n            object.allowList !== undefined && object.allowList !== null\n                ? exports.StakeAuthorization_Validators.fromPartial(object.allowList)\n                : undefined;\n        message.denyList =\n            object.denyList !== undefined && object.denyList !== null\n                ? exports.StakeAuthorization_Validators.fromPartial(object.denyList)\n                : undefined;\n        message.authorizationType = (_a = object.authorizationType) !== null && _a !== void 0 ? _a : 0;\n        return message;\n    },\n};\nfunction createBaseStakeAuthorization_Validators() {\n    return { address: [] };\n}\nexports.StakeAuthorization_Validators = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.address) {\n            writer.uint32(10).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseStakeAuthorization_Validators();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.address.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            address: Array.isArray(object === null || object === void 0 ? void 0 : object.address)\n                ? object.address.map((e) => String(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.address) {\n            obj.address = message.address.map((e) => e);\n        }\n        else {\n            obj.address = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseStakeAuthorization_Validators();\n        message.address = ((_a = object.address) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=authz.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3Mvc3Rha2luZy92MWJldGExL2F1dGh6LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUNBQXFDLEdBQUcsMEJBQTBCLEdBQUcsK0JBQStCLEdBQUcsaUNBQWlDLEdBQUcseUJBQXlCLEdBQUcsdUJBQXVCO0FBQzlMO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMsbURBQU07QUFDN0Msa0NBQWtDLG1CQUFPLENBQUMsc0VBQW9CO0FBQzlELGVBQWUsbUJBQU8sQ0FBQyxxSEFBbUM7QUFDMUQsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0RBQW9ELHlCQUF5QixLQUFLO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvcHJvdG8tdHlwZXMvY29zbW9zL3N0YWtpbmcvdjFiZXRhMS9hdXRoei5qcz81NGRjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdGFrZUF1dGhvcml6YXRpb25fVmFsaWRhdG9ycyA9IGV4cG9ydHMuU3Rha2VBdXRob3JpemF0aW9uID0gZXhwb3J0cy5hdXRob3JpemF0aW9uVHlwZVRvSlNPTiA9IGV4cG9ydHMuYXV0aG9yaXphdGlvblR5cGVGcm9tSlNPTiA9IGV4cG9ydHMuQXV0aG9yaXphdGlvblR5cGUgPSBleHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlICovXG5jb25zdCBsb25nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvbmdcIikpO1xuY29uc3QgbWluaW1hbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwcm90b2J1ZmpzL21pbmltYWxcIikpO1xuY29uc3QgY29pbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2Nvc21vcy9iYXNlL3YxYmV0YTEvY29pblwiKTtcbmV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gXCJjb3Ntb3Muc3Rha2luZy52MWJldGExXCI7XG4vKiogQXV0aG9yaXphdGlvblR5cGUgZGVmaW5lcyB0aGUgdHlwZSBvZiBzdGFraW5nIG1vZHVsZSBhdXRob3JpemF0aW9uIHR5cGUgKi9cbnZhciBBdXRob3JpemF0aW9uVHlwZTtcbihmdW5jdGlvbiAoQXV0aG9yaXphdGlvblR5cGUpIHtcbiAgICAvKiogQVVUSE9SSVpBVElPTl9UWVBFX1VOU1BFQ0lGSUVEIC0gQVVUSE9SSVpBVElPTl9UWVBFX1VOU1BFQ0lGSUVEIHNwZWNpZmllcyBhbiB1bmtub3duIGF1dGhvcml6YXRpb24gdHlwZSAqL1xuICAgIEF1dGhvcml6YXRpb25UeXBlW0F1dGhvcml6YXRpb25UeXBlW1wiQVVUSE9SSVpBVElPTl9UWVBFX1VOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIkFVVEhPUklaQVRJT05fVFlQRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKiBBVVRIT1JJWkFUSU9OX1RZUEVfREVMRUdBVEUgLSBBVVRIT1JJWkFUSU9OX1RZUEVfREVMRUdBVEUgZGVmaW5lcyBhbiBhdXRob3JpemF0aW9uIHR5cGUgZm9yIE1zZy9EZWxlZ2F0ZSAqL1xuICAgIEF1dGhvcml6YXRpb25UeXBlW0F1dGhvcml6YXRpb25UeXBlW1wiQVVUSE9SSVpBVElPTl9UWVBFX0RFTEVHQVRFXCJdID0gMV0gPSBcIkFVVEhPUklaQVRJT05fVFlQRV9ERUxFR0FURVwiO1xuICAgIC8qKiBBVVRIT1JJWkFUSU9OX1RZUEVfVU5ERUxFR0FURSAtIEFVVEhPUklaQVRJT05fVFlQRV9VTkRFTEVHQVRFIGRlZmluZXMgYW4gYXV0aG9yaXphdGlvbiB0eXBlIGZvciBNc2cvVW5kZWxlZ2F0ZSAqL1xuICAgIEF1dGhvcml6YXRpb25UeXBlW0F1dGhvcml6YXRpb25UeXBlW1wiQVVUSE9SSVpBVElPTl9UWVBFX1VOREVMRUdBVEVcIl0gPSAyXSA9IFwiQVVUSE9SSVpBVElPTl9UWVBFX1VOREVMRUdBVEVcIjtcbiAgICAvKiogQVVUSE9SSVpBVElPTl9UWVBFX1JFREVMRUdBVEUgLSBBVVRIT1JJWkFUSU9OX1RZUEVfUkVERUxFR0FURSBkZWZpbmVzIGFuIGF1dGhvcml6YXRpb24gdHlwZSBmb3IgTXNnL0JlZ2luUmVkZWxlZ2F0ZSAqL1xuICAgIEF1dGhvcml6YXRpb25UeXBlW0F1dGhvcml6YXRpb25UeXBlW1wiQVVUSE9SSVpBVElPTl9UWVBFX1JFREVMRUdBVEVcIl0gPSAzXSA9IFwiQVVUSE9SSVpBVElPTl9UWVBFX1JFREVMRUdBVEVcIjtcbiAgICBBdXRob3JpemF0aW9uVHlwZVtBdXRob3JpemF0aW9uVHlwZVtcIlVOUkVDT0dOSVpFRFwiXSA9IC0xXSA9IFwiVU5SRUNPR05JWkVEXCI7XG59KShBdXRob3JpemF0aW9uVHlwZSA9IGV4cG9ydHMuQXV0aG9yaXphdGlvblR5cGUgfHwgKGV4cG9ydHMuQXV0aG9yaXphdGlvblR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gYXV0aG9yaXphdGlvblR5cGVGcm9tSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgXCJBVVRIT1JJWkFUSU9OX1RZUEVfVU5TUEVDSUZJRURcIjpcbiAgICAgICAgICAgIHJldHVybiBBdXRob3JpemF0aW9uVHlwZS5BVVRIT1JJWkFUSU9OX1RZUEVfVU5TUEVDSUZJRUQ7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSBcIkFVVEhPUklaQVRJT05fVFlQRV9ERUxFR0FURVwiOlxuICAgICAgICAgICAgcmV0dXJuIEF1dGhvcml6YXRpb25UeXBlLkFVVEhPUklaQVRJT05fVFlQRV9ERUxFR0FURTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIFwiQVVUSE9SSVpBVElPTl9UWVBFX1VOREVMRUdBVEVcIjpcbiAgICAgICAgICAgIHJldHVybiBBdXRob3JpemF0aW9uVHlwZS5BVVRIT1JJWkFUSU9OX1RZUEVfVU5ERUxFR0FURTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBjYXNlIFwiQVVUSE9SSVpBVElPTl9UWVBFX1JFREVMRUdBVEVcIjpcbiAgICAgICAgICAgIHJldHVybiBBdXRob3JpemF0aW9uVHlwZS5BVVRIT1JJWkFUSU9OX1RZUEVfUkVERUxFR0FURTtcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgY2FzZSBcIlVOUkVDT0dOSVpFRFwiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIEF1dGhvcml6YXRpb25UeXBlLlVOUkVDT0dOSVpFRDtcbiAgICB9XG59XG5leHBvcnRzLmF1dGhvcml6YXRpb25UeXBlRnJvbUpTT04gPSBhdXRob3JpemF0aW9uVHlwZUZyb21KU09OO1xuZnVuY3Rpb24gYXV0aG9yaXphdGlvblR5cGVUb0pTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSBBdXRob3JpemF0aW9uVHlwZS5BVVRIT1JJWkFUSU9OX1RZUEVfVU5TUEVDSUZJRUQ6XG4gICAgICAgICAgICByZXR1cm4gXCJBVVRIT1JJWkFUSU9OX1RZUEVfVU5TUEVDSUZJRURcIjtcbiAgICAgICAgY2FzZSBBdXRob3JpemF0aW9uVHlwZS5BVVRIT1JJWkFUSU9OX1RZUEVfREVMRUdBVEU6XG4gICAgICAgICAgICByZXR1cm4gXCJBVVRIT1JJWkFUSU9OX1RZUEVfREVMRUdBVEVcIjtcbiAgICAgICAgY2FzZSBBdXRob3JpemF0aW9uVHlwZS5BVVRIT1JJWkFUSU9OX1RZUEVfVU5ERUxFR0FURTpcbiAgICAgICAgICAgIHJldHVybiBcIkFVVEhPUklaQVRJT05fVFlQRV9VTkRFTEVHQVRFXCI7XG4gICAgICAgIGNhc2UgQXV0aG9yaXphdGlvblR5cGUuQVVUSE9SSVpBVElPTl9UWVBFX1JFREVMRUdBVEU6XG4gICAgICAgICAgICByZXR1cm4gXCJBVVRIT1JJWkFUSU9OX1RZUEVfUkVERUxFR0FURVwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiVU5LTk9XTlwiO1xuICAgIH1cbn1cbmV4cG9ydHMuYXV0aG9yaXphdGlvblR5cGVUb0pTT04gPSBhdXRob3JpemF0aW9uVHlwZVRvSlNPTjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTdGFrZUF1dGhvcml6YXRpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWF4VG9rZW5zOiB1bmRlZmluZWQsXG4gICAgICAgIGFsbG93TGlzdDogdW5kZWZpbmVkLFxuICAgICAgICBkZW55TGlzdDogdW5kZWZpbmVkLFxuICAgICAgICBhdXRob3JpemF0aW9uVHlwZTogMCxcbiAgICB9O1xufVxuZXhwb3J0cy5TdGFrZUF1dGhvcml6YXRpb24gPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5tYXhUb2tlbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29pbl8xLkNvaW4uZW5jb2RlKG1lc3NhZ2UubWF4VG9rZW5zLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmFsbG93TGlzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLlN0YWtlQXV0aG9yaXphdGlvbl9WYWxpZGF0b3JzLmVuY29kZShtZXNzYWdlLmFsbG93TGlzdCwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5kZW55TGlzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLlN0YWtlQXV0aG9yaXphdGlvbl9WYWxpZGF0b3JzLmVuY29kZShtZXNzYWdlLmRlbnlMaXN0LCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmF1dGhvcml6YXRpb25UeXBlICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDMyKS5pbnQzMihtZXNzYWdlLmF1dGhvcml6YXRpb25UeXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTdGFrZUF1dGhvcml6YXRpb24oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1heFRva2VucyA9IGNvaW5fMS5Db2luLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hbGxvd0xpc3QgPSBleHBvcnRzLlN0YWtlQXV0aG9yaXphdGlvbl9WYWxpZGF0b3JzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kZW55TGlzdCA9IGV4cG9ydHMuU3Rha2VBdXRob3JpemF0aW9uX1ZhbGlkYXRvcnMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmF1dGhvcml6YXRpb25UeXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1heFRva2VuczogaXNTZXQob2JqZWN0Lm1heFRva2VucylcbiAgICAgICAgICAgICAgICA/IGNvaW5fMS5Db2luLmZyb21KU09OKG9iamVjdC5tYXhUb2tlbnMpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhbGxvd0xpc3Q6IGlzU2V0KG9iamVjdC5hbGxvd0xpc3QpXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlN0YWtlQXV0aG9yaXphdGlvbl9WYWxpZGF0b3JzLmZyb21KU09OKG9iamVjdC5hbGxvd0xpc3QpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkZW55TGlzdDogaXNTZXQob2JqZWN0LmRlbnlMaXN0KVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5TdGFrZUF1dGhvcml6YXRpb25fVmFsaWRhdG9ycy5mcm9tSlNPTihvYmplY3QuZGVueUxpc3QpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uVHlwZTogaXNTZXQob2JqZWN0LmF1dGhvcml6YXRpb25UeXBlKVxuICAgICAgICAgICAgICAgID8gYXV0aG9yaXphdGlvblR5cGVGcm9tSlNPTihvYmplY3QuYXV0aG9yaXphdGlvblR5cGUpXG4gICAgICAgICAgICAgICAgOiAwLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UubWF4VG9rZW5zICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoubWF4VG9rZW5zID0gbWVzc2FnZS5tYXhUb2tlbnNcbiAgICAgICAgICAgICAgICA/IGNvaW5fMS5Db2luLnRvSlNPTihtZXNzYWdlLm1heFRva2VucylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuYWxsb3dMaXN0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYWxsb3dMaXN0ID0gbWVzc2FnZS5hbGxvd0xpc3RcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuU3Rha2VBdXRob3JpemF0aW9uX1ZhbGlkYXRvcnMudG9KU09OKG1lc3NhZ2UuYWxsb3dMaXN0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5kZW55TGlzdCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmRlbnlMaXN0ID0gbWVzc2FnZS5kZW55TGlzdFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5TdGFrZUF1dGhvcml6YXRpb25fVmFsaWRhdG9ycy50b0pTT04obWVzc2FnZS5kZW55TGlzdClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuYXV0aG9yaXphdGlvblR5cGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5hdXRob3JpemF0aW9uVHlwZSA9IGF1dGhvcml6YXRpb25UeXBlVG9KU09OKG1lc3NhZ2UuYXV0aG9yaXphdGlvblR5cGUpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU3Rha2VBdXRob3JpemF0aW9uKCk7XG4gICAgICAgIG1lc3NhZ2UubWF4VG9rZW5zID1cbiAgICAgICAgICAgIG9iamVjdC5tYXhUb2tlbnMgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QubWF4VG9rZW5zICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBjb2luXzEuQ29pbi5mcm9tUGFydGlhbChvYmplY3QubWF4VG9rZW5zKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmFsbG93TGlzdCA9XG4gICAgICAgICAgICBvYmplY3QuYWxsb3dMaXN0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmFsbG93TGlzdCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5TdGFrZUF1dGhvcml6YXRpb25fVmFsaWRhdG9ycy5mcm9tUGFydGlhbChvYmplY3QuYWxsb3dMaXN0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmRlbnlMaXN0ID1cbiAgICAgICAgICAgIG9iamVjdC5kZW55TGlzdCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5kZW55TGlzdCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5TdGFrZUF1dGhvcml6YXRpb25fVmFsaWRhdG9ycy5mcm9tUGFydGlhbChvYmplY3QuZGVueUxpc3QpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuYXV0aG9yaXphdGlvblR5cGUgPSAoX2EgPSBvYmplY3QuYXV0aG9yaXphdGlvblR5cGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVN0YWtlQXV0aG9yaXphdGlvbl9WYWxpZGF0b3JzKCkge1xuICAgIHJldHVybiB7IGFkZHJlc3M6IFtdIH07XG59XG5leHBvcnRzLlN0YWtlQXV0aG9yaXphdGlvbl9WYWxpZGF0b3JzID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuYWRkcmVzcykge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVN0YWtlQXV0aG9yaXphdGlvbl9WYWxpZGF0b3JzKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRyZXNzLnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QuYWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5hZGRyZXNzLm1hcCgoZSkgPT4gU3RyaW5nKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYWRkcmVzcykge1xuICAgICAgICAgICAgb2JqLmFkZHJlc3MgPSBtZXNzYWdlLmFkZHJlc3MubWFwKChlKSA9PiBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5hZGRyZXNzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU3Rha2VBdXRob3JpemF0aW9uX1ZhbGlkYXRvcnMoKTtcbiAgICAgICAgbWVzc2FnZS5hZGRyZXNzID0gKChfYSA9IG9iamVjdC5hZGRyZXNzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBlKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuaWYgKG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyAhPT0gbG9uZ18xLmRlZmF1bHQpIHtcbiAgICBtaW5pbWFsXzEuZGVmYXVsdC51dGlsLkxvbmcgPSBsb25nXzEuZGVmYXVsdDtcbiAgICBtaW5pbWFsXzEuZGVmYXVsdC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRoei5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/authz.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/staking.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/staking.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Pool = exports.RedelegationResponse = exports.RedelegationEntryResponse = exports.DelegationResponse = exports.Params = exports.Redelegation = exports.RedelegationEntry = exports.UnbondingDelegationEntry = exports.UnbondingDelegation = exports.Delegation = exports.DVVTriplets = exports.DVVTriplet = exports.DVPairs = exports.DVPair = exports.ValAddresses = exports.Validator = exports.Description = exports.Commission = exports.CommissionRates = exports.HistoricalInfo = exports.bondStatusToJSON = exports.bondStatusFromJSON = exports.BondStatus = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nconst timestamp_1 = __webpack_require__(/*! ../../../google/protobuf/timestamp */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/timestamp.js\");\nconst types_1 = __webpack_require__(/*! ../../../tendermint/types/types */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/tendermint/types/types.js\");\nconst any_1 = __webpack_require__(/*! ../../../google/protobuf/any */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/any.js\");\nconst duration_1 = __webpack_require__(/*! ../../../google/protobuf/duration */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/duration.js\");\nconst coin_1 = __webpack_require__(/*! ../../../cosmos/base/v1beta1/coin */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/base/v1beta1/coin.js\");\nexports.protobufPackage = \"cosmos.staking.v1beta1\";\n/** BondStatus is the status of a validator. */\nvar BondStatus;\n(function (BondStatus) {\n    /** BOND_STATUS_UNSPECIFIED - UNSPECIFIED defines an invalid validator status. */\n    BondStatus[BondStatus[\"BOND_STATUS_UNSPECIFIED\"] = 0] = \"BOND_STATUS_UNSPECIFIED\";\n    /** BOND_STATUS_UNBONDED - UNBONDED defines a validator that is not bonded. */\n    BondStatus[BondStatus[\"BOND_STATUS_UNBONDED\"] = 1] = \"BOND_STATUS_UNBONDED\";\n    /** BOND_STATUS_UNBONDING - UNBONDING defines a validator that is unbonding. */\n    BondStatus[BondStatus[\"BOND_STATUS_UNBONDING\"] = 2] = \"BOND_STATUS_UNBONDING\";\n    /** BOND_STATUS_BONDED - BONDED defines a validator that is bonded. */\n    BondStatus[BondStatus[\"BOND_STATUS_BONDED\"] = 3] = \"BOND_STATUS_BONDED\";\n    BondStatus[BondStatus[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(BondStatus = exports.BondStatus || (exports.BondStatus = {}));\nfunction bondStatusFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"BOND_STATUS_UNSPECIFIED\":\n            return BondStatus.BOND_STATUS_UNSPECIFIED;\n        case 1:\n        case \"BOND_STATUS_UNBONDED\":\n            return BondStatus.BOND_STATUS_UNBONDED;\n        case 2:\n        case \"BOND_STATUS_UNBONDING\":\n            return BondStatus.BOND_STATUS_UNBONDING;\n        case 3:\n        case \"BOND_STATUS_BONDED\":\n            return BondStatus.BOND_STATUS_BONDED;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return BondStatus.UNRECOGNIZED;\n    }\n}\nexports.bondStatusFromJSON = bondStatusFromJSON;\nfunction bondStatusToJSON(object) {\n    switch (object) {\n        case BondStatus.BOND_STATUS_UNSPECIFIED:\n            return \"BOND_STATUS_UNSPECIFIED\";\n        case BondStatus.BOND_STATUS_UNBONDED:\n            return \"BOND_STATUS_UNBONDED\";\n        case BondStatus.BOND_STATUS_UNBONDING:\n            return \"BOND_STATUS_UNBONDING\";\n        case BondStatus.BOND_STATUS_BONDED:\n            return \"BOND_STATUS_BONDED\";\n        default:\n            return \"UNKNOWN\";\n    }\n}\nexports.bondStatusToJSON = bondStatusToJSON;\nfunction createBaseHistoricalInfo() {\n    return { header: undefined, valset: [] };\n}\nexports.HistoricalInfo = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.header !== undefined) {\n            types_1.Header.encode(message.header, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.valset) {\n            exports.Validator.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseHistoricalInfo();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.header = types_1.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.valset.push(exports.Validator.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            header: isSet(object.header) ? types_1.Header.fromJSON(object.header) : undefined,\n            valset: Array.isArray(object === null || object === void 0 ? void 0 : object.valset)\n                ? object.valset.map((e) => exports.Validator.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.header !== undefined &&\n            (obj.header = message.header ? types_1.Header.toJSON(message.header) : undefined);\n        if (message.valset) {\n            obj.valset = message.valset.map((e) => e ? exports.Validator.toJSON(e) : undefined);\n        }\n        else {\n            obj.valset = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseHistoricalInfo();\n        message.header =\n            object.header !== undefined && object.header !== null\n                ? types_1.Header.fromPartial(object.header)\n                : undefined;\n        message.valset = ((_a = object.valset) === null || _a === void 0 ? void 0 : _a.map((e) => exports.Validator.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseCommissionRates() {\n    return { rate: \"\", maxRate: \"\", maxChangeRate: \"\" };\n}\nexports.CommissionRates = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.rate !== \"\") {\n            writer.uint32(10).string(message.rate);\n        }\n        if (message.maxRate !== \"\") {\n            writer.uint32(18).string(message.maxRate);\n        }\n        if (message.maxChangeRate !== \"\") {\n            writer.uint32(26).string(message.maxChangeRate);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCommissionRates();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.rate = reader.string();\n                    break;\n                case 2:\n                    message.maxRate = reader.string();\n                    break;\n                case 3:\n                    message.maxChangeRate = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            rate: isSet(object.rate) ? String(object.rate) : \"\",\n            maxRate: isSet(object.maxRate) ? String(object.maxRate) : \"\",\n            maxChangeRate: isSet(object.maxChangeRate)\n                ? String(object.maxChangeRate)\n                : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.rate !== undefined && (obj.rate = message.rate);\n        message.maxRate !== undefined && (obj.maxRate = message.maxRate);\n        message.maxChangeRate !== undefined &&\n            (obj.maxChangeRate = message.maxChangeRate);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseCommissionRates();\n        message.rate = (_a = object.rate) !== null && _a !== void 0 ? _a : \"\";\n        message.maxRate = (_b = object.maxRate) !== null && _b !== void 0 ? _b : \"\";\n        message.maxChangeRate = (_c = object.maxChangeRate) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBaseCommission() {\n    return { commissionRates: undefined, updateTime: undefined };\n}\nexports.Commission = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.commissionRates !== undefined) {\n            exports.CommissionRates.encode(message.commissionRates, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.updateTime !== undefined) {\n            timestamp_1.Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCommission();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.commissionRates = exports.CommissionRates.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.updateTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            commissionRates: isSet(object.commissionRates)\n                ? exports.CommissionRates.fromJSON(object.commissionRates)\n                : undefined,\n            updateTime: isSet(object.updateTime)\n                ? fromJsonTimestamp(object.updateTime)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.commissionRates !== undefined &&\n            (obj.commissionRates = message.commissionRates\n                ? exports.CommissionRates.toJSON(message.commissionRates)\n                : undefined);\n        message.updateTime !== undefined &&\n            (obj.updateTime = message.updateTime.toISOString());\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseCommission();\n        message.commissionRates =\n            object.commissionRates !== undefined && object.commissionRates !== null\n                ? exports.CommissionRates.fromPartial(object.commissionRates)\n                : undefined;\n        message.updateTime = (_a = object.updateTime) !== null && _a !== void 0 ? _a : undefined;\n        return message;\n    },\n};\nfunction createBaseDescription() {\n    return {\n        moniker: \"\",\n        identity: \"\",\n        website: \"\",\n        securityContact: \"\",\n        details: \"\",\n    };\n}\nexports.Description = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.moniker !== \"\") {\n            writer.uint32(10).string(message.moniker);\n        }\n        if (message.identity !== \"\") {\n            writer.uint32(18).string(message.identity);\n        }\n        if (message.website !== \"\") {\n            writer.uint32(26).string(message.website);\n        }\n        if (message.securityContact !== \"\") {\n            writer.uint32(34).string(message.securityContact);\n        }\n        if (message.details !== \"\") {\n            writer.uint32(42).string(message.details);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDescription();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.moniker = reader.string();\n                    break;\n                case 2:\n                    message.identity = reader.string();\n                    break;\n                case 3:\n                    message.website = reader.string();\n                    break;\n                case 4:\n                    message.securityContact = reader.string();\n                    break;\n                case 5:\n                    message.details = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            moniker: isSet(object.moniker) ? String(object.moniker) : \"\",\n            identity: isSet(object.identity) ? String(object.identity) : \"\",\n            website: isSet(object.website) ? String(object.website) : \"\",\n            securityContact: isSet(object.securityContact)\n                ? String(object.securityContact)\n                : \"\",\n            details: isSet(object.details) ? String(object.details) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.moniker !== undefined && (obj.moniker = message.moniker);\n        message.identity !== undefined && (obj.identity = message.identity);\n        message.website !== undefined && (obj.website = message.website);\n        message.securityContact !== undefined &&\n            (obj.securityContact = message.securityContact);\n        message.details !== undefined && (obj.details = message.details);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e;\n        const message = createBaseDescription();\n        message.moniker = (_a = object.moniker) !== null && _a !== void 0 ? _a : \"\";\n        message.identity = (_b = object.identity) !== null && _b !== void 0 ? _b : \"\";\n        message.website = (_c = object.website) !== null && _c !== void 0 ? _c : \"\";\n        message.securityContact = (_d = object.securityContact) !== null && _d !== void 0 ? _d : \"\";\n        message.details = (_e = object.details) !== null && _e !== void 0 ? _e : \"\";\n        return message;\n    },\n};\nfunction createBaseValidator() {\n    return {\n        operatorAddress: \"\",\n        consensusPubkey: undefined,\n        jailed: false,\n        status: 0,\n        tokens: \"\",\n        delegatorShares: \"\",\n        description: undefined,\n        unbondingHeight: \"0\",\n        unbondingTime: undefined,\n        commission: undefined,\n        minSelfDelegation: \"\",\n    };\n}\nexports.Validator = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.operatorAddress !== \"\") {\n            writer.uint32(10).string(message.operatorAddress);\n        }\n        if (message.consensusPubkey !== undefined) {\n            any_1.Any.encode(message.consensusPubkey, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.jailed === true) {\n            writer.uint32(24).bool(message.jailed);\n        }\n        if (message.status !== 0) {\n            writer.uint32(32).int32(message.status);\n        }\n        if (message.tokens !== \"\") {\n            writer.uint32(42).string(message.tokens);\n        }\n        if (message.delegatorShares !== \"\") {\n            writer.uint32(50).string(message.delegatorShares);\n        }\n        if (message.description !== undefined) {\n            exports.Description.encode(message.description, writer.uint32(58).fork()).ldelim();\n        }\n        if (message.unbondingHeight !== \"0\") {\n            writer.uint32(64).int64(message.unbondingHeight);\n        }\n        if (message.unbondingTime !== undefined) {\n            timestamp_1.Timestamp.encode(toTimestamp(message.unbondingTime), writer.uint32(74).fork()).ldelim();\n        }\n        if (message.commission !== undefined) {\n            exports.Commission.encode(message.commission, writer.uint32(82).fork()).ldelim();\n        }\n        if (message.minSelfDelegation !== \"\") {\n            writer.uint32(90).string(message.minSelfDelegation);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseValidator();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.operatorAddress = reader.string();\n                    break;\n                case 2:\n                    message.consensusPubkey = any_1.Any.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.jailed = reader.bool();\n                    break;\n                case 4:\n                    message.status = reader.int32();\n                    break;\n                case 5:\n                    message.tokens = reader.string();\n                    break;\n                case 6:\n                    message.delegatorShares = reader.string();\n                    break;\n                case 7:\n                    message.description = exports.Description.decode(reader, reader.uint32());\n                    break;\n                case 8:\n                    message.unbondingHeight = longToString(reader.int64());\n                    break;\n                case 9:\n                    message.unbondingTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n                    break;\n                case 10:\n                    message.commission = exports.Commission.decode(reader, reader.uint32());\n                    break;\n                case 11:\n                    message.minSelfDelegation = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            operatorAddress: isSet(object.operatorAddress)\n                ? String(object.operatorAddress)\n                : \"\",\n            consensusPubkey: isSet(object.consensusPubkey)\n                ? any_1.Any.fromJSON(object.consensusPubkey)\n                : undefined,\n            jailed: isSet(object.jailed) ? Boolean(object.jailed) : false,\n            status: isSet(object.status) ? bondStatusFromJSON(object.status) : 0,\n            tokens: isSet(object.tokens) ? String(object.tokens) : \"\",\n            delegatorShares: isSet(object.delegatorShares)\n                ? String(object.delegatorShares)\n                : \"\",\n            description: isSet(object.description)\n                ? exports.Description.fromJSON(object.description)\n                : undefined,\n            unbondingHeight: isSet(object.unbondingHeight)\n                ? String(object.unbondingHeight)\n                : \"0\",\n            unbondingTime: isSet(object.unbondingTime)\n                ? fromJsonTimestamp(object.unbondingTime)\n                : undefined,\n            commission: isSet(object.commission)\n                ? exports.Commission.fromJSON(object.commission)\n                : undefined,\n            minSelfDelegation: isSet(object.minSelfDelegation)\n                ? String(object.minSelfDelegation)\n                : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.operatorAddress !== undefined &&\n            (obj.operatorAddress = message.operatorAddress);\n        message.consensusPubkey !== undefined &&\n            (obj.consensusPubkey = message.consensusPubkey\n                ? any_1.Any.toJSON(message.consensusPubkey)\n                : undefined);\n        message.jailed !== undefined && (obj.jailed = message.jailed);\n        message.status !== undefined &&\n            (obj.status = bondStatusToJSON(message.status));\n        message.tokens !== undefined && (obj.tokens = message.tokens);\n        message.delegatorShares !== undefined &&\n            (obj.delegatorShares = message.delegatorShares);\n        message.description !== undefined &&\n            (obj.description = message.description\n                ? exports.Description.toJSON(message.description)\n                : undefined);\n        message.unbondingHeight !== undefined &&\n            (obj.unbondingHeight = message.unbondingHeight);\n        message.unbondingTime !== undefined &&\n            (obj.unbondingTime = message.unbondingTime.toISOString());\n        message.commission !== undefined &&\n            (obj.commission = message.commission\n                ? exports.Commission.toJSON(message.commission)\n                : undefined);\n        message.minSelfDelegation !== undefined &&\n            (obj.minSelfDelegation = message.minSelfDelegation);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        const message = createBaseValidator();\n        message.operatorAddress = (_a = object.operatorAddress) !== null && _a !== void 0 ? _a : \"\";\n        message.consensusPubkey =\n            object.consensusPubkey !== undefined && object.consensusPubkey !== null\n                ? any_1.Any.fromPartial(object.consensusPubkey)\n                : undefined;\n        message.jailed = (_b = object.jailed) !== null && _b !== void 0 ? _b : false;\n        message.status = (_c = object.status) !== null && _c !== void 0 ? _c : 0;\n        message.tokens = (_d = object.tokens) !== null && _d !== void 0 ? _d : \"\";\n        message.delegatorShares = (_e = object.delegatorShares) !== null && _e !== void 0 ? _e : \"\";\n        message.description =\n            object.description !== undefined && object.description !== null\n                ? exports.Description.fromPartial(object.description)\n                : undefined;\n        message.unbondingHeight = (_f = object.unbondingHeight) !== null && _f !== void 0 ? _f : \"0\";\n        message.unbondingTime = (_g = object.unbondingTime) !== null && _g !== void 0 ? _g : undefined;\n        message.commission =\n            object.commission !== undefined && object.commission !== null\n                ? exports.Commission.fromPartial(object.commission)\n                : undefined;\n        message.minSelfDelegation = (_h = object.minSelfDelegation) !== null && _h !== void 0 ? _h : \"\";\n        return message;\n    },\n};\nfunction createBaseValAddresses() {\n    return { addresses: [] };\n}\nexports.ValAddresses = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.addresses) {\n            writer.uint32(10).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseValAddresses();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.addresses.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            addresses: Array.isArray(object === null || object === void 0 ? void 0 : object.addresses)\n                ? object.addresses.map((e) => String(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.addresses) {\n            obj.addresses = message.addresses.map((e) => e);\n        }\n        else {\n            obj.addresses = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseValAddresses();\n        message.addresses = ((_a = object.addresses) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBaseDVPair() {\n    return { delegatorAddress: \"\", validatorAddress: \"\" };\n}\nexports.DVPair = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.delegatorAddress !== \"\") {\n            writer.uint32(10).string(message.delegatorAddress);\n        }\n        if (message.validatorAddress !== \"\") {\n            writer.uint32(18).string(message.validatorAddress);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDVPair();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.delegatorAddress = reader.string();\n                    break;\n                case 2:\n                    message.validatorAddress = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            delegatorAddress: isSet(object.delegatorAddress)\n                ? String(object.delegatorAddress)\n                : \"\",\n            validatorAddress: isSet(object.validatorAddress)\n                ? String(object.validatorAddress)\n                : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.delegatorAddress !== undefined &&\n            (obj.delegatorAddress = message.delegatorAddress);\n        message.validatorAddress !== undefined &&\n            (obj.validatorAddress = message.validatorAddress);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseDVPair();\n        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : \"\";\n        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseDVPairs() {\n    return { pairs: [] };\n}\nexports.DVPairs = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.pairs) {\n            exports.DVPair.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDVPairs();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.pairs.push(exports.DVPair.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            pairs: Array.isArray(object === null || object === void 0 ? void 0 : object.pairs)\n                ? object.pairs.map((e) => exports.DVPair.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.pairs) {\n            obj.pairs = message.pairs.map((e) => (e ? exports.DVPair.toJSON(e) : undefined));\n        }\n        else {\n            obj.pairs = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseDVPairs();\n        message.pairs = ((_a = object.pairs) === null || _a === void 0 ? void 0 : _a.map((e) => exports.DVPair.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseDVVTriplet() {\n    return {\n        delegatorAddress: \"\",\n        validatorSrcAddress: \"\",\n        validatorDstAddress: \"\",\n    };\n}\nexports.DVVTriplet = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.delegatorAddress !== \"\") {\n            writer.uint32(10).string(message.delegatorAddress);\n        }\n        if (message.validatorSrcAddress !== \"\") {\n            writer.uint32(18).string(message.validatorSrcAddress);\n        }\n        if (message.validatorDstAddress !== \"\") {\n            writer.uint32(26).string(message.validatorDstAddress);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDVVTriplet();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.delegatorAddress = reader.string();\n                    break;\n                case 2:\n                    message.validatorSrcAddress = reader.string();\n                    break;\n                case 3:\n                    message.validatorDstAddress = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            delegatorAddress: isSet(object.delegatorAddress)\n                ? String(object.delegatorAddress)\n                : \"\",\n            validatorSrcAddress: isSet(object.validatorSrcAddress)\n                ? String(object.validatorSrcAddress)\n                : \"\",\n            validatorDstAddress: isSet(object.validatorDstAddress)\n                ? String(object.validatorDstAddress)\n                : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.delegatorAddress !== undefined &&\n            (obj.delegatorAddress = message.delegatorAddress);\n        message.validatorSrcAddress !== undefined &&\n            (obj.validatorSrcAddress = message.validatorSrcAddress);\n        message.validatorDstAddress !== undefined &&\n            (obj.validatorDstAddress = message.validatorDstAddress);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseDVVTriplet();\n        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : \"\";\n        message.validatorSrcAddress = (_b = object.validatorSrcAddress) !== null && _b !== void 0 ? _b : \"\";\n        message.validatorDstAddress = (_c = object.validatorDstAddress) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBaseDVVTriplets() {\n    return { triplets: [] };\n}\nexports.DVVTriplets = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.triplets) {\n            exports.DVVTriplet.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDVVTriplets();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.triplets.push(exports.DVVTriplet.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            triplets: Array.isArray(object === null || object === void 0 ? void 0 : object.triplets)\n                ? object.triplets.map((e) => exports.DVVTriplet.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.triplets) {\n            obj.triplets = message.triplets.map((e) => e ? exports.DVVTriplet.toJSON(e) : undefined);\n        }\n        else {\n            obj.triplets = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseDVVTriplets();\n        message.triplets =\n            ((_a = object.triplets) === null || _a === void 0 ? void 0 : _a.map((e) => exports.DVVTriplet.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseDelegation() {\n    return { delegatorAddress: \"\", validatorAddress: \"\", shares: \"\" };\n}\nexports.Delegation = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.delegatorAddress !== \"\") {\n            writer.uint32(10).string(message.delegatorAddress);\n        }\n        if (message.validatorAddress !== \"\") {\n            writer.uint32(18).string(message.validatorAddress);\n        }\n        if (message.shares !== \"\") {\n            writer.uint32(26).string(message.shares);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDelegation();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.delegatorAddress = reader.string();\n                    break;\n                case 2:\n                    message.validatorAddress = reader.string();\n                    break;\n                case 3:\n                    message.shares = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            delegatorAddress: isSet(object.delegatorAddress)\n                ? String(object.delegatorAddress)\n                : \"\",\n            validatorAddress: isSet(object.validatorAddress)\n                ? String(object.validatorAddress)\n                : \"\",\n            shares: isSet(object.shares) ? String(object.shares) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.delegatorAddress !== undefined &&\n            (obj.delegatorAddress = message.delegatorAddress);\n        message.validatorAddress !== undefined &&\n            (obj.validatorAddress = message.validatorAddress);\n        message.shares !== undefined && (obj.shares = message.shares);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseDelegation();\n        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : \"\";\n        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : \"\";\n        message.shares = (_c = object.shares) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBaseUnbondingDelegation() {\n    return { delegatorAddress: \"\", validatorAddress: \"\", entries: [] };\n}\nexports.UnbondingDelegation = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.delegatorAddress !== \"\") {\n            writer.uint32(10).string(message.delegatorAddress);\n        }\n        if (message.validatorAddress !== \"\") {\n            writer.uint32(18).string(message.validatorAddress);\n        }\n        for (const v of message.entries) {\n            exports.UnbondingDelegationEntry.encode(v, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUnbondingDelegation();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.delegatorAddress = reader.string();\n                    break;\n                case 2:\n                    message.validatorAddress = reader.string();\n                    break;\n                case 3:\n                    message.entries.push(exports.UnbondingDelegationEntry.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            delegatorAddress: isSet(object.delegatorAddress)\n                ? String(object.delegatorAddress)\n                : \"\",\n            validatorAddress: isSet(object.validatorAddress)\n                ? String(object.validatorAddress)\n                : \"\",\n            entries: Array.isArray(object === null || object === void 0 ? void 0 : object.entries)\n                ? object.entries.map((e) => exports.UnbondingDelegationEntry.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.delegatorAddress !== undefined &&\n            (obj.delegatorAddress = message.delegatorAddress);\n        message.validatorAddress !== undefined &&\n            (obj.validatorAddress = message.validatorAddress);\n        if (message.entries) {\n            obj.entries = message.entries.map((e) => e ? exports.UnbondingDelegationEntry.toJSON(e) : undefined);\n        }\n        else {\n            obj.entries = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseUnbondingDelegation();\n        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : \"\";\n        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : \"\";\n        message.entries =\n            ((_c = object.entries) === null || _c === void 0 ? void 0 : _c.map((e) => exports.UnbondingDelegationEntry.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseUnbondingDelegationEntry() {\n    return {\n        creationHeight: \"0\",\n        completionTime: undefined,\n        initialBalance: \"\",\n        balance: \"\",\n    };\n}\nexports.UnbondingDelegationEntry = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.creationHeight !== \"0\") {\n            writer.uint32(8).int64(message.creationHeight);\n        }\n        if (message.completionTime !== undefined) {\n            timestamp_1.Timestamp.encode(toTimestamp(message.completionTime), writer.uint32(18).fork()).ldelim();\n        }\n        if (message.initialBalance !== \"\") {\n            writer.uint32(26).string(message.initialBalance);\n        }\n        if (message.balance !== \"\") {\n            writer.uint32(34).string(message.balance);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUnbondingDelegationEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.creationHeight = longToString(reader.int64());\n                    break;\n                case 2:\n                    message.completionTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.initialBalance = reader.string();\n                    break;\n                case 4:\n                    message.balance = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            creationHeight: isSet(object.creationHeight)\n                ? String(object.creationHeight)\n                : \"0\",\n            completionTime: isSet(object.completionTime)\n                ? fromJsonTimestamp(object.completionTime)\n                : undefined,\n            initialBalance: isSet(object.initialBalance)\n                ? String(object.initialBalance)\n                : \"\",\n            balance: isSet(object.balance) ? String(object.balance) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.creationHeight !== undefined &&\n            (obj.creationHeight = message.creationHeight);\n        message.completionTime !== undefined &&\n            (obj.completionTime = message.completionTime.toISOString());\n        message.initialBalance !== undefined &&\n            (obj.initialBalance = message.initialBalance);\n        message.balance !== undefined && (obj.balance = message.balance);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseUnbondingDelegationEntry();\n        message.creationHeight = (_a = object.creationHeight) !== null && _a !== void 0 ? _a : \"0\";\n        message.completionTime = (_b = object.completionTime) !== null && _b !== void 0 ? _b : undefined;\n        message.initialBalance = (_c = object.initialBalance) !== null && _c !== void 0 ? _c : \"\";\n        message.balance = (_d = object.balance) !== null && _d !== void 0 ? _d : \"\";\n        return message;\n    },\n};\nfunction createBaseRedelegationEntry() {\n    return {\n        creationHeight: \"0\",\n        completionTime: undefined,\n        initialBalance: \"\",\n        sharesDst: \"\",\n    };\n}\nexports.RedelegationEntry = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.creationHeight !== \"0\") {\n            writer.uint32(8).int64(message.creationHeight);\n        }\n        if (message.completionTime !== undefined) {\n            timestamp_1.Timestamp.encode(toTimestamp(message.completionTime), writer.uint32(18).fork()).ldelim();\n        }\n        if (message.initialBalance !== \"\") {\n            writer.uint32(26).string(message.initialBalance);\n        }\n        if (message.sharesDst !== \"\") {\n            writer.uint32(34).string(message.sharesDst);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRedelegationEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.creationHeight = longToString(reader.int64());\n                    break;\n                case 2:\n                    message.completionTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.initialBalance = reader.string();\n                    break;\n                case 4:\n                    message.sharesDst = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            creationHeight: isSet(object.creationHeight)\n                ? String(object.creationHeight)\n                : \"0\",\n            completionTime: isSet(object.completionTime)\n                ? fromJsonTimestamp(object.completionTime)\n                : undefined,\n            initialBalance: isSet(object.initialBalance)\n                ? String(object.initialBalance)\n                : \"\",\n            sharesDst: isSet(object.sharesDst) ? String(object.sharesDst) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.creationHeight !== undefined &&\n            (obj.creationHeight = message.creationHeight);\n        message.completionTime !== undefined &&\n            (obj.completionTime = message.completionTime.toISOString());\n        message.initialBalance !== undefined &&\n            (obj.initialBalance = message.initialBalance);\n        message.sharesDst !== undefined && (obj.sharesDst = message.sharesDst);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseRedelegationEntry();\n        message.creationHeight = (_a = object.creationHeight) !== null && _a !== void 0 ? _a : \"0\";\n        message.completionTime = (_b = object.completionTime) !== null && _b !== void 0 ? _b : undefined;\n        message.initialBalance = (_c = object.initialBalance) !== null && _c !== void 0 ? _c : \"\";\n        message.sharesDst = (_d = object.sharesDst) !== null && _d !== void 0 ? _d : \"\";\n        return message;\n    },\n};\nfunction createBaseRedelegation() {\n    return {\n        delegatorAddress: \"\",\n        validatorSrcAddress: \"\",\n        validatorDstAddress: \"\",\n        entries: [],\n    };\n}\nexports.Redelegation = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.delegatorAddress !== \"\") {\n            writer.uint32(10).string(message.delegatorAddress);\n        }\n        if (message.validatorSrcAddress !== \"\") {\n            writer.uint32(18).string(message.validatorSrcAddress);\n        }\n        if (message.validatorDstAddress !== \"\") {\n            writer.uint32(26).string(message.validatorDstAddress);\n        }\n        for (const v of message.entries) {\n            exports.RedelegationEntry.encode(v, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRedelegation();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.delegatorAddress = reader.string();\n                    break;\n                case 2:\n                    message.validatorSrcAddress = reader.string();\n                    break;\n                case 3:\n                    message.validatorDstAddress = reader.string();\n                    break;\n                case 4:\n                    message.entries.push(exports.RedelegationEntry.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            delegatorAddress: isSet(object.delegatorAddress)\n                ? String(object.delegatorAddress)\n                : \"\",\n            validatorSrcAddress: isSet(object.validatorSrcAddress)\n                ? String(object.validatorSrcAddress)\n                : \"\",\n            validatorDstAddress: isSet(object.validatorDstAddress)\n                ? String(object.validatorDstAddress)\n                : \"\",\n            entries: Array.isArray(object === null || object === void 0 ? void 0 : object.entries)\n                ? object.entries.map((e) => exports.RedelegationEntry.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.delegatorAddress !== undefined &&\n            (obj.delegatorAddress = message.delegatorAddress);\n        message.validatorSrcAddress !== undefined &&\n            (obj.validatorSrcAddress = message.validatorSrcAddress);\n        message.validatorDstAddress !== undefined &&\n            (obj.validatorDstAddress = message.validatorDstAddress);\n        if (message.entries) {\n            obj.entries = message.entries.map((e) => e ? exports.RedelegationEntry.toJSON(e) : undefined);\n        }\n        else {\n            obj.entries = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseRedelegation();\n        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : \"\";\n        message.validatorSrcAddress = (_b = object.validatorSrcAddress) !== null && _b !== void 0 ? _b : \"\";\n        message.validatorDstAddress = (_c = object.validatorDstAddress) !== null && _c !== void 0 ? _c : \"\";\n        message.entries =\n            ((_d = object.entries) === null || _d === void 0 ? void 0 : _d.map((e) => exports.RedelegationEntry.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseParams() {\n    return {\n        unbondingTime: undefined,\n        maxValidators: 0,\n        maxEntries: 0,\n        historicalEntries: 0,\n        bondDenom: \"\",\n    };\n}\nexports.Params = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.unbondingTime !== undefined) {\n            duration_1.Duration.encode(message.unbondingTime, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.maxValidators !== 0) {\n            writer.uint32(16).uint32(message.maxValidators);\n        }\n        if (message.maxEntries !== 0) {\n            writer.uint32(24).uint32(message.maxEntries);\n        }\n        if (message.historicalEntries !== 0) {\n            writer.uint32(32).uint32(message.historicalEntries);\n        }\n        if (message.bondDenom !== \"\") {\n            writer.uint32(42).string(message.bondDenom);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseParams();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.unbondingTime = duration_1.Duration.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.maxValidators = reader.uint32();\n                    break;\n                case 3:\n                    message.maxEntries = reader.uint32();\n                    break;\n                case 4:\n                    message.historicalEntries = reader.uint32();\n                    break;\n                case 5:\n                    message.bondDenom = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            unbondingTime: isSet(object.unbondingTime)\n                ? duration_1.Duration.fromJSON(object.unbondingTime)\n                : undefined,\n            maxValidators: isSet(object.maxValidators)\n                ? Number(object.maxValidators)\n                : 0,\n            maxEntries: isSet(object.maxEntries) ? Number(object.maxEntries) : 0,\n            historicalEntries: isSet(object.historicalEntries)\n                ? Number(object.historicalEntries)\n                : 0,\n            bondDenom: isSet(object.bondDenom) ? String(object.bondDenom) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.unbondingTime !== undefined &&\n            (obj.unbondingTime = message.unbondingTime\n                ? duration_1.Duration.toJSON(message.unbondingTime)\n                : undefined);\n        message.maxValidators !== undefined &&\n            (obj.maxValidators = Math.round(message.maxValidators));\n        message.maxEntries !== undefined &&\n            (obj.maxEntries = Math.round(message.maxEntries));\n        message.historicalEntries !== undefined &&\n            (obj.historicalEntries = Math.round(message.historicalEntries));\n        message.bondDenom !== undefined && (obj.bondDenom = message.bondDenom);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseParams();\n        message.unbondingTime =\n            object.unbondingTime !== undefined && object.unbondingTime !== null\n                ? duration_1.Duration.fromPartial(object.unbondingTime)\n                : undefined;\n        message.maxValidators = (_a = object.maxValidators) !== null && _a !== void 0 ? _a : 0;\n        message.maxEntries = (_b = object.maxEntries) !== null && _b !== void 0 ? _b : 0;\n        message.historicalEntries = (_c = object.historicalEntries) !== null && _c !== void 0 ? _c : 0;\n        message.bondDenom = (_d = object.bondDenom) !== null && _d !== void 0 ? _d : \"\";\n        return message;\n    },\n};\nfunction createBaseDelegationResponse() {\n    return { delegation: undefined, balance: undefined };\n}\nexports.DelegationResponse = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.delegation !== undefined) {\n            exports.Delegation.encode(message.delegation, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.balance !== undefined) {\n            coin_1.Coin.encode(message.balance, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDelegationResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.delegation = exports.Delegation.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.balance = coin_1.Coin.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            delegation: isSet(object.delegation)\n                ? exports.Delegation.fromJSON(object.delegation)\n                : undefined,\n            balance: isSet(object.balance)\n                ? coin_1.Coin.fromJSON(object.balance)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.delegation !== undefined &&\n            (obj.delegation = message.delegation\n                ? exports.Delegation.toJSON(message.delegation)\n                : undefined);\n        message.balance !== undefined &&\n            (obj.balance = message.balance\n                ? coin_1.Coin.toJSON(message.balance)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseDelegationResponse();\n        message.delegation =\n            object.delegation !== undefined && object.delegation !== null\n                ? exports.Delegation.fromPartial(object.delegation)\n                : undefined;\n        message.balance =\n            object.balance !== undefined && object.balance !== null\n                ? coin_1.Coin.fromPartial(object.balance)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseRedelegationEntryResponse() {\n    return { redelegationEntry: undefined, balance: \"\" };\n}\nexports.RedelegationEntryResponse = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.redelegationEntry !== undefined) {\n            exports.RedelegationEntry.encode(message.redelegationEntry, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.balance !== \"\") {\n            writer.uint32(34).string(message.balance);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRedelegationEntryResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.redelegationEntry = exports.RedelegationEntry.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.balance = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            redelegationEntry: isSet(object.redelegationEntry)\n                ? exports.RedelegationEntry.fromJSON(object.redelegationEntry)\n                : undefined,\n            balance: isSet(object.balance) ? String(object.balance) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.redelegationEntry !== undefined &&\n            (obj.redelegationEntry = message.redelegationEntry\n                ? exports.RedelegationEntry.toJSON(message.redelegationEntry)\n                : undefined);\n        message.balance !== undefined && (obj.balance = message.balance);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseRedelegationEntryResponse();\n        message.redelegationEntry =\n            object.redelegationEntry !== undefined &&\n                object.redelegationEntry !== null\n                ? exports.RedelegationEntry.fromPartial(object.redelegationEntry)\n                : undefined;\n        message.balance = (_a = object.balance) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseRedelegationResponse() {\n    return { redelegation: undefined, entries: [] };\n}\nexports.RedelegationResponse = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.redelegation !== undefined) {\n            exports.Redelegation.encode(message.redelegation, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.entries) {\n            exports.RedelegationEntryResponse.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRedelegationResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.redelegation = exports.Redelegation.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.entries.push(exports.RedelegationEntryResponse.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            redelegation: isSet(object.redelegation)\n                ? exports.Redelegation.fromJSON(object.redelegation)\n                : undefined,\n            entries: Array.isArray(object === null || object === void 0 ? void 0 : object.entries)\n                ? object.entries.map((e) => exports.RedelegationEntryResponse.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.redelegation !== undefined &&\n            (obj.redelegation = message.redelegation\n                ? exports.Redelegation.toJSON(message.redelegation)\n                : undefined);\n        if (message.entries) {\n            obj.entries = message.entries.map((e) => e ? exports.RedelegationEntryResponse.toJSON(e) : undefined);\n        }\n        else {\n            obj.entries = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseRedelegationResponse();\n        message.redelegation =\n            object.redelegation !== undefined && object.redelegation !== null\n                ? exports.Redelegation.fromPartial(object.redelegation)\n                : undefined;\n        message.entries =\n            ((_a = object.entries) === null || _a === void 0 ? void 0 : _a.map((e) => exports.RedelegationEntryResponse.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nfunction createBasePool() {\n    return { notBondedTokens: \"\", bondedTokens: \"\" };\n}\nexports.Pool = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.notBondedTokens !== \"\") {\n            writer.uint32(10).string(message.notBondedTokens);\n        }\n        if (message.bondedTokens !== \"\") {\n            writer.uint32(18).string(message.bondedTokens);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePool();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.notBondedTokens = reader.string();\n                    break;\n                case 2:\n                    message.bondedTokens = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            notBondedTokens: isSet(object.notBondedTokens)\n                ? String(object.notBondedTokens)\n                : \"\",\n            bondedTokens: isSet(object.bondedTokens)\n                ? String(object.bondedTokens)\n                : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.notBondedTokens !== undefined &&\n            (obj.notBondedTokens = message.notBondedTokens);\n        message.bondedTokens !== undefined &&\n            (obj.bondedTokens = message.bondedTokens);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePool();\n        message.notBondedTokens = (_a = object.notBondedTokens) !== null && _a !== void 0 ? _a : \"\";\n        message.bondedTokens = (_b = object.bondedTokens) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction toTimestamp(date) {\n    const seconds = Math.trunc(date.getTime() / 1000).toString();\n    const nanos = (date.getTime() % 1000) * 1000000;\n    return { seconds, nanos };\n}\nfunction fromTimestamp(t) {\n    let millis = Number(t.seconds) * 1000;\n    millis += t.nanos / 1000000;\n    return new Date(millis);\n}\nfunction fromJsonTimestamp(o) {\n    if (o instanceof Date) {\n        return o;\n    }\n    else if (typeof o === \"string\") {\n        return new Date(o);\n    }\n    else {\n        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));\n    }\n}\nfunction longToString(long) {\n    return long.toString();\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=staking.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3Mvc3Rha2luZy92MWJldGExL3N0YWtpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZLEdBQUcsNEJBQTRCLEdBQUcsaUNBQWlDLEdBQUcsMEJBQTBCLEdBQUcsY0FBYyxHQUFHLG9CQUFvQixHQUFHLHlCQUF5QixHQUFHLGdDQUFnQyxHQUFHLDJCQUEyQixHQUFHLGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLGtCQUFrQixHQUFHLGVBQWUsR0FBRyxjQUFjLEdBQUcsb0JBQW9CLEdBQUcsaUJBQWlCLEdBQUcsbUJBQW1CLEdBQUcsa0JBQWtCLEdBQUcsdUJBQXVCLEdBQUcsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsMEJBQTBCLEdBQUcsa0JBQWtCLEdBQUcsdUJBQXVCO0FBQ3BrQjtBQUNBLCtCQUErQixtQkFBTyxDQUFDLG1EQUFNO0FBQzdDLGtDQUFrQyxtQkFBTyxDQUFDLHNFQUFvQjtBQUM5RCxvQkFBb0IsbUJBQU8sQ0FBQyx1SEFBb0M7QUFDaEUsZ0JBQWdCLG1CQUFPLENBQUMsaUhBQWlDO0FBQ3pELGNBQWMsbUJBQU8sQ0FBQywyR0FBOEI7QUFDcEQsbUJBQW1CLG1CQUFPLENBQUMscUhBQW1DO0FBQzlELGVBQWUsbUJBQU8sQ0FBQyxxSEFBbUM7QUFDMUQsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDLGtCQUFrQixLQUFLO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLGFBQWE7QUFDYjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L3Byb3RvLXR5cGVzL2Nvc21vcy9zdGFraW5nL3YxYmV0YTEvc3Rha2luZy5qcz8xOGE5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb29sID0gZXhwb3J0cy5SZWRlbGVnYXRpb25SZXNwb25zZSA9IGV4cG9ydHMuUmVkZWxlZ2F0aW9uRW50cnlSZXNwb25zZSA9IGV4cG9ydHMuRGVsZWdhdGlvblJlc3BvbnNlID0gZXhwb3J0cy5QYXJhbXMgPSBleHBvcnRzLlJlZGVsZWdhdGlvbiA9IGV4cG9ydHMuUmVkZWxlZ2F0aW9uRW50cnkgPSBleHBvcnRzLlVuYm9uZGluZ0RlbGVnYXRpb25FbnRyeSA9IGV4cG9ydHMuVW5ib25kaW5nRGVsZWdhdGlvbiA9IGV4cG9ydHMuRGVsZWdhdGlvbiA9IGV4cG9ydHMuRFZWVHJpcGxldHMgPSBleHBvcnRzLkRWVlRyaXBsZXQgPSBleHBvcnRzLkRWUGFpcnMgPSBleHBvcnRzLkRWUGFpciA9IGV4cG9ydHMuVmFsQWRkcmVzc2VzID0gZXhwb3J0cy5WYWxpZGF0b3IgPSBleHBvcnRzLkRlc2NyaXB0aW9uID0gZXhwb3J0cy5Db21taXNzaW9uID0gZXhwb3J0cy5Db21taXNzaW9uUmF0ZXMgPSBleHBvcnRzLkhpc3RvcmljYWxJbmZvID0gZXhwb3J0cy5ib25kU3RhdHVzVG9KU09OID0gZXhwb3J0cy5ib25kU3RhdHVzRnJvbUpTT04gPSBleHBvcnRzLkJvbmRTdGF0dXMgPSBleHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlICovXG5jb25zdCBsb25nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvbmdcIikpO1xuY29uc3QgbWluaW1hbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwcm90b2J1ZmpzL21pbmltYWxcIikpO1xuY29uc3QgdGltZXN0YW1wXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vZ29vZ2xlL3Byb3RvYnVmL3RpbWVzdGFtcFwiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdGVuZGVybWludC90eXBlcy90eXBlc1wiKTtcbmNvbnN0IGFueV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2dvb2dsZS9wcm90b2J1Zi9hbnlcIik7XG5jb25zdCBkdXJhdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2dvb2dsZS9wcm90b2J1Zi9kdXJhdGlvblwiKTtcbmNvbnN0IGNvaW5fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3Ntb3MvYmFzZS92MWJldGExL2NvaW5cIik7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwiY29zbW9zLnN0YWtpbmcudjFiZXRhMVwiO1xuLyoqIEJvbmRTdGF0dXMgaXMgdGhlIHN0YXR1cyBvZiBhIHZhbGlkYXRvci4gKi9cbnZhciBCb25kU3RhdHVzO1xuKGZ1bmN0aW9uIChCb25kU3RhdHVzKSB7XG4gICAgLyoqIEJPTkRfU1RBVFVTX1VOU1BFQ0lGSUVEIC0gVU5TUEVDSUZJRUQgZGVmaW5lcyBhbiBpbnZhbGlkIHZhbGlkYXRvciBzdGF0dXMuICovXG4gICAgQm9uZFN0YXR1c1tCb25kU3RhdHVzW1wiQk9ORF9TVEFUVVNfVU5TUEVDSUZJRURcIl0gPSAwXSA9IFwiQk9ORF9TVEFUVVNfVU5TUEVDSUZJRURcIjtcbiAgICAvKiogQk9ORF9TVEFUVVNfVU5CT05ERUQgLSBVTkJPTkRFRCBkZWZpbmVzIGEgdmFsaWRhdG9yIHRoYXQgaXMgbm90IGJvbmRlZC4gKi9cbiAgICBCb25kU3RhdHVzW0JvbmRTdGF0dXNbXCJCT05EX1NUQVRVU19VTkJPTkRFRFwiXSA9IDFdID0gXCJCT05EX1NUQVRVU19VTkJPTkRFRFwiO1xuICAgIC8qKiBCT05EX1NUQVRVU19VTkJPTkRJTkcgLSBVTkJPTkRJTkcgZGVmaW5lcyBhIHZhbGlkYXRvciB0aGF0IGlzIHVuYm9uZGluZy4gKi9cbiAgICBCb25kU3RhdHVzW0JvbmRTdGF0dXNbXCJCT05EX1NUQVRVU19VTkJPTkRJTkdcIl0gPSAyXSA9IFwiQk9ORF9TVEFUVVNfVU5CT05ESU5HXCI7XG4gICAgLyoqIEJPTkRfU1RBVFVTX0JPTkRFRCAtIEJPTkRFRCBkZWZpbmVzIGEgdmFsaWRhdG9yIHRoYXQgaXMgYm9uZGVkLiAqL1xuICAgIEJvbmRTdGF0dXNbQm9uZFN0YXR1c1tcIkJPTkRfU1RBVFVTX0JPTkRFRFwiXSA9IDNdID0gXCJCT05EX1NUQVRVU19CT05ERURcIjtcbiAgICBCb25kU3RhdHVzW0JvbmRTdGF0dXNbXCJVTlJFQ09HTklaRURcIl0gPSAtMV0gPSBcIlVOUkVDT0dOSVpFRFwiO1xufSkoQm9uZFN0YXR1cyA9IGV4cG9ydHMuQm9uZFN0YXR1cyB8fCAoZXhwb3J0cy5Cb25kU3RhdHVzID0ge30pKTtcbmZ1bmN0aW9uIGJvbmRTdGF0dXNGcm9tSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgXCJCT05EX1NUQVRVU19VTlNQRUNJRklFRFwiOlxuICAgICAgICAgICAgcmV0dXJuIEJvbmRTdGF0dXMuQk9ORF9TVEFUVVNfVU5TUEVDSUZJRUQ7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSBcIkJPTkRfU1RBVFVTX1VOQk9OREVEXCI6XG4gICAgICAgICAgICByZXR1cm4gQm9uZFN0YXR1cy5CT05EX1NUQVRVU19VTkJPTkRFRDtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIFwiQk9ORF9TVEFUVVNfVU5CT05ESU5HXCI6XG4gICAgICAgICAgICByZXR1cm4gQm9uZFN0YXR1cy5CT05EX1NUQVRVU19VTkJPTkRJTkc7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSBcIkJPTkRfU1RBVFVTX0JPTkRFRFwiOlxuICAgICAgICAgICAgcmV0dXJuIEJvbmRTdGF0dXMuQk9ORF9TVEFUVVNfQk9OREVEO1xuICAgICAgICBjYXNlIC0xOlxuICAgICAgICBjYXNlIFwiVU5SRUNPR05JWkVEXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gQm9uZFN0YXR1cy5VTlJFQ09HTklaRUQ7XG4gICAgfVxufVxuZXhwb3J0cy5ib25kU3RhdHVzRnJvbUpTT04gPSBib25kU3RhdHVzRnJvbUpTT047XG5mdW5jdGlvbiBib25kU3RhdHVzVG9KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgQm9uZFN0YXR1cy5CT05EX1NUQVRVU19VTlNQRUNJRklFRDpcbiAgICAgICAgICAgIHJldHVybiBcIkJPTkRfU1RBVFVTX1VOU1BFQ0lGSUVEXCI7XG4gICAgICAgIGNhc2UgQm9uZFN0YXR1cy5CT05EX1NUQVRVU19VTkJPTkRFRDpcbiAgICAgICAgICAgIHJldHVybiBcIkJPTkRfU1RBVFVTX1VOQk9OREVEXCI7XG4gICAgICAgIGNhc2UgQm9uZFN0YXR1cy5CT05EX1NUQVRVU19VTkJPTkRJTkc6XG4gICAgICAgICAgICByZXR1cm4gXCJCT05EX1NUQVRVU19VTkJPTkRJTkdcIjtcbiAgICAgICAgY2FzZSBCb25kU3RhdHVzLkJPTkRfU1RBVFVTX0JPTkRFRDpcbiAgICAgICAgICAgIHJldHVybiBcIkJPTkRfU1RBVFVTX0JPTkRFRFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiVU5LTk9XTlwiO1xuICAgIH1cbn1cbmV4cG9ydHMuYm9uZFN0YXR1c1RvSlNPTiA9IGJvbmRTdGF0dXNUb0pTT047XG5mdW5jdGlvbiBjcmVhdGVCYXNlSGlzdG9yaWNhbEluZm8oKSB7XG4gICAgcmV0dXJuIHsgaGVhZGVyOiB1bmRlZmluZWQsIHZhbHNldDogW10gfTtcbn1cbmV4cG9ydHMuSGlzdG9yaWNhbEluZm8gPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5oZWFkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHlwZXNfMS5IZWFkZXIuZW5jb2RlKG1lc3NhZ2UuaGVhZGVyLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnZhbHNldCkge1xuICAgICAgICAgICAgZXhwb3J0cy5WYWxpZGF0b3IuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSGlzdG9yaWNhbEluZm8oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmhlYWRlciA9IHR5cGVzXzEuSGVhZGVyLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWxzZXQucHVzaChleHBvcnRzLlZhbGlkYXRvci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVhZGVyOiBpc1NldChvYmplY3QuaGVhZGVyKSA/IHR5cGVzXzEuSGVhZGVyLmZyb21KU09OKG9iamVjdC5oZWFkZXIpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdmFsc2V0OiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC52YWxzZXQpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QudmFsc2V0Lm1hcCgoZSkgPT4gZXhwb3J0cy5WYWxpZGF0b3IuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmhlYWRlciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmhlYWRlciA9IG1lc3NhZ2UuaGVhZGVyID8gdHlwZXNfMS5IZWFkZXIudG9KU09OKG1lc3NhZ2UuaGVhZGVyKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChtZXNzYWdlLnZhbHNldCkge1xuICAgICAgICAgICAgb2JqLnZhbHNldCA9IG1lc3NhZ2UudmFsc2V0Lm1hcCgoZSkgPT4gZSA/IGV4cG9ydHMuVmFsaWRhdG9yLnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoudmFsc2V0ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSGlzdG9yaWNhbEluZm8oKTtcbiAgICAgICAgbWVzc2FnZS5oZWFkZXIgPVxuICAgICAgICAgICAgb2JqZWN0LmhlYWRlciAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5oZWFkZXIgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IHR5cGVzXzEuSGVhZGVyLmZyb21QYXJ0aWFsKG9iamVjdC5oZWFkZXIpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UudmFsc2V0ID0gKChfYSA9IG9iamVjdC52YWxzZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IGV4cG9ydHMuVmFsaWRhdG9yLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUNvbW1pc3Npb25SYXRlcygpIHtcbiAgICByZXR1cm4geyByYXRlOiBcIlwiLCBtYXhSYXRlOiBcIlwiLCBtYXhDaGFuZ2VSYXRlOiBcIlwiIH07XG59XG5leHBvcnRzLkNvbW1pc3Npb25SYXRlcyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnJhdGUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLnJhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm1heFJhdGUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLm1heFJhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm1heENoYW5nZVJhdGUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLnN0cmluZyhtZXNzYWdlLm1heENoYW5nZVJhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNvbW1pc3Npb25SYXRlcygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmF0ZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1heFJhdGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tYXhDaGFuZ2VSYXRlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXRlOiBpc1NldChvYmplY3QucmF0ZSkgPyBTdHJpbmcob2JqZWN0LnJhdGUpIDogXCJcIixcbiAgICAgICAgICAgIG1heFJhdGU6IGlzU2V0KG9iamVjdC5tYXhSYXRlKSA/IFN0cmluZyhvYmplY3QubWF4UmF0ZSkgOiBcIlwiLFxuICAgICAgICAgICAgbWF4Q2hhbmdlUmF0ZTogaXNTZXQob2JqZWN0Lm1heENoYW5nZVJhdGUpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0Lm1heENoYW5nZVJhdGUpXG4gICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UucmF0ZSAhPT0gdW5kZWZpbmVkICYmIChvYmoucmF0ZSA9IG1lc3NhZ2UucmF0ZSk7XG4gICAgICAgIG1lc3NhZ2UubWF4UmF0ZSAhPT0gdW5kZWZpbmVkICYmIChvYmoubWF4UmF0ZSA9IG1lc3NhZ2UubWF4UmF0ZSk7XG4gICAgICAgIG1lc3NhZ2UubWF4Q2hhbmdlUmF0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLm1heENoYW5nZVJhdGUgPSBtZXNzYWdlLm1heENoYW5nZVJhdGUpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNvbW1pc3Npb25SYXRlcygpO1xuICAgICAgICBtZXNzYWdlLnJhdGUgPSAoX2EgPSBvYmplY3QucmF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5tYXhSYXRlID0gKF9iID0gb2JqZWN0Lm1heFJhdGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UubWF4Q2hhbmdlUmF0ZSA9IChfYyA9IG9iamVjdC5tYXhDaGFuZ2VSYXRlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VDb21taXNzaW9uKCkge1xuICAgIHJldHVybiB7IGNvbW1pc3Npb25SYXRlczogdW5kZWZpbmVkLCB1cGRhdGVUaW1lOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydHMuQ29tbWlzc2lvbiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbW1pc3Npb25SYXRlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLkNvbW1pc3Npb25SYXRlcy5lbmNvZGUobWVzc2FnZS5jb21taXNzaW9uUmF0ZXMsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudXBkYXRlVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aW1lc3RhbXBfMS5UaW1lc3RhbXAuZW5jb2RlKHRvVGltZXN0YW1wKG1lc3NhZ2UudXBkYXRlVGltZSksIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29tbWlzc2lvbigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29tbWlzc2lvblJhdGVzID0gZXhwb3J0cy5Db21taXNzaW9uUmF0ZXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVwZGF0ZVRpbWUgPSBmcm9tVGltZXN0YW1wKHRpbWVzdGFtcF8xLlRpbWVzdGFtcC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tbWlzc2lvblJhdGVzOiBpc1NldChvYmplY3QuY29tbWlzc2lvblJhdGVzKVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Db21taXNzaW9uUmF0ZXMuZnJvbUpTT04ob2JqZWN0LmNvbW1pc3Npb25SYXRlcylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVwZGF0ZVRpbWU6IGlzU2V0KG9iamVjdC51cGRhdGVUaW1lKVxuICAgICAgICAgICAgICAgID8gZnJvbUpzb25UaW1lc3RhbXAob2JqZWN0LnVwZGF0ZVRpbWUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5jb21taXNzaW9uUmF0ZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb21taXNzaW9uUmF0ZXMgPSBtZXNzYWdlLmNvbW1pc3Npb25SYXRlc1xuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Db21taXNzaW9uUmF0ZXMudG9KU09OKG1lc3NhZ2UuY29tbWlzc2lvblJhdGVzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS51cGRhdGVUaW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudXBkYXRlVGltZSA9IG1lc3NhZ2UudXBkYXRlVGltZS50b0lTT1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29tbWlzc2lvbigpO1xuICAgICAgICBtZXNzYWdlLmNvbW1pc3Npb25SYXRlcyA9XG4gICAgICAgICAgICBvYmplY3QuY29tbWlzc2lvblJhdGVzICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNvbW1pc3Npb25SYXRlcyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Db21taXNzaW9uUmF0ZXMuZnJvbVBhcnRpYWwob2JqZWN0LmNvbW1pc3Npb25SYXRlcylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS51cGRhdGVUaW1lID0gKF9hID0gb2JqZWN0LnVwZGF0ZVRpbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbW9uaWtlcjogXCJcIixcbiAgICAgICAgaWRlbnRpdHk6IFwiXCIsXG4gICAgICAgIHdlYnNpdGU6IFwiXCIsXG4gICAgICAgIHNlY3VyaXR5Q29udGFjdDogXCJcIixcbiAgICAgICAgZGV0YWlsczogXCJcIixcbiAgICB9O1xufVxuZXhwb3J0cy5EZXNjcmlwdGlvbiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLm1vbmlrZXIgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLm1vbmlrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmlkZW50aXR5ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS5pZGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uud2Vic2l0ZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuc3RyaW5nKG1lc3NhZ2Uud2Vic2l0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2VjdXJpdHlDb250YWN0ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDM0KS5zdHJpbmcobWVzc2FnZS5zZWN1cml0eUNvbnRhY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmRldGFpbHMgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNDIpLnN0cmluZyhtZXNzYWdlLmRldGFpbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlc2NyaXB0aW9uKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tb25pa2VyID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWRlbnRpdHkgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS53ZWJzaXRlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VjdXJpdHlDb250YWN0ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGV0YWlscyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbW9uaWtlcjogaXNTZXQob2JqZWN0Lm1vbmlrZXIpID8gU3RyaW5nKG9iamVjdC5tb25pa2VyKSA6IFwiXCIsXG4gICAgICAgICAgICBpZGVudGl0eTogaXNTZXQob2JqZWN0LmlkZW50aXR5KSA/IFN0cmluZyhvYmplY3QuaWRlbnRpdHkpIDogXCJcIixcbiAgICAgICAgICAgIHdlYnNpdGU6IGlzU2V0KG9iamVjdC53ZWJzaXRlKSA/IFN0cmluZyhvYmplY3Qud2Vic2l0ZSkgOiBcIlwiLFxuICAgICAgICAgICAgc2VjdXJpdHlDb250YWN0OiBpc1NldChvYmplY3Quc2VjdXJpdHlDb250YWN0KVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC5zZWN1cml0eUNvbnRhY3QpXG4gICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICAgICAgZGV0YWlsczogaXNTZXQob2JqZWN0LmRldGFpbHMpID8gU3RyaW5nKG9iamVjdC5kZXRhaWxzKSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5tb25pa2VyICE9PSB1bmRlZmluZWQgJiYgKG9iai5tb25pa2VyID0gbWVzc2FnZS5tb25pa2VyKTtcbiAgICAgICAgbWVzc2FnZS5pZGVudGl0eSAhPT0gdW5kZWZpbmVkICYmIChvYmouaWRlbnRpdHkgPSBtZXNzYWdlLmlkZW50aXR5KTtcbiAgICAgICAgbWVzc2FnZS53ZWJzaXRlICE9PSB1bmRlZmluZWQgJiYgKG9iai53ZWJzaXRlID0gbWVzc2FnZS53ZWJzaXRlKTtcbiAgICAgICAgbWVzc2FnZS5zZWN1cml0eUNvbnRhY3QgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zZWN1cml0eUNvbnRhY3QgPSBtZXNzYWdlLnNlY3VyaXR5Q29udGFjdCk7XG4gICAgICAgIG1lc3NhZ2UuZGV0YWlscyAhPT0gdW5kZWZpbmVkICYmIChvYmouZGV0YWlscyA9IG1lc3NhZ2UuZGV0YWlscyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEZXNjcmlwdGlvbigpO1xuICAgICAgICBtZXNzYWdlLm1vbmlrZXIgPSAoX2EgPSBvYmplY3QubW9uaWtlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5pZGVudGl0eSA9IChfYiA9IG9iamVjdC5pZGVudGl0eSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS53ZWJzaXRlID0gKF9jID0gb2JqZWN0LndlYnNpdGUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2Uuc2VjdXJpdHlDb250YWN0ID0gKF9kID0gb2JqZWN0LnNlY3VyaXR5Q29udGFjdCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5kZXRhaWxzID0gKF9lID0gb2JqZWN0LmRldGFpbHMpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVZhbGlkYXRvcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBvcGVyYXRvckFkZHJlc3M6IFwiXCIsXG4gICAgICAgIGNvbnNlbnN1c1B1YmtleTogdW5kZWZpbmVkLFxuICAgICAgICBqYWlsZWQ6IGZhbHNlLFxuICAgICAgICBzdGF0dXM6IDAsXG4gICAgICAgIHRva2VuczogXCJcIixcbiAgICAgICAgZGVsZWdhdG9yU2hhcmVzOiBcIlwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICB1bmJvbmRpbmdIZWlnaHQ6IFwiMFwiLFxuICAgICAgICB1bmJvbmRpbmdUaW1lOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbW1pc3Npb246IHVuZGVmaW5lZCxcbiAgICAgICAgbWluU2VsZkRlbGVnYXRpb246IFwiXCIsXG4gICAgfTtcbn1cbmV4cG9ydHMuVmFsaWRhdG9yID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uub3BlcmF0b3JBZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5vcGVyYXRvckFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbnNlbnN1c1B1YmtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhbnlfMS5BbnkuZW5jb2RlKG1lc3NhZ2UuY29uc2Vuc3VzUHVia2V5LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmphaWxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkuYm9vbChtZXNzYWdlLmphaWxlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3RhdHVzICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDMyKS5pbnQzMihtZXNzYWdlLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudG9rZW5zICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDQyKS5zdHJpbmcobWVzc2FnZS50b2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmRlbGVnYXRvclNoYXJlcyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig1MCkuc3RyaW5nKG1lc3NhZ2UuZGVsZWdhdG9yU2hhcmVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLkRlc2NyaXB0aW9uLmVuY29kZShtZXNzYWdlLmRlc2NyaXB0aW9uLCB3cml0ZXIudWludDMyKDU4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnVuYm9uZGluZ0hlaWdodCAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNjQpLmludDY0KG1lc3NhZ2UudW5ib25kaW5nSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS51bmJvbmRpbmdUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcF8xLlRpbWVzdGFtcC5lbmNvZGUodG9UaW1lc3RhbXAobWVzc2FnZS51bmJvbmRpbmdUaW1lKSwgd3JpdGVyLnVpbnQzMig3NCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb21taXNzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuQ29tbWlzc2lvbi5lbmNvZGUobWVzc2FnZS5jb21taXNzaW9uLCB3cml0ZXIudWludDMyKDgyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm1pblNlbGZEZWxlZ2F0aW9uICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDkwKS5zdHJpbmcobWVzc2FnZS5taW5TZWxmRGVsZWdhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVmFsaWRhdG9yKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vcGVyYXRvckFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb25zZW5zdXNQdWJrZXkgPSBhbnlfMS5BbnkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmphaWxlZCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdGF0dXMgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRva2VucyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRlbGVnYXRvclNoYXJlcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRlc2NyaXB0aW9uID0gZXhwb3J0cy5EZXNjcmlwdGlvbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudW5ib25kaW5nSGVpZ2h0ID0gbG9uZ1RvU3RyaW5nKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVuYm9uZGluZ1RpbWUgPSBmcm9tVGltZXN0YW1wKHRpbWVzdGFtcF8xLlRpbWVzdGFtcC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb21taXNzaW9uID0gZXhwb3J0cy5Db21taXNzaW9uLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWluU2VsZkRlbGVnYXRpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wZXJhdG9yQWRkcmVzczogaXNTZXQob2JqZWN0Lm9wZXJhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3Qub3BlcmF0b3JBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIGNvbnNlbnN1c1B1YmtleTogaXNTZXQob2JqZWN0LmNvbnNlbnN1c1B1YmtleSlcbiAgICAgICAgICAgICAgICA/IGFueV8xLkFueS5mcm9tSlNPTihvYmplY3QuY29uc2Vuc3VzUHVia2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgamFpbGVkOiBpc1NldChvYmplY3QuamFpbGVkKSA/IEJvb2xlYW4ob2JqZWN0LmphaWxlZCkgOiBmYWxzZSxcbiAgICAgICAgICAgIHN0YXR1czogaXNTZXQob2JqZWN0LnN0YXR1cykgPyBib25kU3RhdHVzRnJvbUpTT04ob2JqZWN0LnN0YXR1cykgOiAwLFxuICAgICAgICAgICAgdG9rZW5zOiBpc1NldChvYmplY3QudG9rZW5zKSA/IFN0cmluZyhvYmplY3QudG9rZW5zKSA6IFwiXCIsXG4gICAgICAgICAgICBkZWxlZ2F0b3JTaGFyZXM6IGlzU2V0KG9iamVjdC5kZWxlZ2F0b3JTaGFyZXMpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LmRlbGVnYXRvclNoYXJlcylcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogaXNTZXQob2JqZWN0LmRlc2NyaXB0aW9uKVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5EZXNjcmlwdGlvbi5mcm9tSlNPTihvYmplY3QuZGVzY3JpcHRpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB1bmJvbmRpbmdIZWlnaHQ6IGlzU2V0KG9iamVjdC51bmJvbmRpbmdIZWlnaHQpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LnVuYm9uZGluZ0hlaWdodClcbiAgICAgICAgICAgICAgICA6IFwiMFwiLFxuICAgICAgICAgICAgdW5ib25kaW5nVGltZTogaXNTZXQob2JqZWN0LnVuYm9uZGluZ1RpbWUpXG4gICAgICAgICAgICAgICAgPyBmcm9tSnNvblRpbWVzdGFtcChvYmplY3QudW5ib25kaW5nVGltZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbW1pc3Npb246IGlzU2V0KG9iamVjdC5jb21taXNzaW9uKVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Db21taXNzaW9uLmZyb21KU09OKG9iamVjdC5jb21taXNzaW9uKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWluU2VsZkRlbGVnYXRpb246IGlzU2V0KG9iamVjdC5taW5TZWxmRGVsZWdhdGlvbilcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QubWluU2VsZkRlbGVnYXRpb24pXG4gICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uub3BlcmF0b3JBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoub3BlcmF0b3JBZGRyZXNzID0gbWVzc2FnZS5vcGVyYXRvckFkZHJlc3MpO1xuICAgICAgICBtZXNzYWdlLmNvbnNlbnN1c1B1YmtleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNvbnNlbnN1c1B1YmtleSA9IG1lc3NhZ2UuY29uc2Vuc3VzUHVia2V5XG4gICAgICAgICAgICAgICAgPyBhbnlfMS5BbnkudG9KU09OKG1lc3NhZ2UuY29uc2Vuc3VzUHVia2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5qYWlsZWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmphaWxlZCA9IG1lc3NhZ2UuamFpbGVkKTtcbiAgICAgICAgbWVzc2FnZS5zdGF0dXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zdGF0dXMgPSBib25kU3RhdHVzVG9KU09OKG1lc3NhZ2Uuc3RhdHVzKSk7XG4gICAgICAgIG1lc3NhZ2UudG9rZW5zICE9PSB1bmRlZmluZWQgJiYgKG9iai50b2tlbnMgPSBtZXNzYWdlLnRva2Vucyk7XG4gICAgICAgIG1lc3NhZ2UuZGVsZWdhdG9yU2hhcmVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZGVsZWdhdG9yU2hhcmVzID0gbWVzc2FnZS5kZWxlZ2F0b3JTaGFyZXMpO1xuICAgICAgICBtZXNzYWdlLmRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZGVzY3JpcHRpb24gPSBtZXNzYWdlLmRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkRlc2NyaXB0aW9uLnRvSlNPTihtZXNzYWdlLmRlc2NyaXB0aW9uKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS51bmJvbmRpbmdIZWlnaHQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai51bmJvbmRpbmdIZWlnaHQgPSBtZXNzYWdlLnVuYm9uZGluZ0hlaWdodCk7XG4gICAgICAgIG1lc3NhZ2UudW5ib25kaW5nVGltZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnVuYm9uZGluZ1RpbWUgPSBtZXNzYWdlLnVuYm9uZGluZ1RpbWUudG9JU09TdHJpbmcoKSk7XG4gICAgICAgIG1lc3NhZ2UuY29tbWlzc2lvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNvbW1pc3Npb24gPSBtZXNzYWdlLmNvbW1pc3Npb25cbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuQ29tbWlzc2lvbi50b0pTT04obWVzc2FnZS5jb21taXNzaW9uKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5taW5TZWxmRGVsZWdhdGlvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLm1pblNlbGZEZWxlZ2F0aW9uID0gbWVzc2FnZS5taW5TZWxmRGVsZWdhdGlvbik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VWYWxpZGF0b3IoKTtcbiAgICAgICAgbWVzc2FnZS5vcGVyYXRvckFkZHJlc3MgPSAoX2EgPSBvYmplY3Qub3BlcmF0b3JBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmNvbnNlbnN1c1B1YmtleSA9XG4gICAgICAgICAgICBvYmplY3QuY29uc2Vuc3VzUHVia2V5ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNvbnNlbnN1c1B1YmtleSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gYW55XzEuQW55LmZyb21QYXJ0aWFsKG9iamVjdC5jb25zZW5zdXNQdWJrZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuamFpbGVkID0gKF9iID0gb2JqZWN0LmphaWxlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgICAgIG1lc3NhZ2Uuc3RhdHVzID0gKF9jID0gb2JqZWN0LnN0YXR1cykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMDtcbiAgICAgICAgbWVzc2FnZS50b2tlbnMgPSAoX2QgPSBvYmplY3QudG9rZW5zKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmRlbGVnYXRvclNoYXJlcyA9IChfZSA9IG9iamVjdC5kZWxlZ2F0b3JTaGFyZXMpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuZGVzY3JpcHRpb24gPVxuICAgICAgICAgICAgb2JqZWN0LmRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmRlc2NyaXB0aW9uICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkRlc2NyaXB0aW9uLmZyb21QYXJ0aWFsKG9iamVjdC5kZXNjcmlwdGlvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS51bmJvbmRpbmdIZWlnaHQgPSAoX2YgPSBvYmplY3QudW5ib25kaW5nSGVpZ2h0KSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBcIjBcIjtcbiAgICAgICAgbWVzc2FnZS51bmJvbmRpbmdUaW1lID0gKF9nID0gb2JqZWN0LnVuYm9uZGluZ1RpbWUpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5jb21taXNzaW9uID1cbiAgICAgICAgICAgIG9iamVjdC5jb21taXNzaW9uICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNvbW1pc3Npb24gIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuQ29tbWlzc2lvbi5mcm9tUGFydGlhbChvYmplY3QuY29tbWlzc2lvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5taW5TZWxmRGVsZWdhdGlvbiA9IChfaCA9IG9iamVjdC5taW5TZWxmRGVsZWdhdGlvbikgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVmFsQWRkcmVzc2VzKCkge1xuICAgIHJldHVybiB7IGFkZHJlc3NlczogW10gfTtcbn1cbmV4cG9ydHMuVmFsQWRkcmVzc2VzID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuYWRkcmVzc2VzKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcodik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVmFsQWRkcmVzc2VzKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRyZXNzZXMucHVzaChyZWFkZXIuc3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGRyZXNzZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LmFkZHJlc3NlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5hZGRyZXNzZXMubWFwKChlKSA9PiBTdHJpbmcoZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS5hZGRyZXNzZXMpIHtcbiAgICAgICAgICAgIG9iai5hZGRyZXNzZXMgPSBtZXNzYWdlLmFkZHJlc3Nlcy5tYXAoKGUpID0+IGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLmFkZHJlc3NlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVZhbEFkZHJlc3NlcygpO1xuICAgICAgICBtZXNzYWdlLmFkZHJlc3NlcyA9ICgoX2EgPSBvYmplY3QuYWRkcmVzc2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBlKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZURWUGFpcigpIHtcbiAgICByZXR1cm4geyBkZWxlZ2F0b3JBZGRyZXNzOiBcIlwiLCB2YWxpZGF0b3JBZGRyZXNzOiBcIlwiIH07XG59XG5leHBvcnRzLkRWUGFpciA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURWUGFpcigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGVnYXRvckFkZHJlc3M6IGlzU2V0KG9iamVjdC5kZWxlZ2F0b3JBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC5kZWxlZ2F0b3JBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIHZhbGlkYXRvckFkZHJlc3M6IGlzU2V0KG9iamVjdC52YWxpZGF0b3JBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC52YWxpZGF0b3JBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5kZWxlZ2F0b3JBZGRyZXNzID0gbWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzKTtcbiAgICAgICAgbWVzc2FnZS52YWxpZGF0b3JBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudmFsaWRhdG9yQWRkcmVzcyA9IG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEVlBhaXIoKTtcbiAgICAgICAgbWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzID0gKF9hID0gb2JqZWN0LmRlbGVnYXRvckFkZHJlc3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyA9IChfYiA9IG9iamVjdC52YWxpZGF0b3JBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VEVlBhaXJzKCkge1xuICAgIHJldHVybiB7IHBhaXJzOiBbXSB9O1xufVxuZXhwb3J0cy5EVlBhaXJzID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UucGFpcnMpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuRFZQYWlyLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURWUGFpcnMoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhaXJzLnB1c2goZXhwb3J0cy5EVlBhaXIuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhaXJzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5wYWlycylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5wYWlycy5tYXAoKGUpID0+IGV4cG9ydHMuRFZQYWlyLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UucGFpcnMpIHtcbiAgICAgICAgICAgIG9iai5wYWlycyA9IG1lc3NhZ2UucGFpcnMubWFwKChlKSA9PiAoZSA/IGV4cG9ydHMuRFZQYWlyLnRvSlNPTihlKSA6IHVuZGVmaW5lZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnBhaXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRFZQYWlycygpO1xuICAgICAgICBtZXNzYWdlLnBhaXJzID0gKChfYSA9IG9iamVjdC5wYWlycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gZXhwb3J0cy5EVlBhaXIuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRFZWVHJpcGxldCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxlZ2F0b3JBZGRyZXNzOiBcIlwiLFxuICAgICAgICB2YWxpZGF0b3JTcmNBZGRyZXNzOiBcIlwiLFxuICAgICAgICB2YWxpZGF0b3JEc3RBZGRyZXNzOiBcIlwiLFxuICAgIH07XG59XG5leHBvcnRzLkRWVlRyaXBsZXQgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52YWxpZGF0b3JTcmNBZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS52YWxpZGF0b3JTcmNBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52YWxpZGF0b3JEc3RBZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5zdHJpbmcobWVzc2FnZS52YWxpZGF0b3JEc3RBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEVlZUcmlwbGV0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yU3JjQWRkcmVzcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbGlkYXRvckRzdEFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGVnYXRvckFkZHJlc3M6IGlzU2V0KG9iamVjdC5kZWxlZ2F0b3JBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC5kZWxlZ2F0b3JBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIHZhbGlkYXRvclNyY0FkZHJlc3M6IGlzU2V0KG9iamVjdC52YWxpZGF0b3JTcmNBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC52YWxpZGF0b3JTcmNBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIHZhbGlkYXRvckRzdEFkZHJlc3M6IGlzU2V0KG9iamVjdC52YWxpZGF0b3JEc3RBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC52YWxpZGF0b3JEc3RBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5kZWxlZ2F0b3JBZGRyZXNzID0gbWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzKTtcbiAgICAgICAgbWVzc2FnZS52YWxpZGF0b3JTcmNBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudmFsaWRhdG9yU3JjQWRkcmVzcyA9IG1lc3NhZ2UudmFsaWRhdG9yU3JjQWRkcmVzcyk7XG4gICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yRHN0QWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnZhbGlkYXRvckRzdEFkZHJlc3MgPSBtZXNzYWdlLnZhbGlkYXRvckRzdEFkZHJlc3MpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURWVlRyaXBsZXQoKTtcbiAgICAgICAgbWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzID0gKF9hID0gb2JqZWN0LmRlbGVnYXRvckFkZHJlc3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yU3JjQWRkcmVzcyA9IChfYiA9IG9iamVjdC52YWxpZGF0b3JTcmNBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnZhbGlkYXRvckRzdEFkZHJlc3MgPSAoX2MgPSBvYmplY3QudmFsaWRhdG9yRHN0QWRkcmVzcykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRFZWVHJpcGxldHMoKSB7XG4gICAgcmV0dXJuIHsgdHJpcGxldHM6IFtdIH07XG59XG5leHBvcnRzLkRWVlRyaXBsZXRzID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UudHJpcGxldHMpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuRFZWVHJpcGxldC5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEVlZUcmlwbGV0cygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHJpcGxldHMucHVzaChleHBvcnRzLkRWVlRyaXBsZXQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyaXBsZXRzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC50cmlwbGV0cylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC50cmlwbGV0cy5tYXAoKGUpID0+IGV4cG9ydHMuRFZWVHJpcGxldC5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnRyaXBsZXRzKSB7XG4gICAgICAgICAgICBvYmoudHJpcGxldHMgPSBtZXNzYWdlLnRyaXBsZXRzLm1hcCgoZSkgPT4gZSA/IGV4cG9ydHMuRFZWVHJpcGxldC50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnRyaXBsZXRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRFZWVHJpcGxldHMoKTtcbiAgICAgICAgbWVzc2FnZS50cmlwbGV0cyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnRyaXBsZXRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBleHBvcnRzLkRWVlRyaXBsZXQuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRGVsZWdhdGlvbigpIHtcbiAgICByZXR1cm4geyBkZWxlZ2F0b3JBZGRyZXNzOiBcIlwiLCB2YWxpZGF0b3JBZGRyZXNzOiBcIlwiLCBzaGFyZXM6IFwiXCIgfTtcbn1cbmV4cG9ydHMuRGVsZWdhdGlvbiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNoYXJlcyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuc3RyaW5nKG1lc3NhZ2Uuc2hhcmVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEZWxlZ2F0aW9uKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNoYXJlcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsZWdhdG9yQWRkcmVzczogaXNTZXQob2JqZWN0LmRlbGVnYXRvckFkZHJlc3MpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LmRlbGVnYXRvckFkZHJlc3MpXG4gICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICAgICAgdmFsaWRhdG9yQWRkcmVzczogaXNTZXQob2JqZWN0LnZhbGlkYXRvckFkZHJlc3MpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LnZhbGlkYXRvckFkZHJlc3MpXG4gICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICAgICAgc2hhcmVzOiBpc1NldChvYmplY3Quc2hhcmVzKSA/IFN0cmluZyhvYmplY3Quc2hhcmVzKSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZGVsZWdhdG9yQWRkcmVzcyA9IG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyk7XG4gICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnZhbGlkYXRvckFkZHJlc3MgPSBtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MpO1xuICAgICAgICBtZXNzYWdlLnNoYXJlcyAhPT0gdW5kZWZpbmVkICYmIChvYmouc2hhcmVzID0gbWVzc2FnZS5zaGFyZXMpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURlbGVnYXRpb24oKTtcbiAgICAgICAgbWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzID0gKF9hID0gb2JqZWN0LmRlbGVnYXRvckFkZHJlc3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyA9IChfYiA9IG9iamVjdC52YWxpZGF0b3JBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnNoYXJlcyA9IChfYyA9IG9iamVjdC5zaGFyZXMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVVuYm9uZGluZ0RlbGVnYXRpb24oKSB7XG4gICAgcmV0dXJuIHsgZGVsZWdhdG9yQWRkcmVzczogXCJcIiwgdmFsaWRhdG9yQWRkcmVzczogXCJcIiwgZW50cmllczogW10gfTtcbn1cbmV4cG9ydHMuVW5ib25kaW5nRGVsZWdhdGlvbiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuVW5ib25kaW5nRGVsZWdhdGlvbkVudHJ5LmVuY29kZSh2LCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVVuYm9uZGluZ0RlbGVnYXRpb24oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWxpZGF0b3JBZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZW50cmllcy5wdXNoKGV4cG9ydHMuVW5ib25kaW5nRGVsZWdhdGlvbkVudHJ5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxlZ2F0b3JBZGRyZXNzOiBpc1NldChvYmplY3QuZGVsZWdhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QuZGVsZWdhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICB2YWxpZGF0b3JBZGRyZXNzOiBpc1NldChvYmplY3QudmFsaWRhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QudmFsaWRhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICBlbnRyaWVzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5lbnRyaWVzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LmVudHJpZXMubWFwKChlKSA9PiBleHBvcnRzLlVuYm9uZGluZ0RlbGVnYXRpb25FbnRyeS5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmRlbGVnYXRvckFkZHJlc3MgPSBtZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MpO1xuICAgICAgICBtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52YWxpZGF0b3JBZGRyZXNzID0gbWVzc2FnZS52YWxpZGF0b3JBZGRyZXNzKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZW50cmllcykge1xuICAgICAgICAgICAgb2JqLmVudHJpZXMgPSBtZXNzYWdlLmVudHJpZXMubWFwKChlKSA9PiBlID8gZXhwb3J0cy5VbmJvbmRpbmdEZWxlZ2F0aW9uRW50cnkudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5lbnRyaWVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VVbmJvbmRpbmdEZWxlZ2F0aW9uKCk7XG4gICAgICAgIG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyA9IChfYSA9IG9iamVjdC5kZWxlZ2F0b3JBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MgPSAoX2IgPSBvYmplY3QudmFsaWRhdG9yQWRkcmVzcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5lbnRyaWVzID1cbiAgICAgICAgICAgICgoX2MgPSBvYmplY3QuZW50cmllcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1hcCgoZSkgPT4gZXhwb3J0cy5VbmJvbmRpbmdEZWxlZ2F0aW9uRW50cnkuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVW5ib25kaW5nRGVsZWdhdGlvbkVudHJ5KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0aW9uSGVpZ2h0OiBcIjBcIixcbiAgICAgICAgY29tcGxldGlvblRpbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgaW5pdGlhbEJhbGFuY2U6IFwiXCIsXG4gICAgICAgIGJhbGFuY2U6IFwiXCIsXG4gICAgfTtcbn1cbmV4cG9ydHMuVW5ib25kaW5nRGVsZWdhdGlvbkVudHJ5ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuY3JlYXRpb25IZWlnaHQgIT09IFwiMFwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLmludDY0KG1lc3NhZ2UuY3JlYXRpb25IZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbXBsZXRpb25UaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcF8xLlRpbWVzdGFtcC5lbmNvZGUodG9UaW1lc3RhbXAobWVzc2FnZS5jb21wbGV0aW9uVGltZSksIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5pdGlhbEJhbGFuY2UgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLnN0cmluZyhtZXNzYWdlLmluaXRpYWxCYWxhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5iYWxhbmNlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDM0KS5zdHJpbmcobWVzc2FnZS5iYWxhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VVbmJvbmRpbmdEZWxlZ2F0aW9uRW50cnkoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNyZWF0aW9uSGVpZ2h0ID0gbG9uZ1RvU3RyaW5nKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbXBsZXRpb25UaW1lID0gZnJvbVRpbWVzdGFtcCh0aW1lc3RhbXBfMS5UaW1lc3RhbXAuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbml0aWFsQmFsYW5jZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJhbGFuY2UgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0aW9uSGVpZ2h0OiBpc1NldChvYmplY3QuY3JlYXRpb25IZWlnaHQpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LmNyZWF0aW9uSGVpZ2h0KVxuICAgICAgICAgICAgICAgIDogXCIwXCIsXG4gICAgICAgICAgICBjb21wbGV0aW9uVGltZTogaXNTZXQob2JqZWN0LmNvbXBsZXRpb25UaW1lKVxuICAgICAgICAgICAgICAgID8gZnJvbUpzb25UaW1lc3RhbXAob2JqZWN0LmNvbXBsZXRpb25UaW1lKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaW5pdGlhbEJhbGFuY2U6IGlzU2V0KG9iamVjdC5pbml0aWFsQmFsYW5jZSlcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QuaW5pdGlhbEJhbGFuY2UpXG4gICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICAgICAgYmFsYW5jZTogaXNTZXQob2JqZWN0LmJhbGFuY2UpID8gU3RyaW5nKG9iamVjdC5iYWxhbmNlKSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5jcmVhdGlvbkhlaWdodCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNyZWF0aW9uSGVpZ2h0ID0gbWVzc2FnZS5jcmVhdGlvbkhlaWdodCk7XG4gICAgICAgIG1lc3NhZ2UuY29tcGxldGlvblRpbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb21wbGV0aW9uVGltZSA9IG1lc3NhZ2UuY29tcGxldGlvblRpbWUudG9JU09TdHJpbmcoKSk7XG4gICAgICAgIG1lc3NhZ2UuaW5pdGlhbEJhbGFuY2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pbml0aWFsQmFsYW5jZSA9IG1lc3NhZ2UuaW5pdGlhbEJhbGFuY2UpO1xuICAgICAgICBtZXNzYWdlLmJhbGFuY2UgIT09IHVuZGVmaW5lZCAmJiAob2JqLmJhbGFuY2UgPSBtZXNzYWdlLmJhbGFuY2UpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VVbmJvbmRpbmdEZWxlZ2F0aW9uRW50cnkoKTtcbiAgICAgICAgbWVzc2FnZS5jcmVhdGlvbkhlaWdodCA9IChfYSA9IG9iamVjdC5jcmVhdGlvbkhlaWdodCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCIwXCI7XG4gICAgICAgIG1lc3NhZ2UuY29tcGxldGlvblRpbWUgPSAoX2IgPSBvYmplY3QuY29tcGxldGlvblRpbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5pbml0aWFsQmFsYW5jZSA9IChfYyA9IG9iamVjdC5pbml0aWFsQmFsYW5jZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5iYWxhbmNlID0gKF9kID0gb2JqZWN0LmJhbGFuY2UpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVJlZGVsZWdhdGlvbkVudHJ5KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0aW9uSGVpZ2h0OiBcIjBcIixcbiAgICAgICAgY29tcGxldGlvblRpbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgaW5pdGlhbEJhbGFuY2U6IFwiXCIsXG4gICAgICAgIHNoYXJlc0RzdDogXCJcIixcbiAgICB9O1xufVxuZXhwb3J0cy5SZWRlbGVnYXRpb25FbnRyeSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmNyZWF0aW9uSGVpZ2h0ICE9PSBcIjBcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS5pbnQ2NChtZXNzYWdlLmNyZWF0aW9uSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb21wbGV0aW9uVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aW1lc3RhbXBfMS5UaW1lc3RhbXAuZW5jb2RlKHRvVGltZXN0YW1wKG1lc3NhZ2UuY29tcGxldGlvblRpbWUpLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmluaXRpYWxCYWxhbmNlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5zdHJpbmcobWVzc2FnZS5pbml0aWFsQmFsYW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2hhcmVzRHN0ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDM0KS5zdHJpbmcobWVzc2FnZS5zaGFyZXNEc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVJlZGVsZWdhdGlvbkVudHJ5KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jcmVhdGlvbkhlaWdodCA9IGxvbmdUb1N0cmluZyhyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb21wbGV0aW9uVGltZSA9IGZyb21UaW1lc3RhbXAodGltZXN0YW1wXzEuVGltZXN0YW1wLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5pdGlhbEJhbGFuY2UgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaGFyZXNEc3QgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0aW9uSGVpZ2h0OiBpc1NldChvYmplY3QuY3JlYXRpb25IZWlnaHQpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LmNyZWF0aW9uSGVpZ2h0KVxuICAgICAgICAgICAgICAgIDogXCIwXCIsXG4gICAgICAgICAgICBjb21wbGV0aW9uVGltZTogaXNTZXQob2JqZWN0LmNvbXBsZXRpb25UaW1lKVxuICAgICAgICAgICAgICAgID8gZnJvbUpzb25UaW1lc3RhbXAob2JqZWN0LmNvbXBsZXRpb25UaW1lKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaW5pdGlhbEJhbGFuY2U6IGlzU2V0KG9iamVjdC5pbml0aWFsQmFsYW5jZSlcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QuaW5pdGlhbEJhbGFuY2UpXG4gICAgICAgICAgICAgICAgOiBcIlwiLFxuICAgICAgICAgICAgc2hhcmVzRHN0OiBpc1NldChvYmplY3Quc2hhcmVzRHN0KSA/IFN0cmluZyhvYmplY3Quc2hhcmVzRHN0KSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5jcmVhdGlvbkhlaWdodCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNyZWF0aW9uSGVpZ2h0ID0gbWVzc2FnZS5jcmVhdGlvbkhlaWdodCk7XG4gICAgICAgIG1lc3NhZ2UuY29tcGxldGlvblRpbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb21wbGV0aW9uVGltZSA9IG1lc3NhZ2UuY29tcGxldGlvblRpbWUudG9JU09TdHJpbmcoKSk7XG4gICAgICAgIG1lc3NhZ2UuaW5pdGlhbEJhbGFuY2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pbml0aWFsQmFsYW5jZSA9IG1lc3NhZ2UuaW5pdGlhbEJhbGFuY2UpO1xuICAgICAgICBtZXNzYWdlLnNoYXJlc0RzdCAhPT0gdW5kZWZpbmVkICYmIChvYmouc2hhcmVzRHN0ID0gbWVzc2FnZS5zaGFyZXNEc3QpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VSZWRlbGVnYXRpb25FbnRyeSgpO1xuICAgICAgICBtZXNzYWdlLmNyZWF0aW9uSGVpZ2h0ID0gKF9hID0gb2JqZWN0LmNyZWF0aW9uSGVpZ2h0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIjBcIjtcbiAgICAgICAgbWVzc2FnZS5jb21wbGV0aW9uVGltZSA9IChfYiA9IG9iamVjdC5jb21wbGV0aW9uVGltZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmluaXRpYWxCYWxhbmNlID0gKF9jID0gb2JqZWN0LmluaXRpYWxCYWxhbmNlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnNoYXJlc0RzdCA9IChfZCA9IG9iamVjdC5zaGFyZXNEc3QpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVJlZGVsZWdhdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxlZ2F0b3JBZGRyZXNzOiBcIlwiLFxuICAgICAgICB2YWxpZGF0b3JTcmNBZGRyZXNzOiBcIlwiLFxuICAgICAgICB2YWxpZGF0b3JEc3RBZGRyZXNzOiBcIlwiLFxuICAgICAgICBlbnRyaWVzOiBbXSxcbiAgICB9O1xufVxuZXhwb3J0cy5SZWRlbGVnYXRpb24gPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52YWxpZGF0b3JTcmNBZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS52YWxpZGF0b3JTcmNBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52YWxpZGF0b3JEc3RBZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5zdHJpbmcobWVzc2FnZS52YWxpZGF0b3JEc3RBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICBleHBvcnRzLlJlZGVsZWdhdGlvbkVudHJ5LmVuY29kZSh2LCB3cml0ZXIudWludDMyKDM0KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVJlZGVsZWdhdGlvbigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbGlkYXRvclNyY0FkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWxpZGF0b3JEc3RBZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZW50cmllcy5wdXNoKGV4cG9ydHMuUmVkZWxlZ2F0aW9uRW50cnkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGVnYXRvckFkZHJlc3M6IGlzU2V0KG9iamVjdC5kZWxlZ2F0b3JBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC5kZWxlZ2F0b3JBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIHZhbGlkYXRvclNyY0FkZHJlc3M6IGlzU2V0KG9iamVjdC52YWxpZGF0b3JTcmNBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC52YWxpZGF0b3JTcmNBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIHZhbGlkYXRvckRzdEFkZHJlc3M6IGlzU2V0KG9iamVjdC52YWxpZGF0b3JEc3RBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC52YWxpZGF0b3JEc3RBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIGVudHJpZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LmVudHJpZXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QuZW50cmllcy5tYXAoKGUpID0+IGV4cG9ydHMuUmVkZWxlZ2F0aW9uRW50cnkuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5kZWxlZ2F0b3JBZGRyZXNzID0gbWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzKTtcbiAgICAgICAgbWVzc2FnZS52YWxpZGF0b3JTcmNBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudmFsaWRhdG9yU3JjQWRkcmVzcyA9IG1lc3NhZ2UudmFsaWRhdG9yU3JjQWRkcmVzcyk7XG4gICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yRHN0QWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnZhbGlkYXRvckRzdEFkZHJlc3MgPSBtZXNzYWdlLnZhbGlkYXRvckRzdEFkZHJlc3MpO1xuICAgICAgICBpZiAobWVzc2FnZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICBvYmouZW50cmllcyA9IG1lc3NhZ2UuZW50cmllcy5tYXAoKGUpID0+IGUgPyBleHBvcnRzLlJlZGVsZWdhdGlvbkVudHJ5LnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouZW50cmllcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVJlZGVsZWdhdGlvbigpO1xuICAgICAgICBtZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MgPSAoX2EgPSBvYmplY3QuZGVsZWdhdG9yQWRkcmVzcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS52YWxpZGF0b3JTcmNBZGRyZXNzID0gKF9iID0gb2JqZWN0LnZhbGlkYXRvclNyY0FkZHJlc3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yRHN0QWRkcmVzcyA9IChfYyA9IG9iamVjdC52YWxpZGF0b3JEc3RBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmVudHJpZXMgPVxuICAgICAgICAgICAgKChfZCA9IG9iamVjdC5lbnRyaWVzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubWFwKChlKSA9PiBleHBvcnRzLlJlZGVsZWdhdGlvbkVudHJ5LmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVBhcmFtcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB1bmJvbmRpbmdUaW1lOiB1bmRlZmluZWQsXG4gICAgICAgIG1heFZhbGlkYXRvcnM6IDAsXG4gICAgICAgIG1heEVudHJpZXM6IDAsXG4gICAgICAgIGhpc3RvcmljYWxFbnRyaWVzOiAwLFxuICAgICAgICBib25kRGVub206IFwiXCIsXG4gICAgfTtcbn1cbmV4cG9ydHMuUGFyYW1zID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudW5ib25kaW5nVGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkdXJhdGlvbl8xLkR1cmF0aW9uLmVuY29kZShtZXNzYWdlLnVuYm9uZGluZ1RpbWUsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubWF4VmFsaWRhdG9ycyAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikudWludDMyKG1lc3NhZ2UubWF4VmFsaWRhdG9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubWF4RW50cmllcyAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkudWludDMyKG1lc3NhZ2UubWF4RW50cmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaGlzdG9yaWNhbEVudHJpZXMgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMzIpLnVpbnQzMihtZXNzYWdlLmhpc3RvcmljYWxFbnRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5ib25kRGVub20gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNDIpLnN0cmluZyhtZXNzYWdlLmJvbmREZW5vbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUGFyYW1zKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51bmJvbmRpbmdUaW1lID0gZHVyYXRpb25fMS5EdXJhdGlvbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWF4VmFsaWRhdG9ycyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1heEVudHJpZXMgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5oaXN0b3JpY2FsRW50cmllcyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJvbmREZW5vbSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5ib25kaW5nVGltZTogaXNTZXQob2JqZWN0LnVuYm9uZGluZ1RpbWUpXG4gICAgICAgICAgICAgICAgPyBkdXJhdGlvbl8xLkR1cmF0aW9uLmZyb21KU09OKG9iamVjdC51bmJvbmRpbmdUaW1lKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWF4VmFsaWRhdG9yczogaXNTZXQob2JqZWN0Lm1heFZhbGlkYXRvcnMpXG4gICAgICAgICAgICAgICAgPyBOdW1iZXIob2JqZWN0Lm1heFZhbGlkYXRvcnMpXG4gICAgICAgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgbWF4RW50cmllczogaXNTZXQob2JqZWN0Lm1heEVudHJpZXMpID8gTnVtYmVyKG9iamVjdC5tYXhFbnRyaWVzKSA6IDAsXG4gICAgICAgICAgICBoaXN0b3JpY2FsRW50cmllczogaXNTZXQob2JqZWN0Lmhpc3RvcmljYWxFbnRyaWVzKVxuICAgICAgICAgICAgICAgID8gTnVtYmVyKG9iamVjdC5oaXN0b3JpY2FsRW50cmllcylcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBib25kRGVub206IGlzU2V0KG9iamVjdC5ib25kRGVub20pID8gU3RyaW5nKG9iamVjdC5ib25kRGVub20pIDogXCJcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnVuYm9uZGluZ1RpbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai51bmJvbmRpbmdUaW1lID0gbWVzc2FnZS51bmJvbmRpbmdUaW1lXG4gICAgICAgICAgICAgICAgPyBkdXJhdGlvbl8xLkR1cmF0aW9uLnRvSlNPTihtZXNzYWdlLnVuYm9uZGluZ1RpbWUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLm1heFZhbGlkYXRvcnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5tYXhWYWxpZGF0b3JzID0gTWF0aC5yb3VuZChtZXNzYWdlLm1heFZhbGlkYXRvcnMpKTtcbiAgICAgICAgbWVzc2FnZS5tYXhFbnRyaWVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoubWF4RW50cmllcyA9IE1hdGgucm91bmQobWVzc2FnZS5tYXhFbnRyaWVzKSk7XG4gICAgICAgIG1lc3NhZ2UuaGlzdG9yaWNhbEVudHJpZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5oaXN0b3JpY2FsRW50cmllcyA9IE1hdGgucm91bmQobWVzc2FnZS5oaXN0b3JpY2FsRW50cmllcykpO1xuICAgICAgICBtZXNzYWdlLmJvbmREZW5vbSAhPT0gdW5kZWZpbmVkICYmIChvYmouYm9uZERlbm9tID0gbWVzc2FnZS5ib25kRGVub20pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQYXJhbXMoKTtcbiAgICAgICAgbWVzc2FnZS51bmJvbmRpbmdUaW1lID1cbiAgICAgICAgICAgIG9iamVjdC51bmJvbmRpbmdUaW1lICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnVuYm9uZGluZ1RpbWUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGR1cmF0aW9uXzEuRHVyYXRpb24uZnJvbVBhcnRpYWwob2JqZWN0LnVuYm9uZGluZ1RpbWUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UubWF4VmFsaWRhdG9ycyA9IChfYSA9IG9iamVjdC5tYXhWYWxpZGF0b3JzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBtZXNzYWdlLm1heEVudHJpZXMgPSAoX2IgPSBvYmplY3QubWF4RW50cmllcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICAgICAgbWVzc2FnZS5oaXN0b3JpY2FsRW50cmllcyA9IChfYyA9IG9iamVjdC5oaXN0b3JpY2FsRW50cmllcykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMDtcbiAgICAgICAgbWVzc2FnZS5ib25kRGVub20gPSAoX2QgPSBvYmplY3QuYm9uZERlbm9tKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VEZWxlZ2F0aW9uUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHsgZGVsZWdhdGlvbjogdW5kZWZpbmVkLCBiYWxhbmNlOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydHMuRGVsZWdhdGlvblJlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZGVsZWdhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLkRlbGVnYXRpb24uZW5jb2RlKG1lc3NhZ2UuZGVsZWdhdGlvbiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5iYWxhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvaW5fMS5Db2luLmVuY29kZShtZXNzYWdlLmJhbGFuY2UsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRGVsZWdhdGlvblJlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kZWxlZ2F0aW9uID0gZXhwb3J0cy5EZWxlZ2F0aW9uLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5iYWxhbmNlID0gY29pbl8xLkNvaW4uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVsZWdhdGlvbjogaXNTZXQob2JqZWN0LmRlbGVnYXRpb24pXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkRlbGVnYXRpb24uZnJvbUpTT04ob2JqZWN0LmRlbGVnYXRpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBiYWxhbmNlOiBpc1NldChvYmplY3QuYmFsYW5jZSlcbiAgICAgICAgICAgICAgICA/IGNvaW5fMS5Db2luLmZyb21KU09OKG9iamVjdC5iYWxhbmNlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuZGVsZWdhdGlvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmRlbGVnYXRpb24gPSBtZXNzYWdlLmRlbGVnYXRpb25cbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuRGVsZWdhdGlvbi50b0pTT04obWVzc2FnZS5kZWxlZ2F0aW9uKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5iYWxhbmNlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYmFsYW5jZSA9IG1lc3NhZ2UuYmFsYW5jZVxuICAgICAgICAgICAgICAgID8gY29pbl8xLkNvaW4udG9KU09OKG1lc3NhZ2UuYmFsYW5jZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEZWxlZ2F0aW9uUmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5kZWxlZ2F0aW9uID1cbiAgICAgICAgICAgIG9iamVjdC5kZWxlZ2F0aW9uICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmRlbGVnYXRpb24gIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuRGVsZWdhdGlvbi5mcm9tUGFydGlhbChvYmplY3QuZGVsZWdhdGlvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5iYWxhbmNlID1cbiAgICAgICAgICAgIG9iamVjdC5iYWxhbmNlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmJhbGFuY2UgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGNvaW5fMS5Db2luLmZyb21QYXJ0aWFsKG9iamVjdC5iYWxhbmNlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VSZWRlbGVnYXRpb25FbnRyeVJlc3BvbnNlKCkge1xuICAgIHJldHVybiB7IHJlZGVsZWdhdGlvbkVudHJ5OiB1bmRlZmluZWQsIGJhbGFuY2U6IFwiXCIgfTtcbn1cbmV4cG9ydHMuUmVkZWxlZ2F0aW9uRW50cnlSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnJlZGVsZWdhdGlvbkVudHJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuUmVkZWxlZ2F0aW9uRW50cnkuZW5jb2RlKG1lc3NhZ2UucmVkZWxlZ2F0aW9uRW50cnksIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYmFsYW5jZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzNCkuc3RyaW5nKG1lc3NhZ2UuYmFsYW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUmVkZWxlZ2F0aW9uRW50cnlSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVkZWxlZ2F0aW9uRW50cnkgPSBleHBvcnRzLlJlZGVsZWdhdGlvbkVudHJ5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5iYWxhbmNlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWRlbGVnYXRpb25FbnRyeTogaXNTZXQob2JqZWN0LnJlZGVsZWdhdGlvbkVudHJ5KVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5SZWRlbGVnYXRpb25FbnRyeS5mcm9tSlNPTihvYmplY3QucmVkZWxlZ2F0aW9uRW50cnkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBiYWxhbmNlOiBpc1NldChvYmplY3QuYmFsYW5jZSkgPyBTdHJpbmcob2JqZWN0LmJhbGFuY2UpIDogXCJcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnJlZGVsZWdhdGlvbkVudHJ5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucmVkZWxlZ2F0aW9uRW50cnkgPSBtZXNzYWdlLnJlZGVsZWdhdGlvbkVudHJ5XG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlJlZGVsZWdhdGlvbkVudHJ5LnRvSlNPTihtZXNzYWdlLnJlZGVsZWdhdGlvbkVudHJ5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5iYWxhbmNlICE9PSB1bmRlZmluZWQgJiYgKG9iai5iYWxhbmNlID0gbWVzc2FnZS5iYWxhbmNlKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUmVkZWxlZ2F0aW9uRW50cnlSZXNwb25zZSgpO1xuICAgICAgICBtZXNzYWdlLnJlZGVsZWdhdGlvbkVudHJ5ID1cbiAgICAgICAgICAgIG9iamVjdC5yZWRlbGVnYXRpb25FbnRyeSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgb2JqZWN0LnJlZGVsZWdhdGlvbkVudHJ5ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlJlZGVsZWdhdGlvbkVudHJ5LmZyb21QYXJ0aWFsKG9iamVjdC5yZWRlbGVnYXRpb25FbnRyeSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5iYWxhbmNlID0gKF9hID0gb2JqZWN0LmJhbGFuY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVJlZGVsZWdhdGlvblJlc3BvbnNlKCkge1xuICAgIHJldHVybiB7IHJlZGVsZWdhdGlvbjogdW5kZWZpbmVkLCBlbnRyaWVzOiBbXSB9O1xufVxuZXhwb3J0cy5SZWRlbGVnYXRpb25SZXNwb25zZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnJlZGVsZWdhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLlJlZGVsZWdhdGlvbi5lbmNvZGUobWVzc2FnZS5yZWRlbGVnYXRpb24sIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuZW50cmllcykge1xuICAgICAgICAgICAgZXhwb3J0cy5SZWRlbGVnYXRpb25FbnRyeVJlc3BvbnNlLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVJlZGVsZWdhdGlvblJlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZWRlbGVnYXRpb24gPSBleHBvcnRzLlJlZGVsZWdhdGlvbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZW50cmllcy5wdXNoKGV4cG9ydHMuUmVkZWxlZ2F0aW9uRW50cnlSZXNwb25zZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVkZWxlZ2F0aW9uOiBpc1NldChvYmplY3QucmVkZWxlZ2F0aW9uKVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5SZWRlbGVnYXRpb24uZnJvbUpTT04ob2JqZWN0LnJlZGVsZWdhdGlvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGVudHJpZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LmVudHJpZXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QuZW50cmllcy5tYXAoKGUpID0+IGV4cG9ydHMuUmVkZWxlZ2F0aW9uRW50cnlSZXNwb25zZS5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UucmVkZWxlZ2F0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucmVkZWxlZ2F0aW9uID0gbWVzc2FnZS5yZWRlbGVnYXRpb25cbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuUmVkZWxlZ2F0aW9uLnRvSlNPTihtZXNzYWdlLnJlZGVsZWdhdGlvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChtZXNzYWdlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIG9iai5lbnRyaWVzID0gbWVzc2FnZS5lbnRyaWVzLm1hcCgoZSkgPT4gZSA/IGV4cG9ydHMuUmVkZWxlZ2F0aW9uRW50cnlSZXNwb25zZS50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLmVudHJpZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VSZWRlbGVnYXRpb25SZXNwb25zZSgpO1xuICAgICAgICBtZXNzYWdlLnJlZGVsZWdhdGlvbiA9XG4gICAgICAgICAgICBvYmplY3QucmVkZWxlZ2F0aW9uICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnJlZGVsZWdhdGlvbiAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5SZWRlbGVnYXRpb24uZnJvbVBhcnRpYWwob2JqZWN0LnJlZGVsZWdhdGlvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5lbnRyaWVzID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3QuZW50cmllcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gZXhwb3J0cy5SZWRlbGVnYXRpb25FbnRyeVJlc3BvbnNlLmZyb21QYXJ0aWFsKGUpKSkgfHxcbiAgICAgICAgICAgICAgICBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUG9vbCgpIHtcbiAgICByZXR1cm4geyBub3RCb25kZWRUb2tlbnM6IFwiXCIsIGJvbmRlZFRva2VuczogXCJcIiB9O1xufVxuZXhwb3J0cy5Qb29sID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uubm90Qm9uZGVkVG9rZW5zICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5ub3RCb25kZWRUb2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmJvbmRlZFRva2VucyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UuYm9uZGVkVG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQb29sKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ub3RCb25kZWRUb2tlbnMgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ib25kZWRUb2tlbnMgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vdEJvbmRlZFRva2VuczogaXNTZXQob2JqZWN0Lm5vdEJvbmRlZFRva2VucylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3Qubm90Qm9uZGVkVG9rZW5zKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIGJvbmRlZFRva2VuczogaXNTZXQob2JqZWN0LmJvbmRlZFRva2VucylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QuYm9uZGVkVG9rZW5zKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLm5vdEJvbmRlZFRva2VucyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLm5vdEJvbmRlZFRva2VucyA9IG1lc3NhZ2Uubm90Qm9uZGVkVG9rZW5zKTtcbiAgICAgICAgbWVzc2FnZS5ib25kZWRUb2tlbnMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5ib25kZWRUb2tlbnMgPSBtZXNzYWdlLmJvbmRlZFRva2Vucyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQb29sKCk7XG4gICAgICAgIG1lc3NhZ2Uubm90Qm9uZGVkVG9rZW5zID0gKF9hID0gb2JqZWN0Lm5vdEJvbmRlZFRva2VucykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5ib25kZWRUb2tlbnMgPSAoX2IgPSBvYmplY3QuYm9uZGVkVG9rZW5zKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHRvVGltZXN0YW1wKGRhdGUpIHtcbiAgICBjb25zdCBzZWNvbmRzID0gTWF0aC50cnVuYyhkYXRlLmdldFRpbWUoKSAvIDEwMDApLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgbmFub3MgPSAoZGF0ZS5nZXRUaW1lKCkgJSAxMDAwKSAqIDEwMDAwMDA7XG4gICAgcmV0dXJuIHsgc2Vjb25kcywgbmFub3MgfTtcbn1cbmZ1bmN0aW9uIGZyb21UaW1lc3RhbXAodCkge1xuICAgIGxldCBtaWxsaXMgPSBOdW1iZXIodC5zZWNvbmRzKSAqIDEwMDA7XG4gICAgbWlsbGlzICs9IHQubmFub3MgLyAxMDAwMDAwO1xuICAgIHJldHVybiBuZXcgRGF0ZShtaWxsaXMpO1xufVxuZnVuY3Rpb24gZnJvbUpzb25UaW1lc3RhbXAobykge1xuICAgIGlmIChvIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gbztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG8pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZyb21UaW1lc3RhbXAodGltZXN0YW1wXzEuVGltZXN0YW1wLmZyb21KU09OKG8pKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsb25nVG9TdHJpbmcobG9uZykge1xuICAgIHJldHVybiBsb25nLnRvU3RyaW5nKCk7XG59XG5pZiAobWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nICE9PSBsb25nXzEuZGVmYXVsdCkge1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyA9IGxvbmdfMS5kZWZhdWx0O1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YWtpbmcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/staking.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/tx.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/tx.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MsgUndelegateResponse = exports.MsgUndelegate = exports.MsgBeginRedelegateResponse = exports.MsgBeginRedelegate = exports.MsgDelegateResponse = exports.MsgDelegate = exports.MsgEditValidatorResponse = exports.MsgEditValidator = exports.MsgCreateValidatorResponse = exports.MsgCreateValidator = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nconst timestamp_1 = __webpack_require__(/*! ../../../google/protobuf/timestamp */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/timestamp.js\");\nconst staking_1 = __webpack_require__(/*! ../../../cosmos/staking/v1beta1/staking */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/staking.js\");\nconst any_1 = __webpack_require__(/*! ../../../google/protobuf/any */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/any.js\");\nconst coin_1 = __webpack_require__(/*! ../../../cosmos/base/v1beta1/coin */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/base/v1beta1/coin.js\");\nexports.protobufPackage = \"cosmos.staking.v1beta1\";\nfunction createBaseMsgCreateValidator() {\n    return {\n        description: undefined,\n        commission: undefined,\n        minSelfDelegation: \"\",\n        delegatorAddress: \"\",\n        validatorAddress: \"\",\n        pubkey: undefined,\n        value: undefined,\n    };\n}\nexports.MsgCreateValidator = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.description !== undefined) {\n            staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.commission !== undefined) {\n            staking_1.CommissionRates.encode(message.commission, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.minSelfDelegation !== \"\") {\n            writer.uint32(26).string(message.minSelfDelegation);\n        }\n        if (message.delegatorAddress !== \"\") {\n            writer.uint32(34).string(message.delegatorAddress);\n        }\n        if (message.validatorAddress !== \"\") {\n            writer.uint32(42).string(message.validatorAddress);\n        }\n        if (message.pubkey !== undefined) {\n            any_1.Any.encode(message.pubkey, writer.uint32(50).fork()).ldelim();\n        }\n        if (message.value !== undefined) {\n            coin_1.Coin.encode(message.value, writer.uint32(58).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgCreateValidator();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.description = staking_1.Description.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.commission = staking_1.CommissionRates.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.minSelfDelegation = reader.string();\n                    break;\n                case 4:\n                    message.delegatorAddress = reader.string();\n                    break;\n                case 5:\n                    message.validatorAddress = reader.string();\n                    break;\n                case 6:\n                    message.pubkey = any_1.Any.decode(reader, reader.uint32());\n                    break;\n                case 7:\n                    message.value = coin_1.Coin.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            description: isSet(object.description)\n                ? staking_1.Description.fromJSON(object.description)\n                : undefined,\n            commission: isSet(object.commission)\n                ? staking_1.CommissionRates.fromJSON(object.commission)\n                : undefined,\n            minSelfDelegation: isSet(object.minSelfDelegation)\n                ? String(object.minSelfDelegation)\n                : \"\",\n            delegatorAddress: isSet(object.delegatorAddress)\n                ? String(object.delegatorAddress)\n                : \"\",\n            validatorAddress: isSet(object.validatorAddress)\n                ? String(object.validatorAddress)\n                : \"\",\n            pubkey: isSet(object.pubkey) ? any_1.Any.fromJSON(object.pubkey) : undefined,\n            value: isSet(object.value) ? coin_1.Coin.fromJSON(object.value) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.description !== undefined &&\n            (obj.description = message.description\n                ? staking_1.Description.toJSON(message.description)\n                : undefined);\n        message.commission !== undefined &&\n            (obj.commission = message.commission\n                ? staking_1.CommissionRates.toJSON(message.commission)\n                : undefined);\n        message.minSelfDelegation !== undefined &&\n            (obj.minSelfDelegation = message.minSelfDelegation);\n        message.delegatorAddress !== undefined &&\n            (obj.delegatorAddress = message.delegatorAddress);\n        message.validatorAddress !== undefined &&\n            (obj.validatorAddress = message.validatorAddress);\n        message.pubkey !== undefined &&\n            (obj.pubkey = message.pubkey ? any_1.Any.toJSON(message.pubkey) : undefined);\n        message.value !== undefined &&\n            (obj.value = message.value ? coin_1.Coin.toJSON(message.value) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseMsgCreateValidator();\n        message.description =\n            object.description !== undefined && object.description !== null\n                ? staking_1.Description.fromPartial(object.description)\n                : undefined;\n        message.commission =\n            object.commission !== undefined && object.commission !== null\n                ? staking_1.CommissionRates.fromPartial(object.commission)\n                : undefined;\n        message.minSelfDelegation = (_a = object.minSelfDelegation) !== null && _a !== void 0 ? _a : \"\";\n        message.delegatorAddress = (_b = object.delegatorAddress) !== null && _b !== void 0 ? _b : \"\";\n        message.validatorAddress = (_c = object.validatorAddress) !== null && _c !== void 0 ? _c : \"\";\n        message.pubkey =\n            object.pubkey !== undefined && object.pubkey !== null\n                ? any_1.Any.fromPartial(object.pubkey)\n                : undefined;\n        message.value =\n            object.value !== undefined && object.value !== null\n                ? coin_1.Coin.fromPartial(object.value)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseMsgCreateValidatorResponse() {\n    return {};\n}\nexports.MsgCreateValidatorResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgCreateValidatorResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgCreateValidatorResponse();\n        return message;\n    },\n};\nfunction createBaseMsgEditValidator() {\n    return {\n        description: undefined,\n        validatorAddress: \"\",\n        commissionRate: \"\",\n        minSelfDelegation: \"\",\n    };\n}\nexports.MsgEditValidator = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.description !== undefined) {\n            staking_1.Description.encode(message.description, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.validatorAddress !== \"\") {\n            writer.uint32(18).string(message.validatorAddress);\n        }\n        if (message.commissionRate !== \"\") {\n            writer.uint32(26).string(message.commissionRate);\n        }\n        if (message.minSelfDelegation !== \"\") {\n            writer.uint32(34).string(message.minSelfDelegation);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgEditValidator();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.description = staking_1.Description.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.validatorAddress = reader.string();\n                    break;\n                case 3:\n                    message.commissionRate = reader.string();\n                    break;\n                case 4:\n                    message.minSelfDelegation = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            description: isSet(object.description)\n                ? staking_1.Description.fromJSON(object.description)\n                : undefined,\n            validatorAddress: isSet(object.validatorAddress)\n                ? String(object.validatorAddress)\n                : \"\",\n            commissionRate: isSet(object.commissionRate)\n                ? String(object.commissionRate)\n                : \"\",\n            minSelfDelegation: isSet(object.minSelfDelegation)\n                ? String(object.minSelfDelegation)\n                : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.description !== undefined &&\n            (obj.description = message.description\n                ? staking_1.Description.toJSON(message.description)\n                : undefined);\n        message.validatorAddress !== undefined &&\n            (obj.validatorAddress = message.validatorAddress);\n        message.commissionRate !== undefined &&\n            (obj.commissionRate = message.commissionRate);\n        message.minSelfDelegation !== undefined &&\n            (obj.minSelfDelegation = message.minSelfDelegation);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseMsgEditValidator();\n        message.description =\n            object.description !== undefined && object.description !== null\n                ? staking_1.Description.fromPartial(object.description)\n                : undefined;\n        message.validatorAddress = (_a = object.validatorAddress) !== null && _a !== void 0 ? _a : \"\";\n        message.commissionRate = (_b = object.commissionRate) !== null && _b !== void 0 ? _b : \"\";\n        message.minSelfDelegation = (_c = object.minSelfDelegation) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBaseMsgEditValidatorResponse() {\n    return {};\n}\nexports.MsgEditValidatorResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgEditValidatorResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgEditValidatorResponse();\n        return message;\n    },\n};\nfunction createBaseMsgDelegate() {\n    return { delegatorAddress: \"\", validatorAddress: \"\", amount: undefined };\n}\nexports.MsgDelegate = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.delegatorAddress !== \"\") {\n            writer.uint32(10).string(message.delegatorAddress);\n        }\n        if (message.validatorAddress !== \"\") {\n            writer.uint32(18).string(message.validatorAddress);\n        }\n        if (message.amount !== undefined) {\n            coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgDelegate();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.delegatorAddress = reader.string();\n                    break;\n                case 2:\n                    message.validatorAddress = reader.string();\n                    break;\n                case 3:\n                    message.amount = coin_1.Coin.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            delegatorAddress: isSet(object.delegatorAddress)\n                ? String(object.delegatorAddress)\n                : \"\",\n            validatorAddress: isSet(object.validatorAddress)\n                ? String(object.validatorAddress)\n                : \"\",\n            amount: isSet(object.amount) ? coin_1.Coin.fromJSON(object.amount) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.delegatorAddress !== undefined &&\n            (obj.delegatorAddress = message.delegatorAddress);\n        message.validatorAddress !== undefined &&\n            (obj.validatorAddress = message.validatorAddress);\n        message.amount !== undefined &&\n            (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseMsgDelegate();\n        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : \"\";\n        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : \"\";\n        message.amount =\n            object.amount !== undefined && object.amount !== null\n                ? coin_1.Coin.fromPartial(object.amount)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseMsgDelegateResponse() {\n    return {};\n}\nexports.MsgDelegateResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgDelegateResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgDelegateResponse();\n        return message;\n    },\n};\nfunction createBaseMsgBeginRedelegate() {\n    return {\n        delegatorAddress: \"\",\n        validatorSrcAddress: \"\",\n        validatorDstAddress: \"\",\n        amount: undefined,\n    };\n}\nexports.MsgBeginRedelegate = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.delegatorAddress !== \"\") {\n            writer.uint32(10).string(message.delegatorAddress);\n        }\n        if (message.validatorSrcAddress !== \"\") {\n            writer.uint32(18).string(message.validatorSrcAddress);\n        }\n        if (message.validatorDstAddress !== \"\") {\n            writer.uint32(26).string(message.validatorDstAddress);\n        }\n        if (message.amount !== undefined) {\n            coin_1.Coin.encode(message.amount, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgBeginRedelegate();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.delegatorAddress = reader.string();\n                    break;\n                case 2:\n                    message.validatorSrcAddress = reader.string();\n                    break;\n                case 3:\n                    message.validatorDstAddress = reader.string();\n                    break;\n                case 4:\n                    message.amount = coin_1.Coin.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            delegatorAddress: isSet(object.delegatorAddress)\n                ? String(object.delegatorAddress)\n                : \"\",\n            validatorSrcAddress: isSet(object.validatorSrcAddress)\n                ? String(object.validatorSrcAddress)\n                : \"\",\n            validatorDstAddress: isSet(object.validatorDstAddress)\n                ? String(object.validatorDstAddress)\n                : \"\",\n            amount: isSet(object.amount) ? coin_1.Coin.fromJSON(object.amount) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.delegatorAddress !== undefined &&\n            (obj.delegatorAddress = message.delegatorAddress);\n        message.validatorSrcAddress !== undefined &&\n            (obj.validatorSrcAddress = message.validatorSrcAddress);\n        message.validatorDstAddress !== undefined &&\n            (obj.validatorDstAddress = message.validatorDstAddress);\n        message.amount !== undefined &&\n            (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseMsgBeginRedelegate();\n        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : \"\";\n        message.validatorSrcAddress = (_b = object.validatorSrcAddress) !== null && _b !== void 0 ? _b : \"\";\n        message.validatorDstAddress = (_c = object.validatorDstAddress) !== null && _c !== void 0 ? _c : \"\";\n        message.amount =\n            object.amount !== undefined && object.amount !== null\n                ? coin_1.Coin.fromPartial(object.amount)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseMsgBeginRedelegateResponse() {\n    return { completionTime: undefined };\n}\nexports.MsgBeginRedelegateResponse = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.completionTime !== undefined) {\n            timestamp_1.Timestamp.encode(toTimestamp(message.completionTime), writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgBeginRedelegateResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.completionTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            completionTime: isSet(object.completionTime)\n                ? fromJsonTimestamp(object.completionTime)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.completionTime !== undefined &&\n            (obj.completionTime = message.completionTime.toISOString());\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseMsgBeginRedelegateResponse();\n        message.completionTime = (_a = object.completionTime) !== null && _a !== void 0 ? _a : undefined;\n        return message;\n    },\n};\nfunction createBaseMsgUndelegate() {\n    return { delegatorAddress: \"\", validatorAddress: \"\", amount: undefined };\n}\nexports.MsgUndelegate = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.delegatorAddress !== \"\") {\n            writer.uint32(10).string(message.delegatorAddress);\n        }\n        if (message.validatorAddress !== \"\") {\n            writer.uint32(18).string(message.validatorAddress);\n        }\n        if (message.amount !== undefined) {\n            coin_1.Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgUndelegate();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.delegatorAddress = reader.string();\n                    break;\n                case 2:\n                    message.validatorAddress = reader.string();\n                    break;\n                case 3:\n                    message.amount = coin_1.Coin.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            delegatorAddress: isSet(object.delegatorAddress)\n                ? String(object.delegatorAddress)\n                : \"\",\n            validatorAddress: isSet(object.validatorAddress)\n                ? String(object.validatorAddress)\n                : \"\",\n            amount: isSet(object.amount) ? coin_1.Coin.fromJSON(object.amount) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.delegatorAddress !== undefined &&\n            (obj.delegatorAddress = message.delegatorAddress);\n        message.validatorAddress !== undefined &&\n            (obj.validatorAddress = message.validatorAddress);\n        message.amount !== undefined &&\n            (obj.amount = message.amount ? coin_1.Coin.toJSON(message.amount) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseMsgUndelegate();\n        message.delegatorAddress = (_a = object.delegatorAddress) !== null && _a !== void 0 ? _a : \"\";\n        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : \"\";\n        message.amount =\n            object.amount !== undefined && object.amount !== null\n                ? coin_1.Coin.fromPartial(object.amount)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseMsgUndelegateResponse() {\n    return { completionTime: undefined };\n}\nexports.MsgUndelegateResponse = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.completionTime !== undefined) {\n            timestamp_1.Timestamp.encode(toTimestamp(message.completionTime), writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgUndelegateResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.completionTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            completionTime: isSet(object.completionTime)\n                ? fromJsonTimestamp(object.completionTime)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.completionTime !== undefined &&\n            (obj.completionTime = message.completionTime.toISOString());\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseMsgUndelegateResponse();\n        message.completionTime = (_a = object.completionTime) !== null && _a !== void 0 ? _a : undefined;\n        return message;\n    },\n};\nfunction toTimestamp(date) {\n    const seconds = Math.trunc(date.getTime() / 1000).toString();\n    const nanos = (date.getTime() % 1000) * 1000000;\n    return { seconds, nanos };\n}\nfunction fromTimestamp(t) {\n    let millis = Number(t.seconds) * 1000;\n    millis += t.nanos / 1000000;\n    return new Date(millis);\n}\nfunction fromJsonTimestamp(o) {\n    if (o instanceof Date) {\n        return o;\n    }\n    else if (typeof o === \"string\") {\n        return new Date(o);\n    }\n    else {\n        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));\n    }\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=tx.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3Mvc3Rha2luZy92MWJldGExL3R4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcscUJBQXFCLEdBQUcsa0NBQWtDLEdBQUcsMEJBQTBCLEdBQUcsMkJBQTJCLEdBQUcsbUJBQW1CLEdBQUcsZ0NBQWdDLEdBQUcsd0JBQXdCLEdBQUcsa0NBQWtDLEdBQUcsMEJBQTBCLEdBQUcsdUJBQXVCO0FBQ3JVO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMsbURBQU07QUFDN0Msa0NBQWtDLG1CQUFPLENBQUMsc0VBQW9CO0FBQzlELG9CQUFvQixtQkFBTyxDQUFDLHVIQUFvQztBQUNoRSxrQkFBa0IsbUJBQU8sQ0FBQyxpSUFBeUM7QUFDbkUsY0FBYyxtQkFBTyxDQUFDLDJHQUE4QjtBQUNwRCxlQUFlLG1CQUFPLENBQUMscUhBQW1DO0FBQzFELHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3Mvc3Rha2luZy92MWJldGExL3R4LmpzP2Q0MmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1zZ1VuZGVsZWdhdGVSZXNwb25zZSA9IGV4cG9ydHMuTXNnVW5kZWxlZ2F0ZSA9IGV4cG9ydHMuTXNnQmVnaW5SZWRlbGVnYXRlUmVzcG9uc2UgPSBleHBvcnRzLk1zZ0JlZ2luUmVkZWxlZ2F0ZSA9IGV4cG9ydHMuTXNnRGVsZWdhdGVSZXNwb25zZSA9IGV4cG9ydHMuTXNnRGVsZWdhdGUgPSBleHBvcnRzLk1zZ0VkaXRWYWxpZGF0b3JSZXNwb25zZSA9IGV4cG9ydHMuTXNnRWRpdFZhbGlkYXRvciA9IGV4cG9ydHMuTXNnQ3JlYXRlVmFsaWRhdG9yUmVzcG9uc2UgPSBleHBvcnRzLk1zZ0NyZWF0ZVZhbGlkYXRvciA9IGV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGxvbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9uZ1wiKSk7XG5jb25zdCBtaW5pbWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKSk7XG5jb25zdCB0aW1lc3RhbXBfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9nb29nbGUvcHJvdG9idWYvdGltZXN0YW1wXCIpO1xuY29uc3Qgc3Rha2luZ18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2Nvc21vcy9zdGFraW5nL3YxYmV0YTEvc3Rha2luZ1wiKTtcbmNvbnN0IGFueV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2dvb2dsZS9wcm90b2J1Zi9hbnlcIik7XG5jb25zdCBjb2luXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29zbW9zL2Jhc2UvdjFiZXRhMS9jb2luXCIpO1xuZXhwb3J0cy5wcm90b2J1ZlBhY2thZ2UgPSBcImNvc21vcy5zdGFraW5nLnYxYmV0YTFcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dDcmVhdGVWYWxpZGF0b3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVzY3JpcHRpb246IHVuZGVmaW5lZCxcbiAgICAgICAgY29tbWlzc2lvbjogdW5kZWZpbmVkLFxuICAgICAgICBtaW5TZWxmRGVsZWdhdGlvbjogXCJcIixcbiAgICAgICAgZGVsZWdhdG9yQWRkcmVzczogXCJcIixcbiAgICAgICAgdmFsaWRhdG9yQWRkcmVzczogXCJcIixcbiAgICAgICAgcHVia2V5OiB1bmRlZmluZWQsXG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydHMuTXNnQ3JlYXRlVmFsaWRhdG9yID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3Rha2luZ18xLkRlc2NyaXB0aW9uLmVuY29kZShtZXNzYWdlLmRlc2NyaXB0aW9uLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbW1pc3Npb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3Rha2luZ18xLkNvbW1pc3Npb25SYXRlcy5lbmNvZGUobWVzc2FnZS5jb21taXNzaW9uLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm1pblNlbGZEZWxlZ2F0aW9uICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5zdHJpbmcobWVzc2FnZS5taW5TZWxmRGVsZWdhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzNCkuc3RyaW5nKG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig0Mikuc3RyaW5nKG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucHVia2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFueV8xLkFueS5lbmNvZGUobWVzc2FnZS5wdWJrZXksIHdyaXRlci51aW50MzIoNTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29pbl8xLkNvaW4uZW5jb2RlKG1lc3NhZ2UudmFsdWUsIHdyaXRlci51aW50MzIoNTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnQ3JlYXRlVmFsaWRhdG9yKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kZXNjcmlwdGlvbiA9IHN0YWtpbmdfMS5EZXNjcmlwdGlvbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29tbWlzc2lvbiA9IHN0YWtpbmdfMS5Db21taXNzaW9uUmF0ZXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1pblNlbGZEZWxlZ2F0aW9uID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wdWJrZXkgPSBhbnlfMS5BbnkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlID0gY29pbl8xLkNvaW4uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IGlzU2V0KG9iamVjdC5kZXNjcmlwdGlvbilcbiAgICAgICAgICAgICAgICA/IHN0YWtpbmdfMS5EZXNjcmlwdGlvbi5mcm9tSlNPTihvYmplY3QuZGVzY3JpcHRpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb21taXNzaW9uOiBpc1NldChvYmplY3QuY29tbWlzc2lvbilcbiAgICAgICAgICAgICAgICA/IHN0YWtpbmdfMS5Db21taXNzaW9uUmF0ZXMuZnJvbUpTT04ob2JqZWN0LmNvbW1pc3Npb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBtaW5TZWxmRGVsZWdhdGlvbjogaXNTZXQob2JqZWN0Lm1pblNlbGZEZWxlZ2F0aW9uKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC5taW5TZWxmRGVsZWdhdGlvbilcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICBkZWxlZ2F0b3JBZGRyZXNzOiBpc1NldChvYmplY3QuZGVsZWdhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QuZGVsZWdhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICB2YWxpZGF0b3JBZGRyZXNzOiBpc1NldChvYmplY3QudmFsaWRhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QudmFsaWRhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICBwdWJrZXk6IGlzU2V0KG9iamVjdC5wdWJrZXkpID8gYW55XzEuQW55LmZyb21KU09OKG9iamVjdC5wdWJrZXkpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdmFsdWU6IGlzU2V0KG9iamVjdC52YWx1ZSkgPyBjb2luXzEuQ29pbi5mcm9tSlNPTihvYmplY3QudmFsdWUpIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5kZXNjcmlwdGlvbiA9IG1lc3NhZ2UuZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICA/IHN0YWtpbmdfMS5EZXNjcmlwdGlvbi50b0pTT04obWVzc2FnZS5kZXNjcmlwdGlvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuY29tbWlzc2lvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNvbW1pc3Npb24gPSBtZXNzYWdlLmNvbW1pc3Npb25cbiAgICAgICAgICAgICAgICA/IHN0YWtpbmdfMS5Db21taXNzaW9uUmF0ZXMudG9KU09OKG1lc3NhZ2UuY29tbWlzc2lvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UubWluU2VsZkRlbGVnYXRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5taW5TZWxmRGVsZWdhdGlvbiA9IG1lc3NhZ2UubWluU2VsZkRlbGVnYXRpb24pO1xuICAgICAgICBtZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5kZWxlZ2F0b3JBZGRyZXNzID0gbWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzKTtcbiAgICAgICAgbWVzc2FnZS52YWxpZGF0b3JBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudmFsaWRhdG9yQWRkcmVzcyA9IG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyk7XG4gICAgICAgIG1lc3NhZ2UucHVia2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucHVia2V5ID0gbWVzc2FnZS5wdWJrZXkgPyBhbnlfMS5BbnkudG9KU09OKG1lc3NhZ2UucHVia2V5KSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UudmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52YWx1ZSA9IG1lc3NhZ2UudmFsdWUgPyBjb2luXzEuQ29pbi50b0pTT04obWVzc2FnZS52YWx1ZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ0NyZWF0ZVZhbGlkYXRvcigpO1xuICAgICAgICBtZXNzYWdlLmRlc2NyaXB0aW9uID1cbiAgICAgICAgICAgIG9iamVjdC5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5kZXNjcmlwdGlvbiAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gc3Rha2luZ18xLkRlc2NyaXB0aW9uLmZyb21QYXJ0aWFsKG9iamVjdC5kZXNjcmlwdGlvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5jb21taXNzaW9uID1cbiAgICAgICAgICAgIG9iamVjdC5jb21taXNzaW9uICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNvbW1pc3Npb24gIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IHN0YWtpbmdfMS5Db21taXNzaW9uUmF0ZXMuZnJvbVBhcnRpYWwob2JqZWN0LmNvbW1pc3Npb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UubWluU2VsZkRlbGVnYXRpb24gPSAoX2EgPSBvYmplY3QubWluU2VsZkRlbGVnYXRpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyA9IChfYiA9IG9iamVjdC5kZWxlZ2F0b3JBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MgPSAoX2MgPSBvYmplY3QudmFsaWRhdG9yQWRkcmVzcykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5wdWJrZXkgPVxuICAgICAgICAgICAgb2JqZWN0LnB1YmtleSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wdWJrZXkgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGFueV8xLkFueS5mcm9tUGFydGlhbChvYmplY3QucHVia2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnZhbHVlID1cbiAgICAgICAgICAgIG9iamVjdC52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC52YWx1ZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gY29pbl8xLkNvaW4uZnJvbVBhcnRpYWwob2JqZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dDcmVhdGVWYWxpZGF0b3JSZXNwb25zZSgpIHtcbiAgICByZXR1cm4ge307XG59XG5leHBvcnRzLk1zZ0NyZWF0ZVZhbGlkYXRvclJlc3BvbnNlID0ge1xuICAgIGVuY29kZShfLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnQ3JlYXRlVmFsaWRhdG9yUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKF8pIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH0sXG4gICAgdG9KU09OKF8pIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChfKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnQ3JlYXRlVmFsaWRhdG9yUmVzcG9uc2UoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlTXNnRWRpdFZhbGlkYXRvcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZXNjcmlwdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICB2YWxpZGF0b3JBZGRyZXNzOiBcIlwiLFxuICAgICAgICBjb21taXNzaW9uUmF0ZTogXCJcIixcbiAgICAgICAgbWluU2VsZkRlbGVnYXRpb246IFwiXCIsXG4gICAgfTtcbn1cbmV4cG9ydHMuTXNnRWRpdFZhbGlkYXRvciA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YWtpbmdfMS5EZXNjcmlwdGlvbi5lbmNvZGUobWVzc2FnZS5kZXNjcmlwdGlvbiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52YWxpZGF0b3JBZGRyZXNzICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS52YWxpZGF0b3JBZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb21taXNzaW9uUmF0ZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuc3RyaW5nKG1lc3NhZ2UuY29tbWlzc2lvblJhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm1pblNlbGZEZWxlZ2F0aW9uICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDM0KS5zdHJpbmcobWVzc2FnZS5taW5TZWxmRGVsZWdhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnRWRpdFZhbGlkYXRvcigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVzY3JpcHRpb24gPSBzdGFraW5nXzEuRGVzY3JpcHRpb24uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb21taXNzaW9uUmF0ZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1pblNlbGZEZWxlZ2F0aW9uID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogaXNTZXQob2JqZWN0LmRlc2NyaXB0aW9uKVxuICAgICAgICAgICAgICAgID8gc3Rha2luZ18xLkRlc2NyaXB0aW9uLmZyb21KU09OKG9iamVjdC5kZXNjcmlwdGlvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZhbGlkYXRvckFkZHJlc3M6IGlzU2V0KG9iamVjdC52YWxpZGF0b3JBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC52YWxpZGF0b3JBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIGNvbW1pc3Npb25SYXRlOiBpc1NldChvYmplY3QuY29tbWlzc2lvblJhdGUpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LmNvbW1pc3Npb25SYXRlKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIG1pblNlbGZEZWxlZ2F0aW9uOiBpc1NldChvYmplY3QubWluU2VsZkRlbGVnYXRpb24pXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0Lm1pblNlbGZEZWxlZ2F0aW9uKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZGVzY3JpcHRpb24gPSBtZXNzYWdlLmRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgPyBzdGFraW5nXzEuRGVzY3JpcHRpb24udG9KU09OKG1lc3NhZ2UuZGVzY3JpcHRpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52YWxpZGF0b3JBZGRyZXNzID0gbWVzc2FnZS52YWxpZGF0b3JBZGRyZXNzKTtcbiAgICAgICAgbWVzc2FnZS5jb21taXNzaW9uUmF0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNvbW1pc3Npb25SYXRlID0gbWVzc2FnZS5jb21taXNzaW9uUmF0ZSk7XG4gICAgICAgIG1lc3NhZ2UubWluU2VsZkRlbGVnYXRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5taW5TZWxmRGVsZWdhdGlvbiA9IG1lc3NhZ2UubWluU2VsZkRlbGVnYXRpb24pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ0VkaXRWYWxpZGF0b3IoKTtcbiAgICAgICAgbWVzc2FnZS5kZXNjcmlwdGlvbiA9XG4gICAgICAgICAgICBvYmplY3QuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZGVzY3JpcHRpb24gIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IHN0YWtpbmdfMS5EZXNjcmlwdGlvbi5mcm9tUGFydGlhbChvYmplY3QuZGVzY3JpcHRpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyA9IChfYSA9IG9iamVjdC52YWxpZGF0b3JBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmNvbW1pc3Npb25SYXRlID0gKF9iID0gb2JqZWN0LmNvbW1pc3Npb25SYXRlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLm1pblNlbGZEZWxlZ2F0aW9uID0gKF9jID0gb2JqZWN0Lm1pblNlbGZEZWxlZ2F0aW9uKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dFZGl0VmFsaWRhdG9yUmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHt9O1xufVxuZXhwb3J0cy5Nc2dFZGl0VmFsaWRhdG9yUmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKF8sIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dFZGl0VmFsaWRhdG9yUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKF8pIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH0sXG4gICAgdG9KU09OKF8pIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChfKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnRWRpdFZhbGlkYXRvclJlc3BvbnNlKCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ0RlbGVnYXRlKCkge1xuICAgIHJldHVybiB7IGRlbGVnYXRvckFkZHJlc3M6IFwiXCIsIHZhbGlkYXRvckFkZHJlc3M6IFwiXCIsIGFtb3VudDogdW5kZWZpbmVkIH07XG59XG5leHBvcnRzLk1zZ0RlbGVnYXRlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYW1vdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvaW5fMS5Db2luLmVuY29kZShtZXNzYWdlLmFtb3VudCwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dEZWxlZ2F0ZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hbW91bnQgPSBjb2luXzEuQ29pbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxlZ2F0b3JBZGRyZXNzOiBpc1NldChvYmplY3QuZGVsZWdhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QuZGVsZWdhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICB2YWxpZGF0b3JBZGRyZXNzOiBpc1NldChvYmplY3QudmFsaWRhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QudmFsaWRhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICBhbW91bnQ6IGlzU2V0KG9iamVjdC5hbW91bnQpID8gY29pbl8xLkNvaW4uZnJvbUpTT04ob2JqZWN0LmFtb3VudCkgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZGVsZWdhdG9yQWRkcmVzcyA9IG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyk7XG4gICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnZhbGlkYXRvckFkZHJlc3MgPSBtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MpO1xuICAgICAgICBtZXNzYWdlLmFtb3VudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmFtb3VudCA9IG1lc3NhZ2UuYW1vdW50ID8gY29pbl8xLkNvaW4udG9KU09OKG1lc3NhZ2UuYW1vdW50KSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dEZWxlZ2F0ZSgpO1xuICAgICAgICBtZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MgPSAoX2EgPSBvYmplY3QuZGVsZWdhdG9yQWRkcmVzcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS52YWxpZGF0b3JBZGRyZXNzID0gKF9iID0gb2JqZWN0LnZhbGlkYXRvckFkZHJlc3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuYW1vdW50ID1cbiAgICAgICAgICAgIG9iamVjdC5hbW91bnQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuYW1vdW50ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBjb2luXzEuQ29pbi5mcm9tUGFydGlhbChvYmplY3QuYW1vdW50KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dEZWxlZ2F0ZVJlc3BvbnNlKCkge1xuICAgIHJldHVybiB7fTtcbn1cbmV4cG9ydHMuTXNnRGVsZWdhdGVSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUoXywgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ0RlbGVnYXRlUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKF8pIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH0sXG4gICAgdG9KU09OKF8pIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChfKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnRGVsZWdhdGVSZXNwb25zZSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dCZWdpblJlZGVsZWdhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsZWdhdG9yQWRkcmVzczogXCJcIixcbiAgICAgICAgdmFsaWRhdG9yU3JjQWRkcmVzczogXCJcIixcbiAgICAgICAgdmFsaWRhdG9yRHN0QWRkcmVzczogXCJcIixcbiAgICAgICAgYW1vdW50OiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydHMuTXNnQmVnaW5SZWRlbGVnYXRlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudmFsaWRhdG9yU3JjQWRkcmVzcyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UudmFsaWRhdG9yU3JjQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudmFsaWRhdG9yRHN0QWRkcmVzcyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuc3RyaW5nKG1lc3NhZ2UudmFsaWRhdG9yRHN0QWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYW1vdW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvaW5fMS5Db2luLmVuY29kZShtZXNzYWdlLmFtb3VudCwgd3JpdGVyLnVpbnQzMigzNCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dCZWdpblJlZGVsZWdhdGUoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWxpZGF0b3JTcmNBZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yRHN0QWRkcmVzcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFtb3VudCA9IGNvaW5fMS5Db2luLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGVnYXRvckFkZHJlc3M6IGlzU2V0KG9iamVjdC5kZWxlZ2F0b3JBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC5kZWxlZ2F0b3JBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIHZhbGlkYXRvclNyY0FkZHJlc3M6IGlzU2V0KG9iamVjdC52YWxpZGF0b3JTcmNBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC52YWxpZGF0b3JTcmNBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIHZhbGlkYXRvckRzdEFkZHJlc3M6IGlzU2V0KG9iamVjdC52YWxpZGF0b3JEc3RBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC52YWxpZGF0b3JEc3RBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogXCJcIixcbiAgICAgICAgICAgIGFtb3VudDogaXNTZXQob2JqZWN0LmFtb3VudCkgPyBjb2luXzEuQ29pbi5mcm9tSlNPTihvYmplY3QuYW1vdW50KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5kZWxlZ2F0b3JBZGRyZXNzID0gbWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzKTtcbiAgICAgICAgbWVzc2FnZS52YWxpZGF0b3JTcmNBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudmFsaWRhdG9yU3JjQWRkcmVzcyA9IG1lc3NhZ2UudmFsaWRhdG9yU3JjQWRkcmVzcyk7XG4gICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yRHN0QWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnZhbGlkYXRvckRzdEFkZHJlc3MgPSBtZXNzYWdlLnZhbGlkYXRvckRzdEFkZHJlc3MpO1xuICAgICAgICBtZXNzYWdlLmFtb3VudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmFtb3VudCA9IG1lc3NhZ2UuYW1vdW50ID8gY29pbl8xLkNvaW4udG9KU09OKG1lc3NhZ2UuYW1vdW50KSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnQmVnaW5SZWRlbGVnYXRlKCk7XG4gICAgICAgIG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyA9IChfYSA9IG9iamVjdC5kZWxlZ2F0b3JBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnZhbGlkYXRvclNyY0FkZHJlc3MgPSAoX2IgPSBvYmplY3QudmFsaWRhdG9yU3JjQWRkcmVzcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS52YWxpZGF0b3JEc3RBZGRyZXNzID0gKF9jID0gb2JqZWN0LnZhbGlkYXRvckRzdEFkZHJlc3MpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuYW1vdW50ID1cbiAgICAgICAgICAgIG9iamVjdC5hbW91bnQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuYW1vdW50ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBjb2luXzEuQ29pbi5mcm9tUGFydGlhbChvYmplY3QuYW1vdW50KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dCZWdpblJlZGVsZWdhdGVSZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyBjb21wbGV0aW9uVGltZTogdW5kZWZpbmVkIH07XG59XG5leHBvcnRzLk1zZ0JlZ2luUmVkZWxlZ2F0ZVJlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuY29tcGxldGlvblRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGltZXN0YW1wXzEuVGltZXN0YW1wLmVuY29kZSh0b1RpbWVzdGFtcChtZXNzYWdlLmNvbXBsZXRpb25UaW1lKSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dCZWdpblJlZGVsZWdhdGVSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29tcGxldGlvblRpbWUgPSBmcm9tVGltZXN0YW1wKHRpbWVzdGFtcF8xLlRpbWVzdGFtcC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tcGxldGlvblRpbWU6IGlzU2V0KG9iamVjdC5jb21wbGV0aW9uVGltZSlcbiAgICAgICAgICAgICAgICA/IGZyb21Kc29uVGltZXN0YW1wKG9iamVjdC5jb21wbGV0aW9uVGltZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmNvbXBsZXRpb25UaW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY29tcGxldGlvblRpbWUgPSBtZXNzYWdlLmNvbXBsZXRpb25UaW1lLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dCZWdpblJlZGVsZWdhdGVSZXNwb25zZSgpO1xuICAgICAgICBtZXNzYWdlLmNvbXBsZXRpb25UaW1lID0gKF9hID0gb2JqZWN0LmNvbXBsZXRpb25UaW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ1VuZGVsZWdhdGUoKSB7XG4gICAgcmV0dXJuIHsgZGVsZWdhdG9yQWRkcmVzczogXCJcIiwgdmFsaWRhdG9yQWRkcmVzczogXCJcIiwgYW1vdW50OiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydHMuTXNnVW5kZWxlZ2F0ZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmRlbGVnYXRvckFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmFtb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb2luXzEuQ29pbi5lbmNvZGUobWVzc2FnZS5hbW91bnQsIHdyaXRlci51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnVW5kZWxlZ2F0ZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hbW91bnQgPSBjb2luXzEuQ29pbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWxlZ2F0b3JBZGRyZXNzOiBpc1NldChvYmplY3QuZGVsZWdhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QuZGVsZWdhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICB2YWxpZGF0b3JBZGRyZXNzOiBpc1NldChvYmplY3QudmFsaWRhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QudmFsaWRhdG9yQWRkcmVzcylcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICBhbW91bnQ6IGlzU2V0KG9iamVjdC5hbW91bnQpID8gY29pbl8xLkNvaW4uZnJvbUpTT04ob2JqZWN0LmFtb3VudCkgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5kZWxlZ2F0b3JBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZGVsZWdhdG9yQWRkcmVzcyA9IG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyk7XG4gICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnZhbGlkYXRvckFkZHJlc3MgPSBtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MpO1xuICAgICAgICBtZXNzYWdlLmFtb3VudCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmFtb3VudCA9IG1lc3NhZ2UuYW1vdW50ID8gY29pbl8xLkNvaW4udG9KU09OKG1lc3NhZ2UuYW1vdW50KSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dVbmRlbGVnYXRlKCk7XG4gICAgICAgIG1lc3NhZ2UuZGVsZWdhdG9yQWRkcmVzcyA9IChfYSA9IG9iamVjdC5kZWxlZ2F0b3JBZGRyZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MgPSAoX2IgPSBvYmplY3QudmFsaWRhdG9yQWRkcmVzcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5hbW91bnQgPVxuICAgICAgICAgICAgb2JqZWN0LmFtb3VudCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5hbW91bnQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGNvaW5fMS5Db2luLmZyb21QYXJ0aWFsKG9iamVjdC5hbW91bnQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ1VuZGVsZWdhdGVSZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyBjb21wbGV0aW9uVGltZTogdW5kZWZpbmVkIH07XG59XG5leHBvcnRzLk1zZ1VuZGVsZWdhdGVSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbXBsZXRpb25UaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcF8xLlRpbWVzdGFtcC5lbmNvZGUodG9UaW1lc3RhbXAobWVzc2FnZS5jb21wbGV0aW9uVGltZSksIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnVW5kZWxlZ2F0ZVJlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb21wbGV0aW9uVGltZSA9IGZyb21UaW1lc3RhbXAodGltZXN0YW1wXzEuVGltZXN0YW1wLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21wbGV0aW9uVGltZTogaXNTZXQob2JqZWN0LmNvbXBsZXRpb25UaW1lKVxuICAgICAgICAgICAgICAgID8gZnJvbUpzb25UaW1lc3RhbXAob2JqZWN0LmNvbXBsZXRpb25UaW1lKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuY29tcGxldGlvblRpbWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jb21wbGV0aW9uVGltZSA9IG1lc3NhZ2UuY29tcGxldGlvblRpbWUudG9JU09TdHJpbmcoKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ1VuZGVsZWdhdGVSZXNwb25zZSgpO1xuICAgICAgICBtZXNzYWdlLmNvbXBsZXRpb25UaW1lID0gKF9hID0gb2JqZWN0LmNvbXBsZXRpb25UaW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gdG9UaW1lc3RhbXAoZGF0ZSkge1xuICAgIGNvbnN0IHNlY29uZHMgPSBNYXRoLnRydW5jKGRhdGUuZ2V0VGltZSgpIC8gMTAwMCkudG9TdHJpbmcoKTtcbiAgICBjb25zdCBuYW5vcyA9IChkYXRlLmdldFRpbWUoKSAlIDEwMDApICogMTAwMDAwMDtcbiAgICByZXR1cm4geyBzZWNvbmRzLCBuYW5vcyB9O1xufVxuZnVuY3Rpb24gZnJvbVRpbWVzdGFtcCh0KSB7XG4gICAgbGV0IG1pbGxpcyA9IE51bWJlcih0LnNlY29uZHMpICogMTAwMDtcbiAgICBtaWxsaXMgKz0gdC5uYW5vcyAvIDEwMDAwMDA7XG4gICAgcmV0dXJuIG5ldyBEYXRlKG1pbGxpcyk7XG59XG5mdW5jdGlvbiBmcm9tSnNvblRpbWVzdGFtcChvKSB7XG4gICAgaWYgKG8gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUobyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZnJvbVRpbWVzdGFtcCh0aW1lc3RhbXBfMS5UaW1lc3RhbXAuZnJvbUpTT04obykpO1xuICAgIH1cbn1cbmlmIChtaW5pbWFsXzEuZGVmYXVsdC51dGlsLkxvbmcgIT09IGxvbmdfMS5kZWZhdWx0KSB7XG4gICAgbWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nID0gbG9uZ18xLmRlZmF1bHQ7XG4gICAgbWluaW1hbF8xLmRlZmF1bHQuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/staking/v1beta1/tx.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/tx/signing/v1beta1/signing.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/cosmos/tx/signing/v1beta1/signing.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SignatureDescriptor_Data_Multi = exports.SignatureDescriptor_Data_Single = exports.SignatureDescriptor_Data = exports.SignatureDescriptor = exports.SignatureDescriptors = exports.signModeToJSON = exports.signModeFromJSON = exports.SignMode = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nconst any_1 = __webpack_require__(/*! ../../../../google/protobuf/any */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/any.js\");\nconst multisig_1 = __webpack_require__(/*! ../../../../cosmos/crypto/multisig/v1beta1/multisig */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/crypto/multisig/v1beta1/multisig.js\");\nexports.protobufPackage = \"cosmos.tx.signing.v1beta1\";\n/** SignMode represents a signing mode with its own security guarantees. */\nvar SignMode;\n(function (SignMode) {\n    /**\n     * SIGN_MODE_UNSPECIFIED - SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\n     * rejected\n     */\n    SignMode[SignMode[\"SIGN_MODE_UNSPECIFIED\"] = 0] = \"SIGN_MODE_UNSPECIFIED\";\n    /**\n     * SIGN_MODE_DIRECT - SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\n     * verified with raw bytes from Tx\n     */\n    SignMode[SignMode[\"SIGN_MODE_DIRECT\"] = 1] = \"SIGN_MODE_DIRECT\";\n    /**\n     * SIGN_MODE_TEXTUAL - SIGN_MODE_TEXTUAL is a future signing mode that will verify some\n     * human-readable textual representation on top of the binary representation\n     * from SIGN_MODE_DIRECT\n     */\n    SignMode[SignMode[\"SIGN_MODE_TEXTUAL\"] = 2] = \"SIGN_MODE_TEXTUAL\";\n    /**\n     * SIGN_MODE_LEGACY_AMINO_JSON - SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\n     * Amino JSON and will be removed in the future\n     */\n    SignMode[SignMode[\"SIGN_MODE_LEGACY_AMINO_JSON\"] = 127] = \"SIGN_MODE_LEGACY_AMINO_JSON\";\n    SignMode[SignMode[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(SignMode = exports.SignMode || (exports.SignMode = {}));\nfunction signModeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"SIGN_MODE_UNSPECIFIED\":\n            return SignMode.SIGN_MODE_UNSPECIFIED;\n        case 1:\n        case \"SIGN_MODE_DIRECT\":\n            return SignMode.SIGN_MODE_DIRECT;\n        case 2:\n        case \"SIGN_MODE_TEXTUAL\":\n            return SignMode.SIGN_MODE_TEXTUAL;\n        case 127:\n        case \"SIGN_MODE_LEGACY_AMINO_JSON\":\n            return SignMode.SIGN_MODE_LEGACY_AMINO_JSON;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return SignMode.UNRECOGNIZED;\n    }\n}\nexports.signModeFromJSON = signModeFromJSON;\nfunction signModeToJSON(object) {\n    switch (object) {\n        case SignMode.SIGN_MODE_UNSPECIFIED:\n            return \"SIGN_MODE_UNSPECIFIED\";\n        case SignMode.SIGN_MODE_DIRECT:\n            return \"SIGN_MODE_DIRECT\";\n        case SignMode.SIGN_MODE_TEXTUAL:\n            return \"SIGN_MODE_TEXTUAL\";\n        case SignMode.SIGN_MODE_LEGACY_AMINO_JSON:\n            return \"SIGN_MODE_LEGACY_AMINO_JSON\";\n        default:\n            return \"UNKNOWN\";\n    }\n}\nexports.signModeToJSON = signModeToJSON;\nfunction createBaseSignatureDescriptors() {\n    return { signatures: [] };\n}\nexports.SignatureDescriptors = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.signatures) {\n            exports.SignatureDescriptor.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignatureDescriptors();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.signatures.push(exports.SignatureDescriptor.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            signatures: Array.isArray(object === null || object === void 0 ? void 0 : object.signatures)\n                ? object.signatures.map((e) => exports.SignatureDescriptor.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.signatures) {\n            obj.signatures = message.signatures.map((e) => e ? exports.SignatureDescriptor.toJSON(e) : undefined);\n        }\n        else {\n            obj.signatures = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSignatureDescriptors();\n        message.signatures =\n            ((_a = object.signatures) === null || _a === void 0 ? void 0 : _a.map((e) => exports.SignatureDescriptor.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseSignatureDescriptor() {\n    return { publicKey: undefined, data: undefined, sequence: \"0\" };\n}\nexports.SignatureDescriptor = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.publicKey !== undefined) {\n            any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.data !== undefined) {\n            exports.SignatureDescriptor_Data.encode(message.data, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.sequence !== \"0\") {\n            writer.uint32(24).uint64(message.sequence);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignatureDescriptor();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.publicKey = any_1.Any.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.data = exports.SignatureDescriptor_Data.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.sequence = longToString(reader.uint64());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            publicKey: isSet(object.publicKey)\n                ? any_1.Any.fromJSON(object.publicKey)\n                : undefined,\n            data: isSet(object.data)\n                ? exports.SignatureDescriptor_Data.fromJSON(object.data)\n                : undefined,\n            sequence: isSet(object.sequence) ? String(object.sequence) : \"0\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.publicKey !== undefined &&\n            (obj.publicKey = message.publicKey\n                ? any_1.Any.toJSON(message.publicKey)\n                : undefined);\n        message.data !== undefined &&\n            (obj.data = message.data\n                ? exports.SignatureDescriptor_Data.toJSON(message.data)\n                : undefined);\n        message.sequence !== undefined && (obj.sequence = message.sequence);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSignatureDescriptor();\n        message.publicKey =\n            object.publicKey !== undefined && object.publicKey !== null\n                ? any_1.Any.fromPartial(object.publicKey)\n                : undefined;\n        message.data =\n            object.data !== undefined && object.data !== null\n                ? exports.SignatureDescriptor_Data.fromPartial(object.data)\n                : undefined;\n        message.sequence = (_a = object.sequence) !== null && _a !== void 0 ? _a : \"0\";\n        return message;\n    },\n};\nfunction createBaseSignatureDescriptor_Data() {\n    return { single: undefined, multi: undefined };\n}\nexports.SignatureDescriptor_Data = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.single !== undefined) {\n            exports.SignatureDescriptor_Data_Single.encode(message.single, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.multi !== undefined) {\n            exports.SignatureDescriptor_Data_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignatureDescriptor_Data();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.single = exports.SignatureDescriptor_Data_Single.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.multi = exports.SignatureDescriptor_Data_Multi.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            single: isSet(object.single)\n                ? exports.SignatureDescriptor_Data_Single.fromJSON(object.single)\n                : undefined,\n            multi: isSet(object.multi)\n                ? exports.SignatureDescriptor_Data_Multi.fromJSON(object.multi)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.single !== undefined &&\n            (obj.single = message.single\n                ? exports.SignatureDescriptor_Data_Single.toJSON(message.single)\n                : undefined);\n        message.multi !== undefined &&\n            (obj.multi = message.multi\n                ? exports.SignatureDescriptor_Data_Multi.toJSON(message.multi)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSignatureDescriptor_Data();\n        message.single =\n            object.single !== undefined && object.single !== null\n                ? exports.SignatureDescriptor_Data_Single.fromPartial(object.single)\n                : undefined;\n        message.multi =\n            object.multi !== undefined && object.multi !== null\n                ? exports.SignatureDescriptor_Data_Multi.fromPartial(object.multi)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSignatureDescriptor_Data_Single() {\n    return { mode: 0, signature: new Uint8Array() };\n}\nexports.SignatureDescriptor_Data_Single = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.mode !== 0) {\n            writer.uint32(8).int32(message.mode);\n        }\n        if (message.signature.length !== 0) {\n            writer.uint32(18).bytes(message.signature);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignatureDescriptor_Data_Single();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.mode = reader.int32();\n                    break;\n                case 2:\n                    message.signature = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            mode: isSet(object.mode) ? signModeFromJSON(object.mode) : 0,\n            signature: isSet(object.signature)\n                ? bytesFromBase64(object.signature)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.mode !== undefined && (obj.mode = signModeToJSON(message.mode));\n        message.signature !== undefined &&\n            (obj.signature = base64FromBytes(message.signature !== undefined ? message.signature : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseSignatureDescriptor_Data_Single();\n        message.mode = (_a = object.mode) !== null && _a !== void 0 ? _a : 0;\n        message.signature = (_b = object.signature) !== null && _b !== void 0 ? _b : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseSignatureDescriptor_Data_Multi() {\n    return { bitarray: undefined, signatures: [] };\n}\nexports.SignatureDescriptor_Data_Multi = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.bitarray !== undefined) {\n            multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.signatures) {\n            exports.SignatureDescriptor_Data.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignatureDescriptor_Data_Multi();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.signatures.push(exports.SignatureDescriptor_Data.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            bitarray: isSet(object.bitarray)\n                ? multisig_1.CompactBitArray.fromJSON(object.bitarray)\n                : undefined,\n            signatures: Array.isArray(object === null || object === void 0 ? void 0 : object.signatures)\n                ? object.signatures.map((e) => exports.SignatureDescriptor_Data.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bitarray !== undefined &&\n            (obj.bitarray = message.bitarray\n                ? multisig_1.CompactBitArray.toJSON(message.bitarray)\n                : undefined);\n        if (message.signatures) {\n            obj.signatures = message.signatures.map((e) => e ? exports.SignatureDescriptor_Data.toJSON(e) : undefined);\n        }\n        else {\n            obj.signatures = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSignatureDescriptor_Data_Multi();\n        message.bitarray =\n            object.bitarray !== undefined && object.bitarray !== null\n                ? multisig_1.CompactBitArray.fromPartial(object.bitarray)\n                : undefined;\n        message.signatures =\n            ((_a = object.signatures) === null || _a === void 0 ? void 0 : _a.map((e) => exports.SignatureDescriptor_Data.fromPartial(e))) ||\n                [];\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob ||\n    ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa ||\n    ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (const byte of arr) {\n        bin.push(String.fromCharCode(byte));\n    }\n    return btoa(bin.join(\"\"));\n}\nfunction longToString(long) {\n    return long.toString();\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=signing.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3MvdHgvc2lnbmluZy92MWJldGExL3NpZ25pbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQ0FBc0MsR0FBRyx1Q0FBdUMsR0FBRyxnQ0FBZ0MsR0FBRywyQkFBMkIsR0FBRyw0QkFBNEIsR0FBRyxzQkFBc0IsR0FBRyx3QkFBd0IsR0FBRyxnQkFBZ0IsR0FBRyx1QkFBdUI7QUFDalI7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyxtREFBTTtBQUM3QyxrQ0FBa0MsbUJBQU8sQ0FBQyxzRUFBb0I7QUFDOUQsY0FBYyxtQkFBTyxDQUFDLDhHQUFpQztBQUN2RCxtQkFBbUIsbUJBQU8sQ0FBQyxzSkFBcUQ7QUFDaEYsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0MsZ0JBQWdCLEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L3Byb3RvLXR5cGVzL2Nvc21vcy90eC9zaWduaW5nL3YxYmV0YTEvc2lnbmluZy5qcz9lM2I2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yX0RhdGFfTXVsdGkgPSBleHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9TaW5nbGUgPSBleHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YSA9IGV4cG9ydHMuU2lnbmF0dXJlRGVzY3JpcHRvciA9IGV4cG9ydHMuU2lnbmF0dXJlRGVzY3JpcHRvcnMgPSBleHBvcnRzLnNpZ25Nb2RlVG9KU09OID0gZXhwb3J0cy5zaWduTW9kZUZyb21KU09OID0gZXhwb3J0cy5TaWduTW9kZSA9IGV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGxvbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9uZ1wiKSk7XG5jb25zdCBtaW5pbWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKSk7XG5jb25zdCBhbnlfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9nb29nbGUvcHJvdG9idWYvYW55XCIpO1xuY29uc3QgbXVsdGlzaWdfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9jb3Ntb3MvY3J5cHRvL211bHRpc2lnL3YxYmV0YTEvbXVsdGlzaWdcIik7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwiY29zbW9zLnR4LnNpZ25pbmcudjFiZXRhMVwiO1xuLyoqIFNpZ25Nb2RlIHJlcHJlc2VudHMgYSBzaWduaW5nIG1vZGUgd2l0aCBpdHMgb3duIHNlY3VyaXR5IGd1YXJhbnRlZXMuICovXG52YXIgU2lnbk1vZGU7XG4oZnVuY3Rpb24gKFNpZ25Nb2RlKSB7XG4gICAgLyoqXG4gICAgICogU0lHTl9NT0RFX1VOU1BFQ0lGSUVEIC0gU0lHTl9NT0RFX1VOU1BFQ0lGSUVEIHNwZWNpZmllcyBhbiB1bmtub3duIHNpZ25pbmcgbW9kZSBhbmQgd2lsbCBiZVxuICAgICAqIHJlamVjdGVkXG4gICAgICovXG4gICAgU2lnbk1vZGVbU2lnbk1vZGVbXCJTSUdOX01PREVfVU5TUEVDSUZJRURcIl0gPSAwXSA9IFwiU0lHTl9NT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogU0lHTl9NT0RFX0RJUkVDVCAtIFNJR05fTU9ERV9ESVJFQ1Qgc3BlY2lmaWVzIGEgc2lnbmluZyBtb2RlIHdoaWNoIHVzZXMgU2lnbkRvYyBhbmQgaXNcbiAgICAgKiB2ZXJpZmllZCB3aXRoIHJhdyBieXRlcyBmcm9tIFR4XG4gICAgICovXG4gICAgU2lnbk1vZGVbU2lnbk1vZGVbXCJTSUdOX01PREVfRElSRUNUXCJdID0gMV0gPSBcIlNJR05fTU9ERV9ESVJFQ1RcIjtcbiAgICAvKipcbiAgICAgKiBTSUdOX01PREVfVEVYVFVBTCAtIFNJR05fTU9ERV9URVhUVUFMIGlzIGEgZnV0dXJlIHNpZ25pbmcgbW9kZSB0aGF0IHdpbGwgdmVyaWZ5IHNvbWVcbiAgICAgKiBodW1hbi1yZWFkYWJsZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9uIHRvcCBvZiB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uXG4gICAgICogZnJvbSBTSUdOX01PREVfRElSRUNUXG4gICAgICovXG4gICAgU2lnbk1vZGVbU2lnbk1vZGVbXCJTSUdOX01PREVfVEVYVFVBTFwiXSA9IDJdID0gXCJTSUdOX01PREVfVEVYVFVBTFwiO1xuICAgIC8qKlxuICAgICAqIFNJR05fTU9ERV9MRUdBQ1lfQU1JTk9fSlNPTiAtIFNJR05fTU9ERV9MRUdBQ1lfQU1JTk9fSlNPTiBpcyBhIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IG1vZGUgd2hpY2ggdXNlc1xuICAgICAqIEFtaW5vIEpTT04gYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlXG4gICAgICovXG4gICAgU2lnbk1vZGVbU2lnbk1vZGVbXCJTSUdOX01PREVfTEVHQUNZX0FNSU5PX0pTT05cIl0gPSAxMjddID0gXCJTSUdOX01PREVfTEVHQUNZX0FNSU5PX0pTT05cIjtcbiAgICBTaWduTW9kZVtTaWduTW9kZVtcIlVOUkVDT0dOSVpFRFwiXSA9IC0xXSA9IFwiVU5SRUNPR05JWkVEXCI7XG59KShTaWduTW9kZSA9IGV4cG9ydHMuU2lnbk1vZGUgfHwgKGV4cG9ydHMuU2lnbk1vZGUgPSB7fSkpO1xuZnVuY3Rpb24gc2lnbk1vZGVGcm9tSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgXCJTSUdOX01PREVfVU5TUEVDSUZJRURcIjpcbiAgICAgICAgICAgIHJldHVybiBTaWduTW9kZS5TSUdOX01PREVfVU5TUEVDSUZJRUQ7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSBcIlNJR05fTU9ERV9ESVJFQ1RcIjpcbiAgICAgICAgICAgIHJldHVybiBTaWduTW9kZS5TSUdOX01PREVfRElSRUNUO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgXCJTSUdOX01PREVfVEVYVFVBTFwiOlxuICAgICAgICAgICAgcmV0dXJuIFNpZ25Nb2RlLlNJR05fTU9ERV9URVhUVUFMO1xuICAgICAgICBjYXNlIDEyNzpcbiAgICAgICAgY2FzZSBcIlNJR05fTU9ERV9MRUdBQ1lfQU1JTk9fSlNPTlwiOlxuICAgICAgICAgICAgcmV0dXJuIFNpZ25Nb2RlLlNJR05fTU9ERV9MRUdBQ1lfQU1JTk9fSlNPTjtcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgY2FzZSBcIlVOUkVDT0dOSVpFRFwiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFNpZ25Nb2RlLlVOUkVDT0dOSVpFRDtcbiAgICB9XG59XG5leHBvcnRzLnNpZ25Nb2RlRnJvbUpTT04gPSBzaWduTW9kZUZyb21KU09OO1xuZnVuY3Rpb24gc2lnbk1vZGVUb0pTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSBTaWduTW9kZS5TSUdOX01PREVfVU5TUEVDSUZJRUQ6XG4gICAgICAgICAgICByZXR1cm4gXCJTSUdOX01PREVfVU5TUEVDSUZJRURcIjtcbiAgICAgICAgY2FzZSBTaWduTW9kZS5TSUdOX01PREVfRElSRUNUOlxuICAgICAgICAgICAgcmV0dXJuIFwiU0lHTl9NT0RFX0RJUkVDVFwiO1xuICAgICAgICBjYXNlIFNpZ25Nb2RlLlNJR05fTU9ERV9URVhUVUFMOlxuICAgICAgICAgICAgcmV0dXJuIFwiU0lHTl9NT0RFX1RFWFRVQUxcIjtcbiAgICAgICAgY2FzZSBTaWduTW9kZS5TSUdOX01PREVfTEVHQUNZX0FNSU5PX0pTT046XG4gICAgICAgICAgICByZXR1cm4gXCJTSUdOX01PREVfTEVHQUNZX0FNSU5PX0pTT05cIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIlVOS05PV05cIjtcbiAgICB9XG59XG5leHBvcnRzLnNpZ25Nb2RlVG9KU09OID0gc2lnbk1vZGVUb0pTT047XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2lnbmF0dXJlRGVzY3JpcHRvcnMoKSB7XG4gICAgcmV0dXJuIHsgc2lnbmF0dXJlczogW10gfTtcbn1cbmV4cG9ydHMuU2lnbmF0dXJlRGVzY3JpcHRvcnMgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5zaWduYXR1cmVzKSB7XG4gICAgICAgICAgICBleHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3IuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmF0dXJlRGVzY3JpcHRvcnMoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZXMucHVzaChleHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3IuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNpZ25hdHVyZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnNpZ25hdHVyZXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3Quc2lnbmF0dXJlcy5tYXAoKGUpID0+IGV4cG9ydHMuU2lnbmF0dXJlRGVzY3JpcHRvci5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLnNpZ25hdHVyZXMpIHtcbiAgICAgICAgICAgIG9iai5zaWduYXR1cmVzID0gbWVzc2FnZS5zaWduYXR1cmVzLm1hcCgoZSkgPT4gZSA/IGV4cG9ydHMuU2lnbmF0dXJlRGVzY3JpcHRvci50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnNpZ25hdHVyZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduYXR1cmVEZXNjcmlwdG9ycygpO1xuICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZXMgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC5zaWduYXR1cmVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBleHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3IuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2lnbmF0dXJlRGVzY3JpcHRvcigpIHtcbiAgICByZXR1cm4geyBwdWJsaWNLZXk6IHVuZGVmaW5lZCwgZGF0YTogdW5kZWZpbmVkLCBzZXF1ZW5jZTogXCIwXCIgfTtcbn1cbmV4cG9ydHMuU2lnbmF0dXJlRGVzY3JpcHRvciA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnB1YmxpY0tleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhbnlfMS5BbnkuZW5jb2RlKG1lc3NhZ2UucHVibGljS2V5LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yX0RhdGEuZW5jb2RlKG1lc3NhZ2UuZGF0YSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zZXF1ZW5jZSAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjQpLnVpbnQ2NChtZXNzYWdlLnNlcXVlbmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduYXR1cmVEZXNjcmlwdG9yKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wdWJsaWNLZXkgPSBhbnlfMS5BbnkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGEgPSBleHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VxdWVuY2UgPSBsb25nVG9TdHJpbmcocmVhZGVyLnVpbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHVibGljS2V5OiBpc1NldChvYmplY3QucHVibGljS2V5KVxuICAgICAgICAgICAgICAgID8gYW55XzEuQW55LmZyb21KU09OKG9iamVjdC5wdWJsaWNLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkYXRhOiBpc1NldChvYmplY3QuZGF0YSlcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuU2lnbmF0dXJlRGVzY3JpcHRvcl9EYXRhLmZyb21KU09OKG9iamVjdC5kYXRhKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2VxdWVuY2U6IGlzU2V0KG9iamVjdC5zZXF1ZW5jZSkgPyBTdHJpbmcob2JqZWN0LnNlcXVlbmNlKSA6IFwiMFwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UucHVibGljS2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucHVibGljS2V5ID0gbWVzc2FnZS5wdWJsaWNLZXlcbiAgICAgICAgICAgICAgICA/IGFueV8xLkFueS50b0pTT04obWVzc2FnZS5wdWJsaWNLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmRhdGEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5kYXRhID0gbWVzc2FnZS5kYXRhXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YS50b0pTT04obWVzc2FnZS5kYXRhKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5zZXF1ZW5jZSAhPT0gdW5kZWZpbmVkICYmIChvYmouc2VxdWVuY2UgPSBtZXNzYWdlLnNlcXVlbmNlKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmF0dXJlRGVzY3JpcHRvcigpO1xuICAgICAgICBtZXNzYWdlLnB1YmxpY0tleSA9XG4gICAgICAgICAgICBvYmplY3QucHVibGljS2V5ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnB1YmxpY0tleSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gYW55XzEuQW55LmZyb21QYXJ0aWFsKG9iamVjdC5wdWJsaWNLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UuZGF0YSA9XG4gICAgICAgICAgICBvYmplY3QuZGF0YSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5kYXRhICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YS5mcm9tUGFydGlhbChvYmplY3QuZGF0YSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5zZXF1ZW5jZSA9IChfYSA9IG9iamVjdC5zZXF1ZW5jZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCIwXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YSgpIHtcbiAgICByZXR1cm4geyBzaW5nbGU6IHVuZGVmaW5lZCwgbXVsdGk6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yX0RhdGEgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5zaW5nbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yX0RhdGFfU2luZ2xlLmVuY29kZShtZXNzYWdlLnNpbmdsZSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5tdWx0aSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9NdWx0aS5lbmNvZGUobWVzc2FnZS5tdWx0aSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduYXR1cmVEZXNjcmlwdG9yX0RhdGEoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNpbmdsZSA9IGV4cG9ydHMuU2lnbmF0dXJlRGVzY3JpcHRvcl9EYXRhX1NpbmdsZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubXVsdGkgPSBleHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9NdWx0aS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaW5nbGU6IGlzU2V0KG9iamVjdC5zaW5nbGUpXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9TaW5nbGUuZnJvbUpTT04ob2JqZWN0LnNpbmdsZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG11bHRpOiBpc1NldChvYmplY3QubXVsdGkpXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9NdWx0aS5mcm9tSlNPTihvYmplY3QubXVsdGkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5zaW5nbGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zaW5nbGUgPSBtZXNzYWdlLnNpbmdsZVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yX0RhdGFfU2luZ2xlLnRvSlNPTihtZXNzYWdlLnNpbmdsZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UubXVsdGkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5tdWx0aSA9IG1lc3NhZ2UubXVsdGlcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuU2lnbmF0dXJlRGVzY3JpcHRvcl9EYXRhX011bHRpLnRvSlNPTihtZXNzYWdlLm11bHRpKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YSgpO1xuICAgICAgICBtZXNzYWdlLnNpbmdsZSA9XG4gICAgICAgICAgICBvYmplY3Quc2luZ2xlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNpbmdsZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yX0RhdGFfU2luZ2xlLmZyb21QYXJ0aWFsKG9iamVjdC5zaW5nbGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UubXVsdGkgPVxuICAgICAgICAgICAgb2JqZWN0Lm11bHRpICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0Lm11bHRpICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9NdWx0aS5mcm9tUGFydGlhbChvYmplY3QubXVsdGkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9TaW5nbGUoKSB7XG4gICAgcmV0dXJuIHsgbW9kZTogMCwgc2lnbmF0dXJlOiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9TaW5nbGUgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5tb2RlICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLmludDMyKG1lc3NhZ2UubW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2lnbmF0dXJlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuYnl0ZXMobWVzc2FnZS5zaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9TaW5nbGUoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1vZGUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb2RlOiBpc1NldChvYmplY3QubW9kZSkgPyBzaWduTW9kZUZyb21KU09OKG9iamVjdC5tb2RlKSA6IDAsXG4gICAgICAgICAgICBzaWduYXR1cmU6IGlzU2V0KG9iamVjdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5tb2RlICE9PSB1bmRlZmluZWQgJiYgKG9iai5tb2RlID0gc2lnbk1vZGVUb0pTT04obWVzc2FnZS5tb2RlKSk7XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc2lnbmF0dXJlID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2Uuc2lnbmF0dXJlICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLnNpZ25hdHVyZSA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9TaW5nbGUoKTtcbiAgICAgICAgbWVzc2FnZS5tb2RlID0gKF9hID0gb2JqZWN0Lm1vZGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlID0gKF9iID0gb2JqZWN0LnNpZ25hdHVyZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU2lnbmF0dXJlRGVzY3JpcHRvcl9EYXRhX011bHRpKCkge1xuICAgIHJldHVybiB7IGJpdGFycmF5OiB1bmRlZmluZWQsIHNpZ25hdHVyZXM6IFtdIH07XG59XG5leHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9NdWx0aSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmJpdGFycmF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG11bHRpc2lnXzEuQ29tcGFjdEJpdEFycmF5LmVuY29kZShtZXNzYWdlLmJpdGFycmF5LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnNpZ25hdHVyZXMpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuU2lnbmF0dXJlRGVzY3JpcHRvcl9EYXRhLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9NdWx0aSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYml0YXJyYXkgPSBtdWx0aXNpZ18xLkNvbXBhY3RCaXRBcnJheS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlcy5wdXNoKGV4cG9ydHMuU2lnbmF0dXJlRGVzY3JpcHRvcl9EYXRhLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiaXRhcnJheTogaXNTZXQob2JqZWN0LmJpdGFycmF5KVxuICAgICAgICAgICAgICAgID8gbXVsdGlzaWdfMS5Db21wYWN0Qml0QXJyYXkuZnJvbUpTT04ob2JqZWN0LmJpdGFycmF5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2lnbmF0dXJlczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3Quc2lnbmF0dXJlcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5zaWduYXR1cmVzLm1hcCgoZSkgPT4gZXhwb3J0cy5TaWduYXR1cmVEZXNjcmlwdG9yX0RhdGEuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmJpdGFycmF5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYml0YXJyYXkgPSBtZXNzYWdlLmJpdGFycmF5XG4gICAgICAgICAgICAgICAgPyBtdWx0aXNpZ18xLkNvbXBhY3RCaXRBcnJheS50b0pTT04obWVzc2FnZS5iaXRhcnJheSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChtZXNzYWdlLnNpZ25hdHVyZXMpIHtcbiAgICAgICAgICAgIG9iai5zaWduYXR1cmVzID0gbWVzc2FnZS5zaWduYXR1cmVzLm1hcCgoZSkgPT4gZSA/IGV4cG9ydHMuU2lnbmF0dXJlRGVzY3JpcHRvcl9EYXRhLnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouc2lnbmF0dXJlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YV9NdWx0aSgpO1xuICAgICAgICBtZXNzYWdlLmJpdGFycmF5ID1cbiAgICAgICAgICAgIG9iamVjdC5iaXRhcnJheSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5iaXRhcnJheSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gbXVsdGlzaWdfMS5Db21wYWN0Qml0QXJyYXkuZnJvbVBhcnRpYWwob2JqZWN0LmJpdGFycmF5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZXMgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC5zaWduYXR1cmVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBleHBvcnRzLlNpZ25hdHVyZURlc2NyaXB0b3JfRGF0YS5mcm9tUGFydGlhbChlKSkpIHx8XG4gICAgICAgICAgICAgICAgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xudmFyIGdsb2JhbFRoaXMgPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB0aHJvdyBcIlVuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdFwiO1xufSkoKTtcbmNvbnN0IGF0b2IgPSBnbG9iYWxUaGlzLmF0b2IgfHxcbiAgICAoKGI2NCkgPT4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiNjQsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKFwiYmluYXJ5XCIpKTtcbmZ1bmN0aW9uIGJ5dGVzRnJvbUJhc2U2NChiNjQpIHtcbiAgICBjb25zdCBiaW4gPSBhdG9iKGI2NCk7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYmluLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5jb25zdCBidG9hID0gZ2xvYmFsVGhpcy5idG9hIHx8XG4gICAgKChiaW4pID0+IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYmluLCBcImJpbmFyeVwiKS50b1N0cmluZyhcImJhc2U2NFwiKSk7XG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyKSB7XG4gICAgY29uc3QgYmluID0gW107XG4gICAgZm9yIChjb25zdCBieXRlIG9mIGFycikge1xuICAgICAgICBiaW4ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ0b2EoYmluLmpvaW4oXCJcIikpO1xufVxuZnVuY3Rpb24gbG9uZ1RvU3RyaW5nKGxvbmcpIHtcbiAgICByZXR1cm4gbG9uZy50b1N0cmluZygpO1xufVxuaWYgKG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyAhPT0gbG9uZ18xLmRlZmF1bHQpIHtcbiAgICBtaW5pbWFsXzEuZGVmYXVsdC51dGlsLkxvbmcgPSBsb25nXzEuZGVmYXVsdDtcbiAgICBtaW5pbWFsXzEuZGVmYXVsdC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduaW5nLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/tx/signing/v1beta1/signing.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/tx/v1beta1/tx.js":
/*!************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/cosmos/tx/v1beta1/tx.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Fee = exports.ModeInfo_Multi = exports.ModeInfo_Single = exports.ModeInfo = exports.SignerInfo = exports.AuthInfo = exports.TxBody = exports.SignDoc = exports.TxRaw = exports.Tx = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nconst signing_1 = __webpack_require__(/*! ../../../cosmos/tx/signing/v1beta1/signing */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/tx/signing/v1beta1/signing.js\");\nconst any_1 = __webpack_require__(/*! ../../../google/protobuf/any */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/any.js\");\nconst multisig_1 = __webpack_require__(/*! ../../../cosmos/crypto/multisig/v1beta1/multisig */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/crypto/multisig/v1beta1/multisig.js\");\nconst coin_1 = __webpack_require__(/*! ../../../cosmos/base/v1beta1/coin */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/base/v1beta1/coin.js\");\nexports.protobufPackage = \"cosmos.tx.v1beta1\";\nfunction createBaseTx() {\n    return { body: undefined, authInfo: undefined, signatures: [] };\n}\nexports.Tx = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.body !== undefined) {\n            exports.TxBody.encode(message.body, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.authInfo !== undefined) {\n            exports.AuthInfo.encode(message.authInfo, writer.uint32(18).fork()).ldelim();\n        }\n        for (const v of message.signatures) {\n            writer.uint32(26).bytes(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTx();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.body = exports.TxBody.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.authInfo = exports.AuthInfo.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.signatures.push(reader.bytes());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            body: isSet(object.body) ? exports.TxBody.fromJSON(object.body) : undefined,\n            authInfo: isSet(object.authInfo)\n                ? exports.AuthInfo.fromJSON(object.authInfo)\n                : undefined,\n            signatures: Array.isArray(object === null || object === void 0 ? void 0 : object.signatures)\n                ? object.signatures.map((e) => bytesFromBase64(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.body !== undefined &&\n            (obj.body = message.body ? exports.TxBody.toJSON(message.body) : undefined);\n        message.authInfo !== undefined &&\n            (obj.authInfo = message.authInfo\n                ? exports.AuthInfo.toJSON(message.authInfo)\n                : undefined);\n        if (message.signatures) {\n            obj.signatures = message.signatures.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));\n        }\n        else {\n            obj.signatures = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseTx();\n        message.body =\n            object.body !== undefined && object.body !== null\n                ? exports.TxBody.fromPartial(object.body)\n                : undefined;\n        message.authInfo =\n            object.authInfo !== undefined && object.authInfo !== null\n                ? exports.AuthInfo.fromPartial(object.authInfo)\n                : undefined;\n        message.signatures = ((_a = object.signatures) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBaseTxRaw() {\n    return {\n        bodyBytes: new Uint8Array(),\n        authInfoBytes: new Uint8Array(),\n        signatures: [],\n    };\n}\nexports.TxRaw = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.bodyBytes.length !== 0) {\n            writer.uint32(10).bytes(message.bodyBytes);\n        }\n        if (message.authInfoBytes.length !== 0) {\n            writer.uint32(18).bytes(message.authInfoBytes);\n        }\n        for (const v of message.signatures) {\n            writer.uint32(26).bytes(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTxRaw();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bodyBytes = reader.bytes();\n                    break;\n                case 2:\n                    message.authInfoBytes = reader.bytes();\n                    break;\n                case 3:\n                    message.signatures.push(reader.bytes());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            bodyBytes: isSet(object.bodyBytes)\n                ? bytesFromBase64(object.bodyBytes)\n                : new Uint8Array(),\n            authInfoBytes: isSet(object.authInfoBytes)\n                ? bytesFromBase64(object.authInfoBytes)\n                : new Uint8Array(),\n            signatures: Array.isArray(object === null || object === void 0 ? void 0 : object.signatures)\n                ? object.signatures.map((e) => bytesFromBase64(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bodyBytes !== undefined &&\n            (obj.bodyBytes = base64FromBytes(message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()));\n        message.authInfoBytes !== undefined &&\n            (obj.authInfoBytes = base64FromBytes(message.authInfoBytes !== undefined\n                ? message.authInfoBytes\n                : new Uint8Array()));\n        if (message.signatures) {\n            obj.signatures = message.signatures.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));\n        }\n        else {\n            obj.signatures = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseTxRaw();\n        message.bodyBytes = (_a = object.bodyBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.authInfoBytes = (_b = object.authInfoBytes) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.signatures = ((_c = object.signatures) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBaseSignDoc() {\n    return {\n        bodyBytes: new Uint8Array(),\n        authInfoBytes: new Uint8Array(),\n        chainId: \"\",\n        accountNumber: \"0\",\n    };\n}\nexports.SignDoc = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.bodyBytes.length !== 0) {\n            writer.uint32(10).bytes(message.bodyBytes);\n        }\n        if (message.authInfoBytes.length !== 0) {\n            writer.uint32(18).bytes(message.authInfoBytes);\n        }\n        if (message.chainId !== \"\") {\n            writer.uint32(26).string(message.chainId);\n        }\n        if (message.accountNumber !== \"0\") {\n            writer.uint32(32).uint64(message.accountNumber);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignDoc();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bodyBytes = reader.bytes();\n                    break;\n                case 2:\n                    message.authInfoBytes = reader.bytes();\n                    break;\n                case 3:\n                    message.chainId = reader.string();\n                    break;\n                case 4:\n                    message.accountNumber = longToString(reader.uint64());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            bodyBytes: isSet(object.bodyBytes)\n                ? bytesFromBase64(object.bodyBytes)\n                : new Uint8Array(),\n            authInfoBytes: isSet(object.authInfoBytes)\n                ? bytesFromBase64(object.authInfoBytes)\n                : new Uint8Array(),\n            chainId: isSet(object.chainId) ? String(object.chainId) : \"\",\n            accountNumber: isSet(object.accountNumber)\n                ? String(object.accountNumber)\n                : \"0\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bodyBytes !== undefined &&\n            (obj.bodyBytes = base64FromBytes(message.bodyBytes !== undefined ? message.bodyBytes : new Uint8Array()));\n        message.authInfoBytes !== undefined &&\n            (obj.authInfoBytes = base64FromBytes(message.authInfoBytes !== undefined\n                ? message.authInfoBytes\n                : new Uint8Array()));\n        message.chainId !== undefined && (obj.chainId = message.chainId);\n        message.accountNumber !== undefined &&\n            (obj.accountNumber = message.accountNumber);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseSignDoc();\n        message.bodyBytes = (_a = object.bodyBytes) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.authInfoBytes = (_b = object.authInfoBytes) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.chainId = (_c = object.chainId) !== null && _c !== void 0 ? _c : \"\";\n        message.accountNumber = (_d = object.accountNumber) !== null && _d !== void 0 ? _d : \"0\";\n        return message;\n    },\n};\nfunction createBaseTxBody() {\n    return {\n        messages: [],\n        memo: \"\",\n        timeoutHeight: \"0\",\n        extensionOptions: [],\n        nonCriticalExtensionOptions: [],\n    };\n}\nexports.TxBody = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.messages) {\n            any_1.Any.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.memo !== \"\") {\n            writer.uint32(18).string(message.memo);\n        }\n        if (message.timeoutHeight !== \"0\") {\n            writer.uint32(24).uint64(message.timeoutHeight);\n        }\n        for (const v of message.extensionOptions) {\n            any_1.Any.encode(v, writer.uint32(8186).fork()).ldelim();\n        }\n        for (const v of message.nonCriticalExtensionOptions) {\n            any_1.Any.encode(v, writer.uint32(16378).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTxBody();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.messages.push(any_1.Any.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.memo = reader.string();\n                    break;\n                case 3:\n                    message.timeoutHeight = longToString(reader.uint64());\n                    break;\n                case 1023:\n                    message.extensionOptions.push(any_1.Any.decode(reader, reader.uint32()));\n                    break;\n                case 2047:\n                    message.nonCriticalExtensionOptions.push(any_1.Any.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            messages: Array.isArray(object === null || object === void 0 ? void 0 : object.messages)\n                ? object.messages.map((e) => any_1.Any.fromJSON(e))\n                : [],\n            memo: isSet(object.memo) ? String(object.memo) : \"\",\n            timeoutHeight: isSet(object.timeoutHeight)\n                ? String(object.timeoutHeight)\n                : \"0\",\n            extensionOptions: Array.isArray(object === null || object === void 0 ? void 0 : object.extensionOptions)\n                ? object.extensionOptions.map((e) => any_1.Any.fromJSON(e))\n                : [],\n            nonCriticalExtensionOptions: Array.isArray(object === null || object === void 0 ? void 0 : object.nonCriticalExtensionOptions)\n                ? object.nonCriticalExtensionOptions.map((e) => any_1.Any.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.messages) {\n            obj.messages = message.messages.map((e) => e ? any_1.Any.toJSON(e) : undefined);\n        }\n        else {\n            obj.messages = [];\n        }\n        message.memo !== undefined && (obj.memo = message.memo);\n        message.timeoutHeight !== undefined &&\n            (obj.timeoutHeight = message.timeoutHeight);\n        if (message.extensionOptions) {\n            obj.extensionOptions = message.extensionOptions.map((e) => e ? any_1.Any.toJSON(e) : undefined);\n        }\n        else {\n            obj.extensionOptions = [];\n        }\n        if (message.nonCriticalExtensionOptions) {\n            obj.nonCriticalExtensionOptions = message.nonCriticalExtensionOptions.map((e) => (e ? any_1.Any.toJSON(e) : undefined));\n        }\n        else {\n            obj.nonCriticalExtensionOptions = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e;\n        const message = createBaseTxBody();\n        message.messages = ((_a = object.messages) === null || _a === void 0 ? void 0 : _a.map((e) => any_1.Any.fromPartial(e))) || [];\n        message.memo = (_b = object.memo) !== null && _b !== void 0 ? _b : \"\";\n        message.timeoutHeight = (_c = object.timeoutHeight) !== null && _c !== void 0 ? _c : \"0\";\n        message.extensionOptions =\n            ((_d = object.extensionOptions) === null || _d === void 0 ? void 0 : _d.map((e) => any_1.Any.fromPartial(e))) || [];\n        message.nonCriticalExtensionOptions =\n            ((_e = object.nonCriticalExtensionOptions) === null || _e === void 0 ? void 0 : _e.map((e) => any_1.Any.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseAuthInfo() {\n    return { signerInfos: [], fee: undefined };\n}\nexports.AuthInfo = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.signerInfos) {\n            exports.SignerInfo.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.fee !== undefined) {\n            exports.Fee.encode(message.fee, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAuthInfo();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.signerInfos.push(exports.SignerInfo.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.fee = exports.Fee.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            signerInfos: Array.isArray(object === null || object === void 0 ? void 0 : object.signerInfos)\n                ? object.signerInfos.map((e) => exports.SignerInfo.fromJSON(e))\n                : [],\n            fee: isSet(object.fee) ? exports.Fee.fromJSON(object.fee) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.signerInfos) {\n            obj.signerInfos = message.signerInfos.map((e) => e ? exports.SignerInfo.toJSON(e) : undefined);\n        }\n        else {\n            obj.signerInfos = [];\n        }\n        message.fee !== undefined &&\n            (obj.fee = message.fee ? exports.Fee.toJSON(message.fee) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseAuthInfo();\n        message.signerInfos =\n            ((_a = object.signerInfos) === null || _a === void 0 ? void 0 : _a.map((e) => exports.SignerInfo.fromPartial(e))) || [];\n        message.fee =\n            object.fee !== undefined && object.fee !== null\n                ? exports.Fee.fromPartial(object.fee)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSignerInfo() {\n    return { publicKey: undefined, modeInfo: undefined, sequence: \"0\" };\n}\nexports.SignerInfo = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.publicKey !== undefined) {\n            any_1.Any.encode(message.publicKey, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.modeInfo !== undefined) {\n            exports.ModeInfo.encode(message.modeInfo, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.sequence !== \"0\") {\n            writer.uint32(24).uint64(message.sequence);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignerInfo();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.publicKey = any_1.Any.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.modeInfo = exports.ModeInfo.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.sequence = longToString(reader.uint64());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            publicKey: isSet(object.publicKey)\n                ? any_1.Any.fromJSON(object.publicKey)\n                : undefined,\n            modeInfo: isSet(object.modeInfo)\n                ? exports.ModeInfo.fromJSON(object.modeInfo)\n                : undefined,\n            sequence: isSet(object.sequence) ? String(object.sequence) : \"0\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.publicKey !== undefined &&\n            (obj.publicKey = message.publicKey\n                ? any_1.Any.toJSON(message.publicKey)\n                : undefined);\n        message.modeInfo !== undefined &&\n            (obj.modeInfo = message.modeInfo\n                ? exports.ModeInfo.toJSON(message.modeInfo)\n                : undefined);\n        message.sequence !== undefined && (obj.sequence = message.sequence);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSignerInfo();\n        message.publicKey =\n            object.publicKey !== undefined && object.publicKey !== null\n                ? any_1.Any.fromPartial(object.publicKey)\n                : undefined;\n        message.modeInfo =\n            object.modeInfo !== undefined && object.modeInfo !== null\n                ? exports.ModeInfo.fromPartial(object.modeInfo)\n                : undefined;\n        message.sequence = (_a = object.sequence) !== null && _a !== void 0 ? _a : \"0\";\n        return message;\n    },\n};\nfunction createBaseModeInfo() {\n    return { single: undefined, multi: undefined };\n}\nexports.ModeInfo = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.single !== undefined) {\n            exports.ModeInfo_Single.encode(message.single, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.multi !== undefined) {\n            exports.ModeInfo_Multi.encode(message.multi, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseModeInfo();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.single = exports.ModeInfo_Single.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.multi = exports.ModeInfo_Multi.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            single: isSet(object.single)\n                ? exports.ModeInfo_Single.fromJSON(object.single)\n                : undefined,\n            multi: isSet(object.multi)\n                ? exports.ModeInfo_Multi.fromJSON(object.multi)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.single !== undefined &&\n            (obj.single = message.single\n                ? exports.ModeInfo_Single.toJSON(message.single)\n                : undefined);\n        message.multi !== undefined &&\n            (obj.multi = message.multi\n                ? exports.ModeInfo_Multi.toJSON(message.multi)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseModeInfo();\n        message.single =\n            object.single !== undefined && object.single !== null\n                ? exports.ModeInfo_Single.fromPartial(object.single)\n                : undefined;\n        message.multi =\n            object.multi !== undefined && object.multi !== null\n                ? exports.ModeInfo_Multi.fromPartial(object.multi)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseModeInfo_Single() {\n    return { mode: 0 };\n}\nexports.ModeInfo_Single = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.mode !== 0) {\n            writer.uint32(8).int32(message.mode);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseModeInfo_Single();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.mode = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            mode: isSet(object.mode) ? (0, signing_1.signModeFromJSON)(object.mode) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.mode !== undefined && (obj.mode = (0, signing_1.signModeToJSON)(message.mode));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseModeInfo_Single();\n        message.mode = (_a = object.mode) !== null && _a !== void 0 ? _a : 0;\n        return message;\n    },\n};\nfunction createBaseModeInfo_Multi() {\n    return { bitarray: undefined, modeInfos: [] };\n}\nexports.ModeInfo_Multi = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.bitarray !== undefined) {\n            multisig_1.CompactBitArray.encode(message.bitarray, writer.uint32(10).fork()).ldelim();\n        }\n        for (const v of message.modeInfos) {\n            exports.ModeInfo.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseModeInfo_Multi();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bitarray = multisig_1.CompactBitArray.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.modeInfos.push(exports.ModeInfo.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            bitarray: isSet(object.bitarray)\n                ? multisig_1.CompactBitArray.fromJSON(object.bitarray)\n                : undefined,\n            modeInfos: Array.isArray(object === null || object === void 0 ? void 0 : object.modeInfos)\n                ? object.modeInfos.map((e) => exports.ModeInfo.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bitarray !== undefined &&\n            (obj.bitarray = message.bitarray\n                ? multisig_1.CompactBitArray.toJSON(message.bitarray)\n                : undefined);\n        if (message.modeInfos) {\n            obj.modeInfos = message.modeInfos.map((e) => e ? exports.ModeInfo.toJSON(e) : undefined);\n        }\n        else {\n            obj.modeInfos = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseModeInfo_Multi();\n        message.bitarray =\n            object.bitarray !== undefined && object.bitarray !== null\n                ? multisig_1.CompactBitArray.fromPartial(object.bitarray)\n                : undefined;\n        message.modeInfos =\n            ((_a = object.modeInfos) === null || _a === void 0 ? void 0 : _a.map((e) => exports.ModeInfo.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseFee() {\n    return { amount: [], gasLimit: \"0\", payer: \"\", granter: \"\" };\n}\nexports.Fee = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.amount) {\n            coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.gasLimit !== \"0\") {\n            writer.uint32(16).uint64(message.gasLimit);\n        }\n        if (message.payer !== \"\") {\n            writer.uint32(26).string(message.payer);\n        }\n        if (message.granter !== \"\") {\n            writer.uint32(34).string(message.granter);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseFee();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.amount.push(coin_1.Coin.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.gasLimit = longToString(reader.uint64());\n                    break;\n                case 3:\n                    message.payer = reader.string();\n                    break;\n                case 4:\n                    message.granter = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            amount: Array.isArray(object === null || object === void 0 ? void 0 : object.amount)\n                ? object.amount.map((e) => coin_1.Coin.fromJSON(e))\n                : [],\n            gasLimit: isSet(object.gasLimit) ? String(object.gasLimit) : \"0\",\n            payer: isSet(object.payer) ? String(object.payer) : \"\",\n            granter: isSet(object.granter) ? String(object.granter) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.amount) {\n            obj.amount = message.amount.map((e) => (e ? coin_1.Coin.toJSON(e) : undefined));\n        }\n        else {\n            obj.amount = [];\n        }\n        message.gasLimit !== undefined && (obj.gasLimit = message.gasLimit);\n        message.payer !== undefined && (obj.payer = message.payer);\n        message.granter !== undefined && (obj.granter = message.granter);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseFee();\n        message.amount = ((_a = object.amount) === null || _a === void 0 ? void 0 : _a.map((e) => coin_1.Coin.fromPartial(e))) || [];\n        message.gasLimit = (_b = object.gasLimit) !== null && _b !== void 0 ? _b : \"0\";\n        message.payer = (_c = object.payer) !== null && _c !== void 0 ? _c : \"\";\n        message.granter = (_d = object.granter) !== null && _d !== void 0 ? _d : \"\";\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob ||\n    ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa ||\n    ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (const byte of arr) {\n        bin.push(String.fromCharCode(byte));\n    }\n    return btoa(bin.join(\"\"));\n}\nfunction longToString(long) {\n    return long.toString();\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=tx.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3MvdHgvdjFiZXRhMS90eC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFdBQVcsR0FBRyxzQkFBc0IsR0FBRyx1QkFBdUIsR0FBRyxnQkFBZ0IsR0FBRyxrQkFBa0IsR0FBRyxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsZUFBZSxHQUFHLGFBQWEsR0FBRyxVQUFVLEdBQUcsdUJBQXVCO0FBQ25OO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMsbURBQU07QUFDN0Msa0NBQWtDLG1CQUFPLENBQUMsc0VBQW9CO0FBQzlELGtCQUFrQixtQkFBTyxDQUFDLHVJQUE0QztBQUN0RSxjQUFjLG1CQUFPLENBQUMsMkdBQThCO0FBQ3BELG1CQUFtQixtQkFBTyxDQUFDLG1KQUFrRDtBQUM3RSxlQUFlLG1CQUFPLENBQUMscUhBQW1DO0FBQzFELHVCQUF1QjtBQUN2QjtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3MvdHgvdjFiZXRhMS90eC5qcz9jMzU3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GZWUgPSBleHBvcnRzLk1vZGVJbmZvX011bHRpID0gZXhwb3J0cy5Nb2RlSW5mb19TaW5nbGUgPSBleHBvcnRzLk1vZGVJbmZvID0gZXhwb3J0cy5TaWduZXJJbmZvID0gZXhwb3J0cy5BdXRoSW5mbyA9IGV4cG9ydHMuVHhCb2R5ID0gZXhwb3J0cy5TaWduRG9jID0gZXhwb3J0cy5UeFJhdyA9IGV4cG9ydHMuVHggPSBleHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlICovXG5jb25zdCBsb25nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvbmdcIikpO1xuY29uc3QgbWluaW1hbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwcm90b2J1ZmpzL21pbmltYWxcIikpO1xuY29uc3Qgc2lnbmluZ18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2Nvc21vcy90eC9zaWduaW5nL3YxYmV0YTEvc2lnbmluZ1wiKTtcbmNvbnN0IGFueV8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2dvb2dsZS9wcm90b2J1Zi9hbnlcIik7XG5jb25zdCBtdWx0aXNpZ18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2Nvc21vcy9jcnlwdG8vbXVsdGlzaWcvdjFiZXRhMS9tdWx0aXNpZ1wiKTtcbmNvbnN0IGNvaW5fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3Ntb3MvYmFzZS92MWJldGExL2NvaW5cIik7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwiY29zbW9zLnR4LnYxYmV0YTFcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUeCgpIHtcbiAgICByZXR1cm4geyBib2R5OiB1bmRlZmluZWQsIGF1dGhJbmZvOiB1bmRlZmluZWQsIHNpZ25hdHVyZXM6IFtdIH07XG59XG5leHBvcnRzLlR4ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYm9keSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLlR4Qm9keS5lbmNvZGUobWVzc2FnZS5ib2R5LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmF1dGhJbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuQXV0aEluZm8uZW5jb2RlKG1lc3NhZ2UuYXV0aEluZm8sIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2Uuc2lnbmF0dXJlcykge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuYnl0ZXModik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVHgoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJvZHkgPSBleHBvcnRzLlR4Qm9keS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXV0aEluZm8gPSBleHBvcnRzLkF1dGhJbmZvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaWduYXR1cmVzLnB1c2gocmVhZGVyLmJ5dGVzKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBib2R5OiBpc1NldChvYmplY3QuYm9keSkgPyBleHBvcnRzLlR4Qm9keS5mcm9tSlNPTihvYmplY3QuYm9keSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhdXRoSW5mbzogaXNTZXQob2JqZWN0LmF1dGhJbmZvKVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5BdXRoSW5mby5mcm9tSlNPTihvYmplY3QuYXV0aEluZm8pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzaWduYXR1cmVzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5zaWduYXR1cmVzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LnNpZ25hdHVyZXMubWFwKChlKSA9PiBieXRlc0Zyb21CYXNlNjQoZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmJvZHkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5ib2R5ID0gbWVzc2FnZS5ib2R5ID8gZXhwb3J0cy5UeEJvZHkudG9KU09OKG1lc3NhZ2UuYm9keSkgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmF1dGhJbmZvICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYXV0aEluZm8gPSBtZXNzYWdlLmF1dGhJbmZvXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkF1dGhJbmZvLnRvSlNPTihtZXNzYWdlLmF1dGhJbmZvKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2lnbmF0dXJlcykge1xuICAgICAgICAgICAgb2JqLnNpZ25hdHVyZXMgPSBtZXNzYWdlLnNpZ25hdHVyZXMubWFwKChlKSA9PiBiYXNlNjRGcm9tQnl0ZXMoZSAhPT0gdW5kZWZpbmVkID8gZSA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5zaWduYXR1cmVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVHgoKTtcbiAgICAgICAgbWVzc2FnZS5ib2R5ID1cbiAgICAgICAgICAgIG9iamVjdC5ib2R5ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmJvZHkgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuVHhCb2R5LmZyb21QYXJ0aWFsKG9iamVjdC5ib2R5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmF1dGhJbmZvID1cbiAgICAgICAgICAgIG9iamVjdC5hdXRoSW5mbyAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5hdXRoSW5mbyAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5BdXRoSW5mby5mcm9tUGFydGlhbChvYmplY3QuYXV0aEluZm8pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlcyA9ICgoX2EgPSBvYmplY3Quc2lnbmF0dXJlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gZSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUeFJhdygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBib2R5Qnl0ZXM6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIGF1dGhJbmZvQnl0ZXM6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIHNpZ25hdHVyZXM6IFtdLFxuICAgIH07XG59XG5leHBvcnRzLlR4UmF3ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYm9keUJ5dGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5ib2R5Qnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmF1dGhJbmZvQnl0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5ieXRlcyhtZXNzYWdlLmF1dGhJbmZvQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnNpZ25hdHVyZXMpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLmJ5dGVzKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVR4UmF3KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ib2R5Qnl0ZXMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmF1dGhJbmZvQnl0ZXMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZXMucHVzaChyZWFkZXIuYnl0ZXMoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJvZHlCeXRlczogaXNTZXQob2JqZWN0LmJvZHlCeXRlcylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuYm9keUJ5dGVzKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIGF1dGhJbmZvQnl0ZXM6IGlzU2V0KG9iamVjdC5hdXRoSW5mb0J5dGVzKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5hdXRoSW5mb0J5dGVzKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIHNpZ25hdHVyZXM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnNpZ25hdHVyZXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3Quc2lnbmF0dXJlcy5tYXAoKGUpID0+IGJ5dGVzRnJvbUJhc2U2NChlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuYm9keUJ5dGVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYm9keUJ5dGVzID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuYm9keUJ5dGVzICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmJvZHlCeXRlcyA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5hdXRoSW5mb0J5dGVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYXV0aEluZm9CeXRlcyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmF1dGhJbmZvQnl0ZXMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS5hdXRoSW5mb0J5dGVzXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIGlmIChtZXNzYWdlLnNpZ25hdHVyZXMpIHtcbiAgICAgICAgICAgIG9iai5zaWduYXR1cmVzID0gbWVzc2FnZS5zaWduYXR1cmVzLm1hcCgoZSkgPT4gYmFzZTY0RnJvbUJ5dGVzKGUgIT09IHVuZGVmaW5lZCA/IGUgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouc2lnbmF0dXJlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVHhSYXcoKTtcbiAgICAgICAgbWVzc2FnZS5ib2R5Qnl0ZXMgPSAoX2EgPSBvYmplY3QuYm9keUJ5dGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmF1dGhJbmZvQnl0ZXMgPSAoX2IgPSBvYmplY3QuYXV0aEluZm9CeXRlcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmVzID0gKChfYyA9IG9iamVjdC5zaWduYXR1cmVzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubWFwKChlKSA9PiBlKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNpZ25Eb2MoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYm9keUJ5dGVzOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICBhdXRoSW5mb0J5dGVzOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICBjaGFpbklkOiBcIlwiLFxuICAgICAgICBhY2NvdW50TnVtYmVyOiBcIjBcIixcbiAgICB9O1xufVxuZXhwb3J0cy5TaWduRG9jID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYm9keUJ5dGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5ib2R5Qnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmF1dGhJbmZvQnl0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5ieXRlcyhtZXNzYWdlLmF1dGhJbmZvQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNoYWluSWQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLnN0cmluZyhtZXNzYWdlLmNoYWluSWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmFjY291bnROdW1iZXIgIT09IFwiMFwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDMyKS51aW50NjQobWVzc2FnZS5hY2NvdW50TnVtYmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaWduRG9jKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ib2R5Qnl0ZXMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmF1dGhJbmZvQnl0ZXMgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNoYWluSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hY2NvdW50TnVtYmVyID0gbG9uZ1RvU3RyaW5nKHJlYWRlci51aW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJvZHlCeXRlczogaXNTZXQob2JqZWN0LmJvZHlCeXRlcylcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuYm9keUJ5dGVzKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIGF1dGhJbmZvQnl0ZXM6IGlzU2V0KG9iamVjdC5hdXRoSW5mb0J5dGVzKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5hdXRoSW5mb0J5dGVzKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIGNoYWluSWQ6IGlzU2V0KG9iamVjdC5jaGFpbklkKSA/IFN0cmluZyhvYmplY3QuY2hhaW5JZCkgOiBcIlwiLFxuICAgICAgICAgICAgYWNjb3VudE51bWJlcjogaXNTZXQob2JqZWN0LmFjY291bnROdW1iZXIpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LmFjY291bnROdW1iZXIpXG4gICAgICAgICAgICAgICAgOiBcIjBcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmJvZHlCeXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmJvZHlCeXRlcyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmJvZHlCeXRlcyAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5ib2R5Qnl0ZXMgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UuYXV0aEluZm9CeXRlcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmF1dGhJbmZvQnl0ZXMgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5hdXRoSW5mb0J5dGVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2UuYXV0aEluZm9CeXRlc1xuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLmNoYWluSWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmNoYWluSWQgPSBtZXNzYWdlLmNoYWluSWQpO1xuICAgICAgICBtZXNzYWdlLmFjY291bnROdW1iZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5hY2NvdW50TnVtYmVyID0gbWVzc2FnZS5hY2NvdW50TnVtYmVyKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbkRvYygpO1xuICAgICAgICBtZXNzYWdlLmJvZHlCeXRlcyA9IChfYSA9IG9iamVjdC5ib2R5Qnl0ZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UuYXV0aEluZm9CeXRlcyA9IChfYiA9IG9iamVjdC5hdXRoSW5mb0J5dGVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmNoYWluSWQgPSAoX2MgPSBvYmplY3QuY2hhaW5JZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5hY2NvdW50TnVtYmVyID0gKF9kID0gb2JqZWN0LmFjY291bnROdW1iZXIpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFwiMFwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUeEJvZHkoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgICBtZW1vOiBcIlwiLFxuICAgICAgICB0aW1lb3V0SGVpZ2h0OiBcIjBcIixcbiAgICAgICAgZXh0ZW5zaW9uT3B0aW9uczogW10sXG4gICAgICAgIG5vbkNyaXRpY2FsRXh0ZW5zaW9uT3B0aW9uczogW10sXG4gICAgfTtcbn1cbmV4cG9ydHMuVHhCb2R5ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIGFueV8xLkFueS5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5tZW1vICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS5tZW1vKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50aW1lb3V0SGVpZ2h0ICE9PSBcIjBcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkudWludDY0KG1lc3NhZ2UudGltZW91dEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuZXh0ZW5zaW9uT3B0aW9ucykge1xuICAgICAgICAgICAgYW55XzEuQW55LmVuY29kZSh2LCB3cml0ZXIudWludDMyKDgxODYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2Uubm9uQ3JpdGljYWxFeHRlbnNpb25PcHRpb25zKSB7XG4gICAgICAgICAgICBhbnlfMS5BbnkuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTYzNzgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVHhCb2R5KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZXNzYWdlcy5wdXNoKGFueV8xLkFueS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1lbW8gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50aW1lb3V0SGVpZ2h0ID0gbG9uZ1RvU3RyaW5nKHJlYWRlci51aW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTAyMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5leHRlbnNpb25PcHRpb25zLnB1c2goYW55XzEuQW55LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIwNDc6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uubm9uQ3JpdGljYWxFeHRlbnNpb25PcHRpb25zLnB1c2goYW55XzEuQW55LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QubWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QubWVzc2FnZXMubWFwKChlKSA9PiBhbnlfMS5BbnkuZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgICAgIG1lbW86IGlzU2V0KG9iamVjdC5tZW1vKSA/IFN0cmluZyhvYmplY3QubWVtbykgOiBcIlwiLFxuICAgICAgICAgICAgdGltZW91dEhlaWdodDogaXNTZXQob2JqZWN0LnRpbWVvdXRIZWlnaHQpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LnRpbWVvdXRIZWlnaHQpXG4gICAgICAgICAgICAgICAgOiBcIjBcIixcbiAgICAgICAgICAgIGV4dGVuc2lvbk9wdGlvbnM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LmV4dGVuc2lvbk9wdGlvbnMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QuZXh0ZW5zaW9uT3B0aW9ucy5tYXAoKGUpID0+IGFueV8xLkFueS5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICAgICAgbm9uQ3JpdGljYWxFeHRlbnNpb25PcHRpb25zOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5ub25Dcml0aWNhbEV4dGVuc2lvbk9wdGlvbnMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3Qubm9uQ3JpdGljYWxFeHRlbnNpb25PcHRpb25zLm1hcCgoZSkgPT4gYW55XzEuQW55LmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UubWVzc2FnZXMpIHtcbiAgICAgICAgICAgIG9iai5tZXNzYWdlcyA9IG1lc3NhZ2UubWVzc2FnZXMubWFwKChlKSA9PiBlID8gYW55XzEuQW55LnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLm1lbW8gIT09IHVuZGVmaW5lZCAmJiAob2JqLm1lbW8gPSBtZXNzYWdlLm1lbW8pO1xuICAgICAgICBtZXNzYWdlLnRpbWVvdXRIZWlnaHQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai50aW1lb3V0SGVpZ2h0ID0gbWVzc2FnZS50aW1lb3V0SGVpZ2h0KTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZXh0ZW5zaW9uT3B0aW9ucykge1xuICAgICAgICAgICAgb2JqLmV4dGVuc2lvbk9wdGlvbnMgPSBtZXNzYWdlLmV4dGVuc2lvbk9wdGlvbnMubWFwKChlKSA9PiBlID8gYW55XzEuQW55LnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouZXh0ZW5zaW9uT3B0aW9ucyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm5vbkNyaXRpY2FsRXh0ZW5zaW9uT3B0aW9ucykge1xuICAgICAgICAgICAgb2JqLm5vbkNyaXRpY2FsRXh0ZW5zaW9uT3B0aW9ucyA9IG1lc3NhZ2Uubm9uQ3JpdGljYWxFeHRlbnNpb25PcHRpb25zLm1hcCgoZSkgPT4gKGUgPyBhbnlfMS5BbnkudG9KU09OKGUpIDogdW5kZWZpbmVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoubm9uQ3JpdGljYWxFeHRlbnNpb25PcHRpb25zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVR4Qm9keSgpO1xuICAgICAgICBtZXNzYWdlLm1lc3NhZ2VzID0gKChfYSA9IG9iamVjdC5tZXNzYWdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gYW55XzEuQW55LmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIG1lc3NhZ2UubWVtbyA9IChfYiA9IG9iamVjdC5tZW1vKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnRpbWVvdXRIZWlnaHQgPSAoX2MgPSBvYmplY3QudGltZW91dEhlaWdodCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogXCIwXCI7XG4gICAgICAgIG1lc3NhZ2UuZXh0ZW5zaW9uT3B0aW9ucyA9XG4gICAgICAgICAgICAoKF9kID0gb2JqZWN0LmV4dGVuc2lvbk9wdGlvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5tYXAoKGUpID0+IGFueV8xLkFueS5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICBtZXNzYWdlLm5vbkNyaXRpY2FsRXh0ZW5zaW9uT3B0aW9ucyA9XG4gICAgICAgICAgICAoKF9lID0gb2JqZWN0Lm5vbkNyaXRpY2FsRXh0ZW5zaW9uT3B0aW9ucykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLm1hcCgoZSkgPT4gYW55XzEuQW55LmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUF1dGhJbmZvKCkge1xuICAgIHJldHVybiB7IHNpZ25lckluZm9zOiBbXSwgZmVlOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydHMuQXV0aEluZm8gPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS5zaWduZXJJbmZvcykge1xuICAgICAgICAgICAgZXhwb3J0cy5TaWduZXJJbmZvLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmZlZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLkZlZS5lbmNvZGUobWVzc2FnZS5mZWUsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQXV0aEluZm8oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNpZ25lckluZm9zLnB1c2goZXhwb3J0cy5TaWduZXJJbmZvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZmVlID0gZXhwb3J0cy5GZWUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2lnbmVySW5mb3M6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnNpZ25lckluZm9zKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LnNpZ25lckluZm9zLm1hcCgoZSkgPT4gZXhwb3J0cy5TaWduZXJJbmZvLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgICAgICBmZWU6IGlzU2V0KG9iamVjdC5mZWUpID8gZXhwb3J0cy5GZWUuZnJvbUpTT04ob2JqZWN0LmZlZSkgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2lnbmVySW5mb3MpIHtcbiAgICAgICAgICAgIG9iai5zaWduZXJJbmZvcyA9IG1lc3NhZ2Uuc2lnbmVySW5mb3MubWFwKChlKSA9PiBlID8gZXhwb3J0cy5TaWduZXJJbmZvLnRvSlNPTihlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouc2lnbmVySW5mb3MgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLmZlZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmZlZSA9IG1lc3NhZ2UuZmVlID8gZXhwb3J0cy5GZWUudG9KU09OKG1lc3NhZ2UuZmVlKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUF1dGhJbmZvKCk7XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmVySW5mb3MgPVxuICAgICAgICAgICAgKChfYSA9IG9iamVjdC5zaWduZXJJbmZvcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gZXhwb3J0cy5TaWduZXJJbmZvLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIG1lc3NhZ2UuZmVlID1cbiAgICAgICAgICAgIG9iamVjdC5mZWUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuZmVlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkZlZS5mcm9tUGFydGlhbChvYmplY3QuZmVlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTaWduZXJJbmZvKCkge1xuICAgIHJldHVybiB7IHB1YmxpY0tleTogdW5kZWZpbmVkLCBtb2RlSW5mbzogdW5kZWZpbmVkLCBzZXF1ZW5jZTogXCIwXCIgfTtcbn1cbmV4cG9ydHMuU2lnbmVySW5mbyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnB1YmxpY0tleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhbnlfMS5BbnkuZW5jb2RlKG1lc3NhZ2UucHVibGljS2V5LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm1vZGVJbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuTW9kZUluZm8uZW5jb2RlKG1lc3NhZ2UubW9kZUluZm8sIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2VxdWVuY2UgIT09IFwiMFwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI0KS51aW50NjQobWVzc2FnZS5zZXF1ZW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmVySW5mbygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHVibGljS2V5ID0gYW55XzEuQW55LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tb2RlSW5mbyA9IGV4cG9ydHMuTW9kZUluZm8uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlcXVlbmNlID0gbG9uZ1RvU3RyaW5nKHJlYWRlci51aW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHB1YmxpY0tleTogaXNTZXQob2JqZWN0LnB1YmxpY0tleSlcbiAgICAgICAgICAgICAgICA/IGFueV8xLkFueS5mcm9tSlNPTihvYmplY3QucHVibGljS2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbW9kZUluZm86IGlzU2V0KG9iamVjdC5tb2RlSW5mbylcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuTW9kZUluZm8uZnJvbUpTT04ob2JqZWN0Lm1vZGVJbmZvKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2VxdWVuY2U6IGlzU2V0KG9iamVjdC5zZXF1ZW5jZSkgPyBTdHJpbmcob2JqZWN0LnNlcXVlbmNlKSA6IFwiMFwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UucHVibGljS2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucHVibGljS2V5ID0gbWVzc2FnZS5wdWJsaWNLZXlcbiAgICAgICAgICAgICAgICA/IGFueV8xLkFueS50b0pTT04obWVzc2FnZS5wdWJsaWNLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLm1vZGVJbmZvICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoubW9kZUluZm8gPSBtZXNzYWdlLm1vZGVJbmZvXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLk1vZGVJbmZvLnRvSlNPTihtZXNzYWdlLm1vZGVJbmZvKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5zZXF1ZW5jZSAhPT0gdW5kZWZpbmVkICYmIChvYmouc2VxdWVuY2UgPSBtZXNzYWdlLnNlcXVlbmNlKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU2lnbmVySW5mbygpO1xuICAgICAgICBtZXNzYWdlLnB1YmxpY0tleSA9XG4gICAgICAgICAgICBvYmplY3QucHVibGljS2V5ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnB1YmxpY0tleSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gYW55XzEuQW55LmZyb21QYXJ0aWFsKG9iamVjdC5wdWJsaWNLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UubW9kZUluZm8gPVxuICAgICAgICAgICAgb2JqZWN0Lm1vZGVJbmZvICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0Lm1vZGVJbmZvICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLk1vZGVJbmZvLmZyb21QYXJ0aWFsKG9iamVjdC5tb2RlSW5mbylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5zZXF1ZW5jZSA9IChfYSA9IG9iamVjdC5zZXF1ZW5jZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCIwXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1vZGVJbmZvKCkge1xuICAgIHJldHVybiB7IHNpbmdsZTogdW5kZWZpbmVkLCBtdWx0aTogdW5kZWZpbmVkIH07XG59XG5leHBvcnRzLk1vZGVJbmZvID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2luZ2xlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuTW9kZUluZm9fU2luZ2xlLmVuY29kZShtZXNzYWdlLnNpbmdsZSwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5tdWx0aSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLk1vZGVJbmZvX011bHRpLmVuY29kZShtZXNzYWdlLm11bHRpLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1vZGVJbmZvKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaW5nbGUgPSBleHBvcnRzLk1vZGVJbmZvX1NpbmdsZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubXVsdGkgPSBleHBvcnRzLk1vZGVJbmZvX011bHRpLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNpbmdsZTogaXNTZXQob2JqZWN0LnNpbmdsZSlcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuTW9kZUluZm9fU2luZ2xlLmZyb21KU09OKG9iamVjdC5zaW5nbGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBtdWx0aTogaXNTZXQob2JqZWN0Lm11bHRpKVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Nb2RlSW5mb19NdWx0aS5mcm9tSlNPTihvYmplY3QubXVsdGkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5zaW5nbGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zaW5nbGUgPSBtZXNzYWdlLnNpbmdsZVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Nb2RlSW5mb19TaW5nbGUudG9KU09OKG1lc3NhZ2Uuc2luZ2xlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5tdWx0aSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLm11bHRpID0gbWVzc2FnZS5tdWx0aVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Nb2RlSW5mb19NdWx0aS50b0pTT04obWVzc2FnZS5tdWx0aSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNb2RlSW5mbygpO1xuICAgICAgICBtZXNzYWdlLnNpbmdsZSA9XG4gICAgICAgICAgICBvYmplY3Quc2luZ2xlICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNpbmdsZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Nb2RlSW5mb19TaW5nbGUuZnJvbVBhcnRpYWwob2JqZWN0LnNpbmdsZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5tdWx0aSA9XG4gICAgICAgICAgICBvYmplY3QubXVsdGkgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QubXVsdGkgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuTW9kZUluZm9fTXVsdGkuZnJvbVBhcnRpYWwob2JqZWN0Lm11bHRpKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNb2RlSW5mb19TaW5nbGUoKSB7XG4gICAgcmV0dXJuIHsgbW9kZTogMCB9O1xufVxuZXhwb3J0cy5Nb2RlSW5mb19TaW5nbGUgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5tb2RlICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLmludDMyKG1lc3NhZ2UubW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTW9kZUluZm9fU2luZ2xlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tb2RlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vZGU6IGlzU2V0KG9iamVjdC5tb2RlKSA/ICgwLCBzaWduaW5nXzEuc2lnbk1vZGVGcm9tSlNPTikob2JqZWN0Lm1vZGUpIDogMCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLm1vZGUgIT09IHVuZGVmaW5lZCAmJiAob2JqLm1vZGUgPSAoMCwgc2lnbmluZ18xLnNpZ25Nb2RlVG9KU09OKShtZXNzYWdlLm1vZGUpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTW9kZUluZm9fU2luZ2xlKCk7XG4gICAgICAgIG1lc3NhZ2UubW9kZSA9IChfYSA9IG9iamVjdC5tb2RlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNb2RlSW5mb19NdWx0aSgpIHtcbiAgICByZXR1cm4geyBiaXRhcnJheTogdW5kZWZpbmVkLCBtb2RlSW5mb3M6IFtdIH07XG59XG5leHBvcnRzLk1vZGVJbmZvX011bHRpID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYml0YXJyYXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbXVsdGlzaWdfMS5Db21wYWN0Qml0QXJyYXkuZW5jb2RlKG1lc3NhZ2UuYml0YXJyYXksIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UubW9kZUluZm9zKSB7XG4gICAgICAgICAgICBleHBvcnRzLk1vZGVJbmZvLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1vZGVJbmZvX011bHRpKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5iaXRhcnJheSA9IG11bHRpc2lnXzEuQ29tcGFjdEJpdEFycmF5LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tb2RlSW5mb3MucHVzaChleHBvcnRzLk1vZGVJbmZvLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiaXRhcnJheTogaXNTZXQob2JqZWN0LmJpdGFycmF5KVxuICAgICAgICAgICAgICAgID8gbXVsdGlzaWdfMS5Db21wYWN0Qml0QXJyYXkuZnJvbUpTT04ob2JqZWN0LmJpdGFycmF5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbW9kZUluZm9zOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5tb2RlSW5mb3MpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QubW9kZUluZm9zLm1hcCgoZSkgPT4gZXhwb3J0cy5Nb2RlSW5mby5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuYml0YXJyYXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5iaXRhcnJheSA9IG1lc3NhZ2UuYml0YXJyYXlcbiAgICAgICAgICAgICAgICA/IG11bHRpc2lnXzEuQ29tcGFjdEJpdEFycmF5LnRvSlNPTihtZXNzYWdlLmJpdGFycmF5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UubW9kZUluZm9zKSB7XG4gICAgICAgICAgICBvYmoubW9kZUluZm9zID0gbWVzc2FnZS5tb2RlSW5mb3MubWFwKChlKSA9PiBlID8gZXhwb3J0cy5Nb2RlSW5mby50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLm1vZGVJbmZvcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1vZGVJbmZvX011bHRpKCk7XG4gICAgICAgIG1lc3NhZ2UuYml0YXJyYXkgPVxuICAgICAgICAgICAgb2JqZWN0LmJpdGFycmF5ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmJpdGFycmF5ICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBtdWx0aXNpZ18xLkNvbXBhY3RCaXRBcnJheS5mcm9tUGFydGlhbChvYmplY3QuYml0YXJyYXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UubW9kZUluZm9zID1cbiAgICAgICAgICAgICgoX2EgPSBvYmplY3QubW9kZUluZm9zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBleHBvcnRzLk1vZGVJbmZvLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZlZSgpIHtcbiAgICByZXR1cm4geyBhbW91bnQ6IFtdLCBnYXNMaW1pdDogXCIwXCIsIHBheWVyOiBcIlwiLCBncmFudGVyOiBcIlwiIH07XG59XG5leHBvcnRzLkZlZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLmFtb3VudCkge1xuICAgICAgICAgICAgY29pbl8xLkNvaW4uZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZ2FzTGltaXQgIT09IFwiMFwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS51aW50NjQobWVzc2FnZS5nYXNMaW1pdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucGF5ZXIgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLnN0cmluZyhtZXNzYWdlLnBheWVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5ncmFudGVyICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDM0KS5zdHJpbmcobWVzc2FnZS5ncmFudGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VGZWUoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFtb3VudC5wdXNoKGNvaW5fMS5Db2luLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZ2FzTGltaXQgPSBsb25nVG9TdHJpbmcocmVhZGVyLnVpbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBheWVyID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZ3JhbnRlciA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYW1vdW50OiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5hbW91bnQpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QuYW1vdW50Lm1hcCgoZSkgPT4gY29pbl8xLkNvaW4uZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBpc1NldChvYmplY3QuZ2FzTGltaXQpID8gU3RyaW5nKG9iamVjdC5nYXNMaW1pdCkgOiBcIjBcIixcbiAgICAgICAgICAgIHBheWVyOiBpc1NldChvYmplY3QucGF5ZXIpID8gU3RyaW5nKG9iamVjdC5wYXllcikgOiBcIlwiLFxuICAgICAgICAgICAgZ3JhbnRlcjogaXNTZXQob2JqZWN0LmdyYW50ZXIpID8gU3RyaW5nKG9iamVjdC5ncmFudGVyKSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYW1vdW50KSB7XG4gICAgICAgICAgICBvYmouYW1vdW50ID0gbWVzc2FnZS5hbW91bnQubWFwKChlKSA9PiAoZSA/IGNvaW5fMS5Db2luLnRvSlNPTihlKSA6IHVuZGVmaW5lZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLmFtb3VudCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UuZ2FzTGltaXQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmdhc0xpbWl0ID0gbWVzc2FnZS5nYXNMaW1pdCk7XG4gICAgICAgIG1lc3NhZ2UucGF5ZXIgIT09IHVuZGVmaW5lZCAmJiAob2JqLnBheWVyID0gbWVzc2FnZS5wYXllcik7XG4gICAgICAgIG1lc3NhZ2UuZ3JhbnRlciAhPT0gdW5kZWZpbmVkICYmIChvYmouZ3JhbnRlciA9IG1lc3NhZ2UuZ3JhbnRlcik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUZlZSgpO1xuICAgICAgICBtZXNzYWdlLmFtb3VudCA9ICgoX2EgPSBvYmplY3QuYW1vdW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChlKSA9PiBjb2luXzEuQ29pbi5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICBtZXNzYWdlLmdhc0xpbWl0ID0gKF9iID0gb2JqZWN0Lmdhc0xpbWl0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIjBcIjtcbiAgICAgICAgbWVzc2FnZS5wYXllciA9IChfYyA9IG9iamVjdC5wYXllcikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5ncmFudGVyID0gKF9kID0gb2JqZWN0LmdyYW50ZXIpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xudmFyIGdsb2JhbFRoaXMgPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB0aHJvdyBcIlVuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdFwiO1xufSkoKTtcbmNvbnN0IGF0b2IgPSBnbG9iYWxUaGlzLmF0b2IgfHxcbiAgICAoKGI2NCkgPT4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiNjQsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKFwiYmluYXJ5XCIpKTtcbmZ1bmN0aW9uIGJ5dGVzRnJvbUJhc2U2NChiNjQpIHtcbiAgICBjb25zdCBiaW4gPSBhdG9iKGI2NCk7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYmluLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5jb25zdCBidG9hID0gZ2xvYmFsVGhpcy5idG9hIHx8XG4gICAgKChiaW4pID0+IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYmluLCBcImJpbmFyeVwiKS50b1N0cmluZyhcImJhc2U2NFwiKSk7XG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyKSB7XG4gICAgY29uc3QgYmluID0gW107XG4gICAgZm9yIChjb25zdCBieXRlIG9mIGFycikge1xuICAgICAgICBiaW4ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ0b2EoYmluLmpvaW4oXCJcIikpO1xufVxuZnVuY3Rpb24gbG9uZ1RvU3RyaW5nKGxvbmcpIHtcbiAgICByZXR1cm4gbG9uZy50b1N0cmluZygpO1xufVxuaWYgKG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyAhPT0gbG9uZ18xLmRlZmF1bHQpIHtcbiAgICBtaW5pbWFsXzEuZGVmYXVsdC51dGlsLkxvbmcgPSBsb25nXzEuZGVmYXVsdDtcbiAgICBtaW5pbWFsXzEuZGVmYXVsdC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/tx/v1beta1/tx.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/upgrade/v1beta1/upgrade.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/cosmos/upgrade/v1beta1/upgrade.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ModuleVersion = exports.CancelSoftwareUpgradeProposal = exports.SoftwareUpgradeProposal = exports.Plan = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nconst timestamp_1 = __webpack_require__(/*! ../../../google/protobuf/timestamp */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/timestamp.js\");\nconst any_1 = __webpack_require__(/*! ../../../google/protobuf/any */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/any.js\");\nexports.protobufPackage = \"cosmos.upgrade.v1beta1\";\nfunction createBasePlan() {\n    return {\n        name: \"\",\n        time: undefined,\n        height: \"0\",\n        info: \"\",\n        upgradedClientState: undefined,\n    };\n}\nexports.Plan = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.name !== \"\") {\n            writer.uint32(10).string(message.name);\n        }\n        if (message.time !== undefined) {\n            timestamp_1.Timestamp.encode(toTimestamp(message.time), writer.uint32(18).fork()).ldelim();\n        }\n        if (message.height !== \"0\") {\n            writer.uint32(24).int64(message.height);\n        }\n        if (message.info !== \"\") {\n            writer.uint32(34).string(message.info);\n        }\n        if (message.upgradedClientState !== undefined) {\n            any_1.Any.encode(message.upgradedClientState, writer.uint32(42).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePlan();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.time = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.height = longToString(reader.int64());\n                    break;\n                case 4:\n                    message.info = reader.string();\n                    break;\n                case 5:\n                    message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            name: isSet(object.name) ? String(object.name) : \"\",\n            time: isSet(object.time) ? fromJsonTimestamp(object.time) : undefined,\n            height: isSet(object.height) ? String(object.height) : \"0\",\n            info: isSet(object.info) ? String(object.info) : \"\",\n            upgradedClientState: isSet(object.upgradedClientState)\n                ? any_1.Any.fromJSON(object.upgradedClientState)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.name !== undefined && (obj.name = message.name);\n        message.time !== undefined && (obj.time = message.time.toISOString());\n        message.height !== undefined && (obj.height = message.height);\n        message.info !== undefined && (obj.info = message.info);\n        message.upgradedClientState !== undefined &&\n            (obj.upgradedClientState = message.upgradedClientState\n                ? any_1.Any.toJSON(message.upgradedClientState)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBasePlan();\n        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : \"\";\n        message.time = (_b = object.time) !== null && _b !== void 0 ? _b : undefined;\n        message.height = (_c = object.height) !== null && _c !== void 0 ? _c : \"0\";\n        message.info = (_d = object.info) !== null && _d !== void 0 ? _d : \"\";\n        message.upgradedClientState =\n            object.upgradedClientState !== undefined &&\n                object.upgradedClientState !== null\n                ? any_1.Any.fromPartial(object.upgradedClientState)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseSoftwareUpgradeProposal() {\n    return { title: \"\", description: \"\", plan: undefined };\n}\nexports.SoftwareUpgradeProposal = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.title !== \"\") {\n            writer.uint32(10).string(message.title);\n        }\n        if (message.description !== \"\") {\n            writer.uint32(18).string(message.description);\n        }\n        if (message.plan !== undefined) {\n            exports.Plan.encode(message.plan, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSoftwareUpgradeProposal();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.title = reader.string();\n                    break;\n                case 2:\n                    message.description = reader.string();\n                    break;\n                case 3:\n                    message.plan = exports.Plan.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            title: isSet(object.title) ? String(object.title) : \"\",\n            description: isSet(object.description) ? String(object.description) : \"\",\n            plan: isSet(object.plan) ? exports.Plan.fromJSON(object.plan) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.title !== undefined && (obj.title = message.title);\n        message.description !== undefined &&\n            (obj.description = message.description);\n        message.plan !== undefined &&\n            (obj.plan = message.plan ? exports.Plan.toJSON(message.plan) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseSoftwareUpgradeProposal();\n        message.title = (_a = object.title) !== null && _a !== void 0 ? _a : \"\";\n        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : \"\";\n        message.plan =\n            object.plan !== undefined && object.plan !== null\n                ? exports.Plan.fromPartial(object.plan)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseCancelSoftwareUpgradeProposal() {\n    return { title: \"\", description: \"\" };\n}\nexports.CancelSoftwareUpgradeProposal = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.title !== \"\") {\n            writer.uint32(10).string(message.title);\n        }\n        if (message.description !== \"\") {\n            writer.uint32(18).string(message.description);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCancelSoftwareUpgradeProposal();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.title = reader.string();\n                    break;\n                case 2:\n                    message.description = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            title: isSet(object.title) ? String(object.title) : \"\",\n            description: isSet(object.description) ? String(object.description) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.title !== undefined && (obj.title = message.title);\n        message.description !== undefined &&\n            (obj.description = message.description);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseCancelSoftwareUpgradeProposal();\n        message.title = (_a = object.title) !== null && _a !== void 0 ? _a : \"\";\n        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseModuleVersion() {\n    return { name: \"\", version: \"0\" };\n}\nexports.ModuleVersion = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.name !== \"\") {\n            writer.uint32(10).string(message.name);\n        }\n        if (message.version !== \"0\") {\n            writer.uint32(16).uint64(message.version);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseModuleVersion();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.version = longToString(reader.uint64());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            name: isSet(object.name) ? String(object.name) : \"\",\n            version: isSet(object.version) ? String(object.version) : \"0\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.name !== undefined && (obj.name = message.name);\n        message.version !== undefined && (obj.version = message.version);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseModuleVersion();\n        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : \"\";\n        message.version = (_b = object.version) !== null && _b !== void 0 ? _b : \"0\";\n        return message;\n    },\n};\nfunction toTimestamp(date) {\n    const seconds = Math.trunc(date.getTime() / 1000).toString();\n    const nanos = (date.getTime() % 1000) * 1000000;\n    return { seconds, nanos };\n}\nfunction fromTimestamp(t) {\n    let millis = Number(t.seconds) * 1000;\n    millis += t.nanos / 1000000;\n    return new Date(millis);\n}\nfunction fromJsonTimestamp(o) {\n    if (o instanceof Date) {\n        return o;\n    }\n    else if (typeof o === \"string\") {\n        return new Date(o);\n    }\n    else {\n        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));\n    }\n}\nfunction longToString(long) {\n    return long.toString();\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=upgrade.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3MvdXBncmFkZS92MWJldGExL3VwZ3JhZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxxQ0FBcUMsR0FBRywrQkFBK0IsR0FBRyxZQUFZLEdBQUcsdUJBQXVCO0FBQ3hJO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMsbURBQU07QUFDN0Msa0NBQWtDLG1CQUFPLENBQUMsc0VBQW9CO0FBQzlELG9CQUFvQixtQkFBTyxDQUFDLHVIQUFvQztBQUNoRSxjQUFjLG1CQUFPLENBQUMsMkdBQThCO0FBQ3BELHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntb3MvdXBncmFkZS92MWJldGExL3VwZ3JhZGUuanM/NDAxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTW9kdWxlVmVyc2lvbiA9IGV4cG9ydHMuQ2FuY2VsU29mdHdhcmVVcGdyYWRlUHJvcG9zYWwgPSBleHBvcnRzLlNvZnR3YXJlVXBncmFkZVByb3Bvc2FsID0gZXhwb3J0cy5QbGFuID0gZXhwb3J0cy5wcm90b2J1ZlBhY2thZ2UgPSB2b2lkIDA7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuY29uc3QgbG9uZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb25nXCIpKTtcbmNvbnN0IG1pbmltYWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicHJvdG9idWZqcy9taW5pbWFsXCIpKTtcbmNvbnN0IHRpbWVzdGFtcF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2dvb2dsZS9wcm90b2J1Zi90aW1lc3RhbXBcIik7XG5jb25zdCBhbnlfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9nb29nbGUvcHJvdG9idWYvYW55XCIpO1xuZXhwb3J0cy5wcm90b2J1ZlBhY2thZ2UgPSBcImNvc21vcy51cGdyYWRlLnYxYmV0YTFcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQbGFuKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHRpbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgaGVpZ2h0OiBcIjBcIixcbiAgICAgICAgaW5mbzogXCJcIixcbiAgICAgICAgdXBncmFkZWRDbGllbnRTdGF0ZTogdW5kZWZpbmVkLFxuICAgIH07XG59XG5leHBvcnRzLlBsYW4gPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5uYW1lICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50aW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcF8xLlRpbWVzdGFtcC5lbmNvZGUodG9UaW1lc3RhbXAobWVzc2FnZS50aW1lKSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5oZWlnaHQgIT09IFwiMFwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI0KS5pbnQ2NChtZXNzYWdlLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5mbyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzNCkuc3RyaW5nKG1lc3NhZ2UuaW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudXBncmFkZWRDbGllbnRTdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhbnlfMS5BbnkuZW5jb2RlKG1lc3NhZ2UudXBncmFkZWRDbGllbnRTdGF0ZSwgd3JpdGVyLnVpbnQzMig0MikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQbGFuKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGltZSA9IGZyb21UaW1lc3RhbXAodGltZXN0YW1wXzEuVGltZXN0YW1wLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGVpZ2h0ID0gbG9uZ1RvU3RyaW5nKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluZm8gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS51cGdyYWRlZENsaWVudFN0YXRlID0gYW55XzEuQW55LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IGlzU2V0KG9iamVjdC5uYW1lKSA/IFN0cmluZyhvYmplY3QubmFtZSkgOiBcIlwiLFxuICAgICAgICAgICAgdGltZTogaXNTZXQob2JqZWN0LnRpbWUpID8gZnJvbUpzb25UaW1lc3RhbXAob2JqZWN0LnRpbWUpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaGVpZ2h0OiBpc1NldChvYmplY3QuaGVpZ2h0KSA/IFN0cmluZyhvYmplY3QuaGVpZ2h0KSA6IFwiMFwiLFxuICAgICAgICAgICAgaW5mbzogaXNTZXQob2JqZWN0LmluZm8pID8gU3RyaW5nKG9iamVjdC5pbmZvKSA6IFwiXCIsXG4gICAgICAgICAgICB1cGdyYWRlZENsaWVudFN0YXRlOiBpc1NldChvYmplY3QudXBncmFkZWRDbGllbnRTdGF0ZSlcbiAgICAgICAgICAgICAgICA/IGFueV8xLkFueS5mcm9tSlNPTihvYmplY3QudXBncmFkZWRDbGllbnRTdGF0ZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLm5hbWUgIT09IHVuZGVmaW5lZCAmJiAob2JqLm5hbWUgPSBtZXNzYWdlLm5hbWUpO1xuICAgICAgICBtZXNzYWdlLnRpbWUgIT09IHVuZGVmaW5lZCAmJiAob2JqLnRpbWUgPSBtZXNzYWdlLnRpbWUudG9JU09TdHJpbmcoKSk7XG4gICAgICAgIG1lc3NhZ2UuaGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgKG9iai5oZWlnaHQgPSBtZXNzYWdlLmhlaWdodCk7XG4gICAgICAgIG1lc3NhZ2UuaW5mbyAhPT0gdW5kZWZpbmVkICYmIChvYmouaW5mbyA9IG1lc3NhZ2UuaW5mbyk7XG4gICAgICAgIG1lc3NhZ2UudXBncmFkZWRDbGllbnRTdGF0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnVwZ3JhZGVkQ2xpZW50U3RhdGUgPSBtZXNzYWdlLnVwZ3JhZGVkQ2xpZW50U3RhdGVcbiAgICAgICAgICAgICAgICA/IGFueV8xLkFueS50b0pTT04obWVzc2FnZS51cGdyYWRlZENsaWVudFN0YXRlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUGxhbigpO1xuICAgICAgICBtZXNzYWdlLm5hbWUgPSAoX2EgPSBvYmplY3QubmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS50aW1lID0gKF9iID0gb2JqZWN0LnRpbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5oZWlnaHQgPSAoX2MgPSBvYmplY3QuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcIjBcIjtcbiAgICAgICAgbWVzc2FnZS5pbmZvID0gKF9kID0gb2JqZWN0LmluZm8pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudXBncmFkZWRDbGllbnRTdGF0ZSA9XG4gICAgICAgICAgICBvYmplY3QudXBncmFkZWRDbGllbnRTdGF0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgb2JqZWN0LnVwZ3JhZGVkQ2xpZW50U3RhdGUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGFueV8xLkFueS5mcm9tUGFydGlhbChvYmplY3QudXBncmFkZWRDbGllbnRTdGF0ZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlU29mdHdhcmVVcGdyYWRlUHJvcG9zYWwoKSB7XG4gICAgcmV0dXJuIHsgdGl0bGU6IFwiXCIsIGRlc2NyaXB0aW9uOiBcIlwiLCBwbGFuOiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydHMuU29mdHdhcmVVcGdyYWRlUHJvcG9zYWwgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS50aXRsZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UudGl0bGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmRlc2NyaXB0aW9uICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS5kZXNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucGxhbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLlBsYW4uZW5jb2RlKG1lc3NhZ2UucGxhbiwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTb2Z0d2FyZVVwZ3JhZGVQcm9wb3NhbCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGl0bGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kZXNjcmlwdGlvbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBsYW4gPSBleHBvcnRzLlBsYW4uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGl0bGU6IGlzU2V0KG9iamVjdC50aXRsZSkgPyBTdHJpbmcob2JqZWN0LnRpdGxlKSA6IFwiXCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogaXNTZXQob2JqZWN0LmRlc2NyaXB0aW9uKSA/IFN0cmluZyhvYmplY3QuZGVzY3JpcHRpb24pIDogXCJcIixcbiAgICAgICAgICAgIHBsYW46IGlzU2V0KG9iamVjdC5wbGFuKSA/IGV4cG9ydHMuUGxhbi5mcm9tSlNPTihvYmplY3QucGxhbikgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS50aXRsZSAhPT0gdW5kZWZpbmVkICYmIChvYmoudGl0bGUgPSBtZXNzYWdlLnRpdGxlKTtcbiAgICAgICAgbWVzc2FnZS5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmRlc2NyaXB0aW9uID0gbWVzc2FnZS5kZXNjcmlwdGlvbik7XG4gICAgICAgIG1lc3NhZ2UucGxhbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnBsYW4gPSBtZXNzYWdlLnBsYW4gPyBleHBvcnRzLlBsYW4udG9KU09OKG1lc3NhZ2UucGxhbikgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlU29mdHdhcmVVcGdyYWRlUHJvcG9zYWwoKTtcbiAgICAgICAgbWVzc2FnZS50aXRsZSA9IChfYSA9IG9iamVjdC50aXRsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5kZXNjcmlwdGlvbiA9IChfYiA9IG9iamVjdC5kZXNjcmlwdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5wbGFuID1cbiAgICAgICAgICAgIG9iamVjdC5wbGFuICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnBsYW4gIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuUGxhbi5mcm9tUGFydGlhbChvYmplY3QucGxhbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlQ2FuY2VsU29mdHdhcmVVcGdyYWRlUHJvcG9zYWwoKSB7XG4gICAgcmV0dXJuIHsgdGl0bGU6IFwiXCIsIGRlc2NyaXB0aW9uOiBcIlwiIH07XG59XG5leHBvcnRzLkNhbmNlbFNvZnR3YXJlVXBncmFkZVByb3Bvc2FsID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudGl0bGUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLnRpdGxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5kZXNjcmlwdGlvbiAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UuZGVzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNhbmNlbFNvZnR3YXJlVXBncmFkZVByb3Bvc2FsKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50aXRsZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRlc2NyaXB0aW9uID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0aXRsZTogaXNTZXQob2JqZWN0LnRpdGxlKSA/IFN0cmluZyhvYmplY3QudGl0bGUpIDogXCJcIixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBpc1NldChvYmplY3QuZGVzY3JpcHRpb24pID8gU3RyaW5nKG9iamVjdC5kZXNjcmlwdGlvbikgOiBcIlwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudGl0bGUgIT09IHVuZGVmaW5lZCAmJiAob2JqLnRpdGxlID0gbWVzc2FnZS50aXRsZSk7XG4gICAgICAgIG1lc3NhZ2UuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5kZXNjcmlwdGlvbiA9IG1lc3NhZ2UuZGVzY3JpcHRpb24pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ2FuY2VsU29mdHdhcmVVcGdyYWRlUHJvcG9zYWwoKTtcbiAgICAgICAgbWVzc2FnZS50aXRsZSA9IChfYSA9IG9iamVjdC50aXRsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5kZXNjcmlwdGlvbiA9IChfYiA9IG9iamVjdC5kZXNjcmlwdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlTW9kdWxlVmVyc2lvbigpIHtcbiAgICByZXR1cm4geyBuYW1lOiBcIlwiLCB2ZXJzaW9uOiBcIjBcIiB9O1xufVxuZXhwb3J0cy5Nb2R1bGVWZXJzaW9uID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UubmFtZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudmVyc2lvbiAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLnVpbnQ2NChtZXNzYWdlLnZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1vZHVsZVZlcnNpb24oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52ZXJzaW9uID0gbG9uZ1RvU3RyaW5nKHJlYWRlci51aW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IGlzU2V0KG9iamVjdC5uYW1lKSA/IFN0cmluZyhvYmplY3QubmFtZSkgOiBcIlwiLFxuICAgICAgICAgICAgdmVyc2lvbjogaXNTZXQob2JqZWN0LnZlcnNpb24pID8gU3RyaW5nKG9iamVjdC52ZXJzaW9uKSA6IFwiMFwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UubmFtZSAhPT0gdW5kZWZpbmVkICYmIChvYmoubmFtZSA9IG1lc3NhZ2UubmFtZSk7XG4gICAgICAgIG1lc3NhZ2UudmVyc2lvbiAhPT0gdW5kZWZpbmVkICYmIChvYmoudmVyc2lvbiA9IG1lc3NhZ2UudmVyc2lvbik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNb2R1bGVWZXJzaW9uKCk7XG4gICAgICAgIG1lc3NhZ2UubmFtZSA9IChfYSA9IG9iamVjdC5uYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnZlcnNpb24gPSAoX2IgPSBvYmplY3QudmVyc2lvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCIwXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gdG9UaW1lc3RhbXAoZGF0ZSkge1xuICAgIGNvbnN0IHNlY29uZHMgPSBNYXRoLnRydW5jKGRhdGUuZ2V0VGltZSgpIC8gMTAwMCkudG9TdHJpbmcoKTtcbiAgICBjb25zdCBuYW5vcyA9IChkYXRlLmdldFRpbWUoKSAlIDEwMDApICogMTAwMDAwMDtcbiAgICByZXR1cm4geyBzZWNvbmRzLCBuYW5vcyB9O1xufVxuZnVuY3Rpb24gZnJvbVRpbWVzdGFtcCh0KSB7XG4gICAgbGV0IG1pbGxpcyA9IE51bWJlcih0LnNlY29uZHMpICogMTAwMDtcbiAgICBtaWxsaXMgKz0gdC5uYW5vcyAvIDEwMDAwMDA7XG4gICAgcmV0dXJuIG5ldyBEYXRlKG1pbGxpcyk7XG59XG5mdW5jdGlvbiBmcm9tSnNvblRpbWVzdGFtcChvKSB7XG4gICAgaWYgKG8gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUobyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZnJvbVRpbWVzdGFtcCh0aW1lc3RhbXBfMS5UaW1lc3RhbXAuZnJvbUpTT04obykpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxvbmdUb1N0cmluZyhsb25nKSB7XG4gICAgcmV0dXJuIGxvbmcudG9TdHJpbmcoKTtcbn1cbmlmIChtaW5pbWFsXzEuZGVmYXVsdC51dGlsLkxvbmcgIT09IGxvbmdfMS5kZWZhdWx0KSB7XG4gICAgbWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nID0gbG9uZ18xLmRlZmF1bHQ7XG4gICAgbWluaW1hbF8xLmRlZmF1bHQuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXBncmFkZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/upgrade/v1beta1/upgrade.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/cosmwasm/wasm/v1/tx.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/cosmwasm/wasm/v1/tx.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MsgClearAdminResponse = exports.MsgClearAdmin = exports.MsgUpdateAdminResponse = exports.MsgUpdateAdmin = exports.MsgMigrateContractResponse = exports.MsgMigrateContract = exports.MsgExecuteContractResponse = exports.MsgExecuteContract = exports.MsgInstantiateContractResponse = exports.MsgInstantiateContract = exports.MsgStoreCodeResponse = exports.MsgStoreCode = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nconst types_1 = __webpack_require__(/*! ../../../cosmwasm/wasm/v1/types */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmwasm/wasm/v1/types.js\");\nconst coin_1 = __webpack_require__(/*! ../../../cosmos/base/v1beta1/coin */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/base/v1beta1/coin.js\");\nexports.protobufPackage = \"cosmwasm.wasm.v1\";\nfunction createBaseMsgStoreCode() {\n    return {\n        sender: \"\",\n        wasmByteCode: new Uint8Array(),\n        instantiatePermission: undefined,\n    };\n}\nexports.MsgStoreCode = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.sender !== \"\") {\n            writer.uint32(10).string(message.sender);\n        }\n        if (message.wasmByteCode.length !== 0) {\n            writer.uint32(18).bytes(message.wasmByteCode);\n        }\n        if (message.instantiatePermission !== undefined) {\n            types_1.AccessConfig.encode(message.instantiatePermission, writer.uint32(42).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgStoreCode();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sender = reader.string();\n                    break;\n                case 2:\n                    message.wasmByteCode = reader.bytes();\n                    break;\n                case 5:\n                    message.instantiatePermission = types_1.AccessConfig.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            sender: isSet(object.sender) ? String(object.sender) : \"\",\n            wasmByteCode: isSet(object.wasmByteCode)\n                ? bytesFromBase64(object.wasmByteCode)\n                : new Uint8Array(),\n            instantiatePermission: isSet(object.instantiatePermission)\n                ? types_1.AccessConfig.fromJSON(object.instantiatePermission)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.sender !== undefined && (obj.sender = message.sender);\n        message.wasmByteCode !== undefined &&\n            (obj.wasmByteCode = base64FromBytes(message.wasmByteCode !== undefined\n                ? message.wasmByteCode\n                : new Uint8Array()));\n        message.instantiatePermission !== undefined &&\n            (obj.instantiatePermission = message.instantiatePermission\n                ? types_1.AccessConfig.toJSON(message.instantiatePermission)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseMsgStoreCode();\n        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : \"\";\n        message.wasmByteCode = (_b = object.wasmByteCode) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.instantiatePermission =\n            object.instantiatePermission !== undefined &&\n                object.instantiatePermission !== null\n                ? types_1.AccessConfig.fromPartial(object.instantiatePermission)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseMsgStoreCodeResponse() {\n    return { codeId: \"0\" };\n}\nexports.MsgStoreCodeResponse = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.codeId !== \"0\") {\n            writer.uint32(8).uint64(message.codeId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgStoreCodeResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.codeId = longToString(reader.uint64());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            codeId: isSet(object.codeId) ? String(object.codeId) : \"0\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.codeId !== undefined && (obj.codeId = message.codeId);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseMsgStoreCodeResponse();\n        message.codeId = (_a = object.codeId) !== null && _a !== void 0 ? _a : \"0\";\n        return message;\n    },\n};\nfunction createBaseMsgInstantiateContract() {\n    return {\n        sender: \"\",\n        admin: \"\",\n        codeId: \"0\",\n        label: \"\",\n        msg: new Uint8Array(),\n        funds: [],\n    };\n}\nexports.MsgInstantiateContract = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.sender !== \"\") {\n            writer.uint32(10).string(message.sender);\n        }\n        if (message.admin !== \"\") {\n            writer.uint32(18).string(message.admin);\n        }\n        if (message.codeId !== \"0\") {\n            writer.uint32(24).uint64(message.codeId);\n        }\n        if (message.label !== \"\") {\n            writer.uint32(34).string(message.label);\n        }\n        if (message.msg.length !== 0) {\n            writer.uint32(42).bytes(message.msg);\n        }\n        for (const v of message.funds) {\n            coin_1.Coin.encode(v, writer.uint32(50).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgInstantiateContract();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sender = reader.string();\n                    break;\n                case 2:\n                    message.admin = reader.string();\n                    break;\n                case 3:\n                    message.codeId = longToString(reader.uint64());\n                    break;\n                case 4:\n                    message.label = reader.string();\n                    break;\n                case 5:\n                    message.msg = reader.bytes();\n                    break;\n                case 6:\n                    message.funds.push(coin_1.Coin.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            sender: isSet(object.sender) ? String(object.sender) : \"\",\n            admin: isSet(object.admin) ? String(object.admin) : \"\",\n            codeId: isSet(object.codeId) ? String(object.codeId) : \"0\",\n            label: isSet(object.label) ? String(object.label) : \"\",\n            msg: isSet(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array(),\n            funds: Array.isArray(object === null || object === void 0 ? void 0 : object.funds)\n                ? object.funds.map((e) => coin_1.Coin.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.sender !== undefined && (obj.sender = message.sender);\n        message.admin !== undefined && (obj.admin = message.admin);\n        message.codeId !== undefined && (obj.codeId = message.codeId);\n        message.label !== undefined && (obj.label = message.label);\n        message.msg !== undefined &&\n            (obj.msg = base64FromBytes(message.msg !== undefined ? message.msg : new Uint8Array()));\n        if (message.funds) {\n            obj.funds = message.funds.map((e) => (e ? coin_1.Coin.toJSON(e) : undefined));\n        }\n        else {\n            obj.funds = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f;\n        const message = createBaseMsgInstantiateContract();\n        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : \"\";\n        message.admin = (_b = object.admin) !== null && _b !== void 0 ? _b : \"\";\n        message.codeId = (_c = object.codeId) !== null && _c !== void 0 ? _c : \"0\";\n        message.label = (_d = object.label) !== null && _d !== void 0 ? _d : \"\";\n        message.msg = (_e = object.msg) !== null && _e !== void 0 ? _e : new Uint8Array();\n        message.funds = ((_f = object.funds) === null || _f === void 0 ? void 0 : _f.map((e) => coin_1.Coin.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseMsgInstantiateContractResponse() {\n    return { address: \"\", data: new Uint8Array() };\n}\nexports.MsgInstantiateContractResponse = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.address !== \"\") {\n            writer.uint32(10).string(message.address);\n        }\n        if (message.data.length !== 0) {\n            writer.uint32(18).bytes(message.data);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgInstantiateContractResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.address = reader.string();\n                    break;\n                case 2:\n                    message.data = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            address: isSet(object.address) ? String(object.address) : \"\",\n            data: isSet(object.data)\n                ? bytesFromBase64(object.data)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.address !== undefined && (obj.address = message.address);\n        message.data !== undefined &&\n            (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseMsgInstantiateContractResponse();\n        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : \"\";\n        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseMsgExecuteContract() {\n    return { sender: \"\", contract: \"\", msg: new Uint8Array(), funds: [] };\n}\nexports.MsgExecuteContract = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.sender !== \"\") {\n            writer.uint32(10).string(message.sender);\n        }\n        if (message.contract !== \"\") {\n            writer.uint32(18).string(message.contract);\n        }\n        if (message.msg.length !== 0) {\n            writer.uint32(26).bytes(message.msg);\n        }\n        for (const v of message.funds) {\n            coin_1.Coin.encode(v, writer.uint32(42).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgExecuteContract();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sender = reader.string();\n                    break;\n                case 2:\n                    message.contract = reader.string();\n                    break;\n                case 3:\n                    message.msg = reader.bytes();\n                    break;\n                case 5:\n                    message.funds.push(coin_1.Coin.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            sender: isSet(object.sender) ? String(object.sender) : \"\",\n            contract: isSet(object.contract) ? String(object.contract) : \"\",\n            msg: isSet(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array(),\n            funds: Array.isArray(object === null || object === void 0 ? void 0 : object.funds)\n                ? object.funds.map((e) => coin_1.Coin.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.sender !== undefined && (obj.sender = message.sender);\n        message.contract !== undefined && (obj.contract = message.contract);\n        message.msg !== undefined &&\n            (obj.msg = base64FromBytes(message.msg !== undefined ? message.msg : new Uint8Array()));\n        if (message.funds) {\n            obj.funds = message.funds.map((e) => (e ? coin_1.Coin.toJSON(e) : undefined));\n        }\n        else {\n            obj.funds = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseMsgExecuteContract();\n        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : \"\";\n        message.contract = (_b = object.contract) !== null && _b !== void 0 ? _b : \"\";\n        message.msg = (_c = object.msg) !== null && _c !== void 0 ? _c : new Uint8Array();\n        message.funds = ((_d = object.funds) === null || _d === void 0 ? void 0 : _d.map((e) => coin_1.Coin.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseMsgExecuteContractResponse() {\n    return { data: new Uint8Array() };\n}\nexports.MsgExecuteContractResponse = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.data.length !== 0) {\n            writer.uint32(10).bytes(message.data);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgExecuteContractResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.data = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            data: isSet(object.data)\n                ? bytesFromBase64(object.data)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.data !== undefined &&\n            (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseMsgExecuteContractResponse();\n        message.data = (_a = object.data) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseMsgMigrateContract() {\n    return { sender: \"\", contract: \"\", codeId: \"0\", msg: new Uint8Array() };\n}\nexports.MsgMigrateContract = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.sender !== \"\") {\n            writer.uint32(10).string(message.sender);\n        }\n        if (message.contract !== \"\") {\n            writer.uint32(18).string(message.contract);\n        }\n        if (message.codeId !== \"0\") {\n            writer.uint32(24).uint64(message.codeId);\n        }\n        if (message.msg.length !== 0) {\n            writer.uint32(34).bytes(message.msg);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgMigrateContract();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sender = reader.string();\n                    break;\n                case 2:\n                    message.contract = reader.string();\n                    break;\n                case 3:\n                    message.codeId = longToString(reader.uint64());\n                    break;\n                case 4:\n                    message.msg = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            sender: isSet(object.sender) ? String(object.sender) : \"\",\n            contract: isSet(object.contract) ? String(object.contract) : \"\",\n            codeId: isSet(object.codeId) ? String(object.codeId) : \"0\",\n            msg: isSet(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.sender !== undefined && (obj.sender = message.sender);\n        message.contract !== undefined && (obj.contract = message.contract);\n        message.codeId !== undefined && (obj.codeId = message.codeId);\n        message.msg !== undefined &&\n            (obj.msg = base64FromBytes(message.msg !== undefined ? message.msg : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseMsgMigrateContract();\n        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : \"\";\n        message.contract = (_b = object.contract) !== null && _b !== void 0 ? _b : \"\";\n        message.codeId = (_c = object.codeId) !== null && _c !== void 0 ? _c : \"0\";\n        message.msg = (_d = object.msg) !== null && _d !== void 0 ? _d : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseMsgMigrateContractResponse() {\n    return { data: new Uint8Array() };\n}\nexports.MsgMigrateContractResponse = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.data.length !== 0) {\n            writer.uint32(10).bytes(message.data);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgMigrateContractResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.data = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            data: isSet(object.data)\n                ? bytesFromBase64(object.data)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.data !== undefined &&\n            (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseMsgMigrateContractResponse();\n        message.data = (_a = object.data) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseMsgUpdateAdmin() {\n    return { sender: \"\", newAdmin: \"\", contract: \"\" };\n}\nexports.MsgUpdateAdmin = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.sender !== \"\") {\n            writer.uint32(10).string(message.sender);\n        }\n        if (message.newAdmin !== \"\") {\n            writer.uint32(18).string(message.newAdmin);\n        }\n        if (message.contract !== \"\") {\n            writer.uint32(26).string(message.contract);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgUpdateAdmin();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sender = reader.string();\n                    break;\n                case 2:\n                    message.newAdmin = reader.string();\n                    break;\n                case 3:\n                    message.contract = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            sender: isSet(object.sender) ? String(object.sender) : \"\",\n            newAdmin: isSet(object.newAdmin) ? String(object.newAdmin) : \"\",\n            contract: isSet(object.contract) ? String(object.contract) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.sender !== undefined && (obj.sender = message.sender);\n        message.newAdmin !== undefined && (obj.newAdmin = message.newAdmin);\n        message.contract !== undefined && (obj.contract = message.contract);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseMsgUpdateAdmin();\n        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : \"\";\n        message.newAdmin = (_b = object.newAdmin) !== null && _b !== void 0 ? _b : \"\";\n        message.contract = (_c = object.contract) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBaseMsgUpdateAdminResponse() {\n    return {};\n}\nexports.MsgUpdateAdminResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgUpdateAdminResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgUpdateAdminResponse();\n        return message;\n    },\n};\nfunction createBaseMsgClearAdmin() {\n    return { sender: \"\", contract: \"\" };\n}\nexports.MsgClearAdmin = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.sender !== \"\") {\n            writer.uint32(10).string(message.sender);\n        }\n        if (message.contract !== \"\") {\n            writer.uint32(26).string(message.contract);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgClearAdmin();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sender = reader.string();\n                    break;\n                case 3:\n                    message.contract = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            sender: isSet(object.sender) ? String(object.sender) : \"\",\n            contract: isSet(object.contract) ? String(object.contract) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.sender !== undefined && (obj.sender = message.sender);\n        message.contract !== undefined && (obj.contract = message.contract);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseMsgClearAdmin();\n        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : \"\";\n        message.contract = (_b = object.contract) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseMsgClearAdminResponse() {\n    return {};\n}\nexports.MsgClearAdminResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgClearAdminResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgClearAdminResponse();\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob ||\n    ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa ||\n    ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (const byte of arr) {\n        bin.push(String.fromCharCode(byte));\n    }\n    return btoa(bin.join(\"\"));\n}\nfunction longToString(long) {\n    return long.toString();\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=tx.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntd2FzbS93YXNtL3YxL3R4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLEdBQUcscUJBQXFCLEdBQUcsOEJBQThCLEdBQUcsc0JBQXNCLEdBQUcsa0NBQWtDLEdBQUcsMEJBQTBCLEdBQUcsa0NBQWtDLEdBQUcsMEJBQTBCLEdBQUcsc0NBQXNDLEdBQUcsOEJBQThCLEdBQUcsNEJBQTRCLEdBQUcsb0JBQW9CLEdBQUcsdUJBQXVCO0FBQzdZO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMsbURBQU07QUFDN0Msa0NBQWtDLG1CQUFPLENBQUMsc0VBQW9CO0FBQzlELGdCQUFnQixtQkFBTyxDQUFDLGlIQUFpQztBQUN6RCxlQUFlLG1CQUFPLENBQUMscUhBQW1DO0FBQzFELHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvcHJvdG8tdHlwZXMvY29zbXdhc20vd2FzbS92MS90eC5qcz9lNTJiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Nc2dDbGVhckFkbWluUmVzcG9uc2UgPSBleHBvcnRzLk1zZ0NsZWFyQWRtaW4gPSBleHBvcnRzLk1zZ1VwZGF0ZUFkbWluUmVzcG9uc2UgPSBleHBvcnRzLk1zZ1VwZGF0ZUFkbWluID0gZXhwb3J0cy5Nc2dNaWdyYXRlQ29udHJhY3RSZXNwb25zZSA9IGV4cG9ydHMuTXNnTWlncmF0ZUNvbnRyYWN0ID0gZXhwb3J0cy5Nc2dFeGVjdXRlQ29udHJhY3RSZXNwb25zZSA9IGV4cG9ydHMuTXNnRXhlY3V0ZUNvbnRyYWN0ID0gZXhwb3J0cy5Nc2dJbnN0YW50aWF0ZUNvbnRyYWN0UmVzcG9uc2UgPSBleHBvcnRzLk1zZ0luc3RhbnRpYXRlQ29udHJhY3QgPSBleHBvcnRzLk1zZ1N0b3JlQ29kZVJlc3BvbnNlID0gZXhwb3J0cy5Nc2dTdG9yZUNvZGUgPSBleHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlICovXG5jb25zdCBsb25nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvbmdcIikpO1xuY29uc3QgbWluaW1hbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwcm90b2J1ZmpzL21pbmltYWxcIikpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb3Ntd2FzbS93YXNtL3YxL3R5cGVzXCIpO1xuY29uc3QgY29pbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL2Nvc21vcy9iYXNlL3YxYmV0YTEvY29pblwiKTtcbmV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gXCJjb3Ntd2FzbS53YXNtLnYxXCI7XG5mdW5jdGlvbiBjcmVhdGVCYXNlTXNnU3RvcmVDb2RlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlbmRlcjogXCJcIixcbiAgICAgICAgd2FzbUJ5dGVDb2RlOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICBpbnN0YW50aWF0ZVBlcm1pc3Npb246IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuZXhwb3J0cy5Nc2dTdG9yZUNvZGUgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5zZW5kZXIgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLnNlbmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uud2FzbUJ5dGVDb2RlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuYnl0ZXMobWVzc2FnZS53YXNtQnl0ZUNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmluc3RhbnRpYXRlUGVybWlzc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0eXBlc18xLkFjY2Vzc0NvbmZpZy5lbmNvZGUobWVzc2FnZS5pbnN0YW50aWF0ZVBlcm1pc3Npb24sIHdyaXRlci51aW50MzIoNDIpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnU3RvcmVDb2RlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZW5kZXIgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS53YXNtQnl0ZUNvZGUgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmluc3RhbnRpYXRlUGVybWlzc2lvbiA9IHR5cGVzXzEuQWNjZXNzQ29uZmlnLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlbmRlcjogaXNTZXQob2JqZWN0LnNlbmRlcikgPyBTdHJpbmcob2JqZWN0LnNlbmRlcikgOiBcIlwiLFxuICAgICAgICAgICAgd2FzbUJ5dGVDb2RlOiBpc1NldChvYmplY3Qud2FzbUJ5dGVDb2RlKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC53YXNtQnl0ZUNvZGUpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgaW5zdGFudGlhdGVQZXJtaXNzaW9uOiBpc1NldChvYmplY3QuaW5zdGFudGlhdGVQZXJtaXNzaW9uKVxuICAgICAgICAgICAgICAgID8gdHlwZXNfMS5BY2Nlc3NDb25maWcuZnJvbUpTT04ob2JqZWN0Lmluc3RhbnRpYXRlUGVybWlzc2lvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnNlbmRlciAhPT0gdW5kZWZpbmVkICYmIChvYmouc2VuZGVyID0gbWVzc2FnZS5zZW5kZXIpO1xuICAgICAgICBtZXNzYWdlLndhc21CeXRlQ29kZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLndhc21CeXRlQ29kZSA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLndhc21CeXRlQ29kZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBtZXNzYWdlLndhc21CeXRlQ29kZVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLmluc3RhbnRpYXRlUGVybWlzc2lvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmluc3RhbnRpYXRlUGVybWlzc2lvbiA9IG1lc3NhZ2UuaW5zdGFudGlhdGVQZXJtaXNzaW9uXG4gICAgICAgICAgICAgICAgPyB0eXBlc18xLkFjY2Vzc0NvbmZpZy50b0pTT04obWVzc2FnZS5pbnN0YW50aWF0ZVBlcm1pc3Npb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnU3RvcmVDb2RlKCk7XG4gICAgICAgIG1lc3NhZ2Uuc2VuZGVyID0gKF9hID0gb2JqZWN0LnNlbmRlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS53YXNtQnl0ZUNvZGUgPSAoX2IgPSBvYmplY3Qud2FzbUJ5dGVDb2RlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmluc3RhbnRpYXRlUGVybWlzc2lvbiA9XG4gICAgICAgICAgICBvYmplY3QuaW5zdGFudGlhdGVQZXJtaXNzaW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBvYmplY3QuaW5zdGFudGlhdGVQZXJtaXNzaW9uICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyB0eXBlc18xLkFjY2Vzc0NvbmZpZy5mcm9tUGFydGlhbChvYmplY3QuaW5zdGFudGlhdGVQZXJtaXNzaW9uKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dTdG9yZUNvZGVSZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyBjb2RlSWQ6IFwiMFwiIH07XG59XG5leHBvcnRzLk1zZ1N0b3JlQ29kZVJlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuY29kZUlkICE9PSBcIjBcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS51aW50NjQobWVzc2FnZS5jb2RlSWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ1N0b3JlQ29kZVJlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb2RlSWQgPSBsb25nVG9TdHJpbmcocmVhZGVyLnVpbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZUlkOiBpc1NldChvYmplY3QuY29kZUlkKSA/IFN0cmluZyhvYmplY3QuY29kZUlkKSA6IFwiMFwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuY29kZUlkICE9PSB1bmRlZmluZWQgJiYgKG9iai5jb2RlSWQgPSBtZXNzYWdlLmNvZGVJZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ1N0b3JlQ29kZVJlc3BvbnNlKCk7XG4gICAgICAgIG1lc3NhZ2UuY29kZUlkID0gKF9hID0gb2JqZWN0LmNvZGVJZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCIwXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ0luc3RhbnRpYXRlQ29udHJhY3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VuZGVyOiBcIlwiLFxuICAgICAgICBhZG1pbjogXCJcIixcbiAgICAgICAgY29kZUlkOiBcIjBcIixcbiAgICAgICAgbGFiZWw6IFwiXCIsXG4gICAgICAgIG1zZzogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgZnVuZHM6IFtdLFxuICAgIH07XG59XG5leHBvcnRzLk1zZ0luc3RhbnRpYXRlQ29udHJhY3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5zZW5kZXIgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLnNlbmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYWRtaW4gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLmFkbWluKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb2RlSWQgIT09IFwiMFwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI0KS51aW50NjQobWVzc2FnZS5jb2RlSWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmxhYmVsICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDM0KS5zdHJpbmcobWVzc2FnZS5sYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubXNnLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig0MikuYnl0ZXMobWVzc2FnZS5tc2cpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLmZ1bmRzKSB7XG4gICAgICAgICAgICBjb2luXzEuQ29pbi5lbmNvZGUodiwgd3JpdGVyLnVpbnQzMig1MCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dJbnN0YW50aWF0ZUNvbnRyYWN0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zZW5kZXIgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZG1pbiA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvZGVJZCA9IGxvbmdUb1N0cmluZyhyZWFkZXIudWludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGFiZWwgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tc2cgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZ1bmRzLnB1c2goY29pbl8xLkNvaW4uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlbmRlcjogaXNTZXQob2JqZWN0LnNlbmRlcikgPyBTdHJpbmcob2JqZWN0LnNlbmRlcikgOiBcIlwiLFxuICAgICAgICAgICAgYWRtaW46IGlzU2V0KG9iamVjdC5hZG1pbikgPyBTdHJpbmcob2JqZWN0LmFkbWluKSA6IFwiXCIsXG4gICAgICAgICAgICBjb2RlSWQ6IGlzU2V0KG9iamVjdC5jb2RlSWQpID8gU3RyaW5nKG9iamVjdC5jb2RlSWQpIDogXCIwXCIsXG4gICAgICAgICAgICBsYWJlbDogaXNTZXQob2JqZWN0LmxhYmVsKSA/IFN0cmluZyhvYmplY3QubGFiZWwpIDogXCJcIixcbiAgICAgICAgICAgIG1zZzogaXNTZXQob2JqZWN0Lm1zZykgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0Lm1zZykgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgZnVuZHM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LmZ1bmRzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LmZ1bmRzLm1hcCgoZSkgPT4gY29pbl8xLkNvaW4uZnJvbUpTT04oZSkpXG4gICAgICAgICAgICAgICAgOiBbXSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnNlbmRlciAhPT0gdW5kZWZpbmVkICYmIChvYmouc2VuZGVyID0gbWVzc2FnZS5zZW5kZXIpO1xuICAgICAgICBtZXNzYWdlLmFkbWluICE9PSB1bmRlZmluZWQgJiYgKG9iai5hZG1pbiA9IG1lc3NhZ2UuYWRtaW4pO1xuICAgICAgICBtZXNzYWdlLmNvZGVJZCAhPT0gdW5kZWZpbmVkICYmIChvYmouY29kZUlkID0gbWVzc2FnZS5jb2RlSWQpO1xuICAgICAgICBtZXNzYWdlLmxhYmVsICE9PSB1bmRlZmluZWQgJiYgKG9iai5sYWJlbCA9IG1lc3NhZ2UubGFiZWwpO1xuICAgICAgICBtZXNzYWdlLm1zZyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLm1zZyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLm1zZyAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5tc2cgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIGlmIChtZXNzYWdlLmZ1bmRzKSB7XG4gICAgICAgICAgICBvYmouZnVuZHMgPSBtZXNzYWdlLmZ1bmRzLm1hcCgoZSkgPT4gKGUgPyBjb2luXzEuQ29pbi50b0pTT04oZSkgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5mdW5kcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnSW5zdGFudGlhdGVDb250cmFjdCgpO1xuICAgICAgICBtZXNzYWdlLnNlbmRlciA9IChfYSA9IG9iamVjdC5zZW5kZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuYWRtaW4gPSAoX2IgPSBvYmplY3QuYWRtaW4pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuY29kZUlkID0gKF9jID0gb2JqZWN0LmNvZGVJZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogXCIwXCI7XG4gICAgICAgIG1lc3NhZ2UubGFiZWwgPSAoX2QgPSBvYmplY3QubGFiZWwpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UubXNnID0gKF9lID0gb2JqZWN0Lm1zZykgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5mdW5kcyA9ICgoX2YgPSBvYmplY3QuZnVuZHMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5tYXAoKGUpID0+IGNvaW5fMS5Db2luLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ0luc3RhbnRpYXRlQ29udHJhY3RSZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyBhZGRyZXNzOiBcIlwiLCBkYXRhOiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnRzLk1zZ0luc3RhbnRpYXRlQ29udHJhY3RSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmFkZHJlc3MgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLmFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmRhdGEubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5ieXRlcyhtZXNzYWdlLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ0luc3RhbnRpYXRlQ29udHJhY3RSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkcmVzcyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGEgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzczogaXNTZXQob2JqZWN0LmFkZHJlc3MpID8gU3RyaW5nKG9iamVjdC5hZGRyZXNzKSA6IFwiXCIsXG4gICAgICAgICAgICBkYXRhOiBpc1NldChvYmplY3QuZGF0YSlcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuZGF0YSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5hZGRyZXNzICE9PSB1bmRlZmluZWQgJiYgKG9iai5hZGRyZXNzID0gbWVzc2FnZS5hZGRyZXNzKTtcbiAgICAgICAgbWVzc2FnZS5kYXRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZGF0YSA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmRhdGEgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuZGF0YSA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ0luc3RhbnRpYXRlQ29udHJhY3RSZXNwb25zZSgpO1xuICAgICAgICBtZXNzYWdlLmFkZHJlc3MgPSAoX2EgPSBvYmplY3QuYWRkcmVzcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5kYXRhID0gKF9iID0gb2JqZWN0LmRhdGEpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ0V4ZWN1dGVDb250cmFjdCgpIHtcbiAgICByZXR1cm4geyBzZW5kZXI6IFwiXCIsIGNvbnRyYWN0OiBcIlwiLCBtc2c6IG5ldyBVaW50OEFycmF5KCksIGZ1bmRzOiBbXSB9O1xufVxuZXhwb3J0cy5Nc2dFeGVjdXRlQ29udHJhY3QgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5zZW5kZXIgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLnNlbmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuY29udHJhY3QgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLmNvbnRyYWN0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5tc2cubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5ieXRlcyhtZXNzYWdlLm1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuZnVuZHMpIHtcbiAgICAgICAgICAgIGNvaW5fMS5Db2luLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDQyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ0V4ZWN1dGVDb250cmFjdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VuZGVyID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29udHJhY3QgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tc2cgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZ1bmRzLnB1c2goY29pbl8xLkNvaW4uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNlbmRlcjogaXNTZXQob2JqZWN0LnNlbmRlcikgPyBTdHJpbmcob2JqZWN0LnNlbmRlcikgOiBcIlwiLFxuICAgICAgICAgICAgY29udHJhY3Q6IGlzU2V0KG9iamVjdC5jb250cmFjdCkgPyBTdHJpbmcob2JqZWN0LmNvbnRyYWN0KSA6IFwiXCIsXG4gICAgICAgICAgICBtc2c6IGlzU2V0KG9iamVjdC5tc2cpID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5tc2cpIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIGZ1bmRzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5mdW5kcylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5mdW5kcy5tYXAoKGUpID0+IGNvaW5fMS5Db2luLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5zZW5kZXIgIT09IHVuZGVmaW5lZCAmJiAob2JqLnNlbmRlciA9IG1lc3NhZ2Uuc2VuZGVyKTtcbiAgICAgICAgbWVzc2FnZS5jb250cmFjdCAhPT0gdW5kZWZpbmVkICYmIChvYmouY29udHJhY3QgPSBtZXNzYWdlLmNvbnRyYWN0KTtcbiAgICAgICAgbWVzc2FnZS5tc2cgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5tc2cgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5tc2cgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UubXNnIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBpZiAobWVzc2FnZS5mdW5kcykge1xuICAgICAgICAgICAgb2JqLmZ1bmRzID0gbWVzc2FnZS5mdW5kcy5tYXAoKGUpID0+IChlID8gY29pbl8xLkNvaW4udG9KU09OKGUpIDogdW5kZWZpbmVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmouZnVuZHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dFeGVjdXRlQ29udHJhY3QoKTtcbiAgICAgICAgbWVzc2FnZS5zZW5kZXIgPSAoX2EgPSBvYmplY3Quc2VuZGVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmNvbnRyYWN0ID0gKF9iID0gb2JqZWN0LmNvbnRyYWN0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLm1zZyA9IChfYyA9IG9iamVjdC5tc2cpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UuZnVuZHMgPSAoKF9kID0gb2JqZWN0LmZ1bmRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubWFwKChlKSA9PiBjb2luXzEuQ29pbi5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dFeGVjdXRlQ29udHJhY3RSZXNwb25zZSgpIHtcbiAgICByZXR1cm4geyBkYXRhOiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnRzLk1zZ0V4ZWN1dGVDb250cmFjdFJlc3BvbnNlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnRXhlY3V0ZUNvbnRyYWN0UmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGEgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogaXNTZXQob2JqZWN0LmRhdGEpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmRhdGEpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuZGF0YSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmRhdGEgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5kYXRhICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmRhdGEgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ0V4ZWN1dGVDb250cmFjdFJlc3BvbnNlKCk7XG4gICAgICAgIG1lc3NhZ2UuZGF0YSA9IChfYSA9IG9iamVjdC5kYXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dNaWdyYXRlQ29udHJhY3QoKSB7XG4gICAgcmV0dXJuIHsgc2VuZGVyOiBcIlwiLCBjb250cmFjdDogXCJcIiwgY29kZUlkOiBcIjBcIiwgbXNnOiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnRzLk1zZ01pZ3JhdGVDb250cmFjdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnNlbmRlciAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2Uuc2VuZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb250cmFjdCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UuY29udHJhY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNvZGVJZCAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjQpLnVpbnQ2NChtZXNzYWdlLmNvZGVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubXNnLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzNCkuYnl0ZXMobWVzc2FnZS5tc2cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ01pZ3JhdGVDb250cmFjdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VuZGVyID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29udHJhY3QgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb2RlSWQgPSBsb25nVG9TdHJpbmcocmVhZGVyLnVpbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1zZyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZW5kZXI6IGlzU2V0KG9iamVjdC5zZW5kZXIpID8gU3RyaW5nKG9iamVjdC5zZW5kZXIpIDogXCJcIixcbiAgICAgICAgICAgIGNvbnRyYWN0OiBpc1NldChvYmplY3QuY29udHJhY3QpID8gU3RyaW5nKG9iamVjdC5jb250cmFjdCkgOiBcIlwiLFxuICAgICAgICAgICAgY29kZUlkOiBpc1NldChvYmplY3QuY29kZUlkKSA/IFN0cmluZyhvYmplY3QuY29kZUlkKSA6IFwiMFwiLFxuICAgICAgICAgICAgbXNnOiBpc1NldChvYmplY3QubXNnKSA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QubXNnKSA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5zZW5kZXIgIT09IHVuZGVmaW5lZCAmJiAob2JqLnNlbmRlciA9IG1lc3NhZ2Uuc2VuZGVyKTtcbiAgICAgICAgbWVzc2FnZS5jb250cmFjdCAhPT0gdW5kZWZpbmVkICYmIChvYmouY29udHJhY3QgPSBtZXNzYWdlLmNvbnRyYWN0KTtcbiAgICAgICAgbWVzc2FnZS5jb2RlSWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmNvZGVJZCA9IG1lc3NhZ2UuY29kZUlkKTtcbiAgICAgICAgbWVzc2FnZS5tc2cgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5tc2cgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5tc2cgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UubXNnIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dNaWdyYXRlQ29udHJhY3QoKTtcbiAgICAgICAgbWVzc2FnZS5zZW5kZXIgPSAoX2EgPSBvYmplY3Quc2VuZGVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmNvbnRyYWN0ID0gKF9iID0gb2JqZWN0LmNvbnRyYWN0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmNvZGVJZCA9IChfYyA9IG9iamVjdC5jb2RlSWQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFwiMFwiO1xuICAgICAgICBtZXNzYWdlLm1zZyA9IChfZCA9IG9iamVjdC5tc2cpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ01pZ3JhdGVDb250cmFjdFJlc3BvbnNlKCkge1xuICAgIHJldHVybiB7IGRhdGE6IG5ldyBVaW50OEFycmF5KCkgfTtcbn1cbmV4cG9ydHMuTXNnTWlncmF0ZUNvbnRyYWN0UmVzcG9uc2UgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5kYXRhLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dNaWdyYXRlQ29udHJhY3RSZXNwb25zZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBpc1NldChvYmplY3QuZGF0YSlcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuZGF0YSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5kYXRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZGF0YSA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmRhdGEgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuZGF0YSA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnTWlncmF0ZUNvbnRyYWN0UmVzcG9uc2UoKTtcbiAgICAgICAgbWVzc2FnZS5kYXRhID0gKF9hID0gb2JqZWN0LmRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZU1zZ1VwZGF0ZUFkbWluKCkge1xuICAgIHJldHVybiB7IHNlbmRlcjogXCJcIiwgbmV3QWRtaW46IFwiXCIsIGNvbnRyYWN0OiBcIlwiIH07XG59XG5leHBvcnRzLk1zZ1VwZGF0ZUFkbWluID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2VuZGVyICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5zZW5kZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm5ld0FkbWluICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS5uZXdBZG1pbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuY29udHJhY3QgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjYpLnN0cmluZyhtZXNzYWdlLmNvbnRyYWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dVcGRhdGVBZG1pbigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VuZGVyID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmV3QWRtaW4gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb250cmFjdCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VuZGVyOiBpc1NldChvYmplY3Quc2VuZGVyKSA/IFN0cmluZyhvYmplY3Quc2VuZGVyKSA6IFwiXCIsXG4gICAgICAgICAgICBuZXdBZG1pbjogaXNTZXQob2JqZWN0Lm5ld0FkbWluKSA/IFN0cmluZyhvYmplY3QubmV3QWRtaW4pIDogXCJcIixcbiAgICAgICAgICAgIGNvbnRyYWN0OiBpc1NldChvYmplY3QuY29udHJhY3QpID8gU3RyaW5nKG9iamVjdC5jb250cmFjdCkgOiBcIlwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uuc2VuZGVyICE9PSB1bmRlZmluZWQgJiYgKG9iai5zZW5kZXIgPSBtZXNzYWdlLnNlbmRlcik7XG4gICAgICAgIG1lc3NhZ2UubmV3QWRtaW4gIT09IHVuZGVmaW5lZCAmJiAob2JqLm5ld0FkbWluID0gbWVzc2FnZS5uZXdBZG1pbik7XG4gICAgICAgIG1lc3NhZ2UuY29udHJhY3QgIT09IHVuZGVmaW5lZCAmJiAob2JqLmNvbnRyYWN0ID0gbWVzc2FnZS5jb250cmFjdCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnVXBkYXRlQWRtaW4oKTtcbiAgICAgICAgbWVzc2FnZS5zZW5kZXIgPSAoX2EgPSBvYmplY3Quc2VuZGVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLm5ld0FkbWluID0gKF9iID0gb2JqZWN0Lm5ld0FkbWluKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmNvbnRyYWN0ID0gKF9jID0gb2JqZWN0LmNvbnRyYWN0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dVcGRhdGVBZG1pblJlc3BvbnNlKCkge1xuICAgIHJldHVybiB7fTtcbn1cbmV4cG9ydHMuTXNnVXBkYXRlQWRtaW5SZXNwb25zZSA9IHtcbiAgICBlbmNvZGUoXywgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ1VwZGF0ZUFkbWluUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKF8pIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH0sXG4gICAgdG9KU09OKF8pIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChfKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnVXBkYXRlQWRtaW5SZXNwb25zZSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dDbGVhckFkbWluKCkge1xuICAgIHJldHVybiB7IHNlbmRlcjogXCJcIiwgY29udHJhY3Q6IFwiXCIgfTtcbn1cbmV4cG9ydHMuTXNnQ2xlYXJBZG1pbiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnNlbmRlciAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2Uuc2VuZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb250cmFjdCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuc3RyaW5nKG1lc3NhZ2UuY29udHJhY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ0NsZWFyQWRtaW4oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlbmRlciA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnRyYWN0ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZW5kZXI6IGlzU2V0KG9iamVjdC5zZW5kZXIpID8gU3RyaW5nKG9iamVjdC5zZW5kZXIpIDogXCJcIixcbiAgICAgICAgICAgIGNvbnRyYWN0OiBpc1NldChvYmplY3QuY29udHJhY3QpID8gU3RyaW5nKG9iamVjdC5jb250cmFjdCkgOiBcIlwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uuc2VuZGVyICE9PSB1bmRlZmluZWQgJiYgKG9iai5zZW5kZXIgPSBtZXNzYWdlLnNlbmRlcik7XG4gICAgICAgIG1lc3NhZ2UuY29udHJhY3QgIT09IHVuZGVmaW5lZCAmJiAob2JqLmNvbnRyYWN0ID0gbWVzc2FnZS5jb250cmFjdCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VNc2dDbGVhckFkbWluKCk7XG4gICAgICAgIG1lc3NhZ2Uuc2VuZGVyID0gKF9hID0gb2JqZWN0LnNlbmRlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5jb250cmFjdCA9IChfYiA9IG9iamVjdC5jb250cmFjdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlTXNnQ2xlYXJBZG1pblJlc3BvbnNlKCkge1xuICAgIHJldHVybiB7fTtcbn1cbmV4cG9ydHMuTXNnQ2xlYXJBZG1pblJlc3BvbnNlID0ge1xuICAgIGVuY29kZShfLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnQ2xlYXJBZG1pblJlc3BvbnNlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihfKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9LFxuICAgIHRvSlNPTihfKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwoXykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ0NsZWFyQWRtaW5SZXNwb25zZSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbnZhciBnbG9iYWxUaGlzID0gKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgdGhyb3cgXCJVbmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3RcIjtcbn0pKCk7XG5jb25zdCBhdG9iID0gZ2xvYmFsVGhpcy5hdG9iIHx8XG4gICAgKChiNjQpID0+IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYjY0LCBcImJhc2U2NFwiKS50b1N0cmluZyhcImJpbmFyeVwiKSk7XG5mdW5jdGlvbiBieXRlc0Zyb21CYXNlNjQoYjY0KSB7XG4gICAgY29uc3QgYmluID0gYXRvYihiNjQpO1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJpbi5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGFycltpXSA9IGJpbi5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuY29uc3QgYnRvYSA9IGdsb2JhbFRoaXMuYnRvYSB8fFxuICAgICgoYmluKSA9PiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGJpbiwgXCJiaW5hcnlcIikudG9TdHJpbmcoXCJiYXNlNjRcIikpO1xuZnVuY3Rpb24gYmFzZTY0RnJvbUJ5dGVzKGFycikge1xuICAgIGNvbnN0IGJpbiA9IFtdO1xuICAgIGZvciAoY29uc3QgYnl0ZSBvZiBhcnIpIHtcbiAgICAgICAgYmluLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSk7XG4gICAgfVxuICAgIHJldHVybiBidG9hKGJpbi5qb2luKFwiXCIpKTtcbn1cbmZ1bmN0aW9uIGxvbmdUb1N0cmluZyhsb25nKSB7XG4gICAgcmV0dXJuIGxvbmcudG9TdHJpbmcoKTtcbn1cbmlmIChtaW5pbWFsXzEuZGVmYXVsdC51dGlsLkxvbmcgIT09IGxvbmdfMS5kZWZhdWx0KSB7XG4gICAgbWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nID0gbG9uZ18xLmRlZmF1bHQ7XG4gICAgbWluaW1hbF8xLmRlZmF1bHQuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/cosmwasm/wasm/v1/tx.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/cosmwasm/wasm/v1/types.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/cosmwasm/wasm/v1/types.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Model = exports.AbsoluteTxPosition = exports.ContractCodeHistoryEntry = exports.ContractInfo = exports.CodeInfo = exports.Params = exports.AccessConfig = exports.AccessTypeParam = exports.contractCodeHistoryOperationTypeToJSON = exports.contractCodeHistoryOperationTypeFromJSON = exports.ContractCodeHistoryOperationType = exports.accessTypeToJSON = exports.accessTypeFromJSON = exports.AccessType = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nconst any_1 = __webpack_require__(/*! ../../../google/protobuf/any */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/any.js\");\nexports.protobufPackage = \"cosmwasm.wasm.v1\";\n/** AccessType permission types */\nvar AccessType;\n(function (AccessType) {\n    /** ACCESS_TYPE_UNSPECIFIED - AccessTypeUnspecified placeholder for empty value */\n    AccessType[AccessType[\"ACCESS_TYPE_UNSPECIFIED\"] = 0] = \"ACCESS_TYPE_UNSPECIFIED\";\n    /** ACCESS_TYPE_NOBODY - AccessTypeNobody forbidden */\n    AccessType[AccessType[\"ACCESS_TYPE_NOBODY\"] = 1] = \"ACCESS_TYPE_NOBODY\";\n    /** ACCESS_TYPE_ONLY_ADDRESS - AccessTypeOnlyAddress restricted to an address */\n    AccessType[AccessType[\"ACCESS_TYPE_ONLY_ADDRESS\"] = 2] = \"ACCESS_TYPE_ONLY_ADDRESS\";\n    /** ACCESS_TYPE_EVERYBODY - AccessTypeEverybody unrestricted */\n    AccessType[AccessType[\"ACCESS_TYPE_EVERYBODY\"] = 3] = \"ACCESS_TYPE_EVERYBODY\";\n    AccessType[AccessType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(AccessType = exports.AccessType || (exports.AccessType = {}));\nfunction accessTypeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"ACCESS_TYPE_UNSPECIFIED\":\n            return AccessType.ACCESS_TYPE_UNSPECIFIED;\n        case 1:\n        case \"ACCESS_TYPE_NOBODY\":\n            return AccessType.ACCESS_TYPE_NOBODY;\n        case 2:\n        case \"ACCESS_TYPE_ONLY_ADDRESS\":\n            return AccessType.ACCESS_TYPE_ONLY_ADDRESS;\n        case 3:\n        case \"ACCESS_TYPE_EVERYBODY\":\n            return AccessType.ACCESS_TYPE_EVERYBODY;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return AccessType.UNRECOGNIZED;\n    }\n}\nexports.accessTypeFromJSON = accessTypeFromJSON;\nfunction accessTypeToJSON(object) {\n    switch (object) {\n        case AccessType.ACCESS_TYPE_UNSPECIFIED:\n            return \"ACCESS_TYPE_UNSPECIFIED\";\n        case AccessType.ACCESS_TYPE_NOBODY:\n            return \"ACCESS_TYPE_NOBODY\";\n        case AccessType.ACCESS_TYPE_ONLY_ADDRESS:\n            return \"ACCESS_TYPE_ONLY_ADDRESS\";\n        case AccessType.ACCESS_TYPE_EVERYBODY:\n            return \"ACCESS_TYPE_EVERYBODY\";\n        default:\n            return \"UNKNOWN\";\n    }\n}\nexports.accessTypeToJSON = accessTypeToJSON;\n/** ContractCodeHistoryOperationType actions that caused a code change */\nvar ContractCodeHistoryOperationType;\n(function (ContractCodeHistoryOperationType) {\n    /** CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED - ContractCodeHistoryOperationTypeUnspecified placeholder for empty value */\n    ContractCodeHistoryOperationType[ContractCodeHistoryOperationType[\"CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED\"] = 0] = \"CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED\";\n    /** CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT - ContractCodeHistoryOperationTypeInit on chain contract instantiation */\n    ContractCodeHistoryOperationType[ContractCodeHistoryOperationType[\"CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT\"] = 1] = \"CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT\";\n    /** CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE - ContractCodeHistoryOperationTypeMigrate code migration */\n    ContractCodeHistoryOperationType[ContractCodeHistoryOperationType[\"CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE\"] = 2] = \"CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE\";\n    /** CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS - ContractCodeHistoryOperationTypeGenesis based on genesis data */\n    ContractCodeHistoryOperationType[ContractCodeHistoryOperationType[\"CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS\"] = 3] = \"CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS\";\n    ContractCodeHistoryOperationType[ContractCodeHistoryOperationType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ContractCodeHistoryOperationType = exports.ContractCodeHistoryOperationType || (exports.ContractCodeHistoryOperationType = {}));\nfunction contractCodeHistoryOperationTypeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED\":\n            return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED;\n        case 1:\n        case \"CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT\":\n            return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT;\n        case 2:\n        case \"CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE\":\n            return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE;\n        case 3:\n        case \"CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS\":\n            return ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return ContractCodeHistoryOperationType.UNRECOGNIZED;\n    }\n}\nexports.contractCodeHistoryOperationTypeFromJSON = contractCodeHistoryOperationTypeFromJSON;\nfunction contractCodeHistoryOperationTypeToJSON(object) {\n    switch (object) {\n        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED:\n            return \"CONTRACT_CODE_HISTORY_OPERATION_TYPE_UNSPECIFIED\";\n        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT:\n            return \"CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT\";\n        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE:\n            return \"CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE\";\n        case ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS:\n            return \"CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS\";\n        default:\n            return \"UNKNOWN\";\n    }\n}\nexports.contractCodeHistoryOperationTypeToJSON = contractCodeHistoryOperationTypeToJSON;\nfunction createBaseAccessTypeParam() {\n    return { value: 0 };\n}\nexports.AccessTypeParam = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.value !== 0) {\n            writer.uint32(8).int32(message.value);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAccessTypeParam();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.value = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            value: isSet(object.value) ? accessTypeFromJSON(object.value) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.value !== undefined &&\n            (obj.value = accessTypeToJSON(message.value));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseAccessTypeParam();\n        message.value = (_a = object.value) !== null && _a !== void 0 ? _a : 0;\n        return message;\n    },\n};\nfunction createBaseAccessConfig() {\n    return { permission: 0, address: \"\" };\n}\nexports.AccessConfig = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.permission !== 0) {\n            writer.uint32(8).int32(message.permission);\n        }\n        if (message.address !== \"\") {\n            writer.uint32(18).string(message.address);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAccessConfig();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.permission = reader.int32();\n                    break;\n                case 2:\n                    message.address = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            permission: isSet(object.permission)\n                ? accessTypeFromJSON(object.permission)\n                : 0,\n            address: isSet(object.address) ? String(object.address) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.permission !== undefined &&\n            (obj.permission = accessTypeToJSON(message.permission));\n        message.address !== undefined && (obj.address = message.address);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseAccessConfig();\n        message.permission = (_a = object.permission) !== null && _a !== void 0 ? _a : 0;\n        message.address = (_b = object.address) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseParams() {\n    return {\n        codeUploadAccess: undefined,\n        instantiateDefaultPermission: 0,\n        maxWasmCodeSize: \"0\",\n    };\n}\nexports.Params = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.codeUploadAccess !== undefined) {\n            exports.AccessConfig.encode(message.codeUploadAccess, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.instantiateDefaultPermission !== 0) {\n            writer.uint32(16).int32(message.instantiateDefaultPermission);\n        }\n        if (message.maxWasmCodeSize !== \"0\") {\n            writer.uint32(24).uint64(message.maxWasmCodeSize);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseParams();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.codeUploadAccess = exports.AccessConfig.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.instantiateDefaultPermission = reader.int32();\n                    break;\n                case 3:\n                    message.maxWasmCodeSize = longToString(reader.uint64());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            codeUploadAccess: isSet(object.codeUploadAccess)\n                ? exports.AccessConfig.fromJSON(object.codeUploadAccess)\n                : undefined,\n            instantiateDefaultPermission: isSet(object.instantiateDefaultPermission)\n                ? accessTypeFromJSON(object.instantiateDefaultPermission)\n                : 0,\n            maxWasmCodeSize: isSet(object.maxWasmCodeSize)\n                ? String(object.maxWasmCodeSize)\n                : \"0\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.codeUploadAccess !== undefined &&\n            (obj.codeUploadAccess = message.codeUploadAccess\n                ? exports.AccessConfig.toJSON(message.codeUploadAccess)\n                : undefined);\n        message.instantiateDefaultPermission !== undefined &&\n            (obj.instantiateDefaultPermission = accessTypeToJSON(message.instantiateDefaultPermission));\n        message.maxWasmCodeSize !== undefined &&\n            (obj.maxWasmCodeSize = message.maxWasmCodeSize);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseParams();\n        message.codeUploadAccess =\n            object.codeUploadAccess !== undefined && object.codeUploadAccess !== null\n                ? exports.AccessConfig.fromPartial(object.codeUploadAccess)\n                : undefined;\n        message.instantiateDefaultPermission =\n            (_a = object.instantiateDefaultPermission) !== null && _a !== void 0 ? _a : 0;\n        message.maxWasmCodeSize = (_b = object.maxWasmCodeSize) !== null && _b !== void 0 ? _b : \"0\";\n        return message;\n    },\n};\nfunction createBaseCodeInfo() {\n    return {\n        codeHash: new Uint8Array(),\n        creator: \"\",\n        instantiateConfig: undefined,\n    };\n}\nexports.CodeInfo = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.codeHash.length !== 0) {\n            writer.uint32(10).bytes(message.codeHash);\n        }\n        if (message.creator !== \"\") {\n            writer.uint32(18).string(message.creator);\n        }\n        if (message.instantiateConfig !== undefined) {\n            exports.AccessConfig.encode(message.instantiateConfig, writer.uint32(42).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCodeInfo();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.codeHash = reader.bytes();\n                    break;\n                case 2:\n                    message.creator = reader.string();\n                    break;\n                case 5:\n                    message.instantiateConfig = exports.AccessConfig.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            codeHash: isSet(object.codeHash)\n                ? bytesFromBase64(object.codeHash)\n                : new Uint8Array(),\n            creator: isSet(object.creator) ? String(object.creator) : \"\",\n            instantiateConfig: isSet(object.instantiateConfig)\n                ? exports.AccessConfig.fromJSON(object.instantiateConfig)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.codeHash !== undefined &&\n            (obj.codeHash = base64FromBytes(message.codeHash !== undefined ? message.codeHash : new Uint8Array()));\n        message.creator !== undefined && (obj.creator = message.creator);\n        message.instantiateConfig !== undefined &&\n            (obj.instantiateConfig = message.instantiateConfig\n                ? exports.AccessConfig.toJSON(message.instantiateConfig)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseCodeInfo();\n        message.codeHash = (_a = object.codeHash) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.creator = (_b = object.creator) !== null && _b !== void 0 ? _b : \"\";\n        message.instantiateConfig =\n            object.instantiateConfig !== undefined &&\n                object.instantiateConfig !== null\n                ? exports.AccessConfig.fromPartial(object.instantiateConfig)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseContractInfo() {\n    return {\n        codeId: \"0\",\n        creator: \"\",\n        admin: \"\",\n        label: \"\",\n        created: undefined,\n        ibcPortId: \"\",\n        extension: undefined,\n    };\n}\nexports.ContractInfo = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.codeId !== \"0\") {\n            writer.uint32(8).uint64(message.codeId);\n        }\n        if (message.creator !== \"\") {\n            writer.uint32(18).string(message.creator);\n        }\n        if (message.admin !== \"\") {\n            writer.uint32(26).string(message.admin);\n        }\n        if (message.label !== \"\") {\n            writer.uint32(34).string(message.label);\n        }\n        if (message.created !== undefined) {\n            exports.AbsoluteTxPosition.encode(message.created, writer.uint32(42).fork()).ldelim();\n        }\n        if (message.ibcPortId !== \"\") {\n            writer.uint32(50).string(message.ibcPortId);\n        }\n        if (message.extension !== undefined) {\n            any_1.Any.encode(message.extension, writer.uint32(58).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseContractInfo();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.codeId = longToString(reader.uint64());\n                    break;\n                case 2:\n                    message.creator = reader.string();\n                    break;\n                case 3:\n                    message.admin = reader.string();\n                    break;\n                case 4:\n                    message.label = reader.string();\n                    break;\n                case 5:\n                    message.created = exports.AbsoluteTxPosition.decode(reader, reader.uint32());\n                    break;\n                case 6:\n                    message.ibcPortId = reader.string();\n                    break;\n                case 7:\n                    message.extension = any_1.Any.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            codeId: isSet(object.codeId) ? String(object.codeId) : \"0\",\n            creator: isSet(object.creator) ? String(object.creator) : \"\",\n            admin: isSet(object.admin) ? String(object.admin) : \"\",\n            label: isSet(object.label) ? String(object.label) : \"\",\n            created: isSet(object.created)\n                ? exports.AbsoluteTxPosition.fromJSON(object.created)\n                : undefined,\n            ibcPortId: isSet(object.ibcPortId) ? String(object.ibcPortId) : \"\",\n            extension: isSet(object.extension)\n                ? any_1.Any.fromJSON(object.extension)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.codeId !== undefined && (obj.codeId = message.codeId);\n        message.creator !== undefined && (obj.creator = message.creator);\n        message.admin !== undefined && (obj.admin = message.admin);\n        message.label !== undefined && (obj.label = message.label);\n        message.created !== undefined &&\n            (obj.created = message.created\n                ? exports.AbsoluteTxPosition.toJSON(message.created)\n                : undefined);\n        message.ibcPortId !== undefined && (obj.ibcPortId = message.ibcPortId);\n        message.extension !== undefined &&\n            (obj.extension = message.extension\n                ? any_1.Any.toJSON(message.extension)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e;\n        const message = createBaseContractInfo();\n        message.codeId = (_a = object.codeId) !== null && _a !== void 0 ? _a : \"0\";\n        message.creator = (_b = object.creator) !== null && _b !== void 0 ? _b : \"\";\n        message.admin = (_c = object.admin) !== null && _c !== void 0 ? _c : \"\";\n        message.label = (_d = object.label) !== null && _d !== void 0 ? _d : \"\";\n        message.created =\n            object.created !== undefined && object.created !== null\n                ? exports.AbsoluteTxPosition.fromPartial(object.created)\n                : undefined;\n        message.ibcPortId = (_e = object.ibcPortId) !== null && _e !== void 0 ? _e : \"\";\n        message.extension =\n            object.extension !== undefined && object.extension !== null\n                ? any_1.Any.fromPartial(object.extension)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseContractCodeHistoryEntry() {\n    return {\n        operation: 0,\n        codeId: \"0\",\n        updated: undefined,\n        msg: new Uint8Array(),\n    };\n}\nexports.ContractCodeHistoryEntry = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.operation !== 0) {\n            writer.uint32(8).int32(message.operation);\n        }\n        if (message.codeId !== \"0\") {\n            writer.uint32(16).uint64(message.codeId);\n        }\n        if (message.updated !== undefined) {\n            exports.AbsoluteTxPosition.encode(message.updated, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.msg.length !== 0) {\n            writer.uint32(34).bytes(message.msg);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseContractCodeHistoryEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.operation = reader.int32();\n                    break;\n                case 2:\n                    message.codeId = longToString(reader.uint64());\n                    break;\n                case 3:\n                    message.updated = exports.AbsoluteTxPosition.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.msg = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            operation: isSet(object.operation)\n                ? contractCodeHistoryOperationTypeFromJSON(object.operation)\n                : 0,\n            codeId: isSet(object.codeId) ? String(object.codeId) : \"0\",\n            updated: isSet(object.updated)\n                ? exports.AbsoluteTxPosition.fromJSON(object.updated)\n                : undefined,\n            msg: isSet(object.msg) ? bytesFromBase64(object.msg) : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.operation !== undefined &&\n            (obj.operation = contractCodeHistoryOperationTypeToJSON(message.operation));\n        message.codeId !== undefined && (obj.codeId = message.codeId);\n        message.updated !== undefined &&\n            (obj.updated = message.updated\n                ? exports.AbsoluteTxPosition.toJSON(message.updated)\n                : undefined);\n        message.msg !== undefined &&\n            (obj.msg = base64FromBytes(message.msg !== undefined ? message.msg : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseContractCodeHistoryEntry();\n        message.operation = (_a = object.operation) !== null && _a !== void 0 ? _a : 0;\n        message.codeId = (_b = object.codeId) !== null && _b !== void 0 ? _b : \"0\";\n        message.updated =\n            object.updated !== undefined && object.updated !== null\n                ? exports.AbsoluteTxPosition.fromPartial(object.updated)\n                : undefined;\n        message.msg = (_c = object.msg) !== null && _c !== void 0 ? _c : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseAbsoluteTxPosition() {\n    return { blockHeight: \"0\", txIndex: \"0\" };\n}\nexports.AbsoluteTxPosition = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.blockHeight !== \"0\") {\n            writer.uint32(8).uint64(message.blockHeight);\n        }\n        if (message.txIndex !== \"0\") {\n            writer.uint32(16).uint64(message.txIndex);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAbsoluteTxPosition();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.blockHeight = longToString(reader.uint64());\n                    break;\n                case 2:\n                    message.txIndex = longToString(reader.uint64());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            blockHeight: isSet(object.blockHeight) ? String(object.blockHeight) : \"0\",\n            txIndex: isSet(object.txIndex) ? String(object.txIndex) : \"0\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.blockHeight !== undefined &&\n            (obj.blockHeight = message.blockHeight);\n        message.txIndex !== undefined && (obj.txIndex = message.txIndex);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseAbsoluteTxPosition();\n        message.blockHeight = (_a = object.blockHeight) !== null && _a !== void 0 ? _a : \"0\";\n        message.txIndex = (_b = object.txIndex) !== null && _b !== void 0 ? _b : \"0\";\n        return message;\n    },\n};\nfunction createBaseModel() {\n    return { key: new Uint8Array(), value: new Uint8Array() };\n}\nexports.Model = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.key.length !== 0) {\n            writer.uint32(10).bytes(message.key);\n        }\n        if (message.value.length !== 0) {\n            writer.uint32(18).bytes(message.value);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseModel();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.value = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n            value: isSet(object.value)\n                ? bytesFromBase64(object.value)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined &&\n            (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n        message.value !== undefined &&\n            (obj.value = base64FromBytes(message.value !== undefined ? message.value : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseModel();\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : new Uint8Array();\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob ||\n    ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa ||\n    ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (const byte of arr) {\n        bin.push(String.fromCharCode(byte));\n    }\n    return btoa(bin.join(\"\"));\n}\nfunction longToString(long) {\n    return long.toString();\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9jb3Ntd2FzbS93YXNtL3YxL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLDBCQUEwQixHQUFHLGdDQUFnQyxHQUFHLG9CQUFvQixHQUFHLGdCQUFnQixHQUFHLGNBQWMsR0FBRyxvQkFBb0IsR0FBRyx1QkFBdUIsR0FBRyw4Q0FBOEMsR0FBRyxnREFBZ0QsR0FBRyx3Q0FBd0MsR0FBRyx3QkFBd0IsR0FBRywwQkFBMEIsR0FBRyxrQkFBa0IsR0FBRyx1QkFBdUI7QUFDL2E7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyxtREFBTTtBQUM3QyxrQ0FBa0MsbUJBQU8sQ0FBQyxzRUFBb0I7QUFDOUQsY0FBYyxtQkFBTyxDQUFDLDJHQUE4QjtBQUNwRCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0Msa0JBQWtCLEtBQUs7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0ZBQWtGLHdDQUF3QyxLQUFLO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLGFBQWE7QUFDYjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L3Byb3RvLXR5cGVzL2Nvc213YXNtL3dhc20vdjEvdHlwZXMuanM/ZTU2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTW9kZWwgPSBleHBvcnRzLkFic29sdXRlVHhQb3NpdGlvbiA9IGV4cG9ydHMuQ29udHJhY3RDb2RlSGlzdG9yeUVudHJ5ID0gZXhwb3J0cy5Db250cmFjdEluZm8gPSBleHBvcnRzLkNvZGVJbmZvID0gZXhwb3J0cy5QYXJhbXMgPSBleHBvcnRzLkFjY2Vzc0NvbmZpZyA9IGV4cG9ydHMuQWNjZXNzVHlwZVBhcmFtID0gZXhwb3J0cy5jb250cmFjdENvZGVIaXN0b3J5T3BlcmF0aW9uVHlwZVRvSlNPTiA9IGV4cG9ydHMuY29udHJhY3RDb2RlSGlzdG9yeU9wZXJhdGlvblR5cGVGcm9tSlNPTiA9IGV4cG9ydHMuQ29udHJhY3RDb2RlSGlzdG9yeU9wZXJhdGlvblR5cGUgPSBleHBvcnRzLmFjY2Vzc1R5cGVUb0pTT04gPSBleHBvcnRzLmFjY2Vzc1R5cGVGcm9tSlNPTiA9IGV4cG9ydHMuQWNjZXNzVHlwZSA9IGV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGxvbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9uZ1wiKSk7XG5jb25zdCBtaW5pbWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKSk7XG5jb25zdCBhbnlfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9nb29nbGUvcHJvdG9idWYvYW55XCIpO1xuZXhwb3J0cy5wcm90b2J1ZlBhY2thZ2UgPSBcImNvc213YXNtLndhc20udjFcIjtcbi8qKiBBY2Nlc3NUeXBlIHBlcm1pc3Npb24gdHlwZXMgKi9cbnZhciBBY2Nlc3NUeXBlO1xuKGZ1bmN0aW9uIChBY2Nlc3NUeXBlKSB7XG4gICAgLyoqIEFDQ0VTU19UWVBFX1VOU1BFQ0lGSUVEIC0gQWNjZXNzVHlwZVVuc3BlY2lmaWVkIHBsYWNlaG9sZGVyIGZvciBlbXB0eSB2YWx1ZSAqL1xuICAgIEFjY2Vzc1R5cGVbQWNjZXNzVHlwZVtcIkFDQ0VTU19UWVBFX1VOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIkFDQ0VTU19UWVBFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqIEFDQ0VTU19UWVBFX05PQk9EWSAtIEFjY2Vzc1R5cGVOb2JvZHkgZm9yYmlkZGVuICovXG4gICAgQWNjZXNzVHlwZVtBY2Nlc3NUeXBlW1wiQUNDRVNTX1RZUEVfTk9CT0RZXCJdID0gMV0gPSBcIkFDQ0VTU19UWVBFX05PQk9EWVwiO1xuICAgIC8qKiBBQ0NFU1NfVFlQRV9PTkxZX0FERFJFU1MgLSBBY2Nlc3NUeXBlT25seUFkZHJlc3MgcmVzdHJpY3RlZCB0byBhbiBhZGRyZXNzICovXG4gICAgQWNjZXNzVHlwZVtBY2Nlc3NUeXBlW1wiQUNDRVNTX1RZUEVfT05MWV9BRERSRVNTXCJdID0gMl0gPSBcIkFDQ0VTU19UWVBFX09OTFlfQUREUkVTU1wiO1xuICAgIC8qKiBBQ0NFU1NfVFlQRV9FVkVSWUJPRFkgLSBBY2Nlc3NUeXBlRXZlcnlib2R5IHVucmVzdHJpY3RlZCAqL1xuICAgIEFjY2Vzc1R5cGVbQWNjZXNzVHlwZVtcIkFDQ0VTU19UWVBFX0VWRVJZQk9EWVwiXSA9IDNdID0gXCJBQ0NFU1NfVFlQRV9FVkVSWUJPRFlcIjtcbiAgICBBY2Nlc3NUeXBlW0FjY2Vzc1R5cGVbXCJVTlJFQ09HTklaRURcIl0gPSAtMV0gPSBcIlVOUkVDT0dOSVpFRFwiO1xufSkoQWNjZXNzVHlwZSA9IGV4cG9ydHMuQWNjZXNzVHlwZSB8fCAoZXhwb3J0cy5BY2Nlc3NUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGFjY2Vzc1R5cGVGcm9tSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgXCJBQ0NFU1NfVFlQRV9VTlNQRUNJRklFRFwiOlxuICAgICAgICAgICAgcmV0dXJuIEFjY2Vzc1R5cGUuQUNDRVNTX1RZUEVfVU5TUEVDSUZJRUQ7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSBcIkFDQ0VTU19UWVBFX05PQk9EWVwiOlxuICAgICAgICAgICAgcmV0dXJuIEFjY2Vzc1R5cGUuQUNDRVNTX1RZUEVfTk9CT0RZO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgXCJBQ0NFU1NfVFlQRV9PTkxZX0FERFJFU1NcIjpcbiAgICAgICAgICAgIHJldHVybiBBY2Nlc3NUeXBlLkFDQ0VTU19UWVBFX09OTFlfQUREUkVTUztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBjYXNlIFwiQUNDRVNTX1RZUEVfRVZFUllCT0RZXCI6XG4gICAgICAgICAgICByZXR1cm4gQWNjZXNzVHlwZS5BQ0NFU1NfVFlQRV9FVkVSWUJPRFk7XG4gICAgICAgIGNhc2UgLTE6XG4gICAgICAgIGNhc2UgXCJVTlJFQ09HTklaRURcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBBY2Nlc3NUeXBlLlVOUkVDT0dOSVpFRDtcbiAgICB9XG59XG5leHBvcnRzLmFjY2Vzc1R5cGVGcm9tSlNPTiA9IGFjY2Vzc1R5cGVGcm9tSlNPTjtcbmZ1bmN0aW9uIGFjY2Vzc1R5cGVUb0pTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSBBY2Nlc3NUeXBlLkFDQ0VTU19UWVBFX1VOU1BFQ0lGSUVEOlxuICAgICAgICAgICAgcmV0dXJuIFwiQUNDRVNTX1RZUEVfVU5TUEVDSUZJRURcIjtcbiAgICAgICAgY2FzZSBBY2Nlc3NUeXBlLkFDQ0VTU19UWVBFX05PQk9EWTpcbiAgICAgICAgICAgIHJldHVybiBcIkFDQ0VTU19UWVBFX05PQk9EWVwiO1xuICAgICAgICBjYXNlIEFjY2Vzc1R5cGUuQUNDRVNTX1RZUEVfT05MWV9BRERSRVNTOlxuICAgICAgICAgICAgcmV0dXJuIFwiQUNDRVNTX1RZUEVfT05MWV9BRERSRVNTXCI7XG4gICAgICAgIGNhc2UgQWNjZXNzVHlwZS5BQ0NFU1NfVFlQRV9FVkVSWUJPRFk6XG4gICAgICAgICAgICByZXR1cm4gXCJBQ0NFU1NfVFlQRV9FVkVSWUJPRFlcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIlVOS05PV05cIjtcbiAgICB9XG59XG5leHBvcnRzLmFjY2Vzc1R5cGVUb0pTT04gPSBhY2Nlc3NUeXBlVG9KU09OO1xuLyoqIENvbnRyYWN0Q29kZUhpc3RvcnlPcGVyYXRpb25UeXBlIGFjdGlvbnMgdGhhdCBjYXVzZWQgYSBjb2RlIGNoYW5nZSAqL1xudmFyIENvbnRyYWN0Q29kZUhpc3RvcnlPcGVyYXRpb25UeXBlO1xuKGZ1bmN0aW9uIChDb250cmFjdENvZGVIaXN0b3J5T3BlcmF0aW9uVHlwZSkge1xuICAgIC8qKiBDT05UUkFDVF9DT0RFX0hJU1RPUllfT1BFUkFUSU9OX1RZUEVfVU5TUEVDSUZJRUQgLSBDb250cmFjdENvZGVIaXN0b3J5T3BlcmF0aW9uVHlwZVVuc3BlY2lmaWVkIHBsYWNlaG9sZGVyIGZvciBlbXB0eSB2YWx1ZSAqL1xuICAgIENvbnRyYWN0Q29kZUhpc3RvcnlPcGVyYXRpb25UeXBlW0NvbnRyYWN0Q29kZUhpc3RvcnlPcGVyYXRpb25UeXBlW1wiQ09OVFJBQ1RfQ09ERV9ISVNUT1JZX09QRVJBVElPTl9UWVBFX1VOU1BFQ0lGSUVEXCJdID0gMF0gPSBcIkNPTlRSQUNUX0NPREVfSElTVE9SWV9PUEVSQVRJT05fVFlQRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKiBDT05UUkFDVF9DT0RFX0hJU1RPUllfT1BFUkFUSU9OX1RZUEVfSU5JVCAtIENvbnRyYWN0Q29kZUhpc3RvcnlPcGVyYXRpb25UeXBlSW5pdCBvbiBjaGFpbiBjb250cmFjdCBpbnN0YW50aWF0aW9uICovXG4gICAgQ29udHJhY3RDb2RlSGlzdG9yeU9wZXJhdGlvblR5cGVbQ29udHJhY3RDb2RlSGlzdG9yeU9wZXJhdGlvblR5cGVbXCJDT05UUkFDVF9DT0RFX0hJU1RPUllfT1BFUkFUSU9OX1RZUEVfSU5JVFwiXSA9IDFdID0gXCJDT05UUkFDVF9DT0RFX0hJU1RPUllfT1BFUkFUSU9OX1RZUEVfSU5JVFwiO1xuICAgIC8qKiBDT05UUkFDVF9DT0RFX0hJU1RPUllfT1BFUkFUSU9OX1RZUEVfTUlHUkFURSAtIENvbnRyYWN0Q29kZUhpc3RvcnlPcGVyYXRpb25UeXBlTWlncmF0ZSBjb2RlIG1pZ3JhdGlvbiAqL1xuICAgIENvbnRyYWN0Q29kZUhpc3RvcnlPcGVyYXRpb25UeXBlW0NvbnRyYWN0Q29kZUhpc3RvcnlPcGVyYXRpb25UeXBlW1wiQ09OVFJBQ1RfQ09ERV9ISVNUT1JZX09QRVJBVElPTl9UWVBFX01JR1JBVEVcIl0gPSAyXSA9IFwiQ09OVFJBQ1RfQ09ERV9ISVNUT1JZX09QRVJBVElPTl9UWVBFX01JR1JBVEVcIjtcbiAgICAvKiogQ09OVFJBQ1RfQ09ERV9ISVNUT1JZX09QRVJBVElPTl9UWVBFX0dFTkVTSVMgLSBDb250cmFjdENvZGVIaXN0b3J5T3BlcmF0aW9uVHlwZUdlbmVzaXMgYmFzZWQgb24gZ2VuZXNpcyBkYXRhICovXG4gICAgQ29udHJhY3RDb2RlSGlzdG9yeU9wZXJhdGlvblR5cGVbQ29udHJhY3RDb2RlSGlzdG9yeU9wZXJhdGlvblR5cGVbXCJDT05UUkFDVF9DT0RFX0hJU1RPUllfT1BFUkFUSU9OX1RZUEVfR0VORVNJU1wiXSA9IDNdID0gXCJDT05UUkFDVF9DT0RFX0hJU1RPUllfT1BFUkFUSU9OX1RZUEVfR0VORVNJU1wiO1xuICAgIENvbnRyYWN0Q29kZUhpc3RvcnlPcGVyYXRpb25UeXBlW0NvbnRyYWN0Q29kZUhpc3RvcnlPcGVyYXRpb25UeXBlW1wiVU5SRUNPR05JWkVEXCJdID0gLTFdID0gXCJVTlJFQ09HTklaRURcIjtcbn0pKENvbnRyYWN0Q29kZUhpc3RvcnlPcGVyYXRpb25UeXBlID0gZXhwb3J0cy5Db250cmFjdENvZGVIaXN0b3J5T3BlcmF0aW9uVHlwZSB8fCAoZXhwb3J0cy5Db250cmFjdENvZGVIaXN0b3J5T3BlcmF0aW9uVHlwZSA9IHt9KSk7XG5mdW5jdGlvbiBjb250cmFjdENvZGVIaXN0b3J5T3BlcmF0aW9uVHlwZUZyb21KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSBcIkNPTlRSQUNUX0NPREVfSElTVE9SWV9PUEVSQVRJT05fVFlQRV9VTlNQRUNJRklFRFwiOlxuICAgICAgICAgICAgcmV0dXJuIENvbnRyYWN0Q29kZUhpc3RvcnlPcGVyYXRpb25UeXBlLkNPTlRSQUNUX0NPREVfSElTVE9SWV9PUEVSQVRJT05fVFlQRV9VTlNQRUNJRklFRDtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIFwiQ09OVFJBQ1RfQ09ERV9ISVNUT1JZX09QRVJBVElPTl9UWVBFX0lOSVRcIjpcbiAgICAgICAgICAgIHJldHVybiBDb250cmFjdENvZGVIaXN0b3J5T3BlcmF0aW9uVHlwZS5DT05UUkFDVF9DT0RFX0hJU1RPUllfT1BFUkFUSU9OX1RZUEVfSU5JVDtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIFwiQ09OVFJBQ1RfQ09ERV9ISVNUT1JZX09QRVJBVElPTl9UWVBFX01JR1JBVEVcIjpcbiAgICAgICAgICAgIHJldHVybiBDb250cmFjdENvZGVIaXN0b3J5T3BlcmF0aW9uVHlwZS5DT05UUkFDVF9DT0RFX0hJU1RPUllfT1BFUkFUSU9OX1RZUEVfTUlHUkFURTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBjYXNlIFwiQ09OVFJBQ1RfQ09ERV9ISVNUT1JZX09QRVJBVElPTl9UWVBFX0dFTkVTSVNcIjpcbiAgICAgICAgICAgIHJldHVybiBDb250cmFjdENvZGVIaXN0b3J5T3BlcmF0aW9uVHlwZS5DT05UUkFDVF9DT0RFX0hJU1RPUllfT1BFUkFUSU9OX1RZUEVfR0VORVNJUztcbiAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgY2FzZSBcIlVOUkVDT0dOSVpFRFwiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIENvbnRyYWN0Q29kZUhpc3RvcnlPcGVyYXRpb25UeXBlLlVOUkVDT0dOSVpFRDtcbiAgICB9XG59XG5leHBvcnRzLmNvbnRyYWN0Q29kZUhpc3RvcnlPcGVyYXRpb25UeXBlRnJvbUpTT04gPSBjb250cmFjdENvZGVIaXN0b3J5T3BlcmF0aW9uVHlwZUZyb21KU09OO1xuZnVuY3Rpb24gY29udHJhY3RDb2RlSGlzdG9yeU9wZXJhdGlvblR5cGVUb0pTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSBDb250cmFjdENvZGVIaXN0b3J5T3BlcmF0aW9uVHlwZS5DT05UUkFDVF9DT0RFX0hJU1RPUllfT1BFUkFUSU9OX1RZUEVfVU5TUEVDSUZJRUQ6XG4gICAgICAgICAgICByZXR1cm4gXCJDT05UUkFDVF9DT0RFX0hJU1RPUllfT1BFUkFUSU9OX1RZUEVfVU5TUEVDSUZJRURcIjtcbiAgICAgICAgY2FzZSBDb250cmFjdENvZGVIaXN0b3J5T3BlcmF0aW9uVHlwZS5DT05UUkFDVF9DT0RFX0hJU1RPUllfT1BFUkFUSU9OX1RZUEVfSU5JVDpcbiAgICAgICAgICAgIHJldHVybiBcIkNPTlRSQUNUX0NPREVfSElTVE9SWV9PUEVSQVRJT05fVFlQRV9JTklUXCI7XG4gICAgICAgIGNhc2UgQ29udHJhY3RDb2RlSGlzdG9yeU9wZXJhdGlvblR5cGUuQ09OVFJBQ1RfQ09ERV9ISVNUT1JZX09QRVJBVElPTl9UWVBFX01JR1JBVEU6XG4gICAgICAgICAgICByZXR1cm4gXCJDT05UUkFDVF9DT0RFX0hJU1RPUllfT1BFUkFUSU9OX1RZUEVfTUlHUkFURVwiO1xuICAgICAgICBjYXNlIENvbnRyYWN0Q29kZUhpc3RvcnlPcGVyYXRpb25UeXBlLkNPTlRSQUNUX0NPREVfSElTVE9SWV9PUEVSQVRJT05fVFlQRV9HRU5FU0lTOlxuICAgICAgICAgICAgcmV0dXJuIFwiQ09OVFJBQ1RfQ09ERV9ISVNUT1JZX09QRVJBVElPTl9UWVBFX0dFTkVTSVNcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIlVOS05PV05cIjtcbiAgICB9XG59XG5leHBvcnRzLmNvbnRyYWN0Q29kZUhpc3RvcnlPcGVyYXRpb25UeXBlVG9KU09OID0gY29udHJhY3RDb2RlSGlzdG9yeU9wZXJhdGlvblR5cGVUb0pTT047XG5mdW5jdGlvbiBjcmVhdGVCYXNlQWNjZXNzVHlwZVBhcmFtKCkge1xuICAgIHJldHVybiB7IHZhbHVlOiAwIH07XG59XG5leHBvcnRzLkFjY2Vzc1R5cGVQYXJhbSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnZhbHVlICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLmludDMyKG1lc3NhZ2UudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUFjY2Vzc1R5cGVQYXJhbSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IGlzU2V0KG9iamVjdC52YWx1ZSkgPyBhY2Nlc3NUeXBlRnJvbUpTT04ob2JqZWN0LnZhbHVlKSA6IDAsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS52YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnZhbHVlID0gYWNjZXNzVHlwZVRvSlNPTihtZXNzYWdlLnZhbHVlKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUFjY2Vzc1R5cGVQYXJhbSgpO1xuICAgICAgICBtZXNzYWdlLnZhbHVlID0gKF9hID0gb2JqZWN0LnZhbHVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VBY2Nlc3NDb25maWcoKSB7XG4gICAgcmV0dXJuIHsgcGVybWlzc2lvbjogMCwgYWRkcmVzczogXCJcIiB9O1xufVxuZXhwb3J0cy5BY2Nlc3NDb25maWcgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5wZXJtaXNzaW9uICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLmludDMyKG1lc3NhZ2UucGVybWlzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYWRkcmVzcyAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UuYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQWNjZXNzQ29uZmlnKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wZXJtaXNzaW9uID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwZXJtaXNzaW9uOiBpc1NldChvYmplY3QucGVybWlzc2lvbilcbiAgICAgICAgICAgICAgICA/IGFjY2Vzc1R5cGVGcm9tSlNPTihvYmplY3QucGVybWlzc2lvbilcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBhZGRyZXNzOiBpc1NldChvYmplY3QuYWRkcmVzcykgPyBTdHJpbmcob2JqZWN0LmFkZHJlc3MpIDogXCJcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnBlcm1pc3Npb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wZXJtaXNzaW9uID0gYWNjZXNzVHlwZVRvSlNPTihtZXNzYWdlLnBlcm1pc3Npb24pKTtcbiAgICAgICAgbWVzc2FnZS5hZGRyZXNzICE9PSB1bmRlZmluZWQgJiYgKG9iai5hZGRyZXNzID0gbWVzc2FnZS5hZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUFjY2Vzc0NvbmZpZygpO1xuICAgICAgICBtZXNzYWdlLnBlcm1pc3Npb24gPSAoX2EgPSBvYmplY3QucGVybWlzc2lvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgbWVzc2FnZS5hZGRyZXNzID0gKF9iID0gb2JqZWN0LmFkZHJlc3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVBhcmFtcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlVXBsb2FkQWNjZXNzOiB1bmRlZmluZWQsXG4gICAgICAgIGluc3RhbnRpYXRlRGVmYXVsdFBlcm1pc3Npb246IDAsXG4gICAgICAgIG1heFdhc21Db2RlU2l6ZTogXCIwXCIsXG4gICAgfTtcbn1cbmV4cG9ydHMuUGFyYW1zID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuY29kZVVwbG9hZEFjY2VzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLkFjY2Vzc0NvbmZpZy5lbmNvZGUobWVzc2FnZS5jb2RlVXBsb2FkQWNjZXNzLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmluc3RhbnRpYXRlRGVmYXVsdFBlcm1pc3Npb24gIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLmludDMyKG1lc3NhZ2UuaW5zdGFudGlhdGVEZWZhdWx0UGVybWlzc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubWF4V2FzbUNvZGVTaXplICE9PSBcIjBcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkudWludDY0KG1lc3NhZ2UubWF4V2FzbUNvZGVTaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQYXJhbXMoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvZGVVcGxvYWRBY2Nlc3MgPSBleHBvcnRzLkFjY2Vzc0NvbmZpZy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5zdGFudGlhdGVEZWZhdWx0UGVybWlzc2lvbiA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWF4V2FzbUNvZGVTaXplID0gbG9uZ1RvU3RyaW5nKHJlYWRlci51aW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGVVcGxvYWRBY2Nlc3M6IGlzU2V0KG9iamVjdC5jb2RlVXBsb2FkQWNjZXNzKVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5BY2Nlc3NDb25maWcuZnJvbUpTT04ob2JqZWN0LmNvZGVVcGxvYWRBY2Nlc3MpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpbnN0YW50aWF0ZURlZmF1bHRQZXJtaXNzaW9uOiBpc1NldChvYmplY3QuaW5zdGFudGlhdGVEZWZhdWx0UGVybWlzc2lvbilcbiAgICAgICAgICAgICAgICA/IGFjY2Vzc1R5cGVGcm9tSlNPTihvYmplY3QuaW5zdGFudGlhdGVEZWZhdWx0UGVybWlzc2lvbilcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBtYXhXYXNtQ29kZVNpemU6IGlzU2V0KG9iamVjdC5tYXhXYXNtQ29kZVNpemUpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0Lm1heFdhc21Db2RlU2l6ZSlcbiAgICAgICAgICAgICAgICA6IFwiMFwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuY29kZVVwbG9hZEFjY2VzcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNvZGVVcGxvYWRBY2Nlc3MgPSBtZXNzYWdlLmNvZGVVcGxvYWRBY2Nlc3NcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuQWNjZXNzQ29uZmlnLnRvSlNPTihtZXNzYWdlLmNvZGVVcGxvYWRBY2Nlc3MpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmluc3RhbnRpYXRlRGVmYXVsdFBlcm1pc3Npb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5pbnN0YW50aWF0ZURlZmF1bHRQZXJtaXNzaW9uID0gYWNjZXNzVHlwZVRvSlNPTihtZXNzYWdlLmluc3RhbnRpYXRlRGVmYXVsdFBlcm1pc3Npb24pKTtcbiAgICAgICAgbWVzc2FnZS5tYXhXYXNtQ29kZVNpemUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5tYXhXYXNtQ29kZVNpemUgPSBtZXNzYWdlLm1heFdhc21Db2RlU2l6ZSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQYXJhbXMoKTtcbiAgICAgICAgbWVzc2FnZS5jb2RlVXBsb2FkQWNjZXNzID1cbiAgICAgICAgICAgIG9iamVjdC5jb2RlVXBsb2FkQWNjZXNzICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmNvZGVVcGxvYWRBY2Nlc3MgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuQWNjZXNzQ29uZmlnLmZyb21QYXJ0aWFsKG9iamVjdC5jb2RlVXBsb2FkQWNjZXNzKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmluc3RhbnRpYXRlRGVmYXVsdFBlcm1pc3Npb24gPVxuICAgICAgICAgICAgKF9hID0gb2JqZWN0Lmluc3RhbnRpYXRlRGVmYXVsdFBlcm1pc3Npb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIG1lc3NhZ2UubWF4V2FzbUNvZGVTaXplID0gKF9iID0gb2JqZWN0Lm1heFdhc21Db2RlU2l6ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCIwXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUNvZGVJbmZvKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGVIYXNoOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICBjcmVhdG9yOiBcIlwiLFxuICAgICAgICBpbnN0YW50aWF0ZUNvbmZpZzogdW5kZWZpbmVkLFxuICAgIH07XG59XG5leHBvcnRzLkNvZGVJbmZvID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuY29kZUhhc2gubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLmNvZGVIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jcmVhdG9yICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS5jcmVhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pbnN0YW50aWF0ZUNvbmZpZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLkFjY2Vzc0NvbmZpZy5lbmNvZGUobWVzc2FnZS5pbnN0YW50aWF0ZUNvbmZpZywgd3JpdGVyLnVpbnQzMig0MikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDb2RlSW5mbygpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29kZUhhc2ggPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNyZWF0b3IgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbnN0YW50aWF0ZUNvbmZpZyA9IGV4cG9ydHMuQWNjZXNzQ29uZmlnLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGVIYXNoOiBpc1NldChvYmplY3QuY29kZUhhc2gpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmNvZGVIYXNoKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIGNyZWF0b3I6IGlzU2V0KG9iamVjdC5jcmVhdG9yKSA/IFN0cmluZyhvYmplY3QuY3JlYXRvcikgOiBcIlwiLFxuICAgICAgICAgICAgaW5zdGFudGlhdGVDb25maWc6IGlzU2V0KG9iamVjdC5pbnN0YW50aWF0ZUNvbmZpZylcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuQWNjZXNzQ29uZmlnLmZyb21KU09OKG9iamVjdC5pbnN0YW50aWF0ZUNvbmZpZylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmNvZGVIYXNoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY29kZUhhc2ggPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5jb2RlSGFzaCAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5jb2RlSGFzaCA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5jcmVhdG9yICE9PSB1bmRlZmluZWQgJiYgKG9iai5jcmVhdG9yID0gbWVzc2FnZS5jcmVhdG9yKTtcbiAgICAgICAgbWVzc2FnZS5pbnN0YW50aWF0ZUNvbmZpZyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmluc3RhbnRpYXRlQ29uZmlnID0gbWVzc2FnZS5pbnN0YW50aWF0ZUNvbmZpZ1xuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5BY2Nlc3NDb25maWcudG9KU09OKG1lc3NhZ2UuaW5zdGFudGlhdGVDb25maWcpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29kZUluZm8oKTtcbiAgICAgICAgbWVzc2FnZS5jb2RlSGFzaCA9IChfYSA9IG9iamVjdC5jb2RlSGFzaCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5jcmVhdG9yID0gKF9iID0gb2JqZWN0LmNyZWF0b3IpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuaW5zdGFudGlhdGVDb25maWcgPVxuICAgICAgICAgICAgb2JqZWN0Lmluc3RhbnRpYXRlQ29uZmlnICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBvYmplY3QuaW5zdGFudGlhdGVDb25maWcgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuQWNjZXNzQ29uZmlnLmZyb21QYXJ0aWFsKG9iamVjdC5pbnN0YW50aWF0ZUNvbmZpZylcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlQ29udHJhY3RJbmZvKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGVJZDogXCIwXCIsXG4gICAgICAgIGNyZWF0b3I6IFwiXCIsXG4gICAgICAgIGFkbWluOiBcIlwiLFxuICAgICAgICBsYWJlbDogXCJcIixcbiAgICAgICAgY3JlYXRlZDogdW5kZWZpbmVkLFxuICAgICAgICBpYmNQb3J0SWQ6IFwiXCIsXG4gICAgICAgIGV4dGVuc2lvbjogdW5kZWZpbmVkLFxuICAgIH07XG59XG5leHBvcnRzLkNvbnRyYWN0SW5mbyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmNvZGVJZCAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkudWludDY0KG1lc3NhZ2UuY29kZUlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jcmVhdG9yICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5zdHJpbmcobWVzc2FnZS5jcmVhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5hZG1pbiAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuc3RyaW5nKG1lc3NhZ2UuYWRtaW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmxhYmVsICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDM0KS5zdHJpbmcobWVzc2FnZS5sYWJlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuY3JlYXRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLkFic29sdXRlVHhQb3NpdGlvbi5lbmNvZGUobWVzc2FnZS5jcmVhdGVkLCB3cml0ZXIudWludDMyKDQyKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmliY1BvcnRJZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig1MCkuc3RyaW5nKG1lc3NhZ2UuaWJjUG9ydElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5leHRlbnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYW55XzEuQW55LmVuY29kZShtZXNzYWdlLmV4dGVuc2lvbiwgd3JpdGVyLnVpbnQzMig1OCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDb250cmFjdEluZm8oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvZGVJZCA9IGxvbmdUb1N0cmluZyhyZWFkZXIudWludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY3JlYXRvciA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFkbWluID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGFiZWwgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jcmVhdGVkID0gZXhwb3J0cy5BYnNvbHV0ZVR4UG9zaXRpb24uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmliY1BvcnRJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV4dGVuc2lvbiA9IGFueV8xLkFueS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2RlSWQ6IGlzU2V0KG9iamVjdC5jb2RlSWQpID8gU3RyaW5nKG9iamVjdC5jb2RlSWQpIDogXCIwXCIsXG4gICAgICAgICAgICBjcmVhdG9yOiBpc1NldChvYmplY3QuY3JlYXRvcikgPyBTdHJpbmcob2JqZWN0LmNyZWF0b3IpIDogXCJcIixcbiAgICAgICAgICAgIGFkbWluOiBpc1NldChvYmplY3QuYWRtaW4pID8gU3RyaW5nKG9iamVjdC5hZG1pbikgOiBcIlwiLFxuICAgICAgICAgICAgbGFiZWw6IGlzU2V0KG9iamVjdC5sYWJlbCkgPyBTdHJpbmcob2JqZWN0LmxhYmVsKSA6IFwiXCIsXG4gICAgICAgICAgICBjcmVhdGVkOiBpc1NldChvYmplY3QuY3JlYXRlZClcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuQWJzb2x1dGVUeFBvc2l0aW9uLmZyb21KU09OKG9iamVjdC5jcmVhdGVkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWJjUG9ydElkOiBpc1NldChvYmplY3QuaWJjUG9ydElkKSA/IFN0cmluZyhvYmplY3QuaWJjUG9ydElkKSA6IFwiXCIsXG4gICAgICAgICAgICBleHRlbnNpb246IGlzU2V0KG9iamVjdC5leHRlbnNpb24pXG4gICAgICAgICAgICAgICAgPyBhbnlfMS5BbnkuZnJvbUpTT04ob2JqZWN0LmV4dGVuc2lvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmNvZGVJZCAhPT0gdW5kZWZpbmVkICYmIChvYmouY29kZUlkID0gbWVzc2FnZS5jb2RlSWQpO1xuICAgICAgICBtZXNzYWdlLmNyZWF0b3IgIT09IHVuZGVmaW5lZCAmJiAob2JqLmNyZWF0b3IgPSBtZXNzYWdlLmNyZWF0b3IpO1xuICAgICAgICBtZXNzYWdlLmFkbWluICE9PSB1bmRlZmluZWQgJiYgKG9iai5hZG1pbiA9IG1lc3NhZ2UuYWRtaW4pO1xuICAgICAgICBtZXNzYWdlLmxhYmVsICE9PSB1bmRlZmluZWQgJiYgKG9iai5sYWJlbCA9IG1lc3NhZ2UubGFiZWwpO1xuICAgICAgICBtZXNzYWdlLmNyZWF0ZWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jcmVhdGVkID0gbWVzc2FnZS5jcmVhdGVkXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkFic29sdXRlVHhQb3NpdGlvbi50b0pTT04obWVzc2FnZS5jcmVhdGVkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5pYmNQb3J0SWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmliY1BvcnRJZCA9IG1lc3NhZ2UuaWJjUG9ydElkKTtcbiAgICAgICAgbWVzc2FnZS5leHRlbnNpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5leHRlbnNpb24gPSBtZXNzYWdlLmV4dGVuc2lvblxuICAgICAgICAgICAgICAgID8gYW55XzEuQW55LnRvSlNPTihtZXNzYWdlLmV4dGVuc2lvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDb250cmFjdEluZm8oKTtcbiAgICAgICAgbWVzc2FnZS5jb2RlSWQgPSAoX2EgPSBvYmplY3QuY29kZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIjBcIjtcbiAgICAgICAgbWVzc2FnZS5jcmVhdG9yID0gKF9iID0gb2JqZWN0LmNyZWF0b3IpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuYWRtaW4gPSAoX2MgPSBvYmplY3QuYWRtaW4pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UubGFiZWwgPSAoX2QgPSBvYmplY3QubGFiZWwpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuY3JlYXRlZCA9XG4gICAgICAgICAgICBvYmplY3QuY3JlYXRlZCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jcmVhdGVkICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkFic29sdXRlVHhQb3NpdGlvbi5mcm9tUGFydGlhbChvYmplY3QuY3JlYXRlZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5pYmNQb3J0SWQgPSAoX2UgPSBvYmplY3QuaWJjUG9ydElkKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmV4dGVuc2lvbiA9XG4gICAgICAgICAgICBvYmplY3QuZXh0ZW5zaW9uICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmV4dGVuc2lvbiAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gYW55XzEuQW55LmZyb21QYXJ0aWFsKG9iamVjdC5leHRlbnNpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUNvbnRyYWN0Q29kZUhpc3RvcnlFbnRyeSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBvcGVyYXRpb246IDAsXG4gICAgICAgIGNvZGVJZDogXCIwXCIsXG4gICAgICAgIHVwZGF0ZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgbXNnOiBuZXcgVWludDhBcnJheSgpLFxuICAgIH07XG59XG5leHBvcnRzLkNvbnRyYWN0Q29kZUhpc3RvcnlFbnRyeSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLm9wZXJhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS5pbnQzMihtZXNzYWdlLm9wZXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuY29kZUlkICE9PSBcIjBcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikudWludDY0KG1lc3NhZ2UuY29kZUlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS51cGRhdGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuQWJzb2x1dGVUeFBvc2l0aW9uLmVuY29kZShtZXNzYWdlLnVwZGF0ZWQsIHdyaXRlci51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubXNnLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzNCkuYnl0ZXMobWVzc2FnZS5tc2cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNvbnRyYWN0Q29kZUhpc3RvcnlFbnRyeSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3BlcmF0aW9uID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb2RlSWQgPSBsb25nVG9TdHJpbmcocmVhZGVyLnVpbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVwZGF0ZWQgPSBleHBvcnRzLkFic29sdXRlVHhQb3NpdGlvbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubXNnID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogaXNTZXQob2JqZWN0Lm9wZXJhdGlvbilcbiAgICAgICAgICAgICAgICA/IGNvbnRyYWN0Q29kZUhpc3RvcnlPcGVyYXRpb25UeXBlRnJvbUpTT04ob2JqZWN0Lm9wZXJhdGlvbilcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBjb2RlSWQ6IGlzU2V0KG9iamVjdC5jb2RlSWQpID8gU3RyaW5nKG9iamVjdC5jb2RlSWQpIDogXCIwXCIsXG4gICAgICAgICAgICB1cGRhdGVkOiBpc1NldChvYmplY3QudXBkYXRlZClcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuQWJzb2x1dGVUeFBvc2l0aW9uLmZyb21KU09OKG9iamVjdC51cGRhdGVkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbXNnOiBpc1NldChvYmplY3QubXNnKSA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QubXNnKSA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5vcGVyYXRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5vcGVyYXRpb24gPSBjb250cmFjdENvZGVIaXN0b3J5T3BlcmF0aW9uVHlwZVRvSlNPTihtZXNzYWdlLm9wZXJhdGlvbikpO1xuICAgICAgICBtZXNzYWdlLmNvZGVJZCAhPT0gdW5kZWZpbmVkICYmIChvYmouY29kZUlkID0gbWVzc2FnZS5jb2RlSWQpO1xuICAgICAgICBtZXNzYWdlLnVwZGF0ZWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai51cGRhdGVkID0gbWVzc2FnZS51cGRhdGVkXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkFic29sdXRlVHhQb3NpdGlvbi50b0pTT04obWVzc2FnZS51cGRhdGVkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5tc2cgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5tc2cgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5tc2cgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UubXNnIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNvbnRyYWN0Q29kZUhpc3RvcnlFbnRyeSgpO1xuICAgICAgICBtZXNzYWdlLm9wZXJhdGlvbiA9IChfYSA9IG9iamVjdC5vcGVyYXRpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIG1lc3NhZ2UuY29kZUlkID0gKF9iID0gb2JqZWN0LmNvZGVJZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCIwXCI7XG4gICAgICAgIG1lc3NhZ2UudXBkYXRlZCA9XG4gICAgICAgICAgICBvYmplY3QudXBkYXRlZCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC51cGRhdGVkICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkFic29sdXRlVHhQb3NpdGlvbi5mcm9tUGFydGlhbChvYmplY3QudXBkYXRlZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5tc2cgPSAoX2MgPSBvYmplY3QubXNnKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VBYnNvbHV0ZVR4UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHsgYmxvY2tIZWlnaHQ6IFwiMFwiLCB0eEluZGV4OiBcIjBcIiB9O1xufVxuZXhwb3J0cy5BYnNvbHV0ZVR4UG9zaXRpb24gPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5ibG9ja0hlaWdodCAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkudWludDY0KG1lc3NhZ2UuYmxvY2tIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnR4SW5kZXggIT09IFwiMFwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS51aW50NjQobWVzc2FnZS50eEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VBYnNvbHV0ZVR4UG9zaXRpb24oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJsb2NrSGVpZ2h0ID0gbG9uZ1RvU3RyaW5nKHJlYWRlci51aW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eEluZGV4ID0gbG9uZ1RvU3RyaW5nKHJlYWRlci51aW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJsb2NrSGVpZ2h0OiBpc1NldChvYmplY3QuYmxvY2tIZWlnaHQpID8gU3RyaW5nKG9iamVjdC5ibG9ja0hlaWdodCkgOiBcIjBcIixcbiAgICAgICAgICAgIHR4SW5kZXg6IGlzU2V0KG9iamVjdC50eEluZGV4KSA/IFN0cmluZyhvYmplY3QudHhJbmRleCkgOiBcIjBcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmJsb2NrSGVpZ2h0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYmxvY2tIZWlnaHQgPSBtZXNzYWdlLmJsb2NrSGVpZ2h0KTtcbiAgICAgICAgbWVzc2FnZS50eEluZGV4ICE9PSB1bmRlZmluZWQgJiYgKG9iai50eEluZGV4ID0gbWVzc2FnZS50eEluZGV4KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUFic29sdXRlVHhQb3NpdGlvbigpO1xuICAgICAgICBtZXNzYWdlLmJsb2NrSGVpZ2h0ID0gKF9hID0gb2JqZWN0LmJsb2NrSGVpZ2h0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIjBcIjtcbiAgICAgICAgbWVzc2FnZS50eEluZGV4ID0gKF9iID0gb2JqZWN0LnR4SW5kZXgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiMFwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNb2RlbCgpIHtcbiAgICByZXR1cm4geyBrZXk6IG5ldyBVaW50OEFycmF5KCksIHZhbHVlOiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnRzLk1vZGVsID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uua2V5Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5rZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnZhbHVlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuYnl0ZXMobWVzc2FnZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTW9kZWwoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmtleSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiBpc1NldChvYmplY3Qua2V5KSA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3Qua2V5KSA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICB2YWx1ZTogaXNTZXQob2JqZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC52YWx1ZSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5rZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5rZXkgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5rZXkgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2Uua2V5IDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLnZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudmFsdWUgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS52YWx1ZSAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS52YWx1ZSA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1vZGVsKCk7XG4gICAgICAgIG1lc3NhZ2Uua2V5ID0gKF9hID0gb2JqZWN0LmtleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS52YWx1ZSA9IChfYiA9IG9iamVjdC52YWx1ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG52YXIgZ2xvYmFsVGhpcyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIHRocm93IFwiVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0XCI7XG59KSgpO1xuY29uc3QgYXRvYiA9IGdsb2JhbFRoaXMuYXRvYiB8fFxuICAgICgoYjY0KSA9PiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikudG9TdHJpbmcoXCJiaW5hcnlcIikpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NCkge1xuICAgIGNvbnN0IGJpbiA9IGF0b2IoYjY0KTtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmNvbnN0IGJ0b2EgPSBnbG9iYWxUaGlzLmJ0b2EgfHxcbiAgICAoKGJpbikgPT4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiaW4sIFwiYmluYXJ5XCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpKTtcbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnIpIHtcbiAgICBjb25zdCBiaW4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGJ5dGUgb2YgYXJyKSB7XG4gICAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYShiaW4uam9pbihcIlwiKSk7XG59XG5mdW5jdGlvbiBsb25nVG9TdHJpbmcobG9uZykge1xuICAgIHJldHVybiBsb25nLnRvU3RyaW5nKCk7XG59XG5pZiAobWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nICE9PSBsb25nXzEuZGVmYXVsdCkge1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyA9IGxvbmdfMS5kZWZhdWx0O1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/cosmwasm/wasm/v1/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/any.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/google/protobuf/any.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Any = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nexports.protobufPackage = \"google.protobuf\";\nfunction createBaseAny() {\n    return { typeUrl: \"\", value: new Uint8Array() };\n}\nexports.Any = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.typeUrl !== \"\") {\n            writer.uint32(10).string(message.typeUrl);\n        }\n        if (message.value.length !== 0) {\n            writer.uint32(18).bytes(message.value);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAny();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.typeUrl = reader.string();\n                    break;\n                case 2:\n                    message.value = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            typeUrl: isSet(object.typeUrl) ? String(object.typeUrl) : \"\",\n            value: isSet(object.value)\n                ? bytesFromBase64(object.value)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.typeUrl !== undefined && (obj.typeUrl = message.typeUrl);\n        message.value !== undefined &&\n            (obj.value = base64FromBytes(message.value !== undefined ? message.value : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseAny();\n        message.typeUrl = (_a = object.typeUrl) !== null && _a !== void 0 ? _a : \"\";\n        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : new Uint8Array();\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob ||\n    ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa ||\n    ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (const byte of arr) {\n        bin.push(String.fromCharCode(byte));\n    }\n    return btoa(bin.join(\"\"));\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=any.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9nb29nbGUvcHJvdG9idWYvYW55LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsV0FBVyxHQUFHLHVCQUF1QjtBQUNyQztBQUNBLCtCQUErQixtQkFBTyxDQUFDLG1EQUFNO0FBQzdDLGtDQUFrQyxtQkFBTyxDQUFDLHNFQUFvQjtBQUM5RCx1QkFBdUI7QUFDdkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9nb29nbGUvcHJvdG9idWYvYW55LmpzPzkxMDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFueSA9IGV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGxvbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9uZ1wiKSk7XG5jb25zdCBtaW5pbWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKSk7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwiZ29vZ2xlLnByb3RvYnVmXCI7XG5mdW5jdGlvbiBjcmVhdGVCYXNlQW55KCkge1xuICAgIHJldHVybiB7IHR5cGVVcmw6IFwiXCIsIHZhbHVlOiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnRzLkFueSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGVVcmwgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLnR5cGVVcmwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnZhbHVlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuYnl0ZXMobWVzc2FnZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQW55KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlVXJsID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWUgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZVVybDogaXNTZXQob2JqZWN0LnR5cGVVcmwpID8gU3RyaW5nKG9iamVjdC50eXBlVXJsKSA6IFwiXCIsXG4gICAgICAgICAgICB2YWx1ZTogaXNTZXQob2JqZWN0LnZhbHVlKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC52YWx1ZSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS50eXBlVXJsICE9PSB1bmRlZmluZWQgJiYgKG9iai50eXBlVXJsID0gbWVzc2FnZS50eXBlVXJsKTtcbiAgICAgICAgbWVzc2FnZS52YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnZhbHVlID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UudmFsdWUgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UudmFsdWUgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VBbnkoKTtcbiAgICAgICAgbWVzc2FnZS50eXBlVXJsID0gKF9hID0gb2JqZWN0LnR5cGVVcmwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UudmFsdWUgPSAoX2IgPSBvYmplY3QudmFsdWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xudmFyIGdsb2JhbFRoaXMgPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB0aHJvdyBcIlVuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdFwiO1xufSkoKTtcbmNvbnN0IGF0b2IgPSBnbG9iYWxUaGlzLmF0b2IgfHxcbiAgICAoKGI2NCkgPT4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiNjQsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKFwiYmluYXJ5XCIpKTtcbmZ1bmN0aW9uIGJ5dGVzRnJvbUJhc2U2NChiNjQpIHtcbiAgICBjb25zdCBiaW4gPSBhdG9iKGI2NCk7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYmluLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5jb25zdCBidG9hID0gZ2xvYmFsVGhpcy5idG9hIHx8XG4gICAgKChiaW4pID0+IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYmluLCBcImJpbmFyeVwiKS50b1N0cmluZyhcImJhc2U2NFwiKSk7XG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyKSB7XG4gICAgY29uc3QgYmluID0gW107XG4gICAgZm9yIChjb25zdCBieXRlIG9mIGFycikge1xuICAgICAgICBiaW4ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ0b2EoYmluLmpvaW4oXCJcIikpO1xufVxuaWYgKG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyAhPT0gbG9uZ18xLmRlZmF1bHQpIHtcbiAgICBtaW5pbWFsXzEuZGVmYXVsdC51dGlsLkxvbmcgPSBsb25nXzEuZGVmYXVsdDtcbiAgICBtaW5pbWFsXzEuZGVmYXVsdC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbnkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/any.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/duration.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/google/protobuf/duration.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Duration = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nexports.protobufPackage = \"google.protobuf\";\nfunction createBaseDuration() {\n    return { seconds: \"0\", nanos: 0 };\n}\nexports.Duration = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.seconds !== \"0\") {\n            writer.uint32(8).int64(message.seconds);\n        }\n        if (message.nanos !== 0) {\n            writer.uint32(16).int32(message.nanos);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDuration();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.seconds = longToString(reader.int64());\n                    break;\n                case 2:\n                    message.nanos = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            seconds: isSet(object.seconds) ? String(object.seconds) : \"0\",\n            nanos: isSet(object.nanos) ? Number(object.nanos) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.seconds !== undefined && (obj.seconds = message.seconds);\n        message.nanos !== undefined && (obj.nanos = Math.round(message.nanos));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseDuration();\n        message.seconds = (_a = object.seconds) !== null && _a !== void 0 ? _a : \"0\";\n        message.nanos = (_b = object.nanos) !== null && _b !== void 0 ? _b : 0;\n        return message;\n    },\n};\nfunction longToString(long) {\n    return long.toString();\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=duration.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9nb29nbGUvcHJvdG9idWYvZHVyYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsR0FBRyx1QkFBdUI7QUFDMUM7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyxtREFBTTtBQUM3QyxrQ0FBa0MsbUJBQU8sQ0FBQyxzRUFBb0I7QUFDOUQsdUJBQXVCO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L3Byb3RvLXR5cGVzL2dvb2dsZS9wcm90b2J1Zi9kdXJhdGlvbi5qcz84YmVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EdXJhdGlvbiA9IGV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGxvbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9uZ1wiKSk7XG5jb25zdCBtaW5pbWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKSk7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwiZ29vZ2xlLnByb3RvYnVmXCI7XG5mdW5jdGlvbiBjcmVhdGVCYXNlRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHsgc2Vjb25kczogXCIwXCIsIG5hbm9zOiAwIH07XG59XG5leHBvcnRzLkR1cmF0aW9uID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2Vjb25kcyAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkuaW50NjQobWVzc2FnZS5zZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5uYW5vcyAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikuaW50MzIobWVzc2FnZS5uYW5vcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlRHVyYXRpb24oKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlY29uZHMgPSBsb25nVG9TdHJpbmcocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFub3MgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2Vjb25kczogaXNTZXQob2JqZWN0LnNlY29uZHMpID8gU3RyaW5nKG9iamVjdC5zZWNvbmRzKSA6IFwiMFwiLFxuICAgICAgICAgICAgbmFub3M6IGlzU2V0KG9iamVjdC5uYW5vcykgPyBOdW1iZXIob2JqZWN0Lm5hbm9zKSA6IDAsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5zZWNvbmRzICE9PSB1bmRlZmluZWQgJiYgKG9iai5zZWNvbmRzID0gbWVzc2FnZS5zZWNvbmRzKTtcbiAgICAgICAgbWVzc2FnZS5uYW5vcyAhPT0gdW5kZWZpbmVkICYmIChvYmoubmFub3MgPSBNYXRoLnJvdW5kKG1lc3NhZ2UubmFub3MpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUR1cmF0aW9uKCk7XG4gICAgICAgIG1lc3NhZ2Uuc2Vjb25kcyA9IChfYSA9IG9iamVjdC5zZWNvbmRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIjBcIjtcbiAgICAgICAgbWVzc2FnZS5uYW5vcyA9IChfYiA9IG9iamVjdC5uYW5vcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBsb25nVG9TdHJpbmcobG9uZykge1xuICAgIHJldHVybiBsb25nLnRvU3RyaW5nKCk7XG59XG5pZiAobWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nICE9PSBsb25nXzEuZGVmYXVsdCkge1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyA9IGxvbmdfMS5kZWZhdWx0O1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWR1cmF0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/duration.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/timestamp.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/google/protobuf/timestamp.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Timestamp = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nexports.protobufPackage = \"google.protobuf\";\nfunction createBaseTimestamp() {\n    return { seconds: \"0\", nanos: 0 };\n}\nexports.Timestamp = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.seconds !== \"0\") {\n            writer.uint32(8).int64(message.seconds);\n        }\n        if (message.nanos !== 0) {\n            writer.uint32(16).int32(message.nanos);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTimestamp();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.seconds = longToString(reader.int64());\n                    break;\n                case 2:\n                    message.nanos = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            seconds: isSet(object.seconds) ? String(object.seconds) : \"0\",\n            nanos: isSet(object.nanos) ? Number(object.nanos) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.seconds !== undefined && (obj.seconds = message.seconds);\n        message.nanos !== undefined && (obj.nanos = Math.round(message.nanos));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseTimestamp();\n        message.seconds = (_a = object.seconds) !== null && _a !== void 0 ? _a : \"0\";\n        message.nanos = (_b = object.nanos) !== null && _b !== void 0 ? _b : 0;\n        return message;\n    },\n};\nfunction longToString(long) {\n    return long.toString();\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=timestamp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9nb29nbGUvcHJvdG9idWYvdGltZXN0YW1wLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsdUJBQXVCO0FBQzNDO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMsbURBQU07QUFDN0Msa0NBQWtDLG1CQUFPLENBQUMsc0VBQW9CO0FBQzlELHVCQUF1QjtBQUN2QjtBQUNBLGFBQWE7QUFDYjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9nb29nbGUvcHJvdG9idWYvdGltZXN0YW1wLmpzP2Y1NDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRpbWVzdGFtcCA9IGV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGxvbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9uZ1wiKSk7XG5jb25zdCBtaW5pbWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKSk7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwiZ29vZ2xlLnByb3RvYnVmXCI7XG5mdW5jdGlvbiBjcmVhdGVCYXNlVGltZXN0YW1wKCkge1xuICAgIHJldHVybiB7IHNlY29uZHM6IFwiMFwiLCBuYW5vczogMCB9O1xufVxuZXhwb3J0cy5UaW1lc3RhbXAgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5zZWNvbmRzICE9PSBcIjBcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS5pbnQ2NChtZXNzYWdlLnNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm5hbm9zICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS5pbnQzMihtZXNzYWdlLm5hbm9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUaW1lc3RhbXAoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlY29uZHMgPSBsb25nVG9TdHJpbmcocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFub3MgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2Vjb25kczogaXNTZXQob2JqZWN0LnNlY29uZHMpID8gU3RyaW5nKG9iamVjdC5zZWNvbmRzKSA6IFwiMFwiLFxuICAgICAgICAgICAgbmFub3M6IGlzU2V0KG9iamVjdC5uYW5vcykgPyBOdW1iZXIob2JqZWN0Lm5hbm9zKSA6IDAsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5zZWNvbmRzICE9PSB1bmRlZmluZWQgJiYgKG9iai5zZWNvbmRzID0gbWVzc2FnZS5zZWNvbmRzKTtcbiAgICAgICAgbWVzc2FnZS5uYW5vcyAhPT0gdW5kZWZpbmVkICYmIChvYmoubmFub3MgPSBNYXRoLnJvdW5kKG1lc3NhZ2UubmFub3MpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVRpbWVzdGFtcCgpO1xuICAgICAgICBtZXNzYWdlLnNlY29uZHMgPSAoX2EgPSBvYmplY3Quc2Vjb25kcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCIwXCI7XG4gICAgICAgIG1lc3NhZ2UubmFub3MgPSAoX2IgPSBvYmplY3QubmFub3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gbG9uZ1RvU3RyaW5nKGxvbmcpIHtcbiAgICByZXR1cm4gbG9uZy50b1N0cmluZygpO1xufVxuaWYgKG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyAhPT0gbG9uZ18xLmRlZmF1bHQpIHtcbiAgICBtaW5pbWFsXzEuZGVmYXVsdC51dGlsLkxvbmcgPSBsb25nXzEuZGVmYXVsdDtcbiAgICBtaW5pbWFsXzEuZGVmYXVsdC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lc3RhbXAuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/timestamp.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/ibc/applications/transfer/v1/tx.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/ibc/applications/transfer/v1/tx.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MsgTransferResponse = exports.MsgTransfer = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nconst coin_1 = __webpack_require__(/*! ../../../../cosmos/base/v1beta1/coin */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/base/v1beta1/coin.js\");\nconst client_1 = __webpack_require__(/*! ../../../../ibc/core/client/v1/client */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/ibc/core/client/v1/client.js\");\nexports.protobufPackage = \"ibc.applications.transfer.v1\";\nfunction createBaseMsgTransfer() {\n    return {\n        sourcePort: \"\",\n        sourceChannel: \"\",\n        token: undefined,\n        sender: \"\",\n        receiver: \"\",\n        timeoutHeight: undefined,\n        timeoutTimestamp: \"0\",\n        memo: \"\",\n    };\n}\nexports.MsgTransfer = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.sourcePort !== \"\") {\n            writer.uint32(10).string(message.sourcePort);\n        }\n        if (message.sourceChannel !== \"\") {\n            writer.uint32(18).string(message.sourceChannel);\n        }\n        if (message.token !== undefined) {\n            coin_1.Coin.encode(message.token, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.sender !== \"\") {\n            writer.uint32(34).string(message.sender);\n        }\n        if (message.receiver !== \"\") {\n            writer.uint32(42).string(message.receiver);\n        }\n        if (message.timeoutHeight !== undefined) {\n            client_1.Height.encode(message.timeoutHeight, writer.uint32(50).fork()).ldelim();\n        }\n        if (message.timeoutTimestamp !== \"0\") {\n            writer.uint32(56).uint64(message.timeoutTimestamp);\n        }\n        if (message.memo !== \"\") {\n            writer.uint32(66).string(message.memo);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgTransfer();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sourcePort = reader.string();\n                    break;\n                case 2:\n                    message.sourceChannel = reader.string();\n                    break;\n                case 3:\n                    message.token = coin_1.Coin.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.sender = reader.string();\n                    break;\n                case 5:\n                    message.receiver = reader.string();\n                    break;\n                case 6:\n                    message.timeoutHeight = client_1.Height.decode(reader, reader.uint32());\n                    break;\n                case 7:\n                    message.timeoutTimestamp = longToString(reader.uint64());\n                    break;\n                case 8:\n                    message.memo = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            sourcePort: isSet(object.sourcePort) ? String(object.sourcePort) : \"\",\n            sourceChannel: isSet(object.sourceChannel)\n                ? String(object.sourceChannel)\n                : \"\",\n            token: isSet(object.token) ? coin_1.Coin.fromJSON(object.token) : undefined,\n            sender: isSet(object.sender) ? String(object.sender) : \"\",\n            receiver: isSet(object.receiver) ? String(object.receiver) : \"\",\n            timeoutHeight: isSet(object.timeoutHeight)\n                ? client_1.Height.fromJSON(object.timeoutHeight)\n                : undefined,\n            timeoutTimestamp: isSet(object.timeoutTimestamp)\n                ? String(object.timeoutTimestamp)\n                : \"0\",\n            memo: isSet(object.memo) ? String(object.memo) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.sourcePort !== undefined && (obj.sourcePort = message.sourcePort);\n        message.sourceChannel !== undefined &&\n            (obj.sourceChannel = message.sourceChannel);\n        message.token !== undefined &&\n            (obj.token = message.token ? coin_1.Coin.toJSON(message.token) : undefined);\n        message.sender !== undefined && (obj.sender = message.sender);\n        message.receiver !== undefined && (obj.receiver = message.receiver);\n        message.timeoutHeight !== undefined &&\n            (obj.timeoutHeight = message.timeoutHeight\n                ? client_1.Height.toJSON(message.timeoutHeight)\n                : undefined);\n        message.timeoutTimestamp !== undefined &&\n            (obj.timeoutTimestamp = message.timeoutTimestamp);\n        message.memo !== undefined && (obj.memo = message.memo);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f;\n        const message = createBaseMsgTransfer();\n        message.sourcePort = (_a = object.sourcePort) !== null && _a !== void 0 ? _a : \"\";\n        message.sourceChannel = (_b = object.sourceChannel) !== null && _b !== void 0 ? _b : \"\";\n        message.token =\n            object.token !== undefined && object.token !== null\n                ? coin_1.Coin.fromPartial(object.token)\n                : undefined;\n        message.sender = (_c = object.sender) !== null && _c !== void 0 ? _c : \"\";\n        message.receiver = (_d = object.receiver) !== null && _d !== void 0 ? _d : \"\";\n        message.timeoutHeight =\n            object.timeoutHeight !== undefined && object.timeoutHeight !== null\n                ? client_1.Height.fromPartial(object.timeoutHeight)\n                : undefined;\n        message.timeoutTimestamp = (_e = object.timeoutTimestamp) !== null && _e !== void 0 ? _e : \"0\";\n        message.memo = (_f = object.memo) !== null && _f !== void 0 ? _f : \"\";\n        return message;\n    },\n};\nfunction createBaseMsgTransferResponse() {\n    return {};\n}\nexports.MsgTransferResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMsgTransferResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMsgTransferResponse();\n        return message;\n    },\n};\nfunction longToString(long) {\n    return long.toString();\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=tx.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9pYmMvYXBwbGljYXRpb25zL3RyYW5zZmVyL3YxL3R4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcsbUJBQW1CLEdBQUcsdUJBQXVCO0FBQzNFO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMsbURBQU07QUFDN0Msa0NBQWtDLG1CQUFPLENBQUMsc0VBQW9CO0FBQzlELGVBQWUsbUJBQU8sQ0FBQyx3SEFBc0M7QUFDN0QsaUJBQWlCLG1CQUFPLENBQUMsMEhBQXVDO0FBQ2hFLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvcHJvdG8tdHlwZXMvaWJjL2FwcGxpY2F0aW9ucy90cmFuc2Zlci92MS90eC5qcz8xNzQwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Nc2dUcmFuc2ZlclJlc3BvbnNlID0gZXhwb3J0cy5Nc2dUcmFuc2ZlciA9IGV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGxvbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9uZ1wiKSk7XG5jb25zdCBtaW5pbWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKSk7XG5jb25zdCBjb2luXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vY29zbW9zL2Jhc2UvdjFiZXRhMS9jb2luXCIpO1xuY29uc3QgY2xpZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vaWJjL2NvcmUvY2xpZW50L3YxL2NsaWVudFwiKTtcbmV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gXCJpYmMuYXBwbGljYXRpb25zLnRyYW5zZmVyLnYxXCI7XG5mdW5jdGlvbiBjcmVhdGVCYXNlTXNnVHJhbnNmZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlUG9ydDogXCJcIixcbiAgICAgICAgc291cmNlQ2hhbm5lbDogXCJcIixcbiAgICAgICAgdG9rZW46IHVuZGVmaW5lZCxcbiAgICAgICAgc2VuZGVyOiBcIlwiLFxuICAgICAgICByZWNlaXZlcjogXCJcIixcbiAgICAgICAgdGltZW91dEhlaWdodDogdW5kZWZpbmVkLFxuICAgICAgICB0aW1lb3V0VGltZXN0YW1wOiBcIjBcIixcbiAgICAgICAgbWVtbzogXCJcIixcbiAgICB9O1xufVxuZXhwb3J0cy5Nc2dUcmFuc2ZlciA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnNvdXJjZVBvcnQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLnNvdXJjZVBvcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNvdXJjZUNoYW5uZWwgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnNvdXJjZUNoYW5uZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnRva2VuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvaW5fMS5Db2luLmVuY29kZShtZXNzYWdlLnRva2VuLCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNlbmRlciAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigzNCkuc3RyaW5nKG1lc3NhZ2Uuc2VuZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5yZWNlaXZlciAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig0Mikuc3RyaW5nKG1lc3NhZ2UucmVjZWl2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnRpbWVvdXRIZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2xpZW50XzEuSGVpZ2h0LmVuY29kZShtZXNzYWdlLnRpbWVvdXRIZWlnaHQsIHdyaXRlci51aW50MzIoNTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudGltZW91dFRpbWVzdGFtcCAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNTYpLnVpbnQ2NChtZXNzYWdlLnRpbWVvdXRUaW1lc3RhbXApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm1lbW8gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNjYpLnN0cmluZyhtZXNzYWdlLm1lbW8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ1RyYW5zZmVyKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zb3VyY2VQb3J0ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc291cmNlQ2hhbm5lbCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRva2VuID0gY29pbl8xLkNvaW4uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlbmRlciA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlY2VpdmVyID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGltZW91dEhlaWdodCA9IGNsaWVudF8xLkhlaWdodC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGltZW91dFRpbWVzdGFtcCA9IGxvbmdUb1N0cmluZyhyZWFkZXIudWludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWVtbyA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc291cmNlUG9ydDogaXNTZXQob2JqZWN0LnNvdXJjZVBvcnQpID8gU3RyaW5nKG9iamVjdC5zb3VyY2VQb3J0KSA6IFwiXCIsXG4gICAgICAgICAgICBzb3VyY2VDaGFubmVsOiBpc1NldChvYmplY3Quc291cmNlQ2hhbm5lbClcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3Quc291cmNlQ2hhbm5lbClcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICB0b2tlbjogaXNTZXQob2JqZWN0LnRva2VuKSA/IGNvaW5fMS5Db2luLmZyb21KU09OKG9iamVjdC50b2tlbikgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzZW5kZXI6IGlzU2V0KG9iamVjdC5zZW5kZXIpID8gU3RyaW5nKG9iamVjdC5zZW5kZXIpIDogXCJcIixcbiAgICAgICAgICAgIHJlY2VpdmVyOiBpc1NldChvYmplY3QucmVjZWl2ZXIpID8gU3RyaW5nKG9iamVjdC5yZWNlaXZlcikgOiBcIlwiLFxuICAgICAgICAgICAgdGltZW91dEhlaWdodDogaXNTZXQob2JqZWN0LnRpbWVvdXRIZWlnaHQpXG4gICAgICAgICAgICAgICAgPyBjbGllbnRfMS5IZWlnaHQuZnJvbUpTT04ob2JqZWN0LnRpbWVvdXRIZWlnaHQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0aW1lb3V0VGltZXN0YW1wOiBpc1NldChvYmplY3QudGltZW91dFRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICA/IFN0cmluZyhvYmplY3QudGltZW91dFRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICA6IFwiMFwiLFxuICAgICAgICAgICAgbWVtbzogaXNTZXQob2JqZWN0Lm1lbW8pID8gU3RyaW5nKG9iamVjdC5tZW1vKSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5zb3VyY2VQb3J0ICE9PSB1bmRlZmluZWQgJiYgKG9iai5zb3VyY2VQb3J0ID0gbWVzc2FnZS5zb3VyY2VQb3J0KTtcbiAgICAgICAgbWVzc2FnZS5zb3VyY2VDaGFubmVsICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc291cmNlQ2hhbm5lbCA9IG1lc3NhZ2Uuc291cmNlQ2hhbm5lbCk7XG4gICAgICAgIG1lc3NhZ2UudG9rZW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai50b2tlbiA9IG1lc3NhZ2UudG9rZW4gPyBjb2luXzEuQ29pbi50b0pTT04obWVzc2FnZS50b2tlbikgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnNlbmRlciAhPT0gdW5kZWZpbmVkICYmIChvYmouc2VuZGVyID0gbWVzc2FnZS5zZW5kZXIpO1xuICAgICAgICBtZXNzYWdlLnJlY2VpdmVyICE9PSB1bmRlZmluZWQgJiYgKG9iai5yZWNlaXZlciA9IG1lc3NhZ2UucmVjZWl2ZXIpO1xuICAgICAgICBtZXNzYWdlLnRpbWVvdXRIZWlnaHQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai50aW1lb3V0SGVpZ2h0ID0gbWVzc2FnZS50aW1lb3V0SGVpZ2h0XG4gICAgICAgICAgICAgICAgPyBjbGllbnRfMS5IZWlnaHQudG9KU09OKG1lc3NhZ2UudGltZW91dEhlaWdodClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UudGltZW91dFRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnRpbWVvdXRUaW1lc3RhbXAgPSBtZXNzYWdlLnRpbWVvdXRUaW1lc3RhbXApO1xuICAgICAgICBtZXNzYWdlLm1lbW8gIT09IHVuZGVmaW5lZCAmJiAob2JqLm1lbW8gPSBtZXNzYWdlLm1lbW8pO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ1RyYW5zZmVyKCk7XG4gICAgICAgIG1lc3NhZ2Uuc291cmNlUG9ydCA9IChfYSA9IG9iamVjdC5zb3VyY2VQb3J0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnNvdXJjZUNoYW5uZWwgPSAoX2IgPSBvYmplY3Quc291cmNlQ2hhbm5lbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS50b2tlbiA9XG4gICAgICAgICAgICBvYmplY3QudG9rZW4gIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudG9rZW4gIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGNvaW5fMS5Db2luLmZyb21QYXJ0aWFsKG9iamVjdC50b2tlbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5zZW5kZXIgPSAoX2MgPSBvYmplY3Quc2VuZGVyKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnJlY2VpdmVyID0gKF9kID0gb2JqZWN0LnJlY2VpdmVyKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnRpbWVvdXRIZWlnaHQgPVxuICAgICAgICAgICAgb2JqZWN0LnRpbWVvdXRIZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QudGltZW91dEhlaWdodCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gY2xpZW50XzEuSGVpZ2h0LmZyb21QYXJ0aWFsKG9iamVjdC50aW1lb3V0SGVpZ2h0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnRpbWVvdXRUaW1lc3RhbXAgPSAoX2UgPSBvYmplY3QudGltZW91dFRpbWVzdGFtcCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogXCIwXCI7XG4gICAgICAgIG1lc3NhZ2UubWVtbyA9IChfZiA9IG9iamVjdC5tZW1vKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VNc2dUcmFuc2ZlclJlc3BvbnNlKCkge1xuICAgIHJldHVybiB7fTtcbn1cbmV4cG9ydHMuTXNnVHJhbnNmZXJSZXNwb25zZSA9IHtcbiAgICBlbmNvZGUoXywgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZU1zZ1RyYW5zZmVyUmVzcG9uc2UoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKF8pIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH0sXG4gICAgdG9KU09OKF8pIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChfKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTXNnVHJhbnNmZXJSZXNwb25zZSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGxvbmdUb1N0cmluZyhsb25nKSB7XG4gICAgcmV0dXJuIGxvbmcudG9TdHJpbmcoKTtcbn1cbmlmIChtaW5pbWFsXzEuZGVmYXVsdC51dGlsLkxvbmcgIT09IGxvbmdfMS5kZWZhdWx0KSB7XG4gICAgbWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nID0gbG9uZ18xLmRlZmF1bHQ7XG4gICAgbWluaW1hbF8xLmRlZmF1bHQuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/ibc/applications/transfer/v1/tx.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/ibc/core/client/v1/client.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/ibc/core/client/v1/client.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Params = exports.Height = exports.UpgradeProposal = exports.ClientUpdateProposal = exports.ClientConsensusStates = exports.ConsensusStateWithHeight = exports.IdentifiedClientState = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nconst any_1 = __webpack_require__(/*! ../../../../google/protobuf/any */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/any.js\");\nconst upgrade_1 = __webpack_require__(/*! ../../../../cosmos/upgrade/v1beta1/upgrade */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/cosmos/upgrade/v1beta1/upgrade.js\");\nexports.protobufPackage = \"ibc.core.client.v1\";\nfunction createBaseIdentifiedClientState() {\n    return { clientId: \"\", clientState: undefined };\n}\nexports.IdentifiedClientState = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.clientId !== \"\") {\n            writer.uint32(10).string(message.clientId);\n        }\n        if (message.clientState !== undefined) {\n            any_1.Any.encode(message.clientState, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseIdentifiedClientState();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.clientId = reader.string();\n                    break;\n                case 2:\n                    message.clientState = any_1.Any.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            clientId: isSet(object.clientId) ? String(object.clientId) : \"\",\n            clientState: isSet(object.clientState)\n                ? any_1.Any.fromJSON(object.clientState)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.clientId !== undefined && (obj.clientId = message.clientId);\n        message.clientState !== undefined &&\n            (obj.clientState = message.clientState\n                ? any_1.Any.toJSON(message.clientState)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseIdentifiedClientState();\n        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : \"\";\n        message.clientState =\n            object.clientState !== undefined && object.clientState !== null\n                ? any_1.Any.fromPartial(object.clientState)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseConsensusStateWithHeight() {\n    return { height: undefined, consensusState: undefined };\n}\nexports.ConsensusStateWithHeight = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.height !== undefined) {\n            exports.Height.encode(message.height, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.consensusState !== undefined) {\n            any_1.Any.encode(message.consensusState, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseConsensusStateWithHeight();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.height = exports.Height.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.consensusState = any_1.Any.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            height: isSet(object.height) ? exports.Height.fromJSON(object.height) : undefined,\n            consensusState: isSet(object.consensusState)\n                ? any_1.Any.fromJSON(object.consensusState)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.height !== undefined &&\n            (obj.height = message.height ? exports.Height.toJSON(message.height) : undefined);\n        message.consensusState !== undefined &&\n            (obj.consensusState = message.consensusState\n                ? any_1.Any.toJSON(message.consensusState)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseConsensusStateWithHeight();\n        message.height =\n            object.height !== undefined && object.height !== null\n                ? exports.Height.fromPartial(object.height)\n                : undefined;\n        message.consensusState =\n            object.consensusState !== undefined && object.consensusState !== null\n                ? any_1.Any.fromPartial(object.consensusState)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseClientConsensusStates() {\n    return { clientId: \"\", consensusStates: [] };\n}\nexports.ClientConsensusStates = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.clientId !== \"\") {\n            writer.uint32(10).string(message.clientId);\n        }\n        for (const v of message.consensusStates) {\n            exports.ConsensusStateWithHeight.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseClientConsensusStates();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.clientId = reader.string();\n                    break;\n                case 2:\n                    message.consensusStates.push(exports.ConsensusStateWithHeight.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            clientId: isSet(object.clientId) ? String(object.clientId) : \"\",\n            consensusStates: Array.isArray(object === null || object === void 0 ? void 0 : object.consensusStates)\n                ? object.consensusStates.map((e) => exports.ConsensusStateWithHeight.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.clientId !== undefined && (obj.clientId = message.clientId);\n        if (message.consensusStates) {\n            obj.consensusStates = message.consensusStates.map((e) => e ? exports.ConsensusStateWithHeight.toJSON(e) : undefined);\n        }\n        else {\n            obj.consensusStates = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseClientConsensusStates();\n        message.clientId = (_a = object.clientId) !== null && _a !== void 0 ? _a : \"\";\n        message.consensusStates =\n            ((_b = object.consensusStates) === null || _b === void 0 ? void 0 : _b.map((e) => exports.ConsensusStateWithHeight.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseClientUpdateProposal() {\n    return {\n        title: \"\",\n        description: \"\",\n        subjectClientId: \"\",\n        substituteClientId: \"\",\n    };\n}\nexports.ClientUpdateProposal = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.title !== \"\") {\n            writer.uint32(10).string(message.title);\n        }\n        if (message.description !== \"\") {\n            writer.uint32(18).string(message.description);\n        }\n        if (message.subjectClientId !== \"\") {\n            writer.uint32(26).string(message.subjectClientId);\n        }\n        if (message.substituteClientId !== \"\") {\n            writer.uint32(34).string(message.substituteClientId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseClientUpdateProposal();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.title = reader.string();\n                    break;\n                case 2:\n                    message.description = reader.string();\n                    break;\n                case 3:\n                    message.subjectClientId = reader.string();\n                    break;\n                case 4:\n                    message.substituteClientId = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            title: isSet(object.title) ? String(object.title) : \"\",\n            description: isSet(object.description) ? String(object.description) : \"\",\n            subjectClientId: isSet(object.subjectClientId)\n                ? String(object.subjectClientId)\n                : \"\",\n            substituteClientId: isSet(object.substituteClientId)\n                ? String(object.substituteClientId)\n                : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.title !== undefined && (obj.title = message.title);\n        message.description !== undefined &&\n            (obj.description = message.description);\n        message.subjectClientId !== undefined &&\n            (obj.subjectClientId = message.subjectClientId);\n        message.substituteClientId !== undefined &&\n            (obj.substituteClientId = message.substituteClientId);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseClientUpdateProposal();\n        message.title = (_a = object.title) !== null && _a !== void 0 ? _a : \"\";\n        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : \"\";\n        message.subjectClientId = (_c = object.subjectClientId) !== null && _c !== void 0 ? _c : \"\";\n        message.substituteClientId = (_d = object.substituteClientId) !== null && _d !== void 0 ? _d : \"\";\n        return message;\n    },\n};\nfunction createBaseUpgradeProposal() {\n    return {\n        title: \"\",\n        description: \"\",\n        plan: undefined,\n        upgradedClientState: undefined,\n    };\n}\nexports.UpgradeProposal = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.title !== \"\") {\n            writer.uint32(10).string(message.title);\n        }\n        if (message.description !== \"\") {\n            writer.uint32(18).string(message.description);\n        }\n        if (message.plan !== undefined) {\n            upgrade_1.Plan.encode(message.plan, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.upgradedClientState !== undefined) {\n            any_1.Any.encode(message.upgradedClientState, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUpgradeProposal();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.title = reader.string();\n                    break;\n                case 2:\n                    message.description = reader.string();\n                    break;\n                case 3:\n                    message.plan = upgrade_1.Plan.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            title: isSet(object.title) ? String(object.title) : \"\",\n            description: isSet(object.description) ? String(object.description) : \"\",\n            plan: isSet(object.plan) ? upgrade_1.Plan.fromJSON(object.plan) : undefined,\n            upgradedClientState: isSet(object.upgradedClientState)\n                ? any_1.Any.fromJSON(object.upgradedClientState)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.title !== undefined && (obj.title = message.title);\n        message.description !== undefined &&\n            (obj.description = message.description);\n        message.plan !== undefined &&\n            (obj.plan = message.plan ? upgrade_1.Plan.toJSON(message.plan) : undefined);\n        message.upgradedClientState !== undefined &&\n            (obj.upgradedClientState = message.upgradedClientState\n                ? any_1.Any.toJSON(message.upgradedClientState)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseUpgradeProposal();\n        message.title = (_a = object.title) !== null && _a !== void 0 ? _a : \"\";\n        message.description = (_b = object.description) !== null && _b !== void 0 ? _b : \"\";\n        message.plan =\n            object.plan !== undefined && object.plan !== null\n                ? upgrade_1.Plan.fromPartial(object.plan)\n                : undefined;\n        message.upgradedClientState =\n            object.upgradedClientState !== undefined &&\n                object.upgradedClientState !== null\n                ? any_1.Any.fromPartial(object.upgradedClientState)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseHeight() {\n    return { revisionNumber: \"0\", revisionHeight: \"0\" };\n}\nexports.Height = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.revisionNumber !== \"0\") {\n            writer.uint32(8).uint64(message.revisionNumber);\n        }\n        if (message.revisionHeight !== \"0\") {\n            writer.uint32(16).uint64(message.revisionHeight);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseHeight();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.revisionNumber = longToString(reader.uint64());\n                    break;\n                case 2:\n                    message.revisionHeight = longToString(reader.uint64());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            revisionNumber: isSet(object.revisionNumber)\n                ? String(object.revisionNumber)\n                : \"0\",\n            revisionHeight: isSet(object.revisionHeight)\n                ? String(object.revisionHeight)\n                : \"0\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.revisionNumber !== undefined &&\n            (obj.revisionNumber = message.revisionNumber);\n        message.revisionHeight !== undefined &&\n            (obj.revisionHeight = message.revisionHeight);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseHeight();\n        message.revisionNumber = (_a = object.revisionNumber) !== null && _a !== void 0 ? _a : \"0\";\n        message.revisionHeight = (_b = object.revisionHeight) !== null && _b !== void 0 ? _b : \"0\";\n        return message;\n    },\n};\nfunction createBaseParams() {\n    return { allowedClients: [] };\n}\nexports.Params = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.allowedClients) {\n            writer.uint32(10).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseParams();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.allowedClients.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            allowedClients: Array.isArray(object === null || object === void 0 ? void 0 : object.allowedClients)\n                ? object.allowedClients.map((e) => String(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.allowedClients) {\n            obj.allowedClients = message.allowedClients.map((e) => e);\n        }\n        else {\n            obj.allowedClients = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseParams();\n        message.allowedClients = ((_a = object.allowedClients) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction longToString(long) {\n    return long.toString();\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy9pYmMvY29yZS9jbGllbnQvdjEvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGNBQWMsR0FBRyx1QkFBdUIsR0FBRyw0QkFBNEIsR0FBRyw2QkFBNkIsR0FBRyxnQ0FBZ0MsR0FBRyw2QkFBNkIsR0FBRyx1QkFBdUI7QUFDck47QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyxtREFBTTtBQUM3QyxrQ0FBa0MsbUJBQU8sQ0FBQyxzRUFBb0I7QUFDOUQsY0FBYyxtQkFBTyxDQUFDLDhHQUFpQztBQUN2RCxrQkFBa0IsbUJBQU8sQ0FBQyxvSUFBNEM7QUFDdEUsdUJBQXVCO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L3Byb3RvLXR5cGVzL2liYy9jb3JlL2NsaWVudC92MS9jbGllbnQuanM/YzAxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFyYW1zID0gZXhwb3J0cy5IZWlnaHQgPSBleHBvcnRzLlVwZ3JhZGVQcm9wb3NhbCA9IGV4cG9ydHMuQ2xpZW50VXBkYXRlUHJvcG9zYWwgPSBleHBvcnRzLkNsaWVudENvbnNlbnN1c1N0YXRlcyA9IGV4cG9ydHMuQ29uc2Vuc3VzU3RhdGVXaXRoSGVpZ2h0ID0gZXhwb3J0cy5JZGVudGlmaWVkQ2xpZW50U3RhdGUgPSBleHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlICovXG5jb25zdCBsb25nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvbmdcIikpO1xuY29uc3QgbWluaW1hbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwcm90b2J1ZmpzL21pbmltYWxcIikpO1xuY29uc3QgYW55XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vZ29vZ2xlL3Byb3RvYnVmL2FueVwiKTtcbmNvbnN0IHVwZ3JhZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9jb3Ntb3MvdXBncmFkZS92MWJldGExL3VwZ3JhZGVcIik7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwiaWJjLmNvcmUuY2xpZW50LnYxXCI7XG5mdW5jdGlvbiBjcmVhdGVCYXNlSWRlbnRpZmllZENsaWVudFN0YXRlKCkge1xuICAgIHJldHVybiB7IGNsaWVudElkOiBcIlwiLCBjbGllbnRTdGF0ZTogdW5kZWZpbmVkIH07XG59XG5leHBvcnRzLklkZW50aWZpZWRDbGllbnRTdGF0ZSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmNsaWVudElkICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS5jbGllbnRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuY2xpZW50U3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYW55XzEuQW55LmVuY29kZShtZXNzYWdlLmNsaWVudFN0YXRlLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUlkZW50aWZpZWRDbGllbnRTdGF0ZSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2xpZW50SWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jbGllbnRTdGF0ZSA9IGFueV8xLkFueS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGllbnRJZDogaXNTZXQob2JqZWN0LmNsaWVudElkKSA/IFN0cmluZyhvYmplY3QuY2xpZW50SWQpIDogXCJcIixcbiAgICAgICAgICAgIGNsaWVudFN0YXRlOiBpc1NldChvYmplY3QuY2xpZW50U3RhdGUpXG4gICAgICAgICAgICAgICAgPyBhbnlfMS5BbnkuZnJvbUpTT04ob2JqZWN0LmNsaWVudFN0YXRlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuY2xpZW50SWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmNsaWVudElkID0gbWVzc2FnZS5jbGllbnRJZCk7XG4gICAgICAgIG1lc3NhZ2UuY2xpZW50U3RhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5jbGllbnRTdGF0ZSA9IG1lc3NhZ2UuY2xpZW50U3RhdGVcbiAgICAgICAgICAgICAgICA/IGFueV8xLkFueS50b0pTT04obWVzc2FnZS5jbGllbnRTdGF0ZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUlkZW50aWZpZWRDbGllbnRTdGF0ZSgpO1xuICAgICAgICBtZXNzYWdlLmNsaWVudElkID0gKF9hID0gb2JqZWN0LmNsaWVudElkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLmNsaWVudFN0YXRlID1cbiAgICAgICAgICAgIG9iamVjdC5jbGllbnRTdGF0ZSAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jbGllbnRTdGF0ZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gYW55XzEuQW55LmZyb21QYXJ0aWFsKG9iamVjdC5jbGllbnRTdGF0ZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlQ29uc2Vuc3VzU3RhdGVXaXRoSGVpZ2h0KCkge1xuICAgIHJldHVybiB7IGhlaWdodDogdW5kZWZpbmVkLCBjb25zZW5zdXNTdGF0ZTogdW5kZWZpbmVkIH07XG59XG5leHBvcnRzLkNvbnNlbnN1c1N0YXRlV2l0aEhlaWdodCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLkhlaWdodC5lbmNvZGUobWVzc2FnZS5oZWlnaHQsIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuY29uc2Vuc3VzU3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYW55XzEuQW55LmVuY29kZShtZXNzYWdlLmNvbnNlbnN1c1N0YXRlLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNvbnNlbnN1c1N0YXRlV2l0aEhlaWdodCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGVpZ2h0ID0gZXhwb3J0cy5IZWlnaHQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnNlbnN1c1N0YXRlID0gYW55XzEuQW55LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlaWdodDogaXNTZXQob2JqZWN0LmhlaWdodCkgPyBleHBvcnRzLkhlaWdodC5mcm9tSlNPTihvYmplY3QuaGVpZ2h0KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbnNlbnN1c1N0YXRlOiBpc1NldChvYmplY3QuY29uc2Vuc3VzU3RhdGUpXG4gICAgICAgICAgICAgICAgPyBhbnlfMS5BbnkuZnJvbUpTT04ob2JqZWN0LmNvbnNlbnN1c1N0YXRlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuaGVpZ2h0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouaGVpZ2h0ID0gbWVzc2FnZS5oZWlnaHQgPyBleHBvcnRzLkhlaWdodC50b0pTT04obWVzc2FnZS5oZWlnaHQpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS5jb25zZW5zdXNTdGF0ZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmNvbnNlbnN1c1N0YXRlID0gbWVzc2FnZS5jb25zZW5zdXNTdGF0ZVxuICAgICAgICAgICAgICAgID8gYW55XzEuQW55LnRvSlNPTihtZXNzYWdlLmNvbnNlbnN1c1N0YXRlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNvbnNlbnN1c1N0YXRlV2l0aEhlaWdodCgpO1xuICAgICAgICBtZXNzYWdlLmhlaWdodCA9XG4gICAgICAgICAgICBvYmplY3QuaGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmhlaWdodCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5IZWlnaHQuZnJvbVBhcnRpYWwob2JqZWN0LmhlaWdodClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5jb25zZW5zdXNTdGF0ZSA9XG4gICAgICAgICAgICBvYmplY3QuY29uc2Vuc3VzU3RhdGUgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuY29uc2Vuc3VzU3RhdGUgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGFueV8xLkFueS5mcm9tUGFydGlhbChvYmplY3QuY29uc2Vuc3VzU3RhdGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUNsaWVudENvbnNlbnN1c1N0YXRlcygpIHtcbiAgICByZXR1cm4geyBjbGllbnRJZDogXCJcIiwgY29uc2Vuc3VzU3RhdGVzOiBbXSB9O1xufVxuZXhwb3J0cy5DbGllbnRDb25zZW5zdXNTdGF0ZXMgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5jbGllbnRJZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UuY2xpZW50SWQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLmNvbnNlbnN1c1N0YXRlcykge1xuICAgICAgICAgICAgZXhwb3J0cy5Db25zZW5zdXNTdGF0ZVdpdGhIZWlnaHQuZW5jb2RlKHYsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ2xpZW50Q29uc2Vuc3VzU3RhdGVzKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jbGllbnRJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnNlbnN1c1N0YXRlcy5wdXNoKGV4cG9ydHMuQ29uc2Vuc3VzU3RhdGVXaXRoSGVpZ2h0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGllbnRJZDogaXNTZXQob2JqZWN0LmNsaWVudElkKSA/IFN0cmluZyhvYmplY3QuY2xpZW50SWQpIDogXCJcIixcbiAgICAgICAgICAgIGNvbnNlbnN1c1N0YXRlczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QuY29uc2Vuc3VzU3RhdGVzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LmNvbnNlbnN1c1N0YXRlcy5tYXAoKGUpID0+IGV4cG9ydHMuQ29uc2Vuc3VzU3RhdGVXaXRoSGVpZ2h0LmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5jbGllbnRJZCAhPT0gdW5kZWZpbmVkICYmIChvYmouY2xpZW50SWQgPSBtZXNzYWdlLmNsaWVudElkKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuY29uc2Vuc3VzU3RhdGVzKSB7XG4gICAgICAgICAgICBvYmouY29uc2Vuc3VzU3RhdGVzID0gbWVzc2FnZS5jb25zZW5zdXNTdGF0ZXMubWFwKChlKSA9PiBlID8gZXhwb3J0cy5Db25zZW5zdXNTdGF0ZVdpdGhIZWlnaHQudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5jb25zZW5zdXNTdGF0ZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ2xpZW50Q29uc2Vuc3VzU3RhdGVzKCk7XG4gICAgICAgIG1lc3NhZ2UuY2xpZW50SWQgPSAoX2EgPSBvYmplY3QuY2xpZW50SWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuY29uc2Vuc3VzU3RhdGVzID1cbiAgICAgICAgICAgICgoX2IgPSBvYmplY3QuY29uc2Vuc3VzU3RhdGVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubWFwKChlKSA9PiBleHBvcnRzLkNvbnNlbnN1c1N0YXRlV2l0aEhlaWdodC5mcm9tUGFydGlhbChlKSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VDbGllbnRVcGRhdGVQcm9wb3NhbCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0aXRsZTogXCJcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIHN1YmplY3RDbGllbnRJZDogXCJcIixcbiAgICAgICAgc3Vic3RpdHV0ZUNsaWVudElkOiBcIlwiLFxuICAgIH07XG59XG5leHBvcnRzLkNsaWVudFVwZGF0ZVByb3Bvc2FsID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudGl0bGUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyhtZXNzYWdlLnRpdGxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5kZXNjcmlwdGlvbiAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UuZGVzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnN1YmplY3RDbGllbnRJZCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuc3RyaW5nKG1lc3NhZ2Uuc3ViamVjdENsaWVudElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zdWJzdGl0dXRlQ2xpZW50SWQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMzQpLnN0cmluZyhtZXNzYWdlLnN1YnN0aXR1dGVDbGllbnRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ2xpZW50VXBkYXRlUHJvcG9zYWwoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRpdGxlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVzY3JpcHRpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdWJqZWN0Q2xpZW50SWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zdWJzdGl0dXRlQ2xpZW50SWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpdGxlOiBpc1NldChvYmplY3QudGl0bGUpID8gU3RyaW5nKG9iamVjdC50aXRsZSkgOiBcIlwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGlzU2V0KG9iamVjdC5kZXNjcmlwdGlvbikgPyBTdHJpbmcob2JqZWN0LmRlc2NyaXB0aW9uKSA6IFwiXCIsXG4gICAgICAgICAgICBzdWJqZWN0Q2xpZW50SWQ6IGlzU2V0KG9iamVjdC5zdWJqZWN0Q2xpZW50SWQpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LnN1YmplY3RDbGllbnRJZClcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgICAgICBzdWJzdGl0dXRlQ2xpZW50SWQ6IGlzU2V0KG9iamVjdC5zdWJzdGl0dXRlQ2xpZW50SWQpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LnN1YnN0aXR1dGVDbGllbnRJZClcbiAgICAgICAgICAgICAgICA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS50aXRsZSAhPT0gdW5kZWZpbmVkICYmIChvYmoudGl0bGUgPSBtZXNzYWdlLnRpdGxlKTtcbiAgICAgICAgbWVzc2FnZS5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmRlc2NyaXB0aW9uID0gbWVzc2FnZS5kZXNjcmlwdGlvbik7XG4gICAgICAgIG1lc3NhZ2Uuc3ViamVjdENsaWVudElkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc3ViamVjdENsaWVudElkID0gbWVzc2FnZS5zdWJqZWN0Q2xpZW50SWQpO1xuICAgICAgICBtZXNzYWdlLnN1YnN0aXR1dGVDbGllbnRJZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnN1YnN0aXR1dGVDbGllbnRJZCA9IG1lc3NhZ2Uuc3Vic3RpdHV0ZUNsaWVudElkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ2xpZW50VXBkYXRlUHJvcG9zYWwoKTtcbiAgICAgICAgbWVzc2FnZS50aXRsZSA9IChfYSA9IG9iamVjdC50aXRsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5kZXNjcmlwdGlvbiA9IChfYiA9IG9iamVjdC5kZXNjcmlwdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5zdWJqZWN0Q2xpZW50SWQgPSAoX2MgPSBvYmplY3Quc3ViamVjdENsaWVudElkKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcIlwiO1xuICAgICAgICBtZXNzYWdlLnN1YnN0aXR1dGVDbGllbnRJZCA9IChfZCA9IG9iamVjdC5zdWJzdGl0dXRlQ2xpZW50SWQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFwiXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVVwZ3JhZGVQcm9wb3NhbCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0aXRsZTogXCJcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgICAgIHBsYW46IHVuZGVmaW5lZCxcbiAgICAgICAgdXBncmFkZWRDbGllbnRTdGF0ZTogdW5kZWZpbmVkLFxuICAgIH07XG59XG5leHBvcnRzLlVwZ3JhZGVQcm9wb3NhbCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnRpdGxlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5zdHJpbmcobWVzc2FnZS50aXRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGVzY3JpcHRpb24gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLmRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5wbGFuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHVwZ3JhZGVfMS5QbGFuLmVuY29kZShtZXNzYWdlLnBsYW4sIHdyaXRlci51aW50MzIoMjYpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudXBncmFkZWRDbGllbnRTdGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhbnlfMS5BbnkuZW5jb2RlKG1lc3NhZ2UudXBncmFkZWRDbGllbnRTdGF0ZSwgd3JpdGVyLnVpbnQzMigzNCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VVcGdyYWRlUHJvcG9zYWwoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRpdGxlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGVzY3JpcHRpb24gPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wbGFuID0gdXBncmFkZV8xLlBsYW4uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnVwZ3JhZGVkQ2xpZW50U3RhdGUgPSBhbnlfMS5BbnkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGl0bGU6IGlzU2V0KG9iamVjdC50aXRsZSkgPyBTdHJpbmcob2JqZWN0LnRpdGxlKSA6IFwiXCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogaXNTZXQob2JqZWN0LmRlc2NyaXB0aW9uKSA/IFN0cmluZyhvYmplY3QuZGVzY3JpcHRpb24pIDogXCJcIixcbiAgICAgICAgICAgIHBsYW46IGlzU2V0KG9iamVjdC5wbGFuKSA/IHVwZ3JhZGVfMS5QbGFuLmZyb21KU09OKG9iamVjdC5wbGFuKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVwZ3JhZGVkQ2xpZW50U3RhdGU6IGlzU2V0KG9iamVjdC51cGdyYWRlZENsaWVudFN0YXRlKVxuICAgICAgICAgICAgICAgID8gYW55XzEuQW55LmZyb21KU09OKG9iamVjdC51cGdyYWRlZENsaWVudFN0YXRlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudGl0bGUgIT09IHVuZGVmaW5lZCAmJiAob2JqLnRpdGxlID0gbWVzc2FnZS50aXRsZSk7XG4gICAgICAgIG1lc3NhZ2UuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5kZXNjcmlwdGlvbiA9IG1lc3NhZ2UuZGVzY3JpcHRpb24pO1xuICAgICAgICBtZXNzYWdlLnBsYW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wbGFuID0gbWVzc2FnZS5wbGFuID8gdXBncmFkZV8xLlBsYW4udG9KU09OKG1lc3NhZ2UucGxhbikgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnVwZ3JhZGVkQ2xpZW50U3RhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai51cGdyYWRlZENsaWVudFN0YXRlID0gbWVzc2FnZS51cGdyYWRlZENsaWVudFN0YXRlXG4gICAgICAgICAgICAgICAgPyBhbnlfMS5BbnkudG9KU09OKG1lc3NhZ2UudXBncmFkZWRDbGllbnRTdGF0ZSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VVcGdyYWRlUHJvcG9zYWwoKTtcbiAgICAgICAgbWVzc2FnZS50aXRsZSA9IChfYSA9IG9iamVjdC50aXRsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5kZXNjcmlwdGlvbiA9IChfYiA9IG9iamVjdC5kZXNjcmlwdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5wbGFuID1cbiAgICAgICAgICAgIG9iamVjdC5wbGFuICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnBsYW4gIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IHVwZ3JhZGVfMS5QbGFuLmZyb21QYXJ0aWFsKG9iamVjdC5wbGFuKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnVwZ3JhZGVkQ2xpZW50U3RhdGUgPVxuICAgICAgICAgICAgb2JqZWN0LnVwZ3JhZGVkQ2xpZW50U3RhdGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIG9iamVjdC51cGdyYWRlZENsaWVudFN0YXRlICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBhbnlfMS5BbnkuZnJvbVBhcnRpYWwob2JqZWN0LnVwZ3JhZGVkQ2xpZW50U3RhdGUpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUhlaWdodCgpIHtcbiAgICByZXR1cm4geyByZXZpc2lvbk51bWJlcjogXCIwXCIsIHJldmlzaW9uSGVpZ2h0OiBcIjBcIiB9O1xufVxuZXhwb3J0cy5IZWlnaHQgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5yZXZpc2lvbk51bWJlciAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkudWludDY0KG1lc3NhZ2UucmV2aXNpb25OdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnJldmlzaW9uSGVpZ2h0ICE9PSBcIjBcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxNikudWludDY0KG1lc3NhZ2UucmV2aXNpb25IZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUhlaWdodCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmV2aXNpb25OdW1iZXIgPSBsb25nVG9TdHJpbmcocmVhZGVyLnVpbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJldmlzaW9uSGVpZ2h0ID0gbG9uZ1RvU3RyaW5nKHJlYWRlci51aW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJldmlzaW9uTnVtYmVyOiBpc1NldChvYmplY3QucmV2aXNpb25OdW1iZXIpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LnJldmlzaW9uTnVtYmVyKVxuICAgICAgICAgICAgICAgIDogXCIwXCIsXG4gICAgICAgICAgICByZXZpc2lvbkhlaWdodDogaXNTZXQob2JqZWN0LnJldmlzaW9uSGVpZ2h0KVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC5yZXZpc2lvbkhlaWdodClcbiAgICAgICAgICAgICAgICA6IFwiMFwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UucmV2aXNpb25OdW1iZXIgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5yZXZpc2lvbk51bWJlciA9IG1lc3NhZ2UucmV2aXNpb25OdW1iZXIpO1xuICAgICAgICBtZXNzYWdlLnJldmlzaW9uSGVpZ2h0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucmV2aXNpb25IZWlnaHQgPSBtZXNzYWdlLnJldmlzaW9uSGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUhlaWdodCgpO1xuICAgICAgICBtZXNzYWdlLnJldmlzaW9uTnVtYmVyID0gKF9hID0gb2JqZWN0LnJldmlzaW9uTnVtYmVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIjBcIjtcbiAgICAgICAgbWVzc2FnZS5yZXZpc2lvbkhlaWdodCA9IChfYiA9IG9iamVjdC5yZXZpc2lvbkhlaWdodCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCIwXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVBhcmFtcygpIHtcbiAgICByZXR1cm4geyBhbGxvd2VkQ2xpZW50czogW10gfTtcbn1cbmV4cG9ydHMuUGFyYW1zID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuYWxsb3dlZENsaWVudHMpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLnN0cmluZyh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQYXJhbXMoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFsbG93ZWRDbGllbnRzLnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWxsb3dlZENsaWVudHM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LmFsbG93ZWRDbGllbnRzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LmFsbG93ZWRDbGllbnRzLm1hcCgoZSkgPT4gU3RyaW5nKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuYWxsb3dlZENsaWVudHMpIHtcbiAgICAgICAgICAgIG9iai5hbGxvd2VkQ2xpZW50cyA9IG1lc3NhZ2UuYWxsb3dlZENsaWVudHMubWFwKChlKSA9PiBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5hbGxvd2VkQ2xpZW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVBhcmFtcygpO1xuICAgICAgICBtZXNzYWdlLmFsbG93ZWRDbGllbnRzID0gKChfYSA9IG9iamVjdC5hbGxvd2VkQ2xpZW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gZSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGxvbmdUb1N0cmluZyhsb25nKSB7XG4gICAgcmV0dXJuIGxvbmcudG9TdHJpbmcoKTtcbn1cbmlmIChtaW5pbWFsXzEuZGVmYXVsdC51dGlsLkxvbmcgIT09IGxvbmdfMS5kZWZhdWx0KSB7XG4gICAgbWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nID0gbG9uZ18xLmRlZmF1bHQ7XG4gICAgbWluaW1hbF8xLmRlZmF1bHQuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/ibc/core/client/v1/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/tendermint/crypto/keys.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/tendermint/crypto/keys.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PublicKey = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nexports.protobufPackage = \"tendermint.crypto\";\nfunction createBasePublicKey() {\n    return { ed25519: undefined, secp256k1: undefined };\n}\nexports.PublicKey = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.ed25519 !== undefined) {\n            writer.uint32(10).bytes(message.ed25519);\n        }\n        if (message.secp256k1 !== undefined) {\n            writer.uint32(18).bytes(message.secp256k1);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePublicKey();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.ed25519 = reader.bytes();\n                    break;\n                case 2:\n                    message.secp256k1 = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            ed25519: isSet(object.ed25519)\n                ? bytesFromBase64(object.ed25519)\n                : undefined,\n            secp256k1: isSet(object.secp256k1)\n                ? bytesFromBase64(object.secp256k1)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.ed25519 !== undefined &&\n            (obj.ed25519 =\n                message.ed25519 !== undefined\n                    ? base64FromBytes(message.ed25519)\n                    : undefined);\n        message.secp256k1 !== undefined &&\n            (obj.secp256k1 =\n                message.secp256k1 !== undefined\n                    ? base64FromBytes(message.secp256k1)\n                    : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePublicKey();\n        message.ed25519 = (_a = object.ed25519) !== null && _a !== void 0 ? _a : undefined;\n        message.secp256k1 = (_b = object.secp256k1) !== null && _b !== void 0 ? _b : undefined;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob ||\n    ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa ||\n    ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (const byte of arr) {\n        bin.push(String.fromCharCode(byte));\n    }\n    return btoa(bin.join(\"\"));\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=keys.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy90ZW5kZXJtaW50L2NyeXB0by9rZXlzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsdUJBQXVCO0FBQzNDO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMsbURBQU07QUFDN0Msa0NBQWtDLG1CQUFPLENBQUMsc0VBQW9CO0FBQzlELHVCQUF1QjtBQUN2QjtBQUNBLGFBQWE7QUFDYjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L3Byb3RvLXR5cGVzL3RlbmRlcm1pbnQvY3J5cHRvL2tleXMuanM/YmE0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHVibGljS2V5ID0gZXhwb3J0cy5wcm90b2J1ZlBhY2thZ2UgPSB2b2lkIDA7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuY29uc3QgbG9uZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb25nXCIpKTtcbmNvbnN0IG1pbmltYWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicHJvdG9idWZqcy9taW5pbWFsXCIpKTtcbmV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gXCJ0ZW5kZXJtaW50LmNyeXB0b1wiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZVB1YmxpY0tleSgpIHtcbiAgICByZXR1cm4geyBlZDI1NTE5OiB1bmRlZmluZWQsIHNlY3AyNTZrMTogdW5kZWZpbmVkIH07XG59XG5leHBvcnRzLlB1YmxpY0tleSA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmVkMjU1MTkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5lZDI1NTE5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zZWNwMjU2azEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuYnl0ZXMobWVzc2FnZS5zZWNwMjU2azEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVB1YmxpY0tleSgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZWQyNTUxOSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VjcDI1NmsxID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVkMjU1MTk6IGlzU2V0KG9iamVjdC5lZDI1NTE5KVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5lZDI1NTE5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2VjcDI1NmsxOiBpc1NldChvYmplY3Quc2VjcDI1NmsxKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5zZWNwMjU2azEpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5lZDI1NTE5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZWQyNTUxOSA9XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5lZDI1NTE5ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5lZDI1NTE5KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2Uuc2VjcDI1NmsxICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc2VjcDI1NmsxID1cbiAgICAgICAgICAgICAgICBtZXNzYWdlLnNlY3AyNTZrMSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgID8gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2Uuc2VjcDI1NmsxKVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQdWJsaWNLZXkoKTtcbiAgICAgICAgbWVzc2FnZS5lZDI1NTE5ID0gKF9hID0gb2JqZWN0LmVkMjU1MTkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5zZWNwMjU2azEgPSAoX2IgPSBvYmplY3Quc2VjcDI1NmsxKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xudmFyIGdsb2JhbFRoaXMgPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB0aHJvdyBcIlVuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdFwiO1xufSkoKTtcbmNvbnN0IGF0b2IgPSBnbG9iYWxUaGlzLmF0b2IgfHxcbiAgICAoKGI2NCkgPT4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiNjQsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKFwiYmluYXJ5XCIpKTtcbmZ1bmN0aW9uIGJ5dGVzRnJvbUJhc2U2NChiNjQpIHtcbiAgICBjb25zdCBiaW4gPSBhdG9iKGI2NCk7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYmluLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5jb25zdCBidG9hID0gZ2xvYmFsVGhpcy5idG9hIHx8XG4gICAgKChiaW4pID0+IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYmluLCBcImJpbmFyeVwiKS50b1N0cmluZyhcImJhc2U2NFwiKSk7XG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyKSB7XG4gICAgY29uc3QgYmluID0gW107XG4gICAgZm9yIChjb25zdCBieXRlIG9mIGFycikge1xuICAgICAgICBiaW4ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ0b2EoYmluLmpvaW4oXCJcIikpO1xufVxuaWYgKG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyAhPT0gbG9uZ18xLmRlZmF1bHQpIHtcbiAgICBtaW5pbWFsXzEuZGVmYXVsdC51dGlsLkxvbmcgPSBsb25nXzEuZGVmYXVsdDtcbiAgICBtaW5pbWFsXzEuZGVmYXVsdC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXlzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/tendermint/crypto/keys.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/tendermint/crypto/proof.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/tendermint/crypto/proof.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ProofOps = exports.ProofOp = exports.DominoOp = exports.ValueOp = exports.Proof = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nexports.protobufPackage = \"tendermint.crypto\";\nfunction createBaseProof() {\n    return { total: \"0\", index: \"0\", leafHash: new Uint8Array(), aunts: [] };\n}\nexports.Proof = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.total !== \"0\") {\n            writer.uint32(8).int64(message.total);\n        }\n        if (message.index !== \"0\") {\n            writer.uint32(16).int64(message.index);\n        }\n        if (message.leafHash.length !== 0) {\n            writer.uint32(26).bytes(message.leafHash);\n        }\n        for (const v of message.aunts) {\n            writer.uint32(34).bytes(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseProof();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.total = longToString(reader.int64());\n                    break;\n                case 2:\n                    message.index = longToString(reader.int64());\n                    break;\n                case 3:\n                    message.leafHash = reader.bytes();\n                    break;\n                case 4:\n                    message.aunts.push(reader.bytes());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            total: isSet(object.total) ? String(object.total) : \"0\",\n            index: isSet(object.index) ? String(object.index) : \"0\",\n            leafHash: isSet(object.leafHash)\n                ? bytesFromBase64(object.leafHash)\n                : new Uint8Array(),\n            aunts: Array.isArray(object === null || object === void 0 ? void 0 : object.aunts)\n                ? object.aunts.map((e) => bytesFromBase64(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.total !== undefined && (obj.total = message.total);\n        message.index !== undefined && (obj.index = message.index);\n        message.leafHash !== undefined &&\n            (obj.leafHash = base64FromBytes(message.leafHash !== undefined ? message.leafHash : new Uint8Array()));\n        if (message.aunts) {\n            obj.aunts = message.aunts.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));\n        }\n        else {\n            obj.aunts = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseProof();\n        message.total = (_a = object.total) !== null && _a !== void 0 ? _a : \"0\";\n        message.index = (_b = object.index) !== null && _b !== void 0 ? _b : \"0\";\n        message.leafHash = (_c = object.leafHash) !== null && _c !== void 0 ? _c : new Uint8Array();\n        message.aunts = ((_d = object.aunts) === null || _d === void 0 ? void 0 : _d.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBaseValueOp() {\n    return { key: new Uint8Array(), proof: undefined };\n}\nexports.ValueOp = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.key.length !== 0) {\n            writer.uint32(10).bytes(message.key);\n        }\n        if (message.proof !== undefined) {\n            exports.Proof.encode(message.proof, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseValueOp();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.bytes();\n                    break;\n                case 2:\n                    message.proof = exports.Proof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n            proof: isSet(object.proof) ? exports.Proof.fromJSON(object.proof) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined &&\n            (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n        message.proof !== undefined &&\n            (obj.proof = message.proof ? exports.Proof.toJSON(message.proof) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseValueOp();\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.proof =\n            object.proof !== undefined && object.proof !== null\n                ? exports.Proof.fromPartial(object.proof)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseDominoOp() {\n    return { key: \"\", input: \"\", output: \"\" };\n}\nexports.DominoOp = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.key !== \"\") {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.input !== \"\") {\n            writer.uint32(18).string(message.input);\n        }\n        if (message.output !== \"\") {\n            writer.uint32(26).string(message.output);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDominoOp();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.string();\n                    break;\n                case 2:\n                    message.input = reader.string();\n                    break;\n                case 3:\n                    message.output = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            key: isSet(object.key) ? String(object.key) : \"\",\n            input: isSet(object.input) ? String(object.input) : \"\",\n            output: isSet(object.output) ? String(object.output) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined && (obj.key = message.key);\n        message.input !== undefined && (obj.input = message.input);\n        message.output !== undefined && (obj.output = message.output);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseDominoOp();\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : \"\";\n        message.input = (_b = object.input) !== null && _b !== void 0 ? _b : \"\";\n        message.output = (_c = object.output) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBaseProofOp() {\n    return { type: \"\", key: new Uint8Array(), data: new Uint8Array() };\n}\nexports.ProofOp = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.type !== \"\") {\n            writer.uint32(10).string(message.type);\n        }\n        if (message.key.length !== 0) {\n            writer.uint32(18).bytes(message.key);\n        }\n        if (message.data.length !== 0) {\n            writer.uint32(26).bytes(message.data);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseProofOp();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.type = reader.string();\n                    break;\n                case 2:\n                    message.key = reader.bytes();\n                    break;\n                case 3:\n                    message.data = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            type: isSet(object.type) ? String(object.type) : \"\",\n            key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(),\n            data: isSet(object.data)\n                ? bytesFromBase64(object.data)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.type !== undefined && (obj.type = message.type);\n        message.key !== undefined &&\n            (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n        message.data !== undefined &&\n            (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseProofOp();\n        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : \"\";\n        message.key = (_b = object.key) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.data = (_c = object.data) !== null && _c !== void 0 ? _c : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseProofOps() {\n    return { ops: [] };\n}\nexports.ProofOps = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.ops) {\n            exports.ProofOp.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseProofOps();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.ops.push(exports.ProofOp.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            ops: Array.isArray(object === null || object === void 0 ? void 0 : object.ops)\n                ? object.ops.map((e) => exports.ProofOp.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.ops) {\n            obj.ops = message.ops.map((e) => (e ? exports.ProofOp.toJSON(e) : undefined));\n        }\n        else {\n            obj.ops = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseProofOps();\n        message.ops = ((_a = object.ops) === null || _a === void 0 ? void 0 : _a.map((e) => exports.ProofOp.fromPartial(e))) || [];\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob ||\n    ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa ||\n    ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (const byte of arr) {\n        bin.push(String.fromCharCode(byte));\n    }\n    return btoa(bin.join(\"\"));\n}\nfunction longToString(long) {\n    return long.toString();\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=proof.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy90ZW5kZXJtaW50L2NyeXB0by9wcm9vZi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGVBQWUsR0FBRyxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsYUFBYSxHQUFHLHVCQUF1QjtBQUNqSDtBQUNBLCtCQUErQixtQkFBTyxDQUFDLG1EQUFNO0FBQzdDLGtDQUFrQyxtQkFBTyxDQUFDLHNFQUFvQjtBQUM5RCx1QkFBdUI7QUFDdkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvcHJvdG8tdHlwZXMvdGVuZGVybWludC9jcnlwdG8vcHJvb2YuanM/NzFkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJvb2ZPcHMgPSBleHBvcnRzLlByb29mT3AgPSBleHBvcnRzLkRvbWlub09wID0gZXhwb3J0cy5WYWx1ZU9wID0gZXhwb3J0cy5Qcm9vZiA9IGV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGxvbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9uZ1wiKSk7XG5jb25zdCBtaW5pbWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKSk7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwidGVuZGVybWludC5jcnlwdG9cIjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQcm9vZigpIHtcbiAgICByZXR1cm4geyB0b3RhbDogXCIwXCIsIGluZGV4OiBcIjBcIiwgbGVhZkhhc2g6IG5ldyBVaW50OEFycmF5KCksIGF1bnRzOiBbXSB9O1xufVxuZXhwb3J0cy5Qcm9vZiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnRvdGFsICE9PSBcIjBcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS5pbnQ2NChtZXNzYWdlLnRvdGFsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pbmRleCAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLmludDY0KG1lc3NhZ2UuaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmxlYWZIYXNoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuYnl0ZXMobWVzc2FnZS5sZWFmSGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2IG9mIG1lc3NhZ2UuYXVudHMpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMzQpLmJ5dGVzKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVByb29mKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50b3RhbCA9IGxvbmdUb1N0cmluZyhyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbmRleCA9IGxvbmdUb1N0cmluZyhyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5sZWFmSGFzaCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXVudHMucHVzaChyZWFkZXIuYnl0ZXMoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvdGFsOiBpc1NldChvYmplY3QudG90YWwpID8gU3RyaW5nKG9iamVjdC50b3RhbCkgOiBcIjBcIixcbiAgICAgICAgICAgIGluZGV4OiBpc1NldChvYmplY3QuaW5kZXgpID8gU3RyaW5nKG9iamVjdC5pbmRleCkgOiBcIjBcIixcbiAgICAgICAgICAgIGxlYWZIYXNoOiBpc1NldChvYmplY3QubGVhZkhhc2gpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmxlYWZIYXNoKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIGF1bnRzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5hdW50cylcbiAgICAgICAgICAgICAgICA/IG9iamVjdC5hdW50cy5tYXAoKGUpID0+IGJ5dGVzRnJvbUJhc2U2NChlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudG90YWwgIT09IHVuZGVmaW5lZCAmJiAob2JqLnRvdGFsID0gbWVzc2FnZS50b3RhbCk7XG4gICAgICAgIG1lc3NhZ2UuaW5kZXggIT09IHVuZGVmaW5lZCAmJiAob2JqLmluZGV4ID0gbWVzc2FnZS5pbmRleCk7XG4gICAgICAgIG1lc3NhZ2UubGVhZkhhc2ggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5sZWFmSGFzaCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmxlYWZIYXNoICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmxlYWZIYXNoIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBpZiAobWVzc2FnZS5hdW50cykge1xuICAgICAgICAgICAgb2JqLmF1bnRzID0gbWVzc2FnZS5hdW50cy5tYXAoKGUpID0+IGJhc2U2NEZyb21CeXRlcyhlICE9PSB1bmRlZmluZWQgPyBlIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLmF1bnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHJvb2YoKTtcbiAgICAgICAgbWVzc2FnZS50b3RhbCA9IChfYSA9IG9iamVjdC50b3RhbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCIwXCI7XG4gICAgICAgIG1lc3NhZ2UuaW5kZXggPSAoX2IgPSBvYmplY3QuaW5kZXgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiMFwiO1xuICAgICAgICBtZXNzYWdlLmxlYWZIYXNoID0gKF9jID0gb2JqZWN0LmxlYWZIYXNoKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmF1bnRzID0gKChfZCA9IG9iamVjdC5hdW50cykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLm1hcCgoZSkgPT4gZSkpIHx8IFtdO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWYWx1ZU9wKCkge1xuICAgIHJldHVybiB7IGtleTogbmV3IFVpbnQ4QXJyYXkoKSwgcHJvb2Y6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0cy5WYWx1ZU9wID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uua2V5Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5rZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnByb29mICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuUHJvb2YuZW5jb2RlKG1lc3NhZ2UucHJvb2YsIHdyaXRlci51aW50MzIoMTgpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVmFsdWVPcCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5ID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcm9vZiA9IGV4cG9ydHMuUHJvb2YuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiBpc1NldChvYmplY3Qua2V5KSA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3Qua2V5KSA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBwcm9vZjogaXNTZXQob2JqZWN0LnByb29mKSA/IGV4cG9ydHMuUHJvb2YuZnJvbUpTT04ob2JqZWN0LnByb29mKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmtleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmtleSA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmtleSAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5rZXkgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UucHJvb2YgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wcm9vZiA9IG1lc3NhZ2UucHJvb2YgPyBleHBvcnRzLlByb29mLnRvSlNPTihtZXNzYWdlLnByb29mKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVZhbHVlT3AoKTtcbiAgICAgICAgbWVzc2FnZS5rZXkgPSAoX2EgPSBvYmplY3Qua2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLnByb29mID1cbiAgICAgICAgICAgIG9iamVjdC5wcm9vZiAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5wcm9vZiAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5Qcm9vZi5mcm9tUGFydGlhbChvYmplY3QucHJvb2YpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZURvbWlub09wKCkge1xuICAgIHJldHVybiB7IGtleTogXCJcIiwgaW5wdXQ6IFwiXCIsIG91dHB1dDogXCJcIiB9O1xufVxuZXhwb3J0cy5Eb21pbm9PcCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmtleSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2Uua2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5pbnB1dCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuc3RyaW5nKG1lc3NhZ2UuaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm91dHB1dCAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNikuc3RyaW5nKG1lc3NhZ2Uub3V0cHV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEb21pbm9PcCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uua2V5ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5wdXQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vdXRwdXQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogaXNTZXQob2JqZWN0LmtleSkgPyBTdHJpbmcob2JqZWN0LmtleSkgOiBcIlwiLFxuICAgICAgICAgICAgaW5wdXQ6IGlzU2V0KG9iamVjdC5pbnB1dCkgPyBTdHJpbmcob2JqZWN0LmlucHV0KSA6IFwiXCIsXG4gICAgICAgICAgICBvdXRwdXQ6IGlzU2V0KG9iamVjdC5vdXRwdXQpID8gU3RyaW5nKG9iamVjdC5vdXRwdXQpIDogXCJcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmtleSAhPT0gdW5kZWZpbmVkICYmIChvYmoua2V5ID0gbWVzc2FnZS5rZXkpO1xuICAgICAgICBtZXNzYWdlLmlucHV0ICE9PSB1bmRlZmluZWQgJiYgKG9iai5pbnB1dCA9IG1lc3NhZ2UuaW5wdXQpO1xuICAgICAgICBtZXNzYWdlLm91dHB1dCAhPT0gdW5kZWZpbmVkICYmIChvYmoub3V0cHV0ID0gbWVzc2FnZS5vdXRwdXQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURvbWlub09wKCk7XG4gICAgICAgIG1lc3NhZ2Uua2V5ID0gKF9hID0gb2JqZWN0LmtleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5pbnB1dCA9IChfYiA9IG9iamVjdC5pbnB1dCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5vdXRwdXQgPSAoX2MgPSBvYmplY3Qub3V0cHV0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBcIlwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQcm9vZk9wKCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwiXCIsIGtleTogbmV3IFVpbnQ4QXJyYXkoKSwgZGF0YTogbmV3IFVpbnQ4QXJyYXkoKSB9O1xufVxuZXhwb3J0cy5Qcm9vZk9wID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuc3RyaW5nKG1lc3NhZ2UudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uua2V5Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuYnl0ZXMobWVzc2FnZS5rZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmRhdGEubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI2KS5ieXRlcyhtZXNzYWdlLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVByb29mT3AoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR5cGUgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXkgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGEgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogaXNTZXQob2JqZWN0LnR5cGUpID8gU3RyaW5nKG9iamVjdC50eXBlKSA6IFwiXCIsXG4gICAgICAgICAgICBrZXk6IGlzU2V0KG9iamVjdC5rZXkpID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5rZXkpIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIGRhdGE6IGlzU2V0KG9iamVjdC5kYXRhKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5kYXRhKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLnR5cGUgIT09IHVuZGVmaW5lZCAmJiAob2JqLnR5cGUgPSBtZXNzYWdlLnR5cGUpO1xuICAgICAgICBtZXNzYWdlLmtleSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmtleSA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmtleSAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5rZXkgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UuZGF0YSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmRhdGEgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5kYXRhICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmRhdGEgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHJvb2ZPcCgpO1xuICAgICAgICBtZXNzYWdlLnR5cGUgPSAoX2EgPSBvYmplY3QudHlwZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgbWVzc2FnZS5rZXkgPSAoX2IgPSBvYmplY3Qua2V5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmRhdGEgPSAoX2MgPSBvYmplY3QuZGF0YSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlUHJvb2ZPcHMoKSB7XG4gICAgcmV0dXJuIHsgb3BzOiBbXSB9O1xufVxuZXhwb3J0cy5Qcm9vZk9wcyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLm9wcykge1xuICAgICAgICAgICAgZXhwb3J0cy5Qcm9vZk9wLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVByb29mT3BzKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vcHMucHVzaChleHBvcnRzLlByb29mT3AuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wczogQXJyYXkuaXNBcnJheShvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3Qub3BzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0Lm9wcy5tYXAoKGUpID0+IGV4cG9ydHMuUHJvb2ZPcC5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGlmIChtZXNzYWdlLm9wcykge1xuICAgICAgICAgICAgb2JqLm9wcyA9IG1lc3NhZ2Uub3BzLm1hcCgoZSkgPT4gKGUgPyBleHBvcnRzLlByb29mT3AudG9KU09OKGUpIDogdW5kZWZpbmVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvYmoub3BzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHJvb2ZPcHMoKTtcbiAgICAgICAgbWVzc2FnZS5vcHMgPSAoKF9hID0gb2JqZWN0Lm9wcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoZSkgPT4gZXhwb3J0cy5Qcm9vZk9wLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xudmFyIGdsb2JhbFRoaXMgPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICB0aHJvdyBcIlVuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdFwiO1xufSkoKTtcbmNvbnN0IGF0b2IgPSBnbG9iYWxUaGlzLmF0b2IgfHxcbiAgICAoKGI2NCkgPT4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiNjQsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKFwiYmluYXJ5XCIpKTtcbmZ1bmN0aW9uIGJ5dGVzRnJvbUJhc2U2NChiNjQpIHtcbiAgICBjb25zdCBiaW4gPSBhdG9iKGI2NCk7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYmluLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5jb25zdCBidG9hID0gZ2xvYmFsVGhpcy5idG9hIHx8XG4gICAgKChiaW4pID0+IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYmluLCBcImJpbmFyeVwiKS50b1N0cmluZyhcImJhc2U2NFwiKSk7XG5mdW5jdGlvbiBiYXNlNjRGcm9tQnl0ZXMoYXJyKSB7XG4gICAgY29uc3QgYmluID0gW107XG4gICAgZm9yIChjb25zdCBieXRlIG9mIGFycikge1xuICAgICAgICBiaW4ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ0b2EoYmluLmpvaW4oXCJcIikpO1xufVxuZnVuY3Rpb24gbG9uZ1RvU3RyaW5nKGxvbmcpIHtcbiAgICByZXR1cm4gbG9uZy50b1N0cmluZygpO1xufVxuaWYgKG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyAhPT0gbG9uZ18xLmRlZmF1bHQpIHtcbiAgICBtaW5pbWFsXzEuZGVmYXVsdC51dGlsLkxvbmcgPSBsb25nXzEuZGVmYXVsdDtcbiAgICBtaW5pbWFsXzEuZGVmYXVsdC5jb25maWd1cmUoKTtcbn1cbmZ1bmN0aW9uIGlzU2V0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9vZi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/tendermint/crypto/proof.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/tendermint/types/types.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/tendermint/types/types.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TxProof = exports.BlockMeta = exports.LightBlock = exports.SignedHeader = exports.Proposal = exports.CommitSig = exports.Commit = exports.Vote = exports.Data = exports.Header = exports.BlockID = exports.Part = exports.PartSetHeader = exports.signedMsgTypeToJSON = exports.signedMsgTypeFromJSON = exports.SignedMsgType = exports.blockIDFlagToJSON = exports.blockIDFlagFromJSON = exports.BlockIDFlag = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nconst timestamp_1 = __webpack_require__(/*! ../../google/protobuf/timestamp */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/google/protobuf/timestamp.js\");\nconst proof_1 = __webpack_require__(/*! ../../tendermint/crypto/proof */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/tendermint/crypto/proof.js\");\nconst types_1 = __webpack_require__(/*! ../../tendermint/version/types */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/tendermint/version/types.js\");\nconst validator_1 = __webpack_require__(/*! ../../tendermint/types/validator */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/tendermint/types/validator.js\");\nexports.protobufPackage = \"tendermint.types\";\n/** BlockIdFlag indicates which BlcokID the signature is for */\nvar BlockIDFlag;\n(function (BlockIDFlag) {\n    BlockIDFlag[BlockIDFlag[\"BLOCK_ID_FLAG_UNKNOWN\"] = 0] = \"BLOCK_ID_FLAG_UNKNOWN\";\n    BlockIDFlag[BlockIDFlag[\"BLOCK_ID_FLAG_ABSENT\"] = 1] = \"BLOCK_ID_FLAG_ABSENT\";\n    BlockIDFlag[BlockIDFlag[\"BLOCK_ID_FLAG_COMMIT\"] = 2] = \"BLOCK_ID_FLAG_COMMIT\";\n    BlockIDFlag[BlockIDFlag[\"BLOCK_ID_FLAG_NIL\"] = 3] = \"BLOCK_ID_FLAG_NIL\";\n    BlockIDFlag[BlockIDFlag[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(BlockIDFlag = exports.BlockIDFlag || (exports.BlockIDFlag = {}));\nfunction blockIDFlagFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"BLOCK_ID_FLAG_UNKNOWN\":\n            return BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN;\n        case 1:\n        case \"BLOCK_ID_FLAG_ABSENT\":\n            return BlockIDFlag.BLOCK_ID_FLAG_ABSENT;\n        case 2:\n        case \"BLOCK_ID_FLAG_COMMIT\":\n            return BlockIDFlag.BLOCK_ID_FLAG_COMMIT;\n        case 3:\n        case \"BLOCK_ID_FLAG_NIL\":\n            return BlockIDFlag.BLOCK_ID_FLAG_NIL;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return BlockIDFlag.UNRECOGNIZED;\n    }\n}\nexports.blockIDFlagFromJSON = blockIDFlagFromJSON;\nfunction blockIDFlagToJSON(object) {\n    switch (object) {\n        case BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN:\n            return \"BLOCK_ID_FLAG_UNKNOWN\";\n        case BlockIDFlag.BLOCK_ID_FLAG_ABSENT:\n            return \"BLOCK_ID_FLAG_ABSENT\";\n        case BlockIDFlag.BLOCK_ID_FLAG_COMMIT:\n            return \"BLOCK_ID_FLAG_COMMIT\";\n        case BlockIDFlag.BLOCK_ID_FLAG_NIL:\n            return \"BLOCK_ID_FLAG_NIL\";\n        default:\n            return \"UNKNOWN\";\n    }\n}\nexports.blockIDFlagToJSON = blockIDFlagToJSON;\n/** SignedMsgType is a type of signed message in the consensus. */\nvar SignedMsgType;\n(function (SignedMsgType) {\n    SignedMsgType[SignedMsgType[\"SIGNED_MSG_TYPE_UNKNOWN\"] = 0] = \"SIGNED_MSG_TYPE_UNKNOWN\";\n    /** SIGNED_MSG_TYPE_PREVOTE - Votes */\n    SignedMsgType[SignedMsgType[\"SIGNED_MSG_TYPE_PREVOTE\"] = 1] = \"SIGNED_MSG_TYPE_PREVOTE\";\n    SignedMsgType[SignedMsgType[\"SIGNED_MSG_TYPE_PRECOMMIT\"] = 2] = \"SIGNED_MSG_TYPE_PRECOMMIT\";\n    /** SIGNED_MSG_TYPE_PROPOSAL - Proposals */\n    SignedMsgType[SignedMsgType[\"SIGNED_MSG_TYPE_PROPOSAL\"] = 32] = \"SIGNED_MSG_TYPE_PROPOSAL\";\n    SignedMsgType[SignedMsgType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(SignedMsgType = exports.SignedMsgType || (exports.SignedMsgType = {}));\nfunction signedMsgTypeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"SIGNED_MSG_TYPE_UNKNOWN\":\n            return SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN;\n        case 1:\n        case \"SIGNED_MSG_TYPE_PREVOTE\":\n            return SignedMsgType.SIGNED_MSG_TYPE_PREVOTE;\n        case 2:\n        case \"SIGNED_MSG_TYPE_PRECOMMIT\":\n            return SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT;\n        case 32:\n        case \"SIGNED_MSG_TYPE_PROPOSAL\":\n            return SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return SignedMsgType.UNRECOGNIZED;\n    }\n}\nexports.signedMsgTypeFromJSON = signedMsgTypeFromJSON;\nfunction signedMsgTypeToJSON(object) {\n    switch (object) {\n        case SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN:\n            return \"SIGNED_MSG_TYPE_UNKNOWN\";\n        case SignedMsgType.SIGNED_MSG_TYPE_PREVOTE:\n            return \"SIGNED_MSG_TYPE_PREVOTE\";\n        case SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT:\n            return \"SIGNED_MSG_TYPE_PRECOMMIT\";\n        case SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL:\n            return \"SIGNED_MSG_TYPE_PROPOSAL\";\n        default:\n            return \"UNKNOWN\";\n    }\n}\nexports.signedMsgTypeToJSON = signedMsgTypeToJSON;\nfunction createBasePartSetHeader() {\n    return { total: 0, hash: new Uint8Array() };\n}\nexports.PartSetHeader = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.total !== 0) {\n            writer.uint32(8).uint32(message.total);\n        }\n        if (message.hash.length !== 0) {\n            writer.uint32(18).bytes(message.hash);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePartSetHeader();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.total = reader.uint32();\n                    break;\n                case 2:\n                    message.hash = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            total: isSet(object.total) ? Number(object.total) : 0,\n            hash: isSet(object.hash)\n                ? bytesFromBase64(object.hash)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.total !== undefined && (obj.total = Math.round(message.total));\n        message.hash !== undefined &&\n            (obj.hash = base64FromBytes(message.hash !== undefined ? message.hash : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePartSetHeader();\n        message.total = (_a = object.total) !== null && _a !== void 0 ? _a : 0;\n        message.hash = (_b = object.hash) !== null && _b !== void 0 ? _b : new Uint8Array();\n        return message;\n    },\n};\nfunction createBasePart() {\n    return { index: 0, bytes: new Uint8Array(), proof: undefined };\n}\nexports.Part = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.index !== 0) {\n            writer.uint32(8).uint32(message.index);\n        }\n        if (message.bytes.length !== 0) {\n            writer.uint32(18).bytes(message.bytes);\n        }\n        if (message.proof !== undefined) {\n            proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePart();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.index = reader.uint32();\n                    break;\n                case 2:\n                    message.bytes = reader.bytes();\n                    break;\n                case 3:\n                    message.proof = proof_1.Proof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            index: isSet(object.index) ? Number(object.index) : 0,\n            bytes: isSet(object.bytes)\n                ? bytesFromBase64(object.bytes)\n                : new Uint8Array(),\n            proof: isSet(object.proof) ? proof_1.Proof.fromJSON(object.proof) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.index !== undefined && (obj.index = Math.round(message.index));\n        message.bytes !== undefined &&\n            (obj.bytes = base64FromBytes(message.bytes !== undefined ? message.bytes : new Uint8Array()));\n        message.proof !== undefined &&\n            (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePart();\n        message.index = (_a = object.index) !== null && _a !== void 0 ? _a : 0;\n        message.bytes = (_b = object.bytes) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.proof =\n            object.proof !== undefined && object.proof !== null\n                ? proof_1.Proof.fromPartial(object.proof)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseBlockID() {\n    return { hash: new Uint8Array(), partSetHeader: undefined };\n}\nexports.BlockID = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.hash.length !== 0) {\n            writer.uint32(10).bytes(message.hash);\n        }\n        if (message.partSetHeader !== undefined) {\n            exports.PartSetHeader.encode(message.partSetHeader, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseBlockID();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.hash = reader.bytes();\n                    break;\n                case 2:\n                    message.partSetHeader = exports.PartSetHeader.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            hash: isSet(object.hash)\n                ? bytesFromBase64(object.hash)\n                : new Uint8Array(),\n            partSetHeader: isSet(object.partSetHeader)\n                ? exports.PartSetHeader.fromJSON(object.partSetHeader)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.hash !== undefined &&\n            (obj.hash = base64FromBytes(message.hash !== undefined ? message.hash : new Uint8Array()));\n        message.partSetHeader !== undefined &&\n            (obj.partSetHeader = message.partSetHeader\n                ? exports.PartSetHeader.toJSON(message.partSetHeader)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseBlockID();\n        message.hash = (_a = object.hash) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.partSetHeader =\n            object.partSetHeader !== undefined && object.partSetHeader !== null\n                ? exports.PartSetHeader.fromPartial(object.partSetHeader)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseHeader() {\n    return {\n        version: undefined,\n        chainId: \"\",\n        height: \"0\",\n        time: undefined,\n        lastBlockId: undefined,\n        lastCommitHash: new Uint8Array(),\n        dataHash: new Uint8Array(),\n        validatorsHash: new Uint8Array(),\n        nextValidatorsHash: new Uint8Array(),\n        consensusHash: new Uint8Array(),\n        appHash: new Uint8Array(),\n        lastResultsHash: new Uint8Array(),\n        evidenceHash: new Uint8Array(),\n        proposerAddress: new Uint8Array(),\n    };\n}\nexports.Header = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.version !== undefined) {\n            types_1.Consensus.encode(message.version, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.chainId !== \"\") {\n            writer.uint32(18).string(message.chainId);\n        }\n        if (message.height !== \"0\") {\n            writer.uint32(24).int64(message.height);\n        }\n        if (message.time !== undefined) {\n            timestamp_1.Timestamp.encode(toTimestamp(message.time), writer.uint32(34).fork()).ldelim();\n        }\n        if (message.lastBlockId !== undefined) {\n            exports.BlockID.encode(message.lastBlockId, writer.uint32(42).fork()).ldelim();\n        }\n        if (message.lastCommitHash.length !== 0) {\n            writer.uint32(50).bytes(message.lastCommitHash);\n        }\n        if (message.dataHash.length !== 0) {\n            writer.uint32(58).bytes(message.dataHash);\n        }\n        if (message.validatorsHash.length !== 0) {\n            writer.uint32(66).bytes(message.validatorsHash);\n        }\n        if (message.nextValidatorsHash.length !== 0) {\n            writer.uint32(74).bytes(message.nextValidatorsHash);\n        }\n        if (message.consensusHash.length !== 0) {\n            writer.uint32(82).bytes(message.consensusHash);\n        }\n        if (message.appHash.length !== 0) {\n            writer.uint32(90).bytes(message.appHash);\n        }\n        if (message.lastResultsHash.length !== 0) {\n            writer.uint32(98).bytes(message.lastResultsHash);\n        }\n        if (message.evidenceHash.length !== 0) {\n            writer.uint32(106).bytes(message.evidenceHash);\n        }\n        if (message.proposerAddress.length !== 0) {\n            writer.uint32(114).bytes(message.proposerAddress);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseHeader();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.version = types_1.Consensus.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.chainId = reader.string();\n                    break;\n                case 3:\n                    message.height = longToString(reader.int64());\n                    break;\n                case 4:\n                    message.time = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n                    break;\n                case 5:\n                    message.lastBlockId = exports.BlockID.decode(reader, reader.uint32());\n                    break;\n                case 6:\n                    message.lastCommitHash = reader.bytes();\n                    break;\n                case 7:\n                    message.dataHash = reader.bytes();\n                    break;\n                case 8:\n                    message.validatorsHash = reader.bytes();\n                    break;\n                case 9:\n                    message.nextValidatorsHash = reader.bytes();\n                    break;\n                case 10:\n                    message.consensusHash = reader.bytes();\n                    break;\n                case 11:\n                    message.appHash = reader.bytes();\n                    break;\n                case 12:\n                    message.lastResultsHash = reader.bytes();\n                    break;\n                case 13:\n                    message.evidenceHash = reader.bytes();\n                    break;\n                case 14:\n                    message.proposerAddress = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            version: isSet(object.version)\n                ? types_1.Consensus.fromJSON(object.version)\n                : undefined,\n            chainId: isSet(object.chainId) ? String(object.chainId) : \"\",\n            height: isSet(object.height) ? String(object.height) : \"0\",\n            time: isSet(object.time) ? fromJsonTimestamp(object.time) : undefined,\n            lastBlockId: isSet(object.lastBlockId)\n                ? exports.BlockID.fromJSON(object.lastBlockId)\n                : undefined,\n            lastCommitHash: isSet(object.lastCommitHash)\n                ? bytesFromBase64(object.lastCommitHash)\n                : new Uint8Array(),\n            dataHash: isSet(object.dataHash)\n                ? bytesFromBase64(object.dataHash)\n                : new Uint8Array(),\n            validatorsHash: isSet(object.validatorsHash)\n                ? bytesFromBase64(object.validatorsHash)\n                : new Uint8Array(),\n            nextValidatorsHash: isSet(object.nextValidatorsHash)\n                ? bytesFromBase64(object.nextValidatorsHash)\n                : new Uint8Array(),\n            consensusHash: isSet(object.consensusHash)\n                ? bytesFromBase64(object.consensusHash)\n                : new Uint8Array(),\n            appHash: isSet(object.appHash)\n                ? bytesFromBase64(object.appHash)\n                : new Uint8Array(),\n            lastResultsHash: isSet(object.lastResultsHash)\n                ? bytesFromBase64(object.lastResultsHash)\n                : new Uint8Array(),\n            evidenceHash: isSet(object.evidenceHash)\n                ? bytesFromBase64(object.evidenceHash)\n                : new Uint8Array(),\n            proposerAddress: isSet(object.proposerAddress)\n                ? bytesFromBase64(object.proposerAddress)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.version !== undefined &&\n            (obj.version = message.version\n                ? types_1.Consensus.toJSON(message.version)\n                : undefined);\n        message.chainId !== undefined && (obj.chainId = message.chainId);\n        message.height !== undefined && (obj.height = message.height);\n        message.time !== undefined && (obj.time = message.time.toISOString());\n        message.lastBlockId !== undefined &&\n            (obj.lastBlockId = message.lastBlockId\n                ? exports.BlockID.toJSON(message.lastBlockId)\n                : undefined);\n        message.lastCommitHash !== undefined &&\n            (obj.lastCommitHash = base64FromBytes(message.lastCommitHash !== undefined\n                ? message.lastCommitHash\n                : new Uint8Array()));\n        message.dataHash !== undefined &&\n            (obj.dataHash = base64FromBytes(message.dataHash !== undefined ? message.dataHash : new Uint8Array()));\n        message.validatorsHash !== undefined &&\n            (obj.validatorsHash = base64FromBytes(message.validatorsHash !== undefined\n                ? message.validatorsHash\n                : new Uint8Array()));\n        message.nextValidatorsHash !== undefined &&\n            (obj.nextValidatorsHash = base64FromBytes(message.nextValidatorsHash !== undefined\n                ? message.nextValidatorsHash\n                : new Uint8Array()));\n        message.consensusHash !== undefined &&\n            (obj.consensusHash = base64FromBytes(message.consensusHash !== undefined\n                ? message.consensusHash\n                : new Uint8Array()));\n        message.appHash !== undefined &&\n            (obj.appHash = base64FromBytes(message.appHash !== undefined ? message.appHash : new Uint8Array()));\n        message.lastResultsHash !== undefined &&\n            (obj.lastResultsHash = base64FromBytes(message.lastResultsHash !== undefined\n                ? message.lastResultsHash\n                : new Uint8Array()));\n        message.evidenceHash !== undefined &&\n            (obj.evidenceHash = base64FromBytes(message.evidenceHash !== undefined\n                ? message.evidenceHash\n                : new Uint8Array()));\n        message.proposerAddress !== undefined &&\n            (obj.proposerAddress = base64FromBytes(message.proposerAddress !== undefined\n                ? message.proposerAddress\n                : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        const message = createBaseHeader();\n        message.version =\n            object.version !== undefined && object.version !== null\n                ? types_1.Consensus.fromPartial(object.version)\n                : undefined;\n        message.chainId = (_a = object.chainId) !== null && _a !== void 0 ? _a : \"\";\n        message.height = (_b = object.height) !== null && _b !== void 0 ? _b : \"0\";\n        message.time = (_c = object.time) !== null && _c !== void 0 ? _c : undefined;\n        message.lastBlockId =\n            object.lastBlockId !== undefined && object.lastBlockId !== null\n                ? exports.BlockID.fromPartial(object.lastBlockId)\n                : undefined;\n        message.lastCommitHash = (_d = object.lastCommitHash) !== null && _d !== void 0 ? _d : new Uint8Array();\n        message.dataHash = (_e = object.dataHash) !== null && _e !== void 0 ? _e : new Uint8Array();\n        message.validatorsHash = (_f = object.validatorsHash) !== null && _f !== void 0 ? _f : new Uint8Array();\n        message.nextValidatorsHash = (_g = object.nextValidatorsHash) !== null && _g !== void 0 ? _g : new Uint8Array();\n        message.consensusHash = (_h = object.consensusHash) !== null && _h !== void 0 ? _h : new Uint8Array();\n        message.appHash = (_j = object.appHash) !== null && _j !== void 0 ? _j : new Uint8Array();\n        message.lastResultsHash = (_k = object.lastResultsHash) !== null && _k !== void 0 ? _k : new Uint8Array();\n        message.evidenceHash = (_l = object.evidenceHash) !== null && _l !== void 0 ? _l : new Uint8Array();\n        message.proposerAddress = (_m = object.proposerAddress) !== null && _m !== void 0 ? _m : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseData() {\n    return { txs: [] };\n}\nexports.Data = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.txs) {\n            writer.uint32(10).bytes(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseData();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.txs.push(reader.bytes());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            txs: Array.isArray(object === null || object === void 0 ? void 0 : object.txs)\n                ? object.txs.map((e) => bytesFromBase64(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.txs) {\n            obj.txs = message.txs.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));\n        }\n        else {\n            obj.txs = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseData();\n        message.txs = ((_a = object.txs) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBaseVote() {\n    return {\n        type: 0,\n        height: \"0\",\n        round: 0,\n        blockId: undefined,\n        timestamp: undefined,\n        validatorAddress: new Uint8Array(),\n        validatorIndex: 0,\n        signature: new Uint8Array(),\n    };\n}\nexports.Vote = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.type !== 0) {\n            writer.uint32(8).int32(message.type);\n        }\n        if (message.height !== \"0\") {\n            writer.uint32(16).int64(message.height);\n        }\n        if (message.round !== 0) {\n            writer.uint32(24).int32(message.round);\n        }\n        if (message.blockId !== undefined) {\n            exports.BlockID.encode(message.blockId, writer.uint32(34).fork()).ldelim();\n        }\n        if (message.timestamp !== undefined) {\n            timestamp_1.Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(42).fork()).ldelim();\n        }\n        if (message.validatorAddress.length !== 0) {\n            writer.uint32(50).bytes(message.validatorAddress);\n        }\n        if (message.validatorIndex !== 0) {\n            writer.uint32(56).int32(message.validatorIndex);\n        }\n        if (message.signature.length !== 0) {\n            writer.uint32(66).bytes(message.signature);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseVote();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.type = reader.int32();\n                    break;\n                case 2:\n                    message.height = longToString(reader.int64());\n                    break;\n                case 3:\n                    message.round = reader.int32();\n                    break;\n                case 4:\n                    message.blockId = exports.BlockID.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.timestamp = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n                    break;\n                case 6:\n                    message.validatorAddress = reader.bytes();\n                    break;\n                case 7:\n                    message.validatorIndex = reader.int32();\n                    break;\n                case 8:\n                    message.signature = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            type: isSet(object.type) ? signedMsgTypeFromJSON(object.type) : 0,\n            height: isSet(object.height) ? String(object.height) : \"0\",\n            round: isSet(object.round) ? Number(object.round) : 0,\n            blockId: isSet(object.blockId)\n                ? exports.BlockID.fromJSON(object.blockId)\n                : undefined,\n            timestamp: isSet(object.timestamp)\n                ? fromJsonTimestamp(object.timestamp)\n                : undefined,\n            validatorAddress: isSet(object.validatorAddress)\n                ? bytesFromBase64(object.validatorAddress)\n                : new Uint8Array(),\n            validatorIndex: isSet(object.validatorIndex)\n                ? Number(object.validatorIndex)\n                : 0,\n            signature: isSet(object.signature)\n                ? bytesFromBase64(object.signature)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.type !== undefined &&\n            (obj.type = signedMsgTypeToJSON(message.type));\n        message.height !== undefined && (obj.height = message.height);\n        message.round !== undefined && (obj.round = Math.round(message.round));\n        message.blockId !== undefined &&\n            (obj.blockId = message.blockId\n                ? exports.BlockID.toJSON(message.blockId)\n                : undefined);\n        message.timestamp !== undefined &&\n            (obj.timestamp = message.timestamp.toISOString());\n        message.validatorAddress !== undefined &&\n            (obj.validatorAddress = base64FromBytes(message.validatorAddress !== undefined\n                ? message.validatorAddress\n                : new Uint8Array()));\n        message.validatorIndex !== undefined &&\n            (obj.validatorIndex = Math.round(message.validatorIndex));\n        message.signature !== undefined &&\n            (obj.signature = base64FromBytes(message.signature !== undefined ? message.signature : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        const message = createBaseVote();\n        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;\n        message.height = (_b = object.height) !== null && _b !== void 0 ? _b : \"0\";\n        message.round = (_c = object.round) !== null && _c !== void 0 ? _c : 0;\n        message.blockId =\n            object.blockId !== undefined && object.blockId !== null\n                ? exports.BlockID.fromPartial(object.blockId)\n                : undefined;\n        message.timestamp = (_d = object.timestamp) !== null && _d !== void 0 ? _d : undefined;\n        message.validatorAddress = (_e = object.validatorAddress) !== null && _e !== void 0 ? _e : new Uint8Array();\n        message.validatorIndex = (_f = object.validatorIndex) !== null && _f !== void 0 ? _f : 0;\n        message.signature = (_g = object.signature) !== null && _g !== void 0 ? _g : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseCommit() {\n    return { height: \"0\", round: 0, blockId: undefined, signatures: [] };\n}\nexports.Commit = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.height !== \"0\") {\n            writer.uint32(8).int64(message.height);\n        }\n        if (message.round !== 0) {\n            writer.uint32(16).int32(message.round);\n        }\n        if (message.blockId !== undefined) {\n            exports.BlockID.encode(message.blockId, writer.uint32(26).fork()).ldelim();\n        }\n        for (const v of message.signatures) {\n            exports.CommitSig.encode(v, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCommit();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.height = longToString(reader.int64());\n                    break;\n                case 2:\n                    message.round = reader.int32();\n                    break;\n                case 3:\n                    message.blockId = exports.BlockID.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.signatures.push(exports.CommitSig.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            height: isSet(object.height) ? String(object.height) : \"0\",\n            round: isSet(object.round) ? Number(object.round) : 0,\n            blockId: isSet(object.blockId)\n                ? exports.BlockID.fromJSON(object.blockId)\n                : undefined,\n            signatures: Array.isArray(object === null || object === void 0 ? void 0 : object.signatures)\n                ? object.signatures.map((e) => exports.CommitSig.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.height !== undefined && (obj.height = message.height);\n        message.round !== undefined && (obj.round = Math.round(message.round));\n        message.blockId !== undefined &&\n            (obj.blockId = message.blockId\n                ? exports.BlockID.toJSON(message.blockId)\n                : undefined);\n        if (message.signatures) {\n            obj.signatures = message.signatures.map((e) => e ? exports.CommitSig.toJSON(e) : undefined);\n        }\n        else {\n            obj.signatures = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseCommit();\n        message.height = (_a = object.height) !== null && _a !== void 0 ? _a : \"0\";\n        message.round = (_b = object.round) !== null && _b !== void 0 ? _b : 0;\n        message.blockId =\n            object.blockId !== undefined && object.blockId !== null\n                ? exports.BlockID.fromPartial(object.blockId)\n                : undefined;\n        message.signatures =\n            ((_c = object.signatures) === null || _c === void 0 ? void 0 : _c.map((e) => exports.CommitSig.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseCommitSig() {\n    return {\n        blockIdFlag: 0,\n        validatorAddress: new Uint8Array(),\n        timestamp: undefined,\n        signature: new Uint8Array(),\n    };\n}\nexports.CommitSig = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.blockIdFlag !== 0) {\n            writer.uint32(8).int32(message.blockIdFlag);\n        }\n        if (message.validatorAddress.length !== 0) {\n            writer.uint32(18).bytes(message.validatorAddress);\n        }\n        if (message.timestamp !== undefined) {\n            timestamp_1.Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).ldelim();\n        }\n        if (message.signature.length !== 0) {\n            writer.uint32(34).bytes(message.signature);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCommitSig();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.blockIdFlag = reader.int32();\n                    break;\n                case 2:\n                    message.validatorAddress = reader.bytes();\n                    break;\n                case 3:\n                    message.timestamp = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n                    break;\n                case 4:\n                    message.signature = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            blockIdFlag: isSet(object.blockIdFlag)\n                ? blockIDFlagFromJSON(object.blockIdFlag)\n                : 0,\n            validatorAddress: isSet(object.validatorAddress)\n                ? bytesFromBase64(object.validatorAddress)\n                : new Uint8Array(),\n            timestamp: isSet(object.timestamp)\n                ? fromJsonTimestamp(object.timestamp)\n                : undefined,\n            signature: isSet(object.signature)\n                ? bytesFromBase64(object.signature)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.blockIdFlag !== undefined &&\n            (obj.blockIdFlag = blockIDFlagToJSON(message.blockIdFlag));\n        message.validatorAddress !== undefined &&\n            (obj.validatorAddress = base64FromBytes(message.validatorAddress !== undefined\n                ? message.validatorAddress\n                : new Uint8Array()));\n        message.timestamp !== undefined &&\n            (obj.timestamp = message.timestamp.toISOString());\n        message.signature !== undefined &&\n            (obj.signature = base64FromBytes(message.signature !== undefined ? message.signature : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseCommitSig();\n        message.blockIdFlag = (_a = object.blockIdFlag) !== null && _a !== void 0 ? _a : 0;\n        message.validatorAddress = (_b = object.validatorAddress) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.timestamp = (_c = object.timestamp) !== null && _c !== void 0 ? _c : undefined;\n        message.signature = (_d = object.signature) !== null && _d !== void 0 ? _d : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseProposal() {\n    return {\n        type: 0,\n        height: \"0\",\n        round: 0,\n        polRound: 0,\n        blockId: undefined,\n        timestamp: undefined,\n        signature: new Uint8Array(),\n    };\n}\nexports.Proposal = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.type !== 0) {\n            writer.uint32(8).int32(message.type);\n        }\n        if (message.height !== \"0\") {\n            writer.uint32(16).int64(message.height);\n        }\n        if (message.round !== 0) {\n            writer.uint32(24).int32(message.round);\n        }\n        if (message.polRound !== 0) {\n            writer.uint32(32).int32(message.polRound);\n        }\n        if (message.blockId !== undefined) {\n            exports.BlockID.encode(message.blockId, writer.uint32(42).fork()).ldelim();\n        }\n        if (message.timestamp !== undefined) {\n            timestamp_1.Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(50).fork()).ldelim();\n        }\n        if (message.signature.length !== 0) {\n            writer.uint32(58).bytes(message.signature);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseProposal();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.type = reader.int32();\n                    break;\n                case 2:\n                    message.height = longToString(reader.int64());\n                    break;\n                case 3:\n                    message.round = reader.int32();\n                    break;\n                case 4:\n                    message.polRound = reader.int32();\n                    break;\n                case 5:\n                    message.blockId = exports.BlockID.decode(reader, reader.uint32());\n                    break;\n                case 6:\n                    message.timestamp = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n                    break;\n                case 7:\n                    message.signature = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            type: isSet(object.type) ? signedMsgTypeFromJSON(object.type) : 0,\n            height: isSet(object.height) ? String(object.height) : \"0\",\n            round: isSet(object.round) ? Number(object.round) : 0,\n            polRound: isSet(object.polRound) ? Number(object.polRound) : 0,\n            blockId: isSet(object.blockId)\n                ? exports.BlockID.fromJSON(object.blockId)\n                : undefined,\n            timestamp: isSet(object.timestamp)\n                ? fromJsonTimestamp(object.timestamp)\n                : undefined,\n            signature: isSet(object.signature)\n                ? bytesFromBase64(object.signature)\n                : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.type !== undefined &&\n            (obj.type = signedMsgTypeToJSON(message.type));\n        message.height !== undefined && (obj.height = message.height);\n        message.round !== undefined && (obj.round = Math.round(message.round));\n        message.polRound !== undefined &&\n            (obj.polRound = Math.round(message.polRound));\n        message.blockId !== undefined &&\n            (obj.blockId = message.blockId\n                ? exports.BlockID.toJSON(message.blockId)\n                : undefined);\n        message.timestamp !== undefined &&\n            (obj.timestamp = message.timestamp.toISOString());\n        message.signature !== undefined &&\n            (obj.signature = base64FromBytes(message.signature !== undefined ? message.signature : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f;\n        const message = createBaseProposal();\n        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;\n        message.height = (_b = object.height) !== null && _b !== void 0 ? _b : \"0\";\n        message.round = (_c = object.round) !== null && _c !== void 0 ? _c : 0;\n        message.polRound = (_d = object.polRound) !== null && _d !== void 0 ? _d : 0;\n        message.blockId =\n            object.blockId !== undefined && object.blockId !== null\n                ? exports.BlockID.fromPartial(object.blockId)\n                : undefined;\n        message.timestamp = (_e = object.timestamp) !== null && _e !== void 0 ? _e : undefined;\n        message.signature = (_f = object.signature) !== null && _f !== void 0 ? _f : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseSignedHeader() {\n    return { header: undefined, commit: undefined };\n}\nexports.SignedHeader = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.header !== undefined) {\n            exports.Header.encode(message.header, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.commit !== undefined) {\n            exports.Commit.encode(message.commit, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignedHeader();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.header = exports.Header.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.commit = exports.Commit.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            header: isSet(object.header) ? exports.Header.fromJSON(object.header) : undefined,\n            commit: isSet(object.commit) ? exports.Commit.fromJSON(object.commit) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.header !== undefined &&\n            (obj.header = message.header ? exports.Header.toJSON(message.header) : undefined);\n        message.commit !== undefined &&\n            (obj.commit = message.commit ? exports.Commit.toJSON(message.commit) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseSignedHeader();\n        message.header =\n            object.header !== undefined && object.header !== null\n                ? exports.Header.fromPartial(object.header)\n                : undefined;\n        message.commit =\n            object.commit !== undefined && object.commit !== null\n                ? exports.Commit.fromPartial(object.commit)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseLightBlock() {\n    return { signedHeader: undefined, validatorSet: undefined };\n}\nexports.LightBlock = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.signedHeader !== undefined) {\n            exports.SignedHeader.encode(message.signedHeader, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.validatorSet !== undefined) {\n            validator_1.ValidatorSet.encode(message.validatorSet, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseLightBlock();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.signedHeader = exports.SignedHeader.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.validatorSet = validator_1.ValidatorSet.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            signedHeader: isSet(object.signedHeader)\n                ? exports.SignedHeader.fromJSON(object.signedHeader)\n                : undefined,\n            validatorSet: isSet(object.validatorSet)\n                ? validator_1.ValidatorSet.fromJSON(object.validatorSet)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.signedHeader !== undefined &&\n            (obj.signedHeader = message.signedHeader\n                ? exports.SignedHeader.toJSON(message.signedHeader)\n                : undefined);\n        message.validatorSet !== undefined &&\n            (obj.validatorSet = message.validatorSet\n                ? validator_1.ValidatorSet.toJSON(message.validatorSet)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseLightBlock();\n        message.signedHeader =\n            object.signedHeader !== undefined && object.signedHeader !== null\n                ? exports.SignedHeader.fromPartial(object.signedHeader)\n                : undefined;\n        message.validatorSet =\n            object.validatorSet !== undefined && object.validatorSet !== null\n                ? validator_1.ValidatorSet.fromPartial(object.validatorSet)\n                : undefined;\n        return message;\n    },\n};\nfunction createBaseBlockMeta() {\n    return { blockId: undefined, blockSize: \"0\", header: undefined, numTxs: \"0\" };\n}\nexports.BlockMeta = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.blockId !== undefined) {\n            exports.BlockID.encode(message.blockId, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.blockSize !== \"0\") {\n            writer.uint32(16).int64(message.blockSize);\n        }\n        if (message.header !== undefined) {\n            exports.Header.encode(message.header, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.numTxs !== \"0\") {\n            writer.uint32(32).int64(message.numTxs);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseBlockMeta();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.blockId = exports.BlockID.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.blockSize = longToString(reader.int64());\n                    break;\n                case 3:\n                    message.header = exports.Header.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.numTxs = longToString(reader.int64());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            blockId: isSet(object.blockId)\n                ? exports.BlockID.fromJSON(object.blockId)\n                : undefined,\n            blockSize: isSet(object.blockSize) ? String(object.blockSize) : \"0\",\n            header: isSet(object.header) ? exports.Header.fromJSON(object.header) : undefined,\n            numTxs: isSet(object.numTxs) ? String(object.numTxs) : \"0\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.blockId !== undefined &&\n            (obj.blockId = message.blockId\n                ? exports.BlockID.toJSON(message.blockId)\n                : undefined);\n        message.blockSize !== undefined && (obj.blockSize = message.blockSize);\n        message.header !== undefined &&\n            (obj.header = message.header ? exports.Header.toJSON(message.header) : undefined);\n        message.numTxs !== undefined && (obj.numTxs = message.numTxs);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseBlockMeta();\n        message.blockId =\n            object.blockId !== undefined && object.blockId !== null\n                ? exports.BlockID.fromPartial(object.blockId)\n                : undefined;\n        message.blockSize = (_a = object.blockSize) !== null && _a !== void 0 ? _a : \"0\";\n        message.header =\n            object.header !== undefined && object.header !== null\n                ? exports.Header.fromPartial(object.header)\n                : undefined;\n        message.numTxs = (_b = object.numTxs) !== null && _b !== void 0 ? _b : \"0\";\n        return message;\n    },\n};\nfunction createBaseTxProof() {\n    return {\n        rootHash: new Uint8Array(),\n        data: new Uint8Array(),\n        proof: undefined,\n    };\n}\nexports.TxProof = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.rootHash.length !== 0) {\n            writer.uint32(10).bytes(message.rootHash);\n        }\n        if (message.data.length !== 0) {\n            writer.uint32(18).bytes(message.data);\n        }\n        if (message.proof !== undefined) {\n            proof_1.Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTxProof();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.rootHash = reader.bytes();\n                    break;\n                case 2:\n                    message.data = reader.bytes();\n                    break;\n                case 3:\n                    message.proof = proof_1.Proof.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            rootHash: isSet(object.rootHash)\n                ? bytesFromBase64(object.rootHash)\n                : new Uint8Array(),\n            data: isSet(object.data)\n                ? bytesFromBase64(object.data)\n                : new Uint8Array(),\n            proof: isSet(object.proof) ? proof_1.Proof.fromJSON(object.proof) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.rootHash !== undefined &&\n            (obj.rootHash = base64FromBytes(message.rootHash !== undefined ? message.rootHash : new Uint8Array()));\n        message.data !== undefined &&\n            (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n        message.proof !== undefined &&\n            (obj.proof = message.proof ? proof_1.Proof.toJSON(message.proof) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseTxProof();\n        message.rootHash = (_a = object.rootHash) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.data = (_b = object.data) !== null && _b !== void 0 ? _b : new Uint8Array();\n        message.proof =\n            object.proof !== undefined && object.proof !== null\n                ? proof_1.Proof.fromPartial(object.proof)\n                : undefined;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob ||\n    ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa ||\n    ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (const byte of arr) {\n        bin.push(String.fromCharCode(byte));\n    }\n    return btoa(bin.join(\"\"));\n}\nfunction toTimestamp(date) {\n    const seconds = Math.trunc(date.getTime() / 1000).toString();\n    const nanos = (date.getTime() % 1000) * 1000000;\n    return { seconds, nanos };\n}\nfunction fromTimestamp(t) {\n    let millis = Number(t.seconds) * 1000;\n    millis += t.nanos / 1000000;\n    return new Date(millis);\n}\nfunction fromJsonTimestamp(o) {\n    if (o instanceof Date) {\n        return o;\n    }\n    else if (typeof o === \"string\") {\n        return new Date(o);\n    }\n    else {\n        return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));\n    }\n}\nfunction longToString(long) {\n    return long.toString();\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy90ZW5kZXJtaW50L3R5cGVzL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxHQUFHLGlCQUFpQixHQUFHLGtCQUFrQixHQUFHLG9CQUFvQixHQUFHLGdCQUFnQixHQUFHLGlCQUFpQixHQUFHLGNBQWMsR0FBRyxZQUFZLEdBQUcsWUFBWSxHQUFHLGNBQWMsR0FBRyxlQUFlLEdBQUcsWUFBWSxHQUFHLHFCQUFxQixHQUFHLDJCQUEyQixHQUFHLDZCQUE2QixHQUFHLHFCQUFxQixHQUFHLHlCQUF5QixHQUFHLDJCQUEyQixHQUFHLG1CQUFtQixHQUFHLHVCQUF1QjtBQUMvYTtBQUNBLCtCQUErQixtQkFBTyxDQUFDLG1EQUFNO0FBQzdDLGtDQUFrQyxtQkFBTyxDQUFDLHNFQUFvQjtBQUM5RCxvQkFBb0IsbUJBQU8sQ0FBQyxvSEFBaUM7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMsZ0hBQStCO0FBQ3ZELGdCQUFnQixtQkFBTyxDQUFDLGtIQUFnQztBQUN4RCxvQkFBb0IsbUJBQU8sQ0FBQyxzSEFBa0M7QUFDOUQsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QyxtQkFBbUIsS0FBSztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QyxxQkFBcUIsS0FBSztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L3Byb3RvLXR5cGVzL3RlbmRlcm1pbnQvdHlwZXMvdHlwZXMuanM/NTNlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHhQcm9vZiA9IGV4cG9ydHMuQmxvY2tNZXRhID0gZXhwb3J0cy5MaWdodEJsb2NrID0gZXhwb3J0cy5TaWduZWRIZWFkZXIgPSBleHBvcnRzLlByb3Bvc2FsID0gZXhwb3J0cy5Db21taXRTaWcgPSBleHBvcnRzLkNvbW1pdCA9IGV4cG9ydHMuVm90ZSA9IGV4cG9ydHMuRGF0YSA9IGV4cG9ydHMuSGVhZGVyID0gZXhwb3J0cy5CbG9ja0lEID0gZXhwb3J0cy5QYXJ0ID0gZXhwb3J0cy5QYXJ0U2V0SGVhZGVyID0gZXhwb3J0cy5zaWduZWRNc2dUeXBlVG9KU09OID0gZXhwb3J0cy5zaWduZWRNc2dUeXBlRnJvbUpTT04gPSBleHBvcnRzLlNpZ25lZE1zZ1R5cGUgPSBleHBvcnRzLmJsb2NrSURGbGFnVG9KU09OID0gZXhwb3J0cy5ibG9ja0lERmxhZ0Zyb21KU09OID0gZXhwb3J0cy5CbG9ja0lERmxhZyA9IGV4cG9ydHMucHJvdG9idWZQYWNrYWdlID0gdm9pZCAwO1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmNvbnN0IGxvbmdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9uZ1wiKSk7XG5jb25zdCBtaW5pbWFsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3RvYnVmanMvbWluaW1hbFwiKSk7XG5jb25zdCB0aW1lc3RhbXBfMSA9IHJlcXVpcmUoXCIuLi8uLi9nb29nbGUvcHJvdG9idWYvdGltZXN0YW1wXCIpO1xuY29uc3QgcHJvb2ZfMSA9IHJlcXVpcmUoXCIuLi8uLi90ZW5kZXJtaW50L2NyeXB0by9wcm9vZlwiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vLi4vdGVuZGVybWludC92ZXJzaW9uL3R5cGVzXCIpO1xuY29uc3QgdmFsaWRhdG9yXzEgPSByZXF1aXJlKFwiLi4vLi4vdGVuZGVybWludC90eXBlcy92YWxpZGF0b3JcIik7XG5leHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IFwidGVuZGVybWludC50eXBlc1wiO1xuLyoqIEJsb2NrSWRGbGFnIGluZGljYXRlcyB3aGljaCBCbGNva0lEIHRoZSBzaWduYXR1cmUgaXMgZm9yICovXG52YXIgQmxvY2tJREZsYWc7XG4oZnVuY3Rpb24gKEJsb2NrSURGbGFnKSB7XG4gICAgQmxvY2tJREZsYWdbQmxvY2tJREZsYWdbXCJCTE9DS19JRF9GTEFHX1VOS05PV05cIl0gPSAwXSA9IFwiQkxPQ0tfSURfRkxBR19VTktOT1dOXCI7XG4gICAgQmxvY2tJREZsYWdbQmxvY2tJREZsYWdbXCJCTE9DS19JRF9GTEFHX0FCU0VOVFwiXSA9IDFdID0gXCJCTE9DS19JRF9GTEFHX0FCU0VOVFwiO1xuICAgIEJsb2NrSURGbGFnW0Jsb2NrSURGbGFnW1wiQkxPQ0tfSURfRkxBR19DT01NSVRcIl0gPSAyXSA9IFwiQkxPQ0tfSURfRkxBR19DT01NSVRcIjtcbiAgICBCbG9ja0lERmxhZ1tCbG9ja0lERmxhZ1tcIkJMT0NLX0lEX0ZMQUdfTklMXCJdID0gM10gPSBcIkJMT0NLX0lEX0ZMQUdfTklMXCI7XG4gICAgQmxvY2tJREZsYWdbQmxvY2tJREZsYWdbXCJVTlJFQ09HTklaRURcIl0gPSAtMV0gPSBcIlVOUkVDT0dOSVpFRFwiO1xufSkoQmxvY2tJREZsYWcgPSBleHBvcnRzLkJsb2NrSURGbGFnIHx8IChleHBvcnRzLkJsb2NrSURGbGFnID0ge30pKTtcbmZ1bmN0aW9uIGJsb2NrSURGbGFnRnJvbUpTT04ob2JqZWN0KSB7XG4gICAgc3dpdGNoIChvYmplY3QpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIFwiQkxPQ0tfSURfRkxBR19VTktOT1dOXCI6XG4gICAgICAgICAgICByZXR1cm4gQmxvY2tJREZsYWcuQkxPQ0tfSURfRkxBR19VTktOT1dOO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgIGNhc2UgXCJCTE9DS19JRF9GTEFHX0FCU0VOVFwiOlxuICAgICAgICAgICAgcmV0dXJuIEJsb2NrSURGbGFnLkJMT0NLX0lEX0ZMQUdfQUJTRU5UO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgXCJCTE9DS19JRF9GTEFHX0NPTU1JVFwiOlxuICAgICAgICAgICAgcmV0dXJuIEJsb2NrSURGbGFnLkJMT0NLX0lEX0ZMQUdfQ09NTUlUO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGNhc2UgXCJCTE9DS19JRF9GTEFHX05JTFwiOlxuICAgICAgICAgICAgcmV0dXJuIEJsb2NrSURGbGFnLkJMT0NLX0lEX0ZMQUdfTklMO1xuICAgICAgICBjYXNlIC0xOlxuICAgICAgICBjYXNlIFwiVU5SRUNPR05JWkVEXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gQmxvY2tJREZsYWcuVU5SRUNPR05JWkVEO1xuICAgIH1cbn1cbmV4cG9ydHMuYmxvY2tJREZsYWdGcm9tSlNPTiA9IGJsb2NrSURGbGFnRnJvbUpTT047XG5mdW5jdGlvbiBibG9ja0lERmxhZ1RvSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIEJsb2NrSURGbGFnLkJMT0NLX0lEX0ZMQUdfVU5LTk9XTjpcbiAgICAgICAgICAgIHJldHVybiBcIkJMT0NLX0lEX0ZMQUdfVU5LTk9XTlwiO1xuICAgICAgICBjYXNlIEJsb2NrSURGbGFnLkJMT0NLX0lEX0ZMQUdfQUJTRU5UOlxuICAgICAgICAgICAgcmV0dXJuIFwiQkxPQ0tfSURfRkxBR19BQlNFTlRcIjtcbiAgICAgICAgY2FzZSBCbG9ja0lERmxhZy5CTE9DS19JRF9GTEFHX0NPTU1JVDpcbiAgICAgICAgICAgIHJldHVybiBcIkJMT0NLX0lEX0ZMQUdfQ09NTUlUXCI7XG4gICAgICAgIGNhc2UgQmxvY2tJREZsYWcuQkxPQ0tfSURfRkxBR19OSUw6XG4gICAgICAgICAgICByZXR1cm4gXCJCTE9DS19JRF9GTEFHX05JTFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiVU5LTk9XTlwiO1xuICAgIH1cbn1cbmV4cG9ydHMuYmxvY2tJREZsYWdUb0pTT04gPSBibG9ja0lERmxhZ1RvSlNPTjtcbi8qKiBTaWduZWRNc2dUeXBlIGlzIGEgdHlwZSBvZiBzaWduZWQgbWVzc2FnZSBpbiB0aGUgY29uc2Vuc3VzLiAqL1xudmFyIFNpZ25lZE1zZ1R5cGU7XG4oZnVuY3Rpb24gKFNpZ25lZE1zZ1R5cGUpIHtcbiAgICBTaWduZWRNc2dUeXBlW1NpZ25lZE1zZ1R5cGVbXCJTSUdORURfTVNHX1RZUEVfVU5LTk9XTlwiXSA9IDBdID0gXCJTSUdORURfTVNHX1RZUEVfVU5LTk9XTlwiO1xuICAgIC8qKiBTSUdORURfTVNHX1RZUEVfUFJFVk9URSAtIFZvdGVzICovXG4gICAgU2lnbmVkTXNnVHlwZVtTaWduZWRNc2dUeXBlW1wiU0lHTkVEX01TR19UWVBFX1BSRVZPVEVcIl0gPSAxXSA9IFwiU0lHTkVEX01TR19UWVBFX1BSRVZPVEVcIjtcbiAgICBTaWduZWRNc2dUeXBlW1NpZ25lZE1zZ1R5cGVbXCJTSUdORURfTVNHX1RZUEVfUFJFQ09NTUlUXCJdID0gMl0gPSBcIlNJR05FRF9NU0dfVFlQRV9QUkVDT01NSVRcIjtcbiAgICAvKiogU0lHTkVEX01TR19UWVBFX1BST1BPU0FMIC0gUHJvcG9zYWxzICovXG4gICAgU2lnbmVkTXNnVHlwZVtTaWduZWRNc2dUeXBlW1wiU0lHTkVEX01TR19UWVBFX1BST1BPU0FMXCJdID0gMzJdID0gXCJTSUdORURfTVNHX1RZUEVfUFJPUE9TQUxcIjtcbiAgICBTaWduZWRNc2dUeXBlW1NpZ25lZE1zZ1R5cGVbXCJVTlJFQ09HTklaRURcIl0gPSAtMV0gPSBcIlVOUkVDT0dOSVpFRFwiO1xufSkoU2lnbmVkTXNnVHlwZSA9IGV4cG9ydHMuU2lnbmVkTXNnVHlwZSB8fCAoZXhwb3J0cy5TaWduZWRNc2dUeXBlID0ge30pKTtcbmZ1bmN0aW9uIHNpZ25lZE1zZ1R5cGVGcm9tSlNPTihvYmplY3QpIHtcbiAgICBzd2l0Y2ggKG9iamVjdCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgIGNhc2UgXCJTSUdORURfTVNHX1RZUEVfVU5LTk9XTlwiOlxuICAgICAgICAgICAgcmV0dXJuIFNpZ25lZE1zZ1R5cGUuU0lHTkVEX01TR19UWVBFX1VOS05PV047XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgY2FzZSBcIlNJR05FRF9NU0dfVFlQRV9QUkVWT1RFXCI6XG4gICAgICAgICAgICByZXR1cm4gU2lnbmVkTXNnVHlwZS5TSUdORURfTVNHX1RZUEVfUFJFVk9URTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICBjYXNlIFwiU0lHTkVEX01TR19UWVBFX1BSRUNPTU1JVFwiOlxuICAgICAgICAgICAgcmV0dXJuIFNpZ25lZE1zZ1R5cGUuU0lHTkVEX01TR19UWVBFX1BSRUNPTU1JVDtcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgY2FzZSBcIlNJR05FRF9NU0dfVFlQRV9QUk9QT1NBTFwiOlxuICAgICAgICAgICAgcmV0dXJuIFNpZ25lZE1zZ1R5cGUuU0lHTkVEX01TR19UWVBFX1BST1BPU0FMO1xuICAgICAgICBjYXNlIC0xOlxuICAgICAgICBjYXNlIFwiVU5SRUNPR05JWkVEXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gU2lnbmVkTXNnVHlwZS5VTlJFQ09HTklaRUQ7XG4gICAgfVxufVxuZXhwb3J0cy5zaWduZWRNc2dUeXBlRnJvbUpTT04gPSBzaWduZWRNc2dUeXBlRnJvbUpTT047XG5mdW5jdGlvbiBzaWduZWRNc2dUeXBlVG9KU09OKG9iamVjdCkge1xuICAgIHN3aXRjaCAob2JqZWN0KSB7XG4gICAgICAgIGNhc2UgU2lnbmVkTXNnVHlwZS5TSUdORURfTVNHX1RZUEVfVU5LTk9XTjpcbiAgICAgICAgICAgIHJldHVybiBcIlNJR05FRF9NU0dfVFlQRV9VTktOT1dOXCI7XG4gICAgICAgIGNhc2UgU2lnbmVkTXNnVHlwZS5TSUdORURfTVNHX1RZUEVfUFJFVk9URTpcbiAgICAgICAgICAgIHJldHVybiBcIlNJR05FRF9NU0dfVFlQRV9QUkVWT1RFXCI7XG4gICAgICAgIGNhc2UgU2lnbmVkTXNnVHlwZS5TSUdORURfTVNHX1RZUEVfUFJFQ09NTUlUOlxuICAgICAgICAgICAgcmV0dXJuIFwiU0lHTkVEX01TR19UWVBFX1BSRUNPTU1JVFwiO1xuICAgICAgICBjYXNlIFNpZ25lZE1zZ1R5cGUuU0lHTkVEX01TR19UWVBFX1BST1BPU0FMOlxuICAgICAgICAgICAgcmV0dXJuIFwiU0lHTkVEX01TR19UWVBFX1BST1BPU0FMXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCJVTktOT1dOXCI7XG4gICAgfVxufVxuZXhwb3J0cy5zaWduZWRNc2dUeXBlVG9KU09OID0gc2lnbmVkTXNnVHlwZVRvSlNPTjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQYXJ0U2V0SGVhZGVyKCkge1xuICAgIHJldHVybiB7IHRvdGFsOiAwLCBoYXNoOiBuZXcgVWludDhBcnJheSgpIH07XG59XG5leHBvcnRzLlBhcnRTZXRIZWFkZXIgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS50b3RhbCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS51aW50MzIobWVzc2FnZS50b3RhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuaGFzaC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2UuaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUGFydFNldEhlYWRlcigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudG90YWwgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5oYXNoID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvdGFsOiBpc1NldChvYmplY3QudG90YWwpID8gTnVtYmVyKG9iamVjdC50b3RhbCkgOiAwLFxuICAgICAgICAgICAgaGFzaDogaXNTZXQob2JqZWN0Lmhhc2gpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0Lmhhc2gpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudG90YWwgIT09IHVuZGVmaW5lZCAmJiAob2JqLnRvdGFsID0gTWF0aC5yb3VuZChtZXNzYWdlLnRvdGFsKSk7XG4gICAgICAgIG1lc3NhZ2UuaGFzaCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmhhc2ggPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5oYXNoICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmhhc2ggOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQYXJ0U2V0SGVhZGVyKCk7XG4gICAgICAgIG1lc3NhZ2UudG90YWwgPSAoX2EgPSBvYmplY3QudG90YWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIG1lc3NhZ2UuaGFzaCA9IChfYiA9IG9iamVjdC5oYXNoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VQYXJ0KCkge1xuICAgIHJldHVybiB7IGluZGV4OiAwLCBieXRlczogbmV3IFVpbnQ4QXJyYXkoKSwgcHJvb2Y6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0cy5QYXJ0ID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaW5kZXggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkudWludDMyKG1lc3NhZ2UuaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmJ5dGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxOCkuYnl0ZXMobWVzc2FnZS5ieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucHJvb2YgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvb2ZfMS5Qcm9vZi5lbmNvZGUobWVzc2FnZS5wcm9vZiwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQYXJ0KCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbmRleCA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJ5dGVzID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wcm9vZiA9IHByb29mXzEuUHJvb2YuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5kZXg6IGlzU2V0KG9iamVjdC5pbmRleCkgPyBOdW1iZXIob2JqZWN0LmluZGV4KSA6IDAsXG4gICAgICAgICAgICBieXRlczogaXNTZXQob2JqZWN0LmJ5dGVzKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5ieXRlcylcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgICAgICBwcm9vZjogaXNTZXQob2JqZWN0LnByb29mKSA/IHByb29mXzEuUHJvb2YuZnJvbUpTT04ob2JqZWN0LnByb29mKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmluZGV4ICE9PSB1bmRlZmluZWQgJiYgKG9iai5pbmRleCA9IE1hdGgucm91bmQobWVzc2FnZS5pbmRleCkpO1xuICAgICAgICBtZXNzYWdlLmJ5dGVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYnl0ZXMgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5ieXRlcyAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5ieXRlcyA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5wcm9vZiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnByb29mID0gbWVzc2FnZS5wcm9vZiA/IHByb29mXzEuUHJvb2YudG9KU09OKG1lc3NhZ2UucHJvb2YpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVBhcnQoKTtcbiAgICAgICAgbWVzc2FnZS5pbmRleCA9IChfYSA9IG9iamVjdC5pbmRleCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgbWVzc2FnZS5ieXRlcyA9IChfYiA9IG9iamVjdC5ieXRlcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5wcm9vZiA9XG4gICAgICAgICAgICBvYmplY3QucHJvb2YgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucHJvb2YgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IHByb29mXzEuUHJvb2YuZnJvbVBhcnRpYWwob2JqZWN0LnByb29mKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VCbG9ja0lEKCkge1xuICAgIHJldHVybiB7IGhhc2g6IG5ldyBVaW50OEFycmF5KCksIHBhcnRTZXRIZWFkZXI6IHVuZGVmaW5lZCB9O1xufVxuZXhwb3J0cy5CbG9ja0lEID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaGFzaC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKG1lc3NhZ2UuaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucGFydFNldEhlYWRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLlBhcnRTZXRIZWFkZXIuZW5jb2RlKG1lc3NhZ2UucGFydFNldEhlYWRlciwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VCbG9ja0lEKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5oYXNoID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wYXJ0U2V0SGVhZGVyID0gZXhwb3J0cy5QYXJ0U2V0SGVhZGVyLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhhc2g6IGlzU2V0KG9iamVjdC5oYXNoKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5oYXNoKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIHBhcnRTZXRIZWFkZXI6IGlzU2V0KG9iamVjdC5wYXJ0U2V0SGVhZGVyKVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5QYXJ0U2V0SGVhZGVyLmZyb21KU09OKG9iamVjdC5wYXJ0U2V0SGVhZGVyKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuaGFzaCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmhhc2ggPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5oYXNoICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmhhc2ggOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UucGFydFNldEhlYWRlciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnBhcnRTZXRIZWFkZXIgPSBtZXNzYWdlLnBhcnRTZXRIZWFkZXJcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuUGFydFNldEhlYWRlci50b0pTT04obWVzc2FnZS5wYXJ0U2V0SGVhZGVyKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQmxvY2tJRCgpO1xuICAgICAgICBtZXNzYWdlLmhhc2ggPSAoX2EgPSBvYmplY3QuaGFzaCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5wYXJ0U2V0SGVhZGVyID1cbiAgICAgICAgICAgIG9iamVjdC5wYXJ0U2V0SGVhZGVyICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnBhcnRTZXRIZWFkZXIgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuUGFydFNldEhlYWRlci5mcm9tUGFydGlhbChvYmplY3QucGFydFNldEhlYWRlcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlSGVhZGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHZlcnNpb246IHVuZGVmaW5lZCxcbiAgICAgICAgY2hhaW5JZDogXCJcIixcbiAgICAgICAgaGVpZ2h0OiBcIjBcIixcbiAgICAgICAgdGltZTogdW5kZWZpbmVkLFxuICAgICAgICBsYXN0QmxvY2tJZDogdW5kZWZpbmVkLFxuICAgICAgICBsYXN0Q29tbWl0SGFzaDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgZGF0YUhhc2g6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIHZhbGlkYXRvcnNIYXNoOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICBuZXh0VmFsaWRhdG9yc0hhc2g6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIGNvbnNlbnN1c0hhc2g6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIGFwcEhhc2g6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIGxhc3RSZXN1bHRzSGFzaDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgZXZpZGVuY2VIYXNoOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICBwcm9wb3NlckFkZHJlc3M6IG5ldyBVaW50OEFycmF5KCksXG4gICAgfTtcbn1cbmV4cG9ydHMuSGVhZGVyID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0eXBlc18xLkNvbnNlbnN1cy5lbmNvZGUobWVzc2FnZS52ZXJzaW9uLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNoYWluSWQgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLmNoYWluSWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmhlaWdodCAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjQpLmludDY0KG1lc3NhZ2UuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50aW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcF8xLlRpbWVzdGFtcC5lbmNvZGUodG9UaW1lc3RhbXAobWVzc2FnZS50aW1lKSwgd3JpdGVyLnVpbnQzMigzNCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5sYXN0QmxvY2tJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLkJsb2NrSUQuZW5jb2RlKG1lc3NhZ2UubGFzdEJsb2NrSWQsIHdyaXRlci51aW50MzIoNDIpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubGFzdENvbW1pdEhhc2gubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDUwKS5ieXRlcyhtZXNzYWdlLmxhc3RDb21taXRIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5kYXRhSGFzaC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNTgpLmJ5dGVzKG1lc3NhZ2UuZGF0YUhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnZhbGlkYXRvcnNIYXNoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig2NikuYnl0ZXMobWVzc2FnZS52YWxpZGF0b3JzSGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UubmV4dFZhbGlkYXRvcnNIYXNoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig3NCkuYnl0ZXMobWVzc2FnZS5uZXh0VmFsaWRhdG9yc0hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmNvbnNlbnN1c0hhc2gubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgyKS5ieXRlcyhtZXNzYWdlLmNvbnNlbnN1c0hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmFwcEhhc2gubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDkwKS5ieXRlcyhtZXNzYWdlLmFwcEhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmxhc3RSZXN1bHRzSGFzaC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOTgpLmJ5dGVzKG1lc3NhZ2UubGFzdFJlc3VsdHNIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5ldmlkZW5jZUhhc2gubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwNikuYnl0ZXMobWVzc2FnZS5ldmlkZW5jZUhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnByb3Bvc2VyQWRkcmVzcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTE0KS5ieXRlcyhtZXNzYWdlLnByb3Bvc2VyQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSGVhZGVyKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52ZXJzaW9uID0gdHlwZXNfMS5Db25zZW5zdXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNoYWluSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5oZWlnaHQgPSBsb25nVG9TdHJpbmcocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGltZSA9IGZyb21UaW1lc3RhbXAodGltZXN0YW1wXzEuVGltZXN0YW1wLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGFzdEJsb2NrSWQgPSBleHBvcnRzLkJsb2NrSUQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxhc3RDb21taXRIYXNoID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kYXRhSGFzaCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yc0hhc2ggPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm5leHRWYWxpZGF0b3JzSGFzaCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnNlbnN1c0hhc2ggPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hcHBIYXNoID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGFzdFJlc3VsdHNIYXNoID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZXZpZGVuY2VIYXNoID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJvcG9zZXJBZGRyZXNzID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb246IGlzU2V0KG9iamVjdC52ZXJzaW9uKVxuICAgICAgICAgICAgICAgID8gdHlwZXNfMS5Db25zZW5zdXMuZnJvbUpTT04ob2JqZWN0LnZlcnNpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjaGFpbklkOiBpc1NldChvYmplY3QuY2hhaW5JZCkgPyBTdHJpbmcob2JqZWN0LmNoYWluSWQpIDogXCJcIixcbiAgICAgICAgICAgIGhlaWdodDogaXNTZXQob2JqZWN0LmhlaWdodCkgPyBTdHJpbmcob2JqZWN0LmhlaWdodCkgOiBcIjBcIixcbiAgICAgICAgICAgIHRpbWU6IGlzU2V0KG9iamVjdC50aW1lKSA/IGZyb21Kc29uVGltZXN0YW1wKG9iamVjdC50aW1lKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxhc3RCbG9ja0lkOiBpc1NldChvYmplY3QubGFzdEJsb2NrSWQpXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkJsb2NrSUQuZnJvbUpTT04ob2JqZWN0Lmxhc3RCbG9ja0lkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbGFzdENvbW1pdEhhc2g6IGlzU2V0KG9iamVjdC5sYXN0Q29tbWl0SGFzaClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QubGFzdENvbW1pdEhhc2gpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgZGF0YUhhc2g6IGlzU2V0KG9iamVjdC5kYXRhSGFzaClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QuZGF0YUhhc2gpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgdmFsaWRhdG9yc0hhc2g6IGlzU2V0KG9iamVjdC52YWxpZGF0b3JzSGFzaClcbiAgICAgICAgICAgICAgICA/IGJ5dGVzRnJvbUJhc2U2NChvYmplY3QudmFsaWRhdG9yc0hhc2gpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgbmV4dFZhbGlkYXRvcnNIYXNoOiBpc1NldChvYmplY3QubmV4dFZhbGlkYXRvcnNIYXNoKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5uZXh0VmFsaWRhdG9yc0hhc2gpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgY29uc2Vuc3VzSGFzaDogaXNTZXQob2JqZWN0LmNvbnNlbnN1c0hhc2gpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmNvbnNlbnN1c0hhc2gpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgYXBwSGFzaDogaXNTZXQob2JqZWN0LmFwcEhhc2gpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LmFwcEhhc2gpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgbGFzdFJlc3VsdHNIYXNoOiBpc1NldChvYmplY3QubGFzdFJlc3VsdHNIYXNoKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5sYXN0UmVzdWx0c0hhc2gpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgZXZpZGVuY2VIYXNoOiBpc1NldChvYmplY3QuZXZpZGVuY2VIYXNoKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5ldmlkZW5jZUhhc2gpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgcHJvcG9zZXJBZGRyZXNzOiBpc1NldChvYmplY3QucHJvcG9zZXJBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5wcm9wb3NlckFkZHJlc3MpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudmVyc2lvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnZlcnNpb24gPSBtZXNzYWdlLnZlcnNpb25cbiAgICAgICAgICAgICAgICA/IHR5cGVzXzEuQ29uc2Vuc3VzLnRvSlNPTihtZXNzYWdlLnZlcnNpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmNoYWluSWQgIT09IHVuZGVmaW5lZCAmJiAob2JqLmNoYWluSWQgPSBtZXNzYWdlLmNoYWluSWQpO1xuICAgICAgICBtZXNzYWdlLmhlaWdodCAhPT0gdW5kZWZpbmVkICYmIChvYmouaGVpZ2h0ID0gbWVzc2FnZS5oZWlnaHQpO1xuICAgICAgICBtZXNzYWdlLnRpbWUgIT09IHVuZGVmaW5lZCAmJiAob2JqLnRpbWUgPSBtZXNzYWdlLnRpbWUudG9JU09TdHJpbmcoKSk7XG4gICAgICAgIG1lc3NhZ2UubGFzdEJsb2NrSWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5sYXN0QmxvY2tJZCA9IG1lc3NhZ2UubGFzdEJsb2NrSWRcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuQmxvY2tJRC50b0pTT04obWVzc2FnZS5sYXN0QmxvY2tJZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UubGFzdENvbW1pdEhhc2ggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5sYXN0Q29tbWl0SGFzaCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmxhc3RDb21taXRIYXNoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2UubGFzdENvbW1pdEhhc2hcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5kYXRhSGFzaCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmRhdGFIYXNoID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuZGF0YUhhc2ggIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuZGF0YUhhc2ggOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yc0hhc2ggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52YWxpZGF0b3JzSGFzaCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLnZhbGlkYXRvcnNIYXNoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2UudmFsaWRhdG9yc0hhc2hcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5uZXh0VmFsaWRhdG9yc0hhc2ggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5uZXh0VmFsaWRhdG9yc0hhc2ggPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5uZXh0VmFsaWRhdG9yc0hhc2ggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS5uZXh0VmFsaWRhdG9yc0hhc2hcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5jb25zZW5zdXNIYXNoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY29uc2Vuc3VzSGFzaCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmNvbnNlbnN1c0hhc2ggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gbWVzc2FnZS5jb25zZW5zdXNIYXNoXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UuYXBwSGFzaCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmFwcEhhc2ggPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5hcHBIYXNoICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLmFwcEhhc2ggOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UubGFzdFJlc3VsdHNIYXNoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoubGFzdFJlc3VsdHNIYXNoID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UubGFzdFJlc3VsdHNIYXNoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2UubGFzdFJlc3VsdHNIYXNoXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UuZXZpZGVuY2VIYXNoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouZXZpZGVuY2VIYXNoID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuZXZpZGVuY2VIYXNoICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2UuZXZpZGVuY2VIYXNoXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIG1lc3NhZ2UucHJvcG9zZXJBZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucHJvcG9zZXJBZGRyZXNzID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UucHJvcG9zZXJBZGRyZXNzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2UucHJvcG9zZXJBZGRyZXNzXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX207XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlSGVhZGVyKCk7XG4gICAgICAgIG1lc3NhZ2UudmVyc2lvbiA9XG4gICAgICAgICAgICBvYmplY3QudmVyc2lvbiAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC52ZXJzaW9uICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyB0eXBlc18xLkNvbnNlbnN1cy5mcm9tUGFydGlhbChvYmplY3QudmVyc2lvbilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5jaGFpbklkID0gKF9hID0gb2JqZWN0LmNoYWluSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgICAgIG1lc3NhZ2UuaGVpZ2h0ID0gKF9iID0gb2JqZWN0LmhlaWdodCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCIwXCI7XG4gICAgICAgIG1lc3NhZ2UudGltZSA9IChfYyA9IG9iamVjdC50aW1lKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UubGFzdEJsb2NrSWQgPVxuICAgICAgICAgICAgb2JqZWN0Lmxhc3RCbG9ja0lkICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0Lmxhc3RCbG9ja0lkICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkJsb2NrSUQuZnJvbVBhcnRpYWwob2JqZWN0Lmxhc3RCbG9ja0lkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLmxhc3RDb21taXRIYXNoID0gKF9kID0gb2JqZWN0Lmxhc3RDb21taXRIYXNoKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmRhdGFIYXNoID0gKF9lID0gb2JqZWN0LmRhdGFIYXNoKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLnZhbGlkYXRvcnNIYXNoID0gKF9mID0gb2JqZWN0LnZhbGlkYXRvcnNIYXNoKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLm5leHRWYWxpZGF0b3JzSGFzaCA9IChfZyA9IG9iamVjdC5uZXh0VmFsaWRhdG9yc0hhc2gpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UuY29uc2Vuc3VzSGFzaCA9IChfaCA9IG9iamVjdC5jb25zZW5zdXNIYXNoKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmFwcEhhc2ggPSAoX2ogPSBvYmplY3QuYXBwSGFzaCkgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5sYXN0UmVzdWx0c0hhc2ggPSAoX2sgPSBvYmplY3QubGFzdFJlc3VsdHNIYXNoKSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmV2aWRlbmNlSGFzaCA9IChfbCA9IG9iamVjdC5ldmlkZW5jZUhhc2gpICE9PSBudWxsICYmIF9sICE9PSB2b2lkIDAgPyBfbCA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UucHJvcG9zZXJBZGRyZXNzID0gKF9tID0gb2JqZWN0LnByb3Bvc2VyQWRkcmVzcykgIT09IG51bGwgJiYgX20gIT09IHZvaWQgMCA/IF9tIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlRGF0YSgpIHtcbiAgICByZXR1cm4geyB0eHM6IFtdIH07XG59XG5leHBvcnRzLkRhdGEgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgbWVzc2FnZS50eHMpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTApLmJ5dGVzKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZURhdGEoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnR4cy5wdXNoKHJlYWRlci5ieXRlcygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHhzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC50eHMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QudHhzLm1hcCgoZSkgPT4gYnl0ZXNGcm9tQmFzZTY0KGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHhzKSB7XG4gICAgICAgICAgICBvYmoudHhzID0gbWVzc2FnZS50eHMubWFwKChlKSA9PiBiYXNlNjRGcm9tQnl0ZXMoZSAhPT0gdW5kZWZpbmVkID8gZSA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai50eHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VEYXRhKCk7XG4gICAgICAgIG1lc3NhZ2UudHhzID0gKChfYSA9IG9iamVjdC50eHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IGUpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVm90ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAwLFxuICAgICAgICBoZWlnaHQ6IFwiMFwiLFxuICAgICAgICByb3VuZDogMCxcbiAgICAgICAgYmxvY2tJZDogdW5kZWZpbmVkLFxuICAgICAgICB0aW1lc3RhbXA6IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsaWRhdG9yQWRkcmVzczogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgdmFsaWRhdG9ySW5kZXg6IDAsXG4gICAgICAgIHNpZ25hdHVyZTogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICB9O1xufVxuZXhwb3J0cy5Wb3RlID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS5pbnQzMihtZXNzYWdlLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmhlaWdodCAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLmludDY0KG1lc3NhZ2UuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5yb3VuZCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkuaW50MzIobWVzc2FnZS5yb3VuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuYmxvY2tJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHBvcnRzLkJsb2NrSUQuZW5jb2RlKG1lc3NhZ2UuYmxvY2tJZCwgd3JpdGVyLnVpbnQzMigzNCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGltZXN0YW1wXzEuVGltZXN0YW1wLmVuY29kZSh0b1RpbWVzdGFtcChtZXNzYWdlLnRpbWVzdGFtcCksIHdyaXRlci51aW50MzIoNDIpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNTApLmJ5dGVzKG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudmFsaWRhdG9ySW5kZXggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNTYpLmludDMyKG1lc3NhZ2UudmFsaWRhdG9ySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNpZ25hdHVyZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNjYpLmJ5dGVzKG1lc3NhZ2Uuc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VWb3RlKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50eXBlID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5oZWlnaHQgPSBsb25nVG9TdHJpbmcocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uucm91bmQgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJsb2NrSWQgPSBleHBvcnRzLkJsb2NrSUQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcCA9IGZyb21UaW1lc3RhbXAodGltZXN0YW1wXzEuVGltZXN0YW1wLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsaWRhdG9ySW5kZXggPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgZnJvbUpTT04ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBpc1NldChvYmplY3QudHlwZSkgPyBzaWduZWRNc2dUeXBlRnJvbUpTT04ob2JqZWN0LnR5cGUpIDogMCxcbiAgICAgICAgICAgIGhlaWdodDogaXNTZXQob2JqZWN0LmhlaWdodCkgPyBTdHJpbmcob2JqZWN0LmhlaWdodCkgOiBcIjBcIixcbiAgICAgICAgICAgIHJvdW5kOiBpc1NldChvYmplY3Qucm91bmQpID8gTnVtYmVyKG9iamVjdC5yb3VuZCkgOiAwLFxuICAgICAgICAgICAgYmxvY2tJZDogaXNTZXQob2JqZWN0LmJsb2NrSWQpXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkJsb2NrSUQuZnJvbUpTT04ob2JqZWN0LmJsb2NrSWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGlzU2V0KG9iamVjdC50aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgPyBmcm9tSnNvblRpbWVzdGFtcChvYmplY3QudGltZXN0YW1wKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdmFsaWRhdG9yQWRkcmVzczogaXNTZXQob2JqZWN0LnZhbGlkYXRvckFkZHJlc3MpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnZhbGlkYXRvckFkZHJlc3MpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICAgICAgdmFsaWRhdG9ySW5kZXg6IGlzU2V0KG9iamVjdC52YWxpZGF0b3JJbmRleClcbiAgICAgICAgICAgICAgICA/IE51bWJlcihvYmplY3QudmFsaWRhdG9ySW5kZXgpXG4gICAgICAgICAgICAgICAgOiAwLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBpc1NldChvYmplY3Quc2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudHlwZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnR5cGUgPSBzaWduZWRNc2dUeXBlVG9KU09OKG1lc3NhZ2UudHlwZSkpO1xuICAgICAgICBtZXNzYWdlLmhlaWdodCAhPT0gdW5kZWZpbmVkICYmIChvYmouaGVpZ2h0ID0gbWVzc2FnZS5oZWlnaHQpO1xuICAgICAgICBtZXNzYWdlLnJvdW5kICE9PSB1bmRlZmluZWQgJiYgKG9iai5yb3VuZCA9IE1hdGgucm91bmQobWVzc2FnZS5yb3VuZCkpO1xuICAgICAgICBtZXNzYWdlLmJsb2NrSWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5ibG9ja0lkID0gbWVzc2FnZS5ibG9ja0lkXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkJsb2NrSUQudG9KU09OKG1lc3NhZ2UuYmxvY2tJZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UudGltZXN0YW1wICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudGltZXN0YW1wID0gbWVzc2FnZS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSk7XG4gICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnZhbGlkYXRvckFkZHJlc3MgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS52YWxpZGF0b3JBZGRyZXNzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzc1xuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLnZhbGlkYXRvckluZGV4ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudmFsaWRhdG9ySW5kZXggPSBNYXRoLnJvdW5kKG1lc3NhZ2UudmFsaWRhdG9ySW5kZXgpKTtcbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zaWduYXR1cmUgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2Uuc2lnbmF0dXJlIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VWb3RlKCk7XG4gICAgICAgIG1lc3NhZ2UudHlwZSA9IChfYSA9IG9iamVjdC50eXBlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBtZXNzYWdlLmhlaWdodCA9IChfYiA9IG9iamVjdC5oZWlnaHQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiMFwiO1xuICAgICAgICBtZXNzYWdlLnJvdW5kID0gKF9jID0gb2JqZWN0LnJvdW5kKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwO1xuICAgICAgICBtZXNzYWdlLmJsb2NrSWQgPVxuICAgICAgICAgICAgb2JqZWN0LmJsb2NrSWQgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QuYmxvY2tJZCAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5CbG9ja0lELmZyb21QYXJ0aWFsKG9iamVjdC5ibG9ja0lkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcCA9IChfZCA9IG9iamVjdC50aW1lc3RhbXApICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS52YWxpZGF0b3JBZGRyZXNzID0gKF9lID0gb2JqZWN0LnZhbGlkYXRvckFkZHJlc3MpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UudmFsaWRhdG9ySW5kZXggPSAoX2YgPSBvYmplY3QudmFsaWRhdG9ySW5kZXgpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IDA7XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmF0dXJlID0gKF9nID0gb2JqZWN0LnNpZ25hdHVyZSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlQ29tbWl0KCkge1xuICAgIHJldHVybiB7IGhlaWdodDogXCIwXCIsIHJvdW5kOiAwLCBibG9ja0lkOiB1bmRlZmluZWQsIHNpZ25hdHVyZXM6IFtdIH07XG59XG5leHBvcnRzLkNvbW1pdCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmhlaWdodCAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkuaW50NjQobWVzc2FnZS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnJvdW5kICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS5pbnQzMihtZXNzYWdlLnJvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5ibG9ja0lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuQmxvY2tJRC5lbmNvZGUobWVzc2FnZS5ibG9ja0lkLCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnNpZ25hdHVyZXMpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuQ29tbWl0U2lnLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDM0KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUNvbW1pdCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGVpZ2h0ID0gbG9uZ1RvU3RyaW5nKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJvdW5kID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ibG9ja0lkID0gZXhwb3J0cy5CbG9ja0lELmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaWduYXR1cmVzLnB1c2goZXhwb3J0cy5Db21taXRTaWcuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlaWdodDogaXNTZXQob2JqZWN0LmhlaWdodCkgPyBTdHJpbmcob2JqZWN0LmhlaWdodCkgOiBcIjBcIixcbiAgICAgICAgICAgIHJvdW5kOiBpc1NldChvYmplY3Qucm91bmQpID8gTnVtYmVyKG9iamVjdC5yb3VuZCkgOiAwLFxuICAgICAgICAgICAgYmxvY2tJZDogaXNTZXQob2JqZWN0LmJsb2NrSWQpXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkJsb2NrSUQuZnJvbUpTT04ob2JqZWN0LmJsb2NrSWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzaWduYXR1cmVzOiBBcnJheS5pc0FycmF5KG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5zaWduYXR1cmVzKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0LnNpZ25hdHVyZXMubWFwKChlKSA9PiBleHBvcnRzLkNvbW1pdFNpZy5mcm9tSlNPTihlKSlcbiAgICAgICAgICAgICAgICA6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UuaGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgKG9iai5oZWlnaHQgPSBtZXNzYWdlLmhlaWdodCk7XG4gICAgICAgIG1lc3NhZ2Uucm91bmQgIT09IHVuZGVmaW5lZCAmJiAob2JqLnJvdW5kID0gTWF0aC5yb3VuZChtZXNzYWdlLnJvdW5kKSk7XG4gICAgICAgIG1lc3NhZ2UuYmxvY2tJZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmJsb2NrSWQgPSBtZXNzYWdlLmJsb2NrSWRcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuQmxvY2tJRC50b0pTT04obWVzc2FnZS5ibG9ja0lkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc2lnbmF0dXJlcykge1xuICAgICAgICAgICAgb2JqLnNpZ25hdHVyZXMgPSBtZXNzYWdlLnNpZ25hdHVyZXMubWFwKChlKSA9PiBlID8gZXhwb3J0cy5Db21taXRTaWcudG9KU09OKGUpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iai5zaWduYXR1cmVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDb21taXQoKTtcbiAgICAgICAgbWVzc2FnZS5oZWlnaHQgPSAoX2EgPSBvYmplY3QuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIjBcIjtcbiAgICAgICAgbWVzc2FnZS5yb3VuZCA9IChfYiA9IG9iamVjdC5yb3VuZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICAgICAgbWVzc2FnZS5ibG9ja0lkID1cbiAgICAgICAgICAgIG9iamVjdC5ibG9ja0lkICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmJsb2NrSWQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuQmxvY2tJRC5mcm9tUGFydGlhbChvYmplY3QuYmxvY2tJZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmVzID1cbiAgICAgICAgICAgICgoX2MgPSBvYmplY3Quc2lnbmF0dXJlcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1hcCgoZSkgPT4gZXhwb3J0cy5Db21taXRTaWcuZnJvbVBhcnRpYWwoZSkpKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlQ29tbWl0U2lnKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJsb2NrSWRGbGFnOiAwLFxuICAgICAgICB2YWxpZGF0b3JBZGRyZXNzOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB0aW1lc3RhbXA6IHVuZGVmaW5lZCxcbiAgICAgICAgc2lnbmF0dXJlOiBuZXcgVWludDhBcnJheSgpLFxuICAgIH07XG59XG5leHBvcnRzLkNvbW1pdFNpZyA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmJsb2NrSWRGbGFnICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDgpLmludDMyKG1lc3NhZ2UuYmxvY2tJZEZsYWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE4KS5ieXRlcyhtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aW1lc3RhbXBfMS5UaW1lc3RhbXAuZW5jb2RlKHRvVGltZXN0YW1wKG1lc3NhZ2UudGltZXN0YW1wKSwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5zaWduYXR1cmUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDM0KS5ieXRlcyhtZXNzYWdlLnNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29tbWl0U2lnKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ibG9ja0lkRmxhZyA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGltZXN0YW1wID0gZnJvbVRpbWVzdGFtcCh0aW1lc3RhbXBfMS5UaW1lc3RhbXAuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmxvY2tJZEZsYWc6IGlzU2V0KG9iamVjdC5ibG9ja0lkRmxhZylcbiAgICAgICAgICAgICAgICA/IGJsb2NrSURGbGFnRnJvbUpTT04ob2JqZWN0LmJsb2NrSWRGbGFnKVxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIHZhbGlkYXRvckFkZHJlc3M6IGlzU2V0KG9iamVjdC52YWxpZGF0b3JBZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC52YWxpZGF0b3JBZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogaXNTZXQob2JqZWN0LnRpbWVzdGFtcClcbiAgICAgICAgICAgICAgICA/IGZyb21Kc29uVGltZXN0YW1wKG9iamVjdC50aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzaWduYXR1cmU6IGlzU2V0KG9iamVjdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5ibG9ja0lkRmxhZyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmJsb2NrSWRGbGFnID0gYmxvY2tJREZsYWdUb0pTT04obWVzc2FnZS5ibG9ja0lkRmxhZykpO1xuICAgICAgICBtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3MgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai52YWxpZGF0b3JBZGRyZXNzID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UudmFsaWRhdG9yQWRkcmVzcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBtZXNzYWdlLnZhbGlkYXRvckFkZHJlc3NcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai50aW1lc3RhbXAgPSBtZXNzYWdlLnRpbWVzdGFtcC50b0lTT1N0cmluZygpKTtcbiAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5zaWduYXR1cmUgPSBiYXNlNjRGcm9tQnl0ZXMobWVzc2FnZS5zaWduYXR1cmUgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2Uuc2lnbmF0dXJlIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VDb21taXRTaWcoKTtcbiAgICAgICAgbWVzc2FnZS5ibG9ja0lkRmxhZyA9IChfYSA9IG9iamVjdC5ibG9ja0lkRmxhZykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgbWVzc2FnZS52YWxpZGF0b3JBZGRyZXNzID0gKF9iID0gb2JqZWN0LnZhbGlkYXRvckFkZHJlc3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIG1lc3NhZ2UudGltZXN0YW1wID0gKF9jID0gb2JqZWN0LnRpbWVzdGFtcCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZSA9IChfZCA9IG9iamVjdC5zaWduYXR1cmUpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVByb3Bvc2FsKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDAsXG4gICAgICAgIGhlaWdodDogXCIwXCIsXG4gICAgICAgIHJvdW5kOiAwLFxuICAgICAgICBwb2xSb3VuZDogMCxcbiAgICAgICAgYmxvY2tJZDogdW5kZWZpbmVkLFxuICAgICAgICB0aW1lc3RhbXA6IHVuZGVmaW5lZCxcbiAgICAgICAgc2lnbmF0dXJlOiBuZXcgVWludDhBcnJheSgpLFxuICAgIH07XG59XG5leHBvcnRzLlByb3Bvc2FsID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS5pbnQzMihtZXNzYWdlLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmhlaWdodCAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLmludDY0KG1lc3NhZ2UuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5yb3VuZCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigyNCkuaW50MzIobWVzc2FnZS5yb3VuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucG9sUm91bmQgIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMzIpLmludDMyKG1lc3NhZ2UucG9sUm91bmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmJsb2NrSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5CbG9ja0lELmVuY29kZShtZXNzYWdlLmJsb2NrSWQsIHdyaXRlci51aW50MzIoNDIpLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UudGltZXN0YW1wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcF8xLlRpbWVzdGFtcC5lbmNvZGUodG9UaW1lc3RhbXAobWVzc2FnZS50aW1lc3RhbXApLCB3cml0ZXIudWludDMyKDUwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnNpZ25hdHVyZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoNTgpLmJ5dGVzKG1lc3NhZ2Uuc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VQcm9wb3NhbCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudHlwZSA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGVpZ2h0ID0gbG9uZ1RvU3RyaW5nKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJvdW5kID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wb2xSb3VuZCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYmxvY2tJZCA9IGV4cG9ydHMuQmxvY2tJRC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGltZXN0YW1wID0gZnJvbVRpbWVzdGFtcCh0aW1lc3RhbXBfMS5UaW1lc3RhbXAuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zaWduYXR1cmUgPSByZWFkZXIuYnl0ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogaXNTZXQob2JqZWN0LnR5cGUpID8gc2lnbmVkTXNnVHlwZUZyb21KU09OKG9iamVjdC50eXBlKSA6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IGlzU2V0KG9iamVjdC5oZWlnaHQpID8gU3RyaW5nKG9iamVjdC5oZWlnaHQpIDogXCIwXCIsXG4gICAgICAgICAgICByb3VuZDogaXNTZXQob2JqZWN0LnJvdW5kKSA/IE51bWJlcihvYmplY3Qucm91bmQpIDogMCxcbiAgICAgICAgICAgIHBvbFJvdW5kOiBpc1NldChvYmplY3QucG9sUm91bmQpID8gTnVtYmVyKG9iamVjdC5wb2xSb3VuZCkgOiAwLFxuICAgICAgICAgICAgYmxvY2tJZDogaXNTZXQob2JqZWN0LmJsb2NrSWQpXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkJsb2NrSUQuZnJvbUpTT04ob2JqZWN0LmJsb2NrSWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGlzU2V0KG9iamVjdC50aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgPyBmcm9tSnNvblRpbWVzdGFtcChvYmplY3QudGltZXN0YW1wKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBpc1NldChvYmplY3Quc2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UudHlwZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnR5cGUgPSBzaWduZWRNc2dUeXBlVG9KU09OKG1lc3NhZ2UudHlwZSkpO1xuICAgICAgICBtZXNzYWdlLmhlaWdodCAhPT0gdW5kZWZpbmVkICYmIChvYmouaGVpZ2h0ID0gbWVzc2FnZS5oZWlnaHQpO1xuICAgICAgICBtZXNzYWdlLnJvdW5kICE9PSB1bmRlZmluZWQgJiYgKG9iai5yb3VuZCA9IE1hdGgucm91bmQobWVzc2FnZS5yb3VuZCkpO1xuICAgICAgICBtZXNzYWdlLnBvbFJvdW5kICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucG9sUm91bmQgPSBNYXRoLnJvdW5kKG1lc3NhZ2UucG9sUm91bmQpKTtcbiAgICAgICAgbWVzc2FnZS5ibG9ja0lkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYmxvY2tJZCA9IG1lc3NhZ2UuYmxvY2tJZFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5CbG9ja0lELnRvSlNPTihtZXNzYWdlLmJsb2NrSWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnRpbWVzdGFtcCA9IG1lc3NhZ2UudGltZXN0YW1wLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnNpZ25hdHVyZSA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLnNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5zaWduYXR1cmUgOiBuZXcgVWludDhBcnJheSgpKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlUHJvcG9zYWwoKTtcbiAgICAgICAgbWVzc2FnZS50eXBlID0gKF9hID0gb2JqZWN0LnR5cGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIG1lc3NhZ2UuaGVpZ2h0ID0gKF9iID0gb2JqZWN0LmhlaWdodCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCIwXCI7XG4gICAgICAgIG1lc3NhZ2Uucm91bmQgPSAoX2MgPSBvYmplY3Qucm91bmQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDA7XG4gICAgICAgIG1lc3NhZ2UucG9sUm91bmQgPSAoX2QgPSBvYmplY3QucG9sUm91bmQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDA7XG4gICAgICAgIG1lc3NhZ2UuYmxvY2tJZCA9XG4gICAgICAgICAgICBvYmplY3QuYmxvY2tJZCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5ibG9ja0lkICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkJsb2NrSUQuZnJvbVBhcnRpYWwob2JqZWN0LmJsb2NrSWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UudGltZXN0YW1wID0gKF9lID0gb2JqZWN0LnRpbWVzdGFtcCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnNpZ25hdHVyZSA9IChfZiA9IG9iamVjdC5zaWduYXR1cmUpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVNpZ25lZEhlYWRlcigpIHtcbiAgICByZXR1cm4geyBoZWFkZXI6IHVuZGVmaW5lZCwgY29tbWl0OiB1bmRlZmluZWQgfTtcbn1cbmV4cG9ydHMuU2lnbmVkSGVhZGVyID0ge1xuICAgIGVuY29kZShtZXNzYWdlLCB3cml0ZXIgPSBtaW5pbWFsXzEuZGVmYXVsdC5Xcml0ZXIuY3JlYXRlKCkpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UuaGVhZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuSGVhZGVyLmVuY29kZShtZXNzYWdlLmhlYWRlciwgd3JpdGVyLnVpbnQzMigxMCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5jb21taXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5Db21taXQuZW5jb2RlKG1lc3NhZ2UuY29tbWl0LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25lZEhlYWRlcigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGVhZGVyID0gZXhwb3J0cy5IZWFkZXIuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbW1pdCA9IGV4cG9ydHMuQ29tbWl0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlYWRlcjogaXNTZXQob2JqZWN0LmhlYWRlcikgPyBleHBvcnRzLkhlYWRlci5mcm9tSlNPTihvYmplY3QuaGVhZGVyKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbW1pdDogaXNTZXQob2JqZWN0LmNvbW1pdCkgPyBleHBvcnRzLkNvbW1pdC5mcm9tSlNPTihvYmplY3QuY29tbWl0KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmhlYWRlciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmhlYWRlciA9IG1lc3NhZ2UuaGVhZGVyID8gZXhwb3J0cy5IZWFkZXIudG9KU09OKG1lc3NhZ2UuaGVhZGVyKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UuY29tbWl0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouY29tbWl0ID0gbWVzc2FnZS5jb21taXQgPyBleHBvcnRzLkNvbW1pdC50b0pTT04obWVzc2FnZS5jb21taXQpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpZ25lZEhlYWRlcigpO1xuICAgICAgICBtZXNzYWdlLmhlYWRlciA9XG4gICAgICAgICAgICBvYmplY3QuaGVhZGVyICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmhlYWRlciAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5IZWFkZXIuZnJvbVBhcnRpYWwob2JqZWN0LmhlYWRlcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5jb21taXQgPVxuICAgICAgICAgICAgb2JqZWN0LmNvbW1pdCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5jb21taXQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuQ29tbWl0LmZyb21QYXJ0aWFsKG9iamVjdC5jb21taXQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZUxpZ2h0QmxvY2soKSB7XG4gICAgcmV0dXJuIHsgc2lnbmVkSGVhZGVyOiB1bmRlZmluZWQsIHZhbGlkYXRvclNldDogdW5kZWZpbmVkIH07XG59XG5leHBvcnRzLkxpZ2h0QmxvY2sgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5zaWduZWRIZWFkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5TaWduZWRIZWFkZXIuZW5jb2RlKG1lc3NhZ2Uuc2lnbmVkSGVhZGVyLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnZhbGlkYXRvclNldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWxpZGF0b3JfMS5WYWxpZGF0b3JTZXQuZW5jb2RlKG1lc3NhZ2UudmFsaWRhdG9yU2V0LCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUxpZ2h0QmxvY2soKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNpZ25lZEhlYWRlciA9IGV4cG9ydHMuU2lnbmVkSGVhZGVyLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52YWxpZGF0b3JTZXQgPSB2YWxpZGF0b3JfMS5WYWxpZGF0b3JTZXQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2lnbmVkSGVhZGVyOiBpc1NldChvYmplY3Quc2lnbmVkSGVhZGVyKVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5TaWduZWRIZWFkZXIuZnJvbUpTT04ob2JqZWN0LnNpZ25lZEhlYWRlcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZhbGlkYXRvclNldDogaXNTZXQob2JqZWN0LnZhbGlkYXRvclNldClcbiAgICAgICAgICAgICAgICA/IHZhbGlkYXRvcl8xLlZhbGlkYXRvclNldC5mcm9tSlNPTihvYmplY3QudmFsaWRhdG9yU2V0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uuc2lnbmVkSGVhZGVyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouc2lnbmVkSGVhZGVyID0gbWVzc2FnZS5zaWduZWRIZWFkZXJcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuU2lnbmVkSGVhZGVyLnRvSlNPTihtZXNzYWdlLnNpZ25lZEhlYWRlcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UudmFsaWRhdG9yU2V0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudmFsaWRhdG9yU2V0ID0gbWVzc2FnZS52YWxpZGF0b3JTZXRcbiAgICAgICAgICAgICAgICA/IHZhbGlkYXRvcl8xLlZhbGlkYXRvclNldC50b0pTT04obWVzc2FnZS52YWxpZGF0b3JTZXQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlTGlnaHRCbG9jaygpO1xuICAgICAgICBtZXNzYWdlLnNpZ25lZEhlYWRlciA9XG4gICAgICAgICAgICBvYmplY3Quc2lnbmVkSGVhZGVyICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnNpZ25lZEhlYWRlciAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5TaWduZWRIZWFkZXIuZnJvbVBhcnRpYWwob2JqZWN0LnNpZ25lZEhlYWRlcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS52YWxpZGF0b3JTZXQgPVxuICAgICAgICAgICAgb2JqZWN0LnZhbGlkYXRvclNldCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC52YWxpZGF0b3JTZXQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IHZhbGlkYXRvcl8xLlZhbGlkYXRvclNldC5mcm9tUGFydGlhbChvYmplY3QudmFsaWRhdG9yU2V0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VCbG9ja01ldGEoKSB7XG4gICAgcmV0dXJuIHsgYmxvY2tJZDogdW5kZWZpbmVkLCBibG9ja1NpemU6IFwiMFwiLCBoZWFkZXI6IHVuZGVmaW5lZCwgbnVtVHhzOiBcIjBcIiB9O1xufVxuZXhwb3J0cy5CbG9ja01ldGEgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5ibG9ja0lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuQmxvY2tJRC5lbmNvZGUobWVzc2FnZS5ibG9ja0lkLCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmJsb2NrU2l6ZSAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLmludDY0KG1lc3NhZ2UuYmxvY2tTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS5oZWFkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhwb3J0cy5IZWFkZXIuZW5jb2RlKG1lc3NhZ2UuaGVhZGVyLCB3cml0ZXIudWludDMyKDI2KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLm51bVR4cyAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMzIpLmludDY0KG1lc3NhZ2UubnVtVHhzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VCbG9ja01ldGEoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJsb2NrSWQgPSBleHBvcnRzLkJsb2NrSUQuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJsb2NrU2l6ZSA9IGxvbmdUb1N0cmluZyhyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5oZWFkZXIgPSBleHBvcnRzLkhlYWRlci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubnVtVHhzID0gbG9uZ1RvU3RyaW5nKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmxvY2tJZDogaXNTZXQob2JqZWN0LmJsb2NrSWQpXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLkJsb2NrSUQuZnJvbUpTT04ob2JqZWN0LmJsb2NrSWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBibG9ja1NpemU6IGlzU2V0KG9iamVjdC5ibG9ja1NpemUpID8gU3RyaW5nKG9iamVjdC5ibG9ja1NpemUpIDogXCIwXCIsXG4gICAgICAgICAgICBoZWFkZXI6IGlzU2V0KG9iamVjdC5oZWFkZXIpID8gZXhwb3J0cy5IZWFkZXIuZnJvbUpTT04ob2JqZWN0LmhlYWRlcikgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBudW1UeHM6IGlzU2V0KG9iamVjdC5udW1UeHMpID8gU3RyaW5nKG9iamVjdC5udW1UeHMpIDogXCIwXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5ibG9ja0lkICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYmxvY2tJZCA9IG1lc3NhZ2UuYmxvY2tJZFxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5CbG9ja0lELnRvSlNPTihtZXNzYWdlLmJsb2NrSWQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLmJsb2NrU2l6ZSAhPT0gdW5kZWZpbmVkICYmIChvYmouYmxvY2tTaXplID0gbWVzc2FnZS5ibG9ja1NpemUpO1xuICAgICAgICBtZXNzYWdlLmhlYWRlciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLmhlYWRlciA9IG1lc3NhZ2UuaGVhZGVyID8gZXhwb3J0cy5IZWFkZXIudG9KU09OKG1lc3NhZ2UuaGVhZGVyKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UubnVtVHhzICE9PSB1bmRlZmluZWQgJiYgKG9iai5udW1UeHMgPSBtZXNzYWdlLm51bVR4cyk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VCbG9ja01ldGEoKTtcbiAgICAgICAgbWVzc2FnZS5ibG9ja0lkID1cbiAgICAgICAgICAgIG9iamVjdC5ibG9ja0lkICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LmJsb2NrSWQgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuQmxvY2tJRC5mcm9tUGFydGlhbChvYmplY3QuYmxvY2tJZClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgbWVzc2FnZS5ibG9ja1NpemUgPSAoX2EgPSBvYmplY3QuYmxvY2tTaXplKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIjBcIjtcbiAgICAgICAgbWVzc2FnZS5oZWFkZXIgPVxuICAgICAgICAgICAgb2JqZWN0LmhlYWRlciAhPT0gdW5kZWZpbmVkICYmIG9iamVjdC5oZWFkZXIgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGV4cG9ydHMuSGVhZGVyLmZyb21QYXJ0aWFsKG9iamVjdC5oZWFkZXIpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UubnVtVHhzID0gKF9iID0gb2JqZWN0Lm51bVR4cykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCIwXCI7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gY3JlYXRlQmFzZVR4UHJvb2YoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm9vdEhhc2g6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIGRhdGE6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIHByb29mOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydHMuVHhQcm9vZiA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnJvb3RIYXNoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigxMCkuYnl0ZXMobWVzc2FnZS5yb290SGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UuZGF0YS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLmJ5dGVzKG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UucHJvb2YgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvb2ZfMS5Qcm9vZi5lbmNvZGUobWVzc2FnZS5wcm9vZiwgd3JpdGVyLnVpbnQzMigyNikuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VUeFByb29mKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yb290SGFzaCA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGF0YSA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJvb2YgPSBwcm9vZl8xLlByb29mLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJvb3RIYXNoOiBpc1NldChvYmplY3Qucm9vdEhhc2gpXG4gICAgICAgICAgICAgICAgPyBieXRlc0Zyb21CYXNlNjQob2JqZWN0LnJvb3RIYXNoKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIGRhdGE6IGlzU2V0KG9iamVjdC5kYXRhKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5kYXRhKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIHByb29mOiBpc1NldChvYmplY3QucHJvb2YpID8gcHJvb2ZfMS5Qcm9vZi5mcm9tSlNPTihvYmplY3QucHJvb2YpIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2Uucm9vdEhhc2ggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5yb290SGFzaCA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLnJvb3RIYXNoICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlLnJvb3RIYXNoIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLmRhdGEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5kYXRhID0gYmFzZTY0RnJvbUJ5dGVzKG1lc3NhZ2UuZGF0YSAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZS5kYXRhIDogbmV3IFVpbnQ4QXJyYXkoKSkpO1xuICAgICAgICBtZXNzYWdlLnByb29mICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucHJvb2YgPSBtZXNzYWdlLnByb29mID8gcHJvb2ZfMS5Qcm9vZi50b0pTT04obWVzc2FnZS5wcm9vZikgOiB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVHhQcm9vZigpO1xuICAgICAgICBtZXNzYWdlLnJvb3RIYXNoID0gKF9hID0gb2JqZWN0LnJvb3RIYXNoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLmRhdGEgPSAoX2IgPSBvYmplY3QuZGF0YSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZS5wcm9vZiA9XG4gICAgICAgICAgICBvYmplY3QucHJvb2YgIT09IHVuZGVmaW5lZCAmJiBvYmplY3QucHJvb2YgIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IHByb29mXzEuUHJvb2YuZnJvbVBhcnRpYWwob2JqZWN0LnByb29mKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbnZhciBnbG9iYWxUaGlzID0gKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgdGhyb3cgXCJVbmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3RcIjtcbn0pKCk7XG5jb25zdCBhdG9iID0gZ2xvYmFsVGhpcy5hdG9iIHx8XG4gICAgKChiNjQpID0+IGdsb2JhbFRoaXMuQnVmZmVyLmZyb20oYjY0LCBcImJhc2U2NFwiKS50b1N0cmluZyhcImJpbmFyeVwiKSk7XG5mdW5jdGlvbiBieXRlc0Zyb21CYXNlNjQoYjY0KSB7XG4gICAgY29uc3QgYmluID0gYXRvYihiNjQpO1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGJpbi5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGFycltpXSA9IGJpbi5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuY29uc3QgYnRvYSA9IGdsb2JhbFRoaXMuYnRvYSB8fFxuICAgICgoYmluKSA9PiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGJpbiwgXCJiaW5hcnlcIikudG9TdHJpbmcoXCJiYXNlNjRcIikpO1xuZnVuY3Rpb24gYmFzZTY0RnJvbUJ5dGVzKGFycikge1xuICAgIGNvbnN0IGJpbiA9IFtdO1xuICAgIGZvciAoY29uc3QgYnl0ZSBvZiBhcnIpIHtcbiAgICAgICAgYmluLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSk7XG4gICAgfVxuICAgIHJldHVybiBidG9hKGJpbi5qb2luKFwiXCIpKTtcbn1cbmZ1bmN0aW9uIHRvVGltZXN0YW1wKGRhdGUpIHtcbiAgICBjb25zdCBzZWNvbmRzID0gTWF0aC50cnVuYyhkYXRlLmdldFRpbWUoKSAvIDEwMDApLnRvU3RyaW5nKCk7XG4gICAgY29uc3QgbmFub3MgPSAoZGF0ZS5nZXRUaW1lKCkgJSAxMDAwKSAqIDEwMDAwMDA7XG4gICAgcmV0dXJuIHsgc2Vjb25kcywgbmFub3MgfTtcbn1cbmZ1bmN0aW9uIGZyb21UaW1lc3RhbXAodCkge1xuICAgIGxldCBtaWxsaXMgPSBOdW1iZXIodC5zZWNvbmRzKSAqIDEwMDA7XG4gICAgbWlsbGlzICs9IHQubmFub3MgLyAxMDAwMDAwO1xuICAgIHJldHVybiBuZXcgRGF0ZShtaWxsaXMpO1xufVxuZnVuY3Rpb24gZnJvbUpzb25UaW1lc3RhbXAobykge1xuICAgIGlmIChvIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gbztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG8pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZyb21UaW1lc3RhbXAodGltZXN0YW1wXzEuVGltZXN0YW1wLmZyb21KU09OKG8pKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsb25nVG9TdHJpbmcobG9uZykge1xuICAgIHJldHVybiBsb25nLnRvU3RyaW5nKCk7XG59XG5pZiAobWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nICE9PSBsb25nXzEuZGVmYXVsdCkge1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyA9IGxvbmdfMS5kZWZhdWx0O1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/tendermint/types/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/tendermint/types/validator.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/tendermint/types/validator.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SimpleValidator = exports.Validator = exports.ValidatorSet = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nconst keys_1 = __webpack_require__(/*! ../../tendermint/crypto/keys */ \"(ssr)/./node_modules/@keplr-wallet/proto-types/tendermint/crypto/keys.js\");\nexports.protobufPackage = \"tendermint.types\";\nfunction createBaseValidatorSet() {\n    return { validators: [], proposer: undefined, totalVotingPower: \"0\" };\n}\nexports.ValidatorSet = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.validators) {\n            exports.Validator.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.proposer !== undefined) {\n            exports.Validator.encode(message.proposer, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.totalVotingPower !== \"0\") {\n            writer.uint32(24).int64(message.totalVotingPower);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseValidatorSet();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.validators.push(exports.Validator.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.proposer = exports.Validator.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.totalVotingPower = longToString(reader.int64());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            validators: Array.isArray(object === null || object === void 0 ? void 0 : object.validators)\n                ? object.validators.map((e) => exports.Validator.fromJSON(e))\n                : [],\n            proposer: isSet(object.proposer)\n                ? exports.Validator.fromJSON(object.proposer)\n                : undefined,\n            totalVotingPower: isSet(object.totalVotingPower)\n                ? String(object.totalVotingPower)\n                : \"0\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.validators) {\n            obj.validators = message.validators.map((e) => e ? exports.Validator.toJSON(e) : undefined);\n        }\n        else {\n            obj.validators = [];\n        }\n        message.proposer !== undefined &&\n            (obj.proposer = message.proposer\n                ? exports.Validator.toJSON(message.proposer)\n                : undefined);\n        message.totalVotingPower !== undefined &&\n            (obj.totalVotingPower = message.totalVotingPower);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseValidatorSet();\n        message.validators =\n            ((_a = object.validators) === null || _a === void 0 ? void 0 : _a.map((e) => exports.Validator.fromPartial(e))) || [];\n        message.proposer =\n            object.proposer !== undefined && object.proposer !== null\n                ? exports.Validator.fromPartial(object.proposer)\n                : undefined;\n        message.totalVotingPower = (_b = object.totalVotingPower) !== null && _b !== void 0 ? _b : \"0\";\n        return message;\n    },\n};\nfunction createBaseValidator() {\n    return {\n        address: new Uint8Array(),\n        pubKey: undefined,\n        votingPower: \"0\",\n        proposerPriority: \"0\",\n    };\n}\nexports.Validator = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.address.length !== 0) {\n            writer.uint32(10).bytes(message.address);\n        }\n        if (message.pubKey !== undefined) {\n            keys_1.PublicKey.encode(message.pubKey, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.votingPower !== \"0\") {\n            writer.uint32(24).int64(message.votingPower);\n        }\n        if (message.proposerPriority !== \"0\") {\n            writer.uint32(32).int64(message.proposerPriority);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseValidator();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.address = reader.bytes();\n                    break;\n                case 2:\n                    message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.votingPower = longToString(reader.int64());\n                    break;\n                case 4:\n                    message.proposerPriority = longToString(reader.int64());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            address: isSet(object.address)\n                ? bytesFromBase64(object.address)\n                : new Uint8Array(),\n            pubKey: isSet(object.pubKey)\n                ? keys_1.PublicKey.fromJSON(object.pubKey)\n                : undefined,\n            votingPower: isSet(object.votingPower) ? String(object.votingPower) : \"0\",\n            proposerPriority: isSet(object.proposerPriority)\n                ? String(object.proposerPriority)\n                : \"0\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.address !== undefined &&\n            (obj.address = base64FromBytes(message.address !== undefined ? message.address : new Uint8Array()));\n        message.pubKey !== undefined &&\n            (obj.pubKey = message.pubKey\n                ? keys_1.PublicKey.toJSON(message.pubKey)\n                : undefined);\n        message.votingPower !== undefined &&\n            (obj.votingPower = message.votingPower);\n        message.proposerPriority !== undefined &&\n            (obj.proposerPriority = message.proposerPriority);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseValidator();\n        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : new Uint8Array();\n        message.pubKey =\n            object.pubKey !== undefined && object.pubKey !== null\n                ? keys_1.PublicKey.fromPartial(object.pubKey)\n                : undefined;\n        message.votingPower = (_b = object.votingPower) !== null && _b !== void 0 ? _b : \"0\";\n        message.proposerPriority = (_c = object.proposerPriority) !== null && _c !== void 0 ? _c : \"0\";\n        return message;\n    },\n};\nfunction createBaseSimpleValidator() {\n    return { pubKey: undefined, votingPower: \"0\" };\n}\nexports.SimpleValidator = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.pubKey !== undefined) {\n            keys_1.PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.votingPower !== \"0\") {\n            writer.uint32(16).int64(message.votingPower);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSimpleValidator();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.votingPower = longToString(reader.int64());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            pubKey: isSet(object.pubKey)\n                ? keys_1.PublicKey.fromJSON(object.pubKey)\n                : undefined,\n            votingPower: isSet(object.votingPower) ? String(object.votingPower) : \"0\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.pubKey !== undefined &&\n            (obj.pubKey = message.pubKey\n                ? keys_1.PublicKey.toJSON(message.pubKey)\n                : undefined);\n        message.votingPower !== undefined &&\n            (obj.votingPower = message.votingPower);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSimpleValidator();\n        message.pubKey =\n            object.pubKey !== undefined && object.pubKey !== null\n                ? keys_1.PublicKey.fromPartial(object.pubKey)\n                : undefined;\n        message.votingPower = (_a = object.votingPower) !== null && _a !== void 0 ? _a : \"0\";\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob ||\n    ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa ||\n    ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (const byte of arr) {\n        bin.push(String.fromCharCode(byte));\n    }\n    return btoa(bin.join(\"\"));\n}\nfunction longToString(long) {\n    return long.toString();\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=validator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy90ZW5kZXJtaW50L3R5cGVzL3ZhbGlkYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLGlCQUFpQixHQUFHLG9CQUFvQixHQUFHLHVCQUF1QjtBQUM1RjtBQUNBLCtCQUErQixtQkFBTyxDQUFDLG1EQUFNO0FBQzdDLGtDQUFrQyxtQkFBTyxDQUFDLHNFQUFvQjtBQUM5RCxlQUFlLG1CQUFPLENBQUMsOEdBQThCO0FBQ3JELHVCQUF1QjtBQUN2QjtBQUNBLGFBQWE7QUFDYjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy90ZW5kZXJtaW50L3R5cGVzL3ZhbGlkYXRvci5qcz9lYzdjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaW1wbGVWYWxpZGF0b3IgPSBleHBvcnRzLlZhbGlkYXRvciA9IGV4cG9ydHMuVmFsaWRhdG9yU2V0ID0gZXhwb3J0cy5wcm90b2J1ZlBhY2thZ2UgPSB2b2lkIDA7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuY29uc3QgbG9uZ18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb25nXCIpKTtcbmNvbnN0IG1pbmltYWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicHJvdG9idWZqcy9taW5pbWFsXCIpKTtcbmNvbnN0IGtleXNfMSA9IHJlcXVpcmUoXCIuLi8uLi90ZW5kZXJtaW50L2NyeXB0by9rZXlzXCIpO1xuZXhwb3J0cy5wcm90b2J1ZlBhY2thZ2UgPSBcInRlbmRlcm1pbnQudHlwZXNcIjtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VWYWxpZGF0b3JTZXQoKSB7XG4gICAgcmV0dXJuIHsgdmFsaWRhdG9yczogW10sIHByb3Bvc2VyOiB1bmRlZmluZWQsIHRvdGFsVm90aW5nUG93ZXI6IFwiMFwiIH07XG59XG5leHBvcnRzLlZhbGlkYXRvclNldCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBtZXNzYWdlLnZhbGlkYXRvcnMpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuVmFsaWRhdG9yLmVuY29kZSh2LCB3cml0ZXIudWludDMyKDEwKS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnByb3Bvc2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuVmFsaWRhdG9yLmVuY29kZShtZXNzYWdlLnByb3Bvc2VyLCB3cml0ZXIudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnRvdGFsVm90aW5nUG93ZXIgIT09IFwiMFwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDI0KS5pbnQ2NChtZXNzYWdlLnRvdGFsVm90aW5nUG93ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVZhbGlkYXRvclNldCgpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsaWRhdG9ycy5wdXNoKGV4cG9ydHMuVmFsaWRhdG9yLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJvcG9zZXIgPSBleHBvcnRzLlZhbGlkYXRvci5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudG90YWxWb3RpbmdQb3dlciA9IGxvbmdUb1N0cmluZyhyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcnM6IEFycmF5LmlzQXJyYXkob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JqZWN0LnZhbGlkYXRvcnMpXG4gICAgICAgICAgICAgICAgPyBvYmplY3QudmFsaWRhdG9ycy5tYXAoKGUpID0+IGV4cG9ydHMuVmFsaWRhdG9yLmZyb21KU09OKGUpKVxuICAgICAgICAgICAgICAgIDogW10sXG4gICAgICAgICAgICBwcm9wb3NlcjogaXNTZXQob2JqZWN0LnByb3Bvc2VyKVxuICAgICAgICAgICAgICAgID8gZXhwb3J0cy5WYWxpZGF0b3IuZnJvbUpTT04ob2JqZWN0LnByb3Bvc2VyKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdG90YWxWb3RpbmdQb3dlcjogaXNTZXQob2JqZWN0LnRvdGFsVm90aW5nUG93ZXIpXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcob2JqZWN0LnRvdGFsVm90aW5nUG93ZXIpXG4gICAgICAgICAgICAgICAgOiBcIjBcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBpZiAobWVzc2FnZS52YWxpZGF0b3JzKSB7XG4gICAgICAgICAgICBvYmoudmFsaWRhdG9ycyA9IG1lc3NhZ2UudmFsaWRhdG9ycy5tYXAoKGUpID0+IGUgPyBleHBvcnRzLlZhbGlkYXRvci50b0pTT04oZSkgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqLnZhbGlkYXRvcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlLnByb3Bvc2VyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucHJvcG9zZXIgPSBtZXNzYWdlLnByb3Bvc2VyXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlZhbGlkYXRvci50b0pTT04obWVzc2FnZS5wcm9wb3NlcilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIG1lc3NhZ2UudG90YWxWb3RpbmdQb3dlciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnRvdGFsVm90aW5nUG93ZXIgPSBtZXNzYWdlLnRvdGFsVm90aW5nUG93ZXIpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVmFsaWRhdG9yU2V0KCk7XG4gICAgICAgIG1lc3NhZ2UudmFsaWRhdG9ycyA9XG4gICAgICAgICAgICAoKF9hID0gb2JqZWN0LnZhbGlkYXRvcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGUpID0+IGV4cG9ydHMuVmFsaWRhdG9yLmZyb21QYXJ0aWFsKGUpKSkgfHwgW107XG4gICAgICAgIG1lc3NhZ2UucHJvcG9zZXIgPVxuICAgICAgICAgICAgb2JqZWN0LnByb3Bvc2VyICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnByb3Bvc2VyICE9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBleHBvcnRzLlZhbGlkYXRvci5mcm9tUGFydGlhbChvYmplY3QucHJvcG9zZXIpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIG1lc3NhZ2UudG90YWxWb3RpbmdQb3dlciA9IChfYiA9IG9iamVjdC50b3RhbFZvdGluZ1Bvd2VyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIjBcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlVmFsaWRhdG9yKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IG5ldyBVaW50OEFycmF5KCksXG4gICAgICAgIHB1YktleTogdW5kZWZpbmVkLFxuICAgICAgICB2b3RpbmdQb3dlcjogXCIwXCIsXG4gICAgICAgIHByb3Bvc2VyUHJpb3JpdHk6IFwiMFwiLFxuICAgIH07XG59XG5leHBvcnRzLlZhbGlkYXRvciA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmFkZHJlc3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDEwKS5ieXRlcyhtZXNzYWdlLmFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnB1YktleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBrZXlzXzEuUHVibGljS2V5LmVuY29kZShtZXNzYWdlLnB1YktleSwgd3JpdGVyLnVpbnQzMigxOCkuZm9yaygpKS5sZGVsaW0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZS52b3RpbmdQb3dlciAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMjQpLmludDY0KG1lc3NhZ2Uudm90aW5nUG93ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnByb3Bvc2VyUHJpb3JpdHkgIT09IFwiMFwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDMyKS5pbnQ2NChtZXNzYWdlLnByb3Bvc2VyUHJpb3JpdHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSxcbiAgICBkZWNvZGUoaW5wdXQsIGxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBpbnB1dCBpbnN0YW5jZW9mIG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlciA/IGlucHV0IDogbmV3IG1pbmltYWxfMS5kZWZhdWx0LlJlYWRlcihpbnB1dCk7XG4gICAgICAgIGxldCBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVZhbGlkYXRvcigpO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRkcmVzcyA9IHJlYWRlci5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHViS2V5ID0ga2V5c18xLlB1YmxpY0tleS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uudm90aW5nUG93ZXIgPSBsb25nVG9TdHJpbmcocmVhZGVyLmludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJvcG9zZXJQcmlvcml0eSA9IGxvbmdUb1N0cmluZyhyZWFkZXIuaW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGlzU2V0KG9iamVjdC5hZGRyZXNzKVxuICAgICAgICAgICAgICAgID8gYnl0ZXNGcm9tQmFzZTY0KG9iamVjdC5hZGRyZXNzKVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgICAgIHB1YktleTogaXNTZXQob2JqZWN0LnB1YktleSlcbiAgICAgICAgICAgICAgICA/IGtleXNfMS5QdWJsaWNLZXkuZnJvbUpTT04ob2JqZWN0LnB1YktleSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHZvdGluZ1Bvd2VyOiBpc1NldChvYmplY3Qudm90aW5nUG93ZXIpID8gU3RyaW5nKG9iamVjdC52b3RpbmdQb3dlcikgOiBcIjBcIixcbiAgICAgICAgICAgIHByb3Bvc2VyUHJpb3JpdHk6IGlzU2V0KG9iamVjdC5wcm9wb3NlclByaW9yaXR5KVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKG9iamVjdC5wcm9wb3NlclByaW9yaXR5KVxuICAgICAgICAgICAgICAgIDogXCIwXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5hZGRyZXNzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmouYWRkcmVzcyA9IGJhc2U2NEZyb21CeXRlcyhtZXNzYWdlLmFkZHJlc3MgIT09IHVuZGVmaW5lZCA/IG1lc3NhZ2UuYWRkcmVzcyA6IG5ldyBVaW50OEFycmF5KCkpKTtcbiAgICAgICAgbWVzc2FnZS5wdWJLZXkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKG9iai5wdWJLZXkgPSBtZXNzYWdlLnB1YktleVxuICAgICAgICAgICAgICAgID8ga2V5c18xLlB1YmxpY0tleS50b0pTT04obWVzc2FnZS5wdWJLZXkpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICBtZXNzYWdlLnZvdGluZ1Bvd2VyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoudm90aW5nUG93ZXIgPSBtZXNzYWdlLnZvdGluZ1Bvd2VyKTtcbiAgICAgICAgbWVzc2FnZS5wcm9wb3NlclByaW9yaXR5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucHJvcG9zZXJQcmlvcml0eSA9IG1lc3NhZ2UucHJvcG9zZXJQcmlvcml0eSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlVmFsaWRhdG9yKCk7XG4gICAgICAgIG1lc3NhZ2UuYWRkcmVzcyA9IChfYSA9IG9iamVjdC5hZGRyZXNzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlLnB1YktleSA9XG4gICAgICAgICAgICBvYmplY3QucHViS2V5ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnB1YktleSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8ga2V5c18xLlB1YmxpY0tleS5mcm9tUGFydGlhbChvYmplY3QucHViS2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnZvdGluZ1Bvd2VyID0gKF9iID0gb2JqZWN0LnZvdGluZ1Bvd2VyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIjBcIjtcbiAgICAgICAgbWVzc2FnZS5wcm9wb3NlclByaW9yaXR5ID0gKF9jID0gb2JqZWN0LnByb3Bvc2VyUHJpb3JpdHkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFwiMFwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUJhc2VTaW1wbGVWYWxpZGF0b3IoKSB7XG4gICAgcmV0dXJuIHsgcHViS2V5OiB1bmRlZmluZWQsIHZvdGluZ1Bvd2VyOiBcIjBcIiB9O1xufVxuZXhwb3J0cy5TaW1wbGVWYWxpZGF0b3IgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5wdWJLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAga2V5c18xLlB1YmxpY0tleS5lbmNvZGUobWVzc2FnZS5wdWJLZXksIHdyaXRlci51aW50MzIoMTApLmZvcmsoKSkubGRlbGltKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uudm90aW5nUG93ZXIgIT09IFwiMFwiKSB7XG4gICAgICAgICAgICB3cml0ZXIudWludDMyKDE2KS5pbnQ2NChtZXNzYWdlLnZvdGluZ1Bvd2VyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VTaW1wbGVWYWxpZGF0b3IoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnB1YktleSA9IGtleXNfMS5QdWJsaWNLZXkuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZvdGluZ1Bvd2VyID0gbG9uZ1RvU3RyaW5nKHJlYWRlci5pbnQ2NCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHViS2V5OiBpc1NldChvYmplY3QucHViS2V5KVxuICAgICAgICAgICAgICAgID8ga2V5c18xLlB1YmxpY0tleS5mcm9tSlNPTihvYmplY3QucHViS2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdm90aW5nUG93ZXI6IGlzU2V0KG9iamVjdC52b3RpbmdQb3dlcikgPyBTdHJpbmcob2JqZWN0LnZvdGluZ1Bvd2VyKSA6IFwiMFwiLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgdG9KU09OKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG1lc3NhZ2UucHViS2V5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChvYmoucHViS2V5ID0gbWVzc2FnZS5wdWJLZXlcbiAgICAgICAgICAgICAgICA/IGtleXNfMS5QdWJsaWNLZXkudG9KU09OKG1lc3NhZ2UucHViS2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgbWVzc2FnZS52b3RpbmdQb3dlciAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAob2JqLnZvdGluZ1Bvd2VyID0gbWVzc2FnZS52b3RpbmdQb3dlcik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBmcm9tUGFydGlhbChvYmplY3QpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZVNpbXBsZVZhbGlkYXRvcigpO1xuICAgICAgICBtZXNzYWdlLnB1YktleSA9XG4gICAgICAgICAgICBvYmplY3QucHViS2V5ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0LnB1YktleSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgID8ga2V5c18xLlB1YmxpY0tleS5mcm9tUGFydGlhbChvYmplY3QucHViS2V5KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBtZXNzYWdlLnZvdGluZ1Bvd2VyID0gKF9hID0gb2JqZWN0LnZvdGluZ1Bvd2VyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIjBcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG52YXIgZ2xvYmFsVGhpcyA9ICgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsVGhpcztcbiAgICBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIHRocm93IFwiVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0XCI7XG59KSgpO1xuY29uc3QgYXRvYiA9IGdsb2JhbFRoaXMuYXRvYiB8fFxuICAgICgoYjY0KSA9PiBnbG9iYWxUaGlzLkJ1ZmZlci5mcm9tKGI2NCwgXCJiYXNlNjRcIikudG9TdHJpbmcoXCJiaW5hcnlcIikpO1xuZnVuY3Rpb24gYnl0ZXNGcm9tQmFzZTY0KGI2NCkge1xuICAgIGNvbnN0IGJpbiA9IGF0b2IoYjY0KTtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShiaW4ubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBhcnJbaV0gPSBiaW4uY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmNvbnN0IGJ0b2EgPSBnbG9iYWxUaGlzLmJ0b2EgfHxcbiAgICAoKGJpbikgPT4gZ2xvYmFsVGhpcy5CdWZmZXIuZnJvbShiaW4sIFwiYmluYXJ5XCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpKTtcbmZ1bmN0aW9uIGJhc2U2NEZyb21CeXRlcyhhcnIpIHtcbiAgICBjb25zdCBiaW4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGJ5dGUgb2YgYXJyKSB7XG4gICAgICAgIGJpbi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYShiaW4uam9pbihcIlwiKSk7XG59XG5mdW5jdGlvbiBsb25nVG9TdHJpbmcobG9uZykge1xuICAgIHJldHVybiBsb25nLnRvU3RyaW5nKCk7XG59XG5pZiAobWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nICE9PSBsb25nXzEuZGVmYXVsdCkge1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LnV0aWwuTG9uZyA9IGxvbmdfMS5kZWZhdWx0O1xuICAgIG1pbmltYWxfMS5kZWZhdWx0LmNvbmZpZ3VyZSgpO1xufVxuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/tendermint/types/validator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/proto-types/tendermint/version/types.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@keplr-wallet/proto-types/tendermint/version/types.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Consensus = exports.App = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\"));\nconst minimal_1 = __importDefault(__webpack_require__(/*! protobufjs/minimal */ \"(ssr)/./node_modules/protobufjs/minimal.js\"));\nexports.protobufPackage = \"tendermint.version\";\nfunction createBaseApp() {\n    return { protocol: \"0\", software: \"\" };\n}\nexports.App = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.protocol !== \"0\") {\n            writer.uint32(8).uint64(message.protocol);\n        }\n        if (message.software !== \"\") {\n            writer.uint32(18).string(message.software);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseApp();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.protocol = longToString(reader.uint64());\n                    break;\n                case 2:\n                    message.software = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            protocol: isSet(object.protocol) ? String(object.protocol) : \"0\",\n            software: isSet(object.software) ? String(object.software) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.protocol !== undefined && (obj.protocol = message.protocol);\n        message.software !== undefined && (obj.software = message.software);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseApp();\n        message.protocol = (_a = object.protocol) !== null && _a !== void 0 ? _a : \"0\";\n        message.software = (_b = object.software) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseConsensus() {\n    return { block: \"0\", app: \"0\" };\n}\nexports.Consensus = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.block !== \"0\") {\n            writer.uint32(8).uint64(message.block);\n        }\n        if (message.app !== \"0\") {\n            writer.uint32(16).uint64(message.app);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseConsensus();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.block = longToString(reader.uint64());\n                    break;\n                case 2:\n                    message.app = longToString(reader.uint64());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            block: isSet(object.block) ? String(object.block) : \"0\",\n            app: isSet(object.app) ? String(object.app) : \"0\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.block !== undefined && (obj.block = message.block);\n        message.app !== undefined && (obj.app = message.app);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseConsensus();\n        message.block = (_a = object.block) !== null && _a !== void 0 ? _a : \"0\";\n        message.app = (_b = object.app) !== null && _b !== void 0 ? _b : \"0\";\n        return message;\n    },\n};\nfunction longToString(long) {\n    return long.toString();\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy90ZW5kZXJtaW50L3ZlcnNpb24vdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxXQUFXLEdBQUcsdUJBQXVCO0FBQ3pEO0FBQ0EsK0JBQStCLG1CQUFPLENBQUMsbURBQU07QUFDN0Msa0NBQWtDLG1CQUFPLENBQUMsc0VBQW9CO0FBQzlELHVCQUF1QjtBQUN2QjtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9wcm90by10eXBlcy90ZW5kZXJtaW50L3ZlcnNpb24vdHlwZXMuanM/MWVkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29uc2Vuc3VzID0gZXhwb3J0cy5BcHAgPSBleHBvcnRzLnByb3RvYnVmUGFja2FnZSA9IHZvaWQgMDtcbi8qIGVzbGludC1kaXNhYmxlICovXG5jb25zdCBsb25nXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvbmdcIikpO1xuY29uc3QgbWluaW1hbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwcm90b2J1ZmpzL21pbmltYWxcIikpO1xuZXhwb3J0cy5wcm90b2J1ZlBhY2thZ2UgPSBcInRlbmRlcm1pbnQudmVyc2lvblwiO1xuZnVuY3Rpb24gY3JlYXRlQmFzZUFwcCgpIHtcbiAgICByZXR1cm4geyBwcm90b2NvbDogXCIwXCIsIHNvZnR3YXJlOiBcIlwiIH07XG59XG5leHBvcnRzLkFwcCA9IHtcbiAgICBlbmNvZGUobWVzc2FnZSwgd3JpdGVyID0gbWluaW1hbF8xLmRlZmF1bHQuV3JpdGVyLmNyZWF0ZSgpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnByb3RvY29sICE9PSBcIjBcIikge1xuICAgICAgICAgICAgd3JpdGVyLnVpbnQzMig4KS51aW50NjQobWVzc2FnZS5wcm90b2NvbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc29mdHdhcmUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTgpLnN0cmluZyhtZXNzYWdlLnNvZnR3YXJlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgZGVjb2RlKGlucHV0LCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gaW5wdXQgaW5zdGFuY2VvZiBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIgPyBpbnB1dCA6IG5ldyBtaW5pbWFsXzEuZGVmYXVsdC5SZWFkZXIoaW5wdXQpO1xuICAgICAgICBsZXQgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aDtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNyZWF0ZUJhc2VBcHAoKTtcbiAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByb3RvY29sID0gbG9uZ1RvU3RyaW5nKHJlYWRlci51aW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5zb2Z0d2FyZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIGZyb21KU09OKG9iamVjdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvdG9jb2w6IGlzU2V0KG9iamVjdC5wcm90b2NvbCkgPyBTdHJpbmcob2JqZWN0LnByb3RvY29sKSA6IFwiMFwiLFxuICAgICAgICAgICAgc29mdHdhcmU6IGlzU2V0KG9iamVjdC5zb2Z0d2FyZSkgPyBTdHJpbmcob2JqZWN0LnNvZnR3YXJlKSA6IFwiXCIsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICB0b0pTT04obWVzc2FnZSkge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgbWVzc2FnZS5wcm90b2NvbCAhPT0gdW5kZWZpbmVkICYmIChvYmoucHJvdG9jb2wgPSBtZXNzYWdlLnByb3RvY29sKTtcbiAgICAgICAgbWVzc2FnZS5zb2Z0d2FyZSAhPT0gdW5kZWZpbmVkICYmIChvYmouc29mdHdhcmUgPSBtZXNzYWdlLnNvZnR3YXJlKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIGZyb21QYXJ0aWFsKG9iamVjdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gY3JlYXRlQmFzZUFwcCgpO1xuICAgICAgICBtZXNzYWdlLnByb3RvY29sID0gKF9hID0gb2JqZWN0LnByb3RvY29sKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIjBcIjtcbiAgICAgICAgbWVzc2FnZS5zb2Z0d2FyZSA9IChfYiA9IG9iamVjdC5zb2Z0d2FyZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBjcmVhdGVCYXNlQ29uc2Vuc3VzKCkge1xuICAgIHJldHVybiB7IGJsb2NrOiBcIjBcIiwgYXBwOiBcIjBcIiB9O1xufVxuZXhwb3J0cy5Db25zZW5zdXMgPSB7XG4gICAgZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciA9IG1pbmltYWxfMS5kZWZhdWx0LldyaXRlci5jcmVhdGUoKSkge1xuICAgICAgICBpZiAobWVzc2FnZS5ibG9jayAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoOCkudWludDY0KG1lc3NhZ2UuYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLmFwcCAhPT0gXCIwXCIpIHtcbiAgICAgICAgICAgIHdyaXRlci51aW50MzIoMTYpLnVpbnQ2NChtZXNzYWdlLmFwcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICB9LFxuICAgIGRlY29kZShpbnB1dCwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IGlucHV0IGluc3RhbmNlb2YgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyID8gaW5wdXQgOiBuZXcgbWluaW1hbF8xLmRlZmF1bHQuUmVhZGVyKGlucHV0KTtcbiAgICAgICAgbGV0IGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29uc2Vuc3VzKCk7XG4gICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5ibG9jayA9IGxvbmdUb1N0cmluZyhyZWFkZXIudWludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYXBwID0gbG9uZ1RvU3RyaW5nKHJlYWRlci51aW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfSxcbiAgICBmcm9tSlNPTihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJsb2NrOiBpc1NldChvYmplY3QuYmxvY2spID8gU3RyaW5nKG9iamVjdC5ibG9jaykgOiBcIjBcIixcbiAgICAgICAgICAgIGFwcDogaXNTZXQob2JqZWN0LmFwcCkgPyBTdHJpbmcob2JqZWN0LmFwcCkgOiBcIjBcIixcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHRvSlNPTihtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBtZXNzYWdlLmJsb2NrICE9PSB1bmRlZmluZWQgJiYgKG9iai5ibG9jayA9IG1lc3NhZ2UuYmxvY2spO1xuICAgICAgICBtZXNzYWdlLmFwcCAhPT0gdW5kZWZpbmVkICYmIChvYmouYXBwID0gbWVzc2FnZS5hcHApO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgZnJvbVBhcnRpYWwob2JqZWN0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjcmVhdGVCYXNlQ29uc2Vuc3VzKCk7XG4gICAgICAgIG1lc3NhZ2UuYmxvY2sgPSAoX2EgPSBvYmplY3QuYmxvY2spICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiMFwiO1xuICAgICAgICBtZXNzYWdlLmFwcCA9IChfYiA9IG9iamVjdC5hcHApICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiMFwiO1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGxvbmdUb1N0cmluZyhsb25nKSB7XG4gICAgcmV0dXJuIGxvbmcudG9TdHJpbmcoKTtcbn1cbmlmIChtaW5pbWFsXzEuZGVmYXVsdC51dGlsLkxvbmcgIT09IGxvbmdfMS5kZWZhdWx0KSB7XG4gICAgbWluaW1hbF8xLmRlZmF1bHQudXRpbC5Mb25nID0gbG9uZ18xLmRlZmF1bHQ7XG4gICAgbWluaW1hbF8xLmRlZmF1bHQuY29uZmlndXJlKCk7XG59XG5mdW5jdGlvbiBpc1NldCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/proto-types/tendermint/version/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/simple-fetch/build/error.js":
/*!****************************************************************!*\
  !*** ./node_modules/@keplr-wallet/simple-fetch/build/error.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isSimpleFetchError = exports.SimpleFetchError = void 0;\nclass SimpleFetchError extends Error {\n    constructor(baseURL, url, response) {\n        super(`Failed to get response from ${new URL(url, baseURL).toString()}`);\n        this.baseURL = baseURL;\n        this.url = url;\n        this.response = response;\n        // Set the prototype explicitly.\n        Object.setPrototypeOf(this, SimpleFetchError.prototype);\n    }\n}\nexports.SimpleFetchError = SimpleFetchError;\nfunction isSimpleFetchError(payload) {\n    return payload instanceof SimpleFetchError;\n}\nexports.isSimpleFetchError = isSimpleFetchError;\n//# sourceMappingURL=error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9zaW1wbGUtZmV0Y2gvYnVpbGQvZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsd0JBQXdCO0FBQ3JEO0FBQ0E7QUFDQSw2Q0FBNkMsaUNBQWlDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvc2ltcGxlLWZldGNoL2J1aWxkL2Vycm9yLmpzP2I1N2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzU2ltcGxlRmV0Y2hFcnJvciA9IGV4cG9ydHMuU2ltcGxlRmV0Y2hFcnJvciA9IHZvaWQgMDtcbmNsYXNzIFNpbXBsZUZldGNoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoYmFzZVVSTCwgdXJsLCByZXNwb25zZSkge1xuICAgICAgICBzdXBlcihgRmFpbGVkIHRvIGdldCByZXNwb25zZSBmcm9tICR7bmV3IFVSTCh1cmwsIGJhc2VVUkwpLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIHRoaXMuYmFzZVVSTCA9IGJhc2VVUkw7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIC8vIFNldCB0aGUgcHJvdG90eXBlIGV4cGxpY2l0bHkuXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBTaW1wbGVGZXRjaEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5TaW1wbGVGZXRjaEVycm9yID0gU2ltcGxlRmV0Y2hFcnJvcjtcbmZ1bmN0aW9uIGlzU2ltcGxlRmV0Y2hFcnJvcihwYXlsb2FkKSB7XG4gICAgcmV0dXJuIHBheWxvYWQgaW5zdGFuY2VvZiBTaW1wbGVGZXRjaEVycm9yO1xufVxuZXhwb3J0cy5pc1NpbXBsZUZldGNoRXJyb3IgPSBpc1NpbXBsZUZldGNoRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/simple-fetch/build/error.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/simple-fetch/build/fetch.js":
/*!****************************************************************!*\
  !*** ./node_modules/@keplr-wallet/simple-fetch/build/fetch.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.simpleFetch = exports.makeURL = void 0;\nconst error_1 = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/@keplr-wallet/simple-fetch/build/error.js\");\nfunction makeURL(baseURL, url) {\n    const baseURLInstance = new URL(baseURL);\n    baseURL = removeLastSlashIfIs(baseURLInstance.origin);\n    url =\n        removeLastSlashIfIs(baseURLInstance.pathname) +\n            \"/\" +\n            removeFirstSlashIfIs(url);\n    return removeLastSlashIfIs(baseURL + \"/\" + removeFirstSlashIfIs(url));\n}\nexports.makeURL = makeURL;\nfunction removeFirstSlashIfIs(str) {\n    if (str.length > 0 && str[0] === \"/\") {\n        return str.slice(1);\n    }\n    return str;\n}\nfunction removeLastSlashIfIs(str) {\n    if (str.length > 0 && str[str.length - 1] === \"/\") {\n        return str.slice(0, str.length - 1);\n    }\n    return str;\n}\nfunction simpleFetch(baseURL, url, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (typeof url !== \"string\") {\n            if (url) {\n                options = url;\n            }\n            url = \"\";\n        }\n        if (url === \"/\") {\n            // If url is \"/\", probably its mean should be to use only base url.\n            // However, `URL` with \"/\" url generate the root url with removing trailing url from base url.\n            // To prevent this invalid case, just handle \"/\" as \"\".\n            url = \"\";\n        }\n        const actualURL = makeURL(baseURL, url);\n        const _a = options || {}, { headers: optionHeaders } = _a, otherOptions = __rest(_a, [\"headers\"]);\n        const fetched = yield fetch(actualURL, Object.assign({ headers: Object.assign({ accept: \"application/json, text/plain, */*\" }, optionHeaders) }, otherOptions));\n        let data;\n        const contentType = fetched.headers.get(\"content-type\") || \"\";\n        if (contentType.startsWith(\"application/json\")) {\n            data = yield fetched.json();\n        }\n        else {\n            const r = yield fetched.text();\n            const trim = r.trim();\n            if (trim.startsWith(\"{\") && trim.endsWith(\"}\")) {\n                data = JSON.parse(trim);\n            }\n            else {\n                data = r;\n            }\n        }\n        const res = {\n            url: actualURL,\n            data,\n            headers: fetched.headers,\n            status: fetched.status,\n            statusText: fetched.statusText,\n        };\n        const validateStatusFn = (options === null || options === void 0 ? void 0 : options.validateStatus) || defaultValidateStatusFn;\n        if (!validateStatusFn(fetched.status)) {\n            throw new error_1.SimpleFetchError(baseURL, url, res);\n        }\n        return res;\n    });\n}\nexports.simpleFetch = simpleFetch;\nfunction defaultValidateStatusFn(status) {\n    return status === 200;\n}\n//# sourceMappingURL=fetch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9zaW1wbGUtZmV0Y2gvYnVpbGQvZmV0Y2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsZUFBZTtBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLElBQUkseUJBQXlCO0FBQzdELCtEQUErRCx5QkFBeUIsNkNBQTZDLGtCQUFrQjtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNCQUFzQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L3NpbXBsZS1mZXRjaC9idWlsZC9mZXRjaC5qcz82MmJhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNpbXBsZUZldGNoID0gZXhwb3J0cy5tYWtlVVJMID0gdm9pZCAwO1xuY29uc3QgZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xuZnVuY3Rpb24gbWFrZVVSTChiYXNlVVJMLCB1cmwpIHtcbiAgICBjb25zdCBiYXNlVVJMSW5zdGFuY2UgPSBuZXcgVVJMKGJhc2VVUkwpO1xuICAgIGJhc2VVUkwgPSByZW1vdmVMYXN0U2xhc2hJZklzKGJhc2VVUkxJbnN0YW5jZS5vcmlnaW4pO1xuICAgIHVybCA9XG4gICAgICAgIHJlbW92ZUxhc3RTbGFzaElmSXMoYmFzZVVSTEluc3RhbmNlLnBhdGhuYW1lKSArXG4gICAgICAgICAgICBcIi9cIiArXG4gICAgICAgICAgICByZW1vdmVGaXJzdFNsYXNoSWZJcyh1cmwpO1xuICAgIHJldHVybiByZW1vdmVMYXN0U2xhc2hJZklzKGJhc2VVUkwgKyBcIi9cIiArIHJlbW92ZUZpcnN0U2xhc2hJZklzKHVybCkpO1xufVxuZXhwb3J0cy5tYWtlVVJMID0gbWFrZVVSTDtcbmZ1bmN0aW9uIHJlbW92ZUZpcnN0U2xhc2hJZklzKHN0cikge1xuICAgIGlmIChzdHIubGVuZ3RoID4gMCAmJiBzdHJbMF0gPT09IFwiL1wiKSB7XG4gICAgICAgIHJldHVybiBzdHIuc2xpY2UoMSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiByZW1vdmVMYXN0U2xhc2hJZklzKHN0cikge1xuICAgIGlmIChzdHIubGVuZ3RoID4gMCAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdID09PSBcIi9cIikge1xuICAgICAgICByZXR1cm4gc3RyLnNsaWNlKDAsIHN0ci5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIHNpbXBsZUZldGNoKGJhc2VVUkwsIHVybCwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVybCA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVybCA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgIC8vIElmIHVybCBpcyBcIi9cIiwgcHJvYmFibHkgaXRzIG1lYW4gc2hvdWxkIGJlIHRvIHVzZSBvbmx5IGJhc2UgdXJsLlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgYFVSTGAgd2l0aCBcIi9cIiB1cmwgZ2VuZXJhdGUgdGhlIHJvb3QgdXJsIHdpdGggcmVtb3ZpbmcgdHJhaWxpbmcgdXJsIGZyb20gYmFzZSB1cmwuXG4gICAgICAgICAgICAvLyBUbyBwcmV2ZW50IHRoaXMgaW52YWxpZCBjYXNlLCBqdXN0IGhhbmRsZSBcIi9cIiBhcyBcIlwiLlxuICAgICAgICAgICAgdXJsID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY3R1YWxVUkwgPSBtYWtlVVJMKGJhc2VVUkwsIHVybCk7XG4gICAgICAgIGNvbnN0IF9hID0gb3B0aW9ucyB8fCB7fSwgeyBoZWFkZXJzOiBvcHRpb25IZWFkZXJzIH0gPSBfYSwgb3RoZXJPcHRpb25zID0gX19yZXN0KF9hLCBbXCJoZWFkZXJzXCJdKTtcbiAgICAgICAgY29uc3QgZmV0Y2hlZCA9IHlpZWxkIGZldGNoKGFjdHVhbFVSTCwgT2JqZWN0LmFzc2lnbih7IGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oeyBhY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qXCIgfSwgb3B0aW9uSGVhZGVycykgfSwgb3RoZXJPcHRpb25zKSk7XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGZldGNoZWQuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgfHwgXCJcIjtcbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICAgICAgICBkYXRhID0geWllbGQgZmV0Y2hlZC5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByID0geWllbGQgZmV0Y2hlZC50ZXh0KCk7XG4gICAgICAgICAgICBjb25zdCB0cmltID0gci50cmltKCk7XG4gICAgICAgICAgICBpZiAodHJpbS5zdGFydHNXaXRoKFwie1wiKSAmJiB0cmltLmVuZHNXaXRoKFwifVwiKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHRyaW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgICAgdXJsOiBhY3R1YWxVUkwsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgaGVhZGVyczogZmV0Y2hlZC5oZWFkZXJzLFxuICAgICAgICAgICAgc3RhdHVzOiBmZXRjaGVkLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IGZldGNoZWQuc3RhdHVzVGV4dCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVTdGF0dXNGbiA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmFsaWRhdGVTdGF0dXMpIHx8IGRlZmF1bHRWYWxpZGF0ZVN0YXR1c0ZuO1xuICAgICAgICBpZiAoIXZhbGlkYXRlU3RhdHVzRm4oZmV0Y2hlZC5zdGF0dXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JfMS5TaW1wbGVGZXRjaEVycm9yKGJhc2VVUkwsIHVybCwgcmVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xufVxuZXhwb3J0cy5zaW1wbGVGZXRjaCA9IHNpbXBsZUZldGNoO1xuZnVuY3Rpb24gZGVmYXVsdFZhbGlkYXRlU3RhdHVzRm4oc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gMjAwO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2guanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/simple-fetch/build/fetch.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/simple-fetch/build/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@keplr-wallet/simple-fetch/build/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./fetch */ \"(ssr)/./node_modules/@keplr-wallet/simple-fetch/build/fetch.js\"), exports);\n__exportStar(__webpack_require__(/*! ./error */ \"(ssr)/./node_modules/@keplr-wallet/simple-fetch/build/error.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@keplr-wallet/simple-fetch/build/types.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9zaW1wbGUtZmV0Y2gvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLCtFQUFTO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQywrRUFBUztBQUM5QixhQUFhLG1CQUFPLENBQUMsK0VBQVM7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L3NpbXBsZS1mZXRjaC9idWlsZC9pbmRleC5qcz8wZDM0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZmV0Y2hcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Vycm9yXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlc1wiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/simple-fetch/build/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/simple-fetch/build/types.js":
/*!****************************************************************!*\
  !*** ./node_modules/@keplr-wallet/simple-fetch/build/types.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC9zaW1wbGUtZmV0Y2gvYnVpbGQvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L3NpbXBsZS1mZXRjaC9idWlsZC90eXBlcy5qcz9kYTMxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/simple-fetch/build/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/unit/build/coin-pretty.js":
/*!**************************************************************!*\
  !*** ./node_modules/@keplr-wallet/unit/build/coin-pretty.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CoinPretty = void 0;\nconst int_pretty_1 = __webpack_require__(/*! ./int-pretty */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/int-pretty.js\");\nconst decimal_1 = __webpack_require__(/*! ./decimal */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/decimal.js\");\nconst dec_utils_1 = __webpack_require__(/*! ./dec-utils */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/dec-utils.js\");\nclass CoinPretty {\n    constructor(_currency, amount) {\n        this._currency = _currency;\n        this._options = {\n            separator: \" \",\n            upperCase: false,\n            lowerCase: false,\n            hideDenom: false,\n            hideIBCMetadata: false,\n        };\n        if (typeof amount === \"object\" && \"toDec\" in amount) {\n            amount = amount.toDec();\n        }\n        else if (!(amount instanceof decimal_1.Dec)) {\n            amount = new decimal_1.Dec(amount);\n        }\n        this.intPretty = new int_pretty_1.IntPretty(amount.quoTruncate(dec_utils_1.DecUtils.getTenExponentNInPrecisionRange(_currency.coinDecimals))).maxDecimals(_currency.coinDecimals);\n    }\n    get options() {\n        return Object.assign(Object.assign({}, this._options), this.intPretty.options);\n    }\n    get denom() {\n        return this.currency.coinDenom;\n    }\n    get currency() {\n        return this._currency;\n    }\n    setCurrency(currency) {\n        const pretty = this.clone();\n        pretty.intPretty = this.intPretty.moveDecimalPointRight(this._currency.coinDecimals - currency.coinDecimals);\n        pretty._currency = currency;\n        return pretty;\n    }\n    separator(str) {\n        const pretty = this.clone();\n        pretty._options.separator = str;\n        return pretty;\n    }\n    upperCase(bool) {\n        const pretty = this.clone();\n        pretty._options.upperCase = bool;\n        pretty._options.lowerCase = !bool;\n        return pretty;\n    }\n    lowerCase(bool) {\n        const pretty = this.clone();\n        pretty._options.lowerCase = bool;\n        pretty._options.upperCase = !bool;\n        return pretty;\n    }\n    hideDenom(bool) {\n        const pretty = this.clone();\n        pretty._options.hideDenom = bool;\n        return pretty;\n    }\n    hideIBCMetadata(bool) {\n        const pretty = this.clone();\n        pretty._options.hideIBCMetadata = bool;\n        return pretty;\n    }\n    moveDecimalPointLeft(delta) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.moveDecimalPointLeft(delta);\n        return pretty;\n    }\n    moveDecimalPointRight(delta) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.moveDecimalPointRight(delta);\n        return pretty;\n    }\n    /**\n     * @deprecated Use`moveDecimalPointLeft`\n     */\n    increasePrecision(delta) {\n        return this.moveDecimalPointLeft(delta);\n    }\n    /**\n     * @deprecated Use`moveDecimalPointRight`\n     */\n    decreasePrecision(delta) {\n        return this.moveDecimalPointRight(delta);\n    }\n    maxDecimals(max) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.maxDecimals(max);\n        return pretty;\n    }\n    inequalitySymbol(bool) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.inequalitySymbol(bool);\n        return pretty;\n    }\n    inequalitySymbolSeparator(str) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.inequalitySymbolSeparator(str);\n        return pretty;\n    }\n    trim(bool) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.trim(bool);\n        return pretty;\n    }\n    shrink(bool) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.shrink(bool);\n        return pretty;\n    }\n    locale(locale) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.locale(locale);\n        return pretty;\n    }\n    /**\n     * Ready indicates the actual value is ready to show the users.\n     * Even if the ready option is false, it expects that the value can be shown to users (probably as 0).\n     * The method that returns prettied value may return `undefined` or `null` if the value is not ready.\n     * But, alternatively, it can return the 0 value that can be shown the users anyway, but indicates that the value is not ready.\n     * @param bool\n     */\n    ready(bool) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.ready(bool);\n        return pretty;\n    }\n    get isReady() {\n        return this.intPretty.isReady;\n    }\n    add(target) {\n        const isCoinPretty = target instanceof CoinPretty;\n        if (isCoinPretty) {\n            // If target is `CoinPretty` and it has different denom, do nothing.\n            if (\"currency\" in target &&\n                this.currency.coinMinimalDenom !== target.currency.coinMinimalDenom) {\n                return this.clone();\n            }\n        }\n        if (\"toDec\" in target) {\n            target = target.toDec();\n        }\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.add(isCoinPretty\n            ? target\n            : target.mul(dec_utils_1.DecUtils.getTenExponentNInPrecisionRange(-this._currency.coinDecimals)));\n        return pretty;\n    }\n    sub(target) {\n        const isCoinPretty = target instanceof CoinPretty;\n        if (isCoinPretty) {\n            // If target is `CoinPretty` and it has different denom, do nothing.\n            if (\"currency\" in target &&\n                this.currency.coinMinimalDenom !== target.currency.coinMinimalDenom) {\n                return this.clone();\n            }\n        }\n        if (\"toDec\" in target) {\n            target = target.toDec();\n        }\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.sub(isCoinPretty\n            ? target\n            : target.mul(dec_utils_1.DecUtils.getTenExponentNInPrecisionRange(-this._currency.coinDecimals)));\n        return pretty;\n    }\n    mul(target) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.mul(target);\n        return pretty;\n    }\n    quo(target) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.quo(target);\n        return pretty;\n    }\n    toDec() {\n        return this.intPretty.toDec();\n    }\n    toCoin() {\n        const amount = this.toDec()\n            .mulTruncate(dec_utils_1.DecUtils.getTenExponentNInPrecisionRange(this.currency.coinDecimals))\n            .truncate();\n        return {\n            denom: this.currency.coinMinimalDenom,\n            amount: amount.toString(),\n        };\n    }\n    toString() {\n        let denom = this.denom;\n        if (this._options.hideIBCMetadata &&\n            \"originCurrency\" in this.currency &&\n            this.currency.originCurrency) {\n            denom = this.currency.originCurrency.coinDenom;\n        }\n        if (this._options.upperCase) {\n            denom = denom.toUpperCase();\n        }\n        if (this._options.lowerCase) {\n            denom = denom.toLowerCase();\n        }\n        let separator = this._options.separator;\n        if (this._options.hideDenom) {\n            denom = \"\";\n            separator = \"\";\n        }\n        return this.intPretty.toStringWithSymbols(\"\", `${separator}${denom}`);\n    }\n    clone() {\n        const pretty = new CoinPretty(this._currency, 0);\n        pretty._options = Object.assign({}, this._options);\n        pretty.intPretty = this.intPretty.clone();\n        return pretty;\n    }\n}\nexports.CoinPretty = CoinPretty;\n//# sourceMappingURL=coin-pretty.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC91bml0L2J1aWxkL2NvaW4tcHJldHR5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixxQkFBcUIsbUJBQU8sQ0FBQyxpRkFBYztBQUMzQyxrQkFBa0IsbUJBQU8sQ0FBQywyRUFBVztBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQywrRUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsVUFBVSxFQUFFLE1BQU07QUFDM0U7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC91bml0L2J1aWxkL2NvaW4tcHJldHR5LmpzP2U5OWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvaW5QcmV0dHkgPSB2b2lkIDA7XG5jb25zdCBpbnRfcHJldHR5XzEgPSByZXF1aXJlKFwiLi9pbnQtcHJldHR5XCIpO1xuY29uc3QgZGVjaW1hbF8xID0gcmVxdWlyZShcIi4vZGVjaW1hbFwiKTtcbmNvbnN0IGRlY191dGlsc18xID0gcmVxdWlyZShcIi4vZGVjLXV0aWxzXCIpO1xuY2xhc3MgQ29pblByZXR0eSB7XG4gICAgY29uc3RydWN0b3IoX2N1cnJlbmN5LCBhbW91bnQpIHtcbiAgICAgICAgdGhpcy5fY3VycmVuY3kgPSBfY3VycmVuY3k7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSB7XG4gICAgICAgICAgICBzZXBhcmF0b3I6IFwiIFwiLFxuICAgICAgICAgICAgdXBwZXJDYXNlOiBmYWxzZSxcbiAgICAgICAgICAgIGxvd2VyQ2FzZTogZmFsc2UsXG4gICAgICAgICAgICBoaWRlRGVub206IGZhbHNlLFxuICAgICAgICAgICAgaGlkZUlCQ01ldGFkYXRhOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBhbW91bnQgPT09IFwib2JqZWN0XCIgJiYgXCJ0b0RlY1wiIGluIGFtb3VudCkge1xuICAgICAgICAgICAgYW1vdW50ID0gYW1vdW50LnRvRGVjKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShhbW91bnQgaW5zdGFuY2VvZiBkZWNpbWFsXzEuRGVjKSkge1xuICAgICAgICAgICAgYW1vdW50ID0gbmV3IGRlY2ltYWxfMS5EZWMoYW1vdW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludFByZXR0eSA9IG5ldyBpbnRfcHJldHR5XzEuSW50UHJldHR5KGFtb3VudC5xdW9UcnVuY2F0ZShkZWNfdXRpbHNfMS5EZWNVdGlscy5nZXRUZW5FeHBvbmVudE5JblByZWNpc2lvblJhbmdlKF9jdXJyZW5jeS5jb2luRGVjaW1hbHMpKSkubWF4RGVjaW1hbHMoX2N1cnJlbmN5LmNvaW5EZWNpbWFscyk7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9vcHRpb25zKSwgdGhpcy5pbnRQcmV0dHkub3B0aW9ucyk7XG4gICAgfVxuICAgIGdldCBkZW5vbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVuY3kuY29pbkRlbm9tO1xuICAgIH1cbiAgICBnZXQgY3VycmVuY3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW5jeTtcbiAgICB9XG4gICAgc2V0Q3VycmVuY3koY3VycmVuY3kpIHtcbiAgICAgICAgY29uc3QgcHJldHR5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwcmV0dHkuaW50UHJldHR5ID0gdGhpcy5pbnRQcmV0dHkubW92ZURlY2ltYWxQb2ludFJpZ2h0KHRoaXMuX2N1cnJlbmN5LmNvaW5EZWNpbWFscyAtIGN1cnJlbmN5LmNvaW5EZWNpbWFscyk7XG4gICAgICAgIHByZXR0eS5fY3VycmVuY3kgPSBjdXJyZW5jeTtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgc2VwYXJhdG9yKHN0cikge1xuICAgICAgICBjb25zdCBwcmV0dHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHByZXR0eS5fb3B0aW9ucy5zZXBhcmF0b3IgPSBzdHI7XG4gICAgICAgIHJldHVybiBwcmV0dHk7XG4gICAgfVxuICAgIHVwcGVyQ2FzZShib29sKSB7XG4gICAgICAgIGNvbnN0IHByZXR0eSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcHJldHR5Ll9vcHRpb25zLnVwcGVyQ2FzZSA9IGJvb2w7XG4gICAgICAgIHByZXR0eS5fb3B0aW9ucy5sb3dlckNhc2UgPSAhYm9vbDtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgbG93ZXJDYXNlKGJvb2wpIHtcbiAgICAgICAgY29uc3QgcHJldHR5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwcmV0dHkuX29wdGlvbnMubG93ZXJDYXNlID0gYm9vbDtcbiAgICAgICAgcHJldHR5Ll9vcHRpb25zLnVwcGVyQ2FzZSA9ICFib29sO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICBoaWRlRGVub20oYm9vbCkge1xuICAgICAgICBjb25zdCBwcmV0dHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHByZXR0eS5fb3B0aW9ucy5oaWRlRGVub20gPSBib29sO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICBoaWRlSUJDTWV0YWRhdGEoYm9vbCkge1xuICAgICAgICBjb25zdCBwcmV0dHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHByZXR0eS5fb3B0aW9ucy5oaWRlSUJDTWV0YWRhdGEgPSBib29sO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICBtb3ZlRGVjaW1hbFBvaW50TGVmdChkZWx0YSkge1xuICAgICAgICBjb25zdCBwcmV0dHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHByZXR0eS5pbnRQcmV0dHkgPSBwcmV0dHkuaW50UHJldHR5Lm1vdmVEZWNpbWFsUG9pbnRMZWZ0KGRlbHRhKTtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgbW92ZURlY2ltYWxQb2ludFJpZ2h0KGRlbHRhKSB7XG4gICAgICAgIGNvbnN0IHByZXR0eSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcHJldHR5LmludFByZXR0eSA9IHByZXR0eS5pbnRQcmV0dHkubW92ZURlY2ltYWxQb2ludFJpZ2h0KGRlbHRhKTtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlYG1vdmVEZWNpbWFsUG9pbnRMZWZ0YFxuICAgICAqL1xuICAgIGluY3JlYXNlUHJlY2lzaW9uKGRlbHRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdmVEZWNpbWFsUG9pbnRMZWZ0KGRlbHRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlYG1vdmVEZWNpbWFsUG9pbnRSaWdodGBcbiAgICAgKi9cbiAgICBkZWNyZWFzZVByZWNpc2lvbihkZWx0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3ZlRGVjaW1hbFBvaW50UmlnaHQoZGVsdGEpO1xuICAgIH1cbiAgICBtYXhEZWNpbWFscyhtYXgpIHtcbiAgICAgICAgY29uc3QgcHJldHR5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwcmV0dHkuaW50UHJldHR5ID0gcHJldHR5LmludFByZXR0eS5tYXhEZWNpbWFscyhtYXgpO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICBpbmVxdWFsaXR5U3ltYm9sKGJvb2wpIHtcbiAgICAgICAgY29uc3QgcHJldHR5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwcmV0dHkuaW50UHJldHR5ID0gcHJldHR5LmludFByZXR0eS5pbmVxdWFsaXR5U3ltYm9sKGJvb2wpO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICBpbmVxdWFsaXR5U3ltYm9sU2VwYXJhdG9yKHN0cikge1xuICAgICAgICBjb25zdCBwcmV0dHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHByZXR0eS5pbnRQcmV0dHkgPSBwcmV0dHkuaW50UHJldHR5LmluZXF1YWxpdHlTeW1ib2xTZXBhcmF0b3Ioc3RyKTtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgdHJpbShib29sKSB7XG4gICAgICAgIGNvbnN0IHByZXR0eSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcHJldHR5LmludFByZXR0eSA9IHByZXR0eS5pbnRQcmV0dHkudHJpbShib29sKTtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgc2hyaW5rKGJvb2wpIHtcbiAgICAgICAgY29uc3QgcHJldHR5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwcmV0dHkuaW50UHJldHR5ID0gcHJldHR5LmludFByZXR0eS5zaHJpbmsoYm9vbCk7XG4gICAgICAgIHJldHVybiBwcmV0dHk7XG4gICAgfVxuICAgIGxvY2FsZShsb2NhbGUpIHtcbiAgICAgICAgY29uc3QgcHJldHR5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwcmV0dHkuaW50UHJldHR5ID0gcHJldHR5LmludFByZXR0eS5sb2NhbGUobG9jYWxlKTtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHkgaW5kaWNhdGVzIHRoZSBhY3R1YWwgdmFsdWUgaXMgcmVhZHkgdG8gc2hvdyB0aGUgdXNlcnMuXG4gICAgICogRXZlbiBpZiB0aGUgcmVhZHkgb3B0aW9uIGlzIGZhbHNlLCBpdCBleHBlY3RzIHRoYXQgdGhlIHZhbHVlIGNhbiBiZSBzaG93biB0byB1c2VycyAocHJvYmFibHkgYXMgMCkuXG4gICAgICogVGhlIG1ldGhvZCB0aGF0IHJldHVybnMgcHJldHRpZWQgdmFsdWUgbWF5IHJldHVybiBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaWYgdGhlIHZhbHVlIGlzIG5vdCByZWFkeS5cbiAgICAgKiBCdXQsIGFsdGVybmF0aXZlbHksIGl0IGNhbiByZXR1cm4gdGhlIDAgdmFsdWUgdGhhdCBjYW4gYmUgc2hvd24gdGhlIHVzZXJzIGFueXdheSwgYnV0IGluZGljYXRlcyB0aGF0IHRoZSB2YWx1ZSBpcyBub3QgcmVhZHkuXG4gICAgICogQHBhcmFtIGJvb2xcbiAgICAgKi9cbiAgICByZWFkeShib29sKSB7XG4gICAgICAgIGNvbnN0IHByZXR0eSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcHJldHR5LmludFByZXR0eSA9IHByZXR0eS5pbnRQcmV0dHkucmVhZHkoYm9vbCk7XG4gICAgICAgIHJldHVybiBwcmV0dHk7XG4gICAgfVxuICAgIGdldCBpc1JlYWR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRQcmV0dHkuaXNSZWFkeTtcbiAgICB9XG4gICAgYWRkKHRhcmdldCkge1xuICAgICAgICBjb25zdCBpc0NvaW5QcmV0dHkgPSB0YXJnZXQgaW5zdGFuY2VvZiBDb2luUHJldHR5O1xuICAgICAgICBpZiAoaXNDb2luUHJldHR5KSB7XG4gICAgICAgICAgICAvLyBJZiB0YXJnZXQgaXMgYENvaW5QcmV0dHlgIGFuZCBpdCBoYXMgZGlmZmVyZW50IGRlbm9tLCBkbyBub3RoaW5nLlxuICAgICAgICAgICAgaWYgKFwiY3VycmVuY3lcIiBpbiB0YXJnZXQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbmN5LmNvaW5NaW5pbWFsRGVub20gIT09IHRhcmdldC5jdXJyZW5jeS5jb2luTWluaW1hbERlbm9tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJ0b0RlY1wiIGluIHRhcmdldCkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnRvRGVjKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldHR5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwcmV0dHkuaW50UHJldHR5ID0gcHJldHR5LmludFByZXR0eS5hZGQoaXNDb2luUHJldHR5XG4gICAgICAgICAgICA/IHRhcmdldFxuICAgICAgICAgICAgOiB0YXJnZXQubXVsKGRlY191dGlsc18xLkRlY1V0aWxzLmdldFRlbkV4cG9uZW50TkluUHJlY2lzaW9uUmFuZ2UoLXRoaXMuX2N1cnJlbmN5LmNvaW5EZWNpbWFscykpKTtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgc3ViKHRhcmdldCkge1xuICAgICAgICBjb25zdCBpc0NvaW5QcmV0dHkgPSB0YXJnZXQgaW5zdGFuY2VvZiBDb2luUHJldHR5O1xuICAgICAgICBpZiAoaXNDb2luUHJldHR5KSB7XG4gICAgICAgICAgICAvLyBJZiB0YXJnZXQgaXMgYENvaW5QcmV0dHlgIGFuZCBpdCBoYXMgZGlmZmVyZW50IGRlbm9tLCBkbyBub3RoaW5nLlxuICAgICAgICAgICAgaWYgKFwiY3VycmVuY3lcIiBpbiB0YXJnZXQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbmN5LmNvaW5NaW5pbWFsRGVub20gIT09IHRhcmdldC5jdXJyZW5jeS5jb2luTWluaW1hbERlbm9tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJ0b0RlY1wiIGluIHRhcmdldCkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnRvRGVjKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldHR5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwcmV0dHkuaW50UHJldHR5ID0gcHJldHR5LmludFByZXR0eS5zdWIoaXNDb2luUHJldHR5XG4gICAgICAgICAgICA/IHRhcmdldFxuICAgICAgICAgICAgOiB0YXJnZXQubXVsKGRlY191dGlsc18xLkRlY1V0aWxzLmdldFRlbkV4cG9uZW50TkluUHJlY2lzaW9uUmFuZ2UoLXRoaXMuX2N1cnJlbmN5LmNvaW5EZWNpbWFscykpKTtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgbXVsKHRhcmdldCkge1xuICAgICAgICBjb25zdCBwcmV0dHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHByZXR0eS5pbnRQcmV0dHkgPSBwcmV0dHkuaW50UHJldHR5Lm11bCh0YXJnZXQpO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICBxdW8odGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHByZXR0eSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcHJldHR5LmludFByZXR0eSA9IHByZXR0eS5pbnRQcmV0dHkucXVvKHRhcmdldCk7XG4gICAgICAgIHJldHVybiBwcmV0dHk7XG4gICAgfVxuICAgIHRvRGVjKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRQcmV0dHkudG9EZWMoKTtcbiAgICB9XG4gICAgdG9Db2luKCkge1xuICAgICAgICBjb25zdCBhbW91bnQgPSB0aGlzLnRvRGVjKClcbiAgICAgICAgICAgIC5tdWxUcnVuY2F0ZShkZWNfdXRpbHNfMS5EZWNVdGlscy5nZXRUZW5FeHBvbmVudE5JblByZWNpc2lvblJhbmdlKHRoaXMuY3VycmVuY3kuY29pbkRlY2ltYWxzKSlcbiAgICAgICAgICAgIC50cnVuY2F0ZSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVub206IHRoaXMuY3VycmVuY3kuY29pbk1pbmltYWxEZW5vbSxcbiAgICAgICAgICAgIGFtb3VudDogYW1vdW50LnRvU3RyaW5nKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgZGVub20gPSB0aGlzLmRlbm9tO1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5oaWRlSUJDTWV0YWRhdGEgJiZcbiAgICAgICAgICAgIFwib3JpZ2luQ3VycmVuY3lcIiBpbiB0aGlzLmN1cnJlbmN5ICYmXG4gICAgICAgICAgICB0aGlzLmN1cnJlbmN5Lm9yaWdpbkN1cnJlbmN5KSB7XG4gICAgICAgICAgICBkZW5vbSA9IHRoaXMuY3VycmVuY3kub3JpZ2luQ3VycmVuY3kuY29pbkRlbm9tO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnVwcGVyQ2FzZSkge1xuICAgICAgICAgICAgZGVub20gPSBkZW5vbS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmxvd2VyQ2FzZSkge1xuICAgICAgICAgICAgZGVub20gPSBkZW5vbS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZXBhcmF0b3IgPSB0aGlzLl9vcHRpb25zLnNlcGFyYXRvcjtcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuaGlkZURlbm9tKSB7XG4gICAgICAgICAgICBkZW5vbSA9IFwiXCI7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmludFByZXR0eS50b1N0cmluZ1dpdGhTeW1ib2xzKFwiXCIsIGAke3NlcGFyYXRvcn0ke2Rlbm9tfWApO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgcHJldHR5ID0gbmV3IENvaW5QcmV0dHkodGhpcy5fY3VycmVuY3ksIDApO1xuICAgICAgICBwcmV0dHkuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9vcHRpb25zKTtcbiAgICAgICAgcHJldHR5LmludFByZXR0eSA9IHRoaXMuaW50UHJldHR5LmNsb25lKCk7XG4gICAgICAgIHJldHVybiBwcmV0dHk7XG4gICAgfVxufVxuZXhwb3J0cy5Db2luUHJldHR5ID0gQ29pblByZXR0eTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvaW4tcHJldHR5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/unit/build/coin-pretty.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/unit/build/coin-utils.js":
/*!*************************************************************!*\
  !*** ./node_modules/@keplr-wallet/unit/build/coin-utils.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CoinUtils = void 0;\nconst coin_1 = __webpack_require__(/*! ./coin */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/coin.js\");\nconst int_1 = __webpack_require__(/*! ./int */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/int.js\");\nconst decimal_1 = __webpack_require__(/*! ./decimal */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/decimal.js\");\nconst dec_utils_1 = __webpack_require__(/*! ./dec-utils */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/dec-utils.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/utils.js\");\nclass CoinUtils {\n    static createCoinsFromPrimitives(coinPrimitives) {\n        return coinPrimitives.map((primitive) => {\n            return new coin_1.Coin(primitive.denom, primitive.amount);\n        });\n    }\n    static amountOf(coins, denom) {\n        const coin = coins.find((coin) => {\n            return coin.denom === denom;\n        });\n        if (!coin) {\n            return new int_1.Int(0);\n        }\n        else {\n            return coin.amount;\n        }\n    }\n    static exclude(coins, demons) {\n        return coins.filter((coin) => {\n            return demons.indexOf(coin.denom) === 0;\n        });\n    }\n    static concat(...coins) {\n        if (coins.length === 0) {\n            return [];\n        }\n        const arr = coins.slice();\n        const reducer = (accumulator, coin) => {\n            // Find the duplicated denom.\n            const find = accumulator.find((c) => c.denom === coin.denom);\n            // If duplicated coin exists, add the amount to duplicated one.\n            if (find) {\n                const newCoin = new coin_1.Coin(find.denom, find.amount.add(coin.amount));\n                accumulator.push(newCoin);\n            }\n            else {\n                const newCoin = new coin_1.Coin(coin.denom, coin.amount);\n                accumulator.push(newCoin);\n            }\n            return accumulator;\n        };\n        return arr.reduce(reducer, []);\n    }\n    static getCoinFromDecimals(currencies, decAmountStr, denom) {\n        const currency = currencies.find((currency) => {\n            return currency.coinDenom === denom;\n        });\n        if (!currency) {\n            throw new Error(\"Invalid currency\");\n        }\n        let precision = new decimal_1.Dec(1);\n        for (let i = 0; i < currency.coinDecimals; i++) {\n            precision = precision.mul(new decimal_1.Dec(10));\n        }\n        let decAmount = new decimal_1.Dec(decAmountStr);\n        decAmount = decAmount.mul(precision);\n        if (!new decimal_1.Dec(decAmount.truncate()).equals(decAmount)) {\n            throw new Error(\"Can't divide anymore\");\n        }\n        return new coin_1.Coin(currency.coinMinimalDenom, decAmount.truncate());\n    }\n    static parseDecAndDenomFromCoin(currencies, coin) {\n        let currency = currencies.find((currency) => {\n            return currency.coinMinimalDenom === coin.denom;\n        });\n        if (!currency) {\n            // If the currency is unknown, just use the raw currency.\n            currency = {\n                coinDecimals: 0,\n                coinDenom: coin.denom,\n                coinMinimalDenom: coin.denom,\n            };\n        }\n        let precision = new decimal_1.Dec(1);\n        for (let i = 0; i < currency.coinDecimals; i++) {\n            precision = precision.mul(new decimal_1.Dec(10));\n        }\n        const decAmount = new decimal_1.Dec(coin.amount).quoTruncate(precision);\n        return {\n            amount: decAmount.toString(currency.coinDecimals),\n            denom: currency.coinDenom,\n        };\n    }\n    static shrinkDecimals(dec, minDecimals, maxDecimals, locale = false) {\n        if (dec.equals(new decimal_1.Dec(0))) {\n            return \"0\";\n        }\n        const isNeg = dec.isNegative();\n        const integer = dec.abs().truncate();\n        const fraction = dec.abs().sub(new decimal_1.Dec(integer));\n        const decimals = Math.max(maxDecimals - integer.toString().length + 1, minDecimals);\n        const fractionStr = decimals === 0 ? \"\" : fraction.toString(decimals).replace(\"0.\", \"\");\n        const integerStr = locale\n            ? CoinUtils.integerStringToUSLocaleString(integer.toString())\n            : integer.toString();\n        return ((isNeg ? \"-\" : \"\") +\n            integerStr +\n            (fractionStr.length > 0 ? \".\" : \"\") +\n            fractionStr);\n    }\n    static coinToTrimmedString(coin, currency, separator = \" \") {\n        const dec = new decimal_1.Dec(coin.amount).quoTruncate(dec_utils_1.DecUtils.getPrecisionDec(currency.coinDecimals));\n        return `${dec_utils_1.DecUtils.trim(dec)}${separator}${currency.coinDenom}`;\n    }\n}\nexports.CoinUtils = CoinUtils;\nCoinUtils.integerStringToUSLocaleString = utils_1.integerStringToUSLocaleString;\n//# sourceMappingURL=coin-utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC91bml0L2J1aWxkL2NvaW4tdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLGVBQWUsbUJBQU8sQ0FBQyxxRUFBUTtBQUMvQixjQUFjLG1CQUFPLENBQUMsbUVBQU87QUFDN0Isa0JBQWtCLG1CQUFPLENBQUMsMkVBQVc7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsK0VBQWE7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsdUVBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrQkFBK0IsRUFBRSxVQUFVLEVBQUUsbUJBQW1CO0FBQ2xGO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvdW5pdC9idWlsZC9jb2luLXV0aWxzLmpzPzJmYjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvaW5VdGlscyA9IHZvaWQgMDtcbmNvbnN0IGNvaW5fMSA9IHJlcXVpcmUoXCIuL2NvaW5cIik7XG5jb25zdCBpbnRfMSA9IHJlcXVpcmUoXCIuL2ludFwiKTtcbmNvbnN0IGRlY2ltYWxfMSA9IHJlcXVpcmUoXCIuL2RlY2ltYWxcIik7XG5jb25zdCBkZWNfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2RlYy11dGlsc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNsYXNzIENvaW5VdGlscyB7XG4gICAgc3RhdGljIGNyZWF0ZUNvaW5zRnJvbVByaW1pdGl2ZXMoY29pblByaW1pdGl2ZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvaW5QcmltaXRpdmVzLm1hcCgocHJpbWl0aXZlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvaW5fMS5Db2luKHByaW1pdGl2ZS5kZW5vbSwgcHJpbWl0aXZlLmFtb3VudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgYW1vdW50T2YoY29pbnMsIGRlbm9tKSB7XG4gICAgICAgIGNvbnN0IGNvaW4gPSBjb2lucy5maW5kKChjb2luKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY29pbi5kZW5vbSA9PT0gZGVub207XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNvaW4pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgaW50XzEuSW50KDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvaW4uYW1vdW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBleGNsdWRlKGNvaW5zLCBkZW1vbnMpIHtcbiAgICAgICAgcmV0dXJuIGNvaW5zLmZpbHRlcigoY29pbikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRlbW9ucy5pbmRleE9mKGNvaW4uZGVub20pID09PSAwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGNvbmNhdCguLi5jb2lucykge1xuICAgICAgICBpZiAoY29pbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJyID0gY29pbnMuc2xpY2UoKTtcbiAgICAgICAgY29uc3QgcmVkdWNlciA9IChhY2N1bXVsYXRvciwgY29pbikgPT4ge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgZHVwbGljYXRlZCBkZW5vbS5cbiAgICAgICAgICAgIGNvbnN0IGZpbmQgPSBhY2N1bXVsYXRvci5maW5kKChjKSA9PiBjLmRlbm9tID09PSBjb2luLmRlbm9tKTtcbiAgICAgICAgICAgIC8vIElmIGR1cGxpY2F0ZWQgY29pbiBleGlzdHMsIGFkZCB0aGUgYW1vdW50IHRvIGR1cGxpY2F0ZWQgb25lLlxuICAgICAgICAgICAgaWYgKGZpbmQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDb2luID0gbmV3IGNvaW5fMS5Db2luKGZpbmQuZGVub20sIGZpbmQuYW1vdW50LmFkZChjb2luLmFtb3VudCkpO1xuICAgICAgICAgICAgICAgIGFjY3VtdWxhdG9yLnB1c2gobmV3Q29pbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDb2luID0gbmV3IGNvaW5fMS5Db2luKGNvaW4uZGVub20sIGNvaW4uYW1vdW50KTtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRvci5wdXNoKG5ld0NvaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXJyLnJlZHVjZShyZWR1Y2VyLCBbXSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRDb2luRnJvbURlY2ltYWxzKGN1cnJlbmNpZXMsIGRlY0Ftb3VudFN0ciwgZGVub20pIHtcbiAgICAgICAgY29uc3QgY3VycmVuY3kgPSBjdXJyZW5jaWVzLmZpbmQoKGN1cnJlbmN5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVuY3kuY29pbkRlbm9tID09PSBkZW5vbTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghY3VycmVuY3kpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY3VycmVuY3lcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZWNpc2lvbiA9IG5ldyBkZWNpbWFsXzEuRGVjKDEpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmN5LmNvaW5EZWNpbWFsczsgaSsrKSB7XG4gICAgICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24ubXVsKG5ldyBkZWNpbWFsXzEuRGVjKDEwKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlY0Ftb3VudCA9IG5ldyBkZWNpbWFsXzEuRGVjKGRlY0Ftb3VudFN0cik7XG4gICAgICAgIGRlY0Ftb3VudCA9IGRlY0Ftb3VudC5tdWwocHJlY2lzaW9uKTtcbiAgICAgICAgaWYgKCFuZXcgZGVjaW1hbF8xLkRlYyhkZWNBbW91bnQudHJ1bmNhdGUoKSkuZXF1YWxzKGRlY0Ftb3VudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGRpdmlkZSBhbnltb3JlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgY29pbl8xLkNvaW4oY3VycmVuY3kuY29pbk1pbmltYWxEZW5vbSwgZGVjQW1vdW50LnRydW5jYXRlKCkpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2VEZWNBbmREZW5vbUZyb21Db2luKGN1cnJlbmNpZXMsIGNvaW4pIHtcbiAgICAgICAgbGV0IGN1cnJlbmN5ID0gY3VycmVuY2llcy5maW5kKChjdXJyZW5jeSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbmN5LmNvaW5NaW5pbWFsRGVub20gPT09IGNvaW4uZGVub207XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWN1cnJlbmN5KSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY3VycmVuY3kgaXMgdW5rbm93biwganVzdCB1c2UgdGhlIHJhdyBjdXJyZW5jeS5cbiAgICAgICAgICAgIGN1cnJlbmN5ID0ge1xuICAgICAgICAgICAgICAgIGNvaW5EZWNpbWFsczogMCxcbiAgICAgICAgICAgICAgICBjb2luRGVub206IGNvaW4uZGVub20sXG4gICAgICAgICAgICAgICAgY29pbk1pbmltYWxEZW5vbTogY29pbi5kZW5vbSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZWNpc2lvbiA9IG5ldyBkZWNpbWFsXzEuRGVjKDEpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbmN5LmNvaW5EZWNpbWFsczsgaSsrKSB7XG4gICAgICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24ubXVsKG5ldyBkZWNpbWFsXzEuRGVjKDEwKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVjQW1vdW50ID0gbmV3IGRlY2ltYWxfMS5EZWMoY29pbi5hbW91bnQpLnF1b1RydW5jYXRlKHByZWNpc2lvbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbW91bnQ6IGRlY0Ftb3VudC50b1N0cmluZyhjdXJyZW5jeS5jb2luRGVjaW1hbHMpLFxuICAgICAgICAgICAgZGVub206IGN1cnJlbmN5LmNvaW5EZW5vbSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIHNocmlua0RlY2ltYWxzKGRlYywgbWluRGVjaW1hbHMsIG1heERlY2ltYWxzLCBsb2NhbGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAoZGVjLmVxdWFscyhuZXcgZGVjaW1hbF8xLkRlYygwKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc05lZyA9IGRlYy5pc05lZ2F0aXZlKCk7XG4gICAgICAgIGNvbnN0IGludGVnZXIgPSBkZWMuYWJzKCkudHJ1bmNhdGUoKTtcbiAgICAgICAgY29uc3QgZnJhY3Rpb24gPSBkZWMuYWJzKCkuc3ViKG5ldyBkZWNpbWFsXzEuRGVjKGludGVnZXIpKTtcbiAgICAgICAgY29uc3QgZGVjaW1hbHMgPSBNYXRoLm1heChtYXhEZWNpbWFscyAtIGludGVnZXIudG9TdHJpbmcoKS5sZW5ndGggKyAxLCBtaW5EZWNpbWFscyk7XG4gICAgICAgIGNvbnN0IGZyYWN0aW9uU3RyID0gZGVjaW1hbHMgPT09IDAgPyBcIlwiIDogZnJhY3Rpb24udG9TdHJpbmcoZGVjaW1hbHMpLnJlcGxhY2UoXCIwLlwiLCBcIlwiKTtcbiAgICAgICAgY29uc3QgaW50ZWdlclN0ciA9IGxvY2FsZVxuICAgICAgICAgICAgPyBDb2luVXRpbHMuaW50ZWdlclN0cmluZ1RvVVNMb2NhbGVTdHJpbmcoaW50ZWdlci50b1N0cmluZygpKVxuICAgICAgICAgICAgOiBpbnRlZ2VyLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiAoKGlzTmVnID8gXCItXCIgOiBcIlwiKSArXG4gICAgICAgICAgICBpbnRlZ2VyU3RyICtcbiAgICAgICAgICAgIChmcmFjdGlvblN0ci5sZW5ndGggPiAwID8gXCIuXCIgOiBcIlwiKSArXG4gICAgICAgICAgICBmcmFjdGlvblN0cik7XG4gICAgfVxuICAgIHN0YXRpYyBjb2luVG9UcmltbWVkU3RyaW5nKGNvaW4sIGN1cnJlbmN5LCBzZXBhcmF0b3IgPSBcIiBcIikge1xuICAgICAgICBjb25zdCBkZWMgPSBuZXcgZGVjaW1hbF8xLkRlYyhjb2luLmFtb3VudCkucXVvVHJ1bmNhdGUoZGVjX3V0aWxzXzEuRGVjVXRpbHMuZ2V0UHJlY2lzaW9uRGVjKGN1cnJlbmN5LmNvaW5EZWNpbWFscykpO1xuICAgICAgICByZXR1cm4gYCR7ZGVjX3V0aWxzXzEuRGVjVXRpbHMudHJpbShkZWMpfSR7c2VwYXJhdG9yfSR7Y3VycmVuY3kuY29pbkRlbm9tfWA7XG4gICAgfVxufVxuZXhwb3J0cy5Db2luVXRpbHMgPSBDb2luVXRpbHM7XG5Db2luVXRpbHMuaW50ZWdlclN0cmluZ1RvVVNMb2NhbGVTdHJpbmcgPSB1dGlsc18xLmludGVnZXJTdHJpbmdUb1VTTG9jYWxlU3RyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29pbi11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/unit/build/coin-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/unit/build/coin.js":
/*!*******************************************************!*\
  !*** ./node_modules/@keplr-wallet/unit/build/coin.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Coin = void 0;\nconst int_1 = __webpack_require__(/*! ./int */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/int.js\");\nclass Coin {\n    static parse(str) {\n        const re = new RegExp(\"([0-9]+)[ ]*([a-zA-Z]+)$\");\n        const execed = re.exec(str);\n        if (!execed || execed.length !== 3) {\n            throw new Error(\"Invalid coin str\");\n        }\n        const denom = execed[2];\n        const amount = execed[1];\n        return new Coin(denom, amount);\n    }\n    constructor(denom, amount) {\n        this.denom = denom;\n        this.amount = amount instanceof int_1.Int ? amount : new int_1.Int(amount);\n    }\n    toString() {\n        return `${this.amount.toString()}${this.denom}`;\n    }\n}\nexports.Coin = Coin;\n//# sourceMappingURL=coin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC91bml0L2J1aWxkL2NvaW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWTtBQUNaLGNBQWMsbUJBQU8sQ0FBQyxtRUFBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUIsRUFBRSxXQUFXO0FBQ3REO0FBQ0E7QUFDQSxZQUFZO0FBQ1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L3VuaXQvYnVpbGQvY29pbi5qcz84YWQ3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2luID0gdm9pZCAwO1xuY29uc3QgaW50XzEgPSByZXF1aXJlKFwiLi9pbnRcIik7XG5jbGFzcyBDb2luIHtcbiAgICBzdGF0aWMgcGFyc2Uoc3RyKSB7XG4gICAgICAgIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChcIihbMC05XSspWyBdKihbYS16QS1aXSspJFwiKTtcbiAgICAgICAgY29uc3QgZXhlY2VkID0gcmUuZXhlYyhzdHIpO1xuICAgICAgICBpZiAoIWV4ZWNlZCB8fCBleGVjZWQubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvaW4gc3RyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbm9tID0gZXhlY2VkWzJdO1xuICAgICAgICBjb25zdCBhbW91bnQgPSBleGVjZWRbMV07XG4gICAgICAgIHJldHVybiBuZXcgQ29pbihkZW5vbSwgYW1vdW50KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZGVub20sIGFtb3VudCkge1xuICAgICAgICB0aGlzLmRlbm9tID0gZGVub207XG4gICAgICAgIHRoaXMuYW1vdW50ID0gYW1vdW50IGluc3RhbmNlb2YgaW50XzEuSW50ID8gYW1vdW50IDogbmV3IGludF8xLkludChhbW91bnQpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuYW1vdW50LnRvU3RyaW5nKCl9JHt0aGlzLmRlbm9tfWA7XG4gICAgfVxufVxuZXhwb3J0cy5Db2luID0gQ29pbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvaW4uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/unit/build/coin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/unit/build/dec-utils.js":
/*!************************************************************!*\
  !*** ./node_modules/@keplr-wallet/unit/build/dec-utils.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DecUtils = void 0;\nconst decimal_1 = __webpack_require__(/*! ./decimal */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/decimal.js\");\nconst int_1 = __webpack_require__(/*! ./int */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/int.js\");\nclass DecUtils {\n    static trim(dec) {\n        let decStr = typeof dec === \"string\" ? dec : dec.toString();\n        if (decStr.indexOf(\".\") < 0) {\n            return decStr;\n        }\n        for (let i = decStr.length - 1; i >= 0; i--) {\n            if (decStr[i] === \"0\") {\n                decStr = decStr.slice(0, i);\n            }\n            else {\n                break;\n            }\n        }\n        if (decStr.length > 0) {\n            if (decStr[decStr.length - 1] === \".\") {\n                decStr = decStr.slice(0, decStr.length - 1);\n            }\n        }\n        return decStr;\n    }\n    static getTenExponentN(n) {\n        if (n < -decimal_1.Dec.precision) {\n            // Dec can only handle up to precision 18.\n            // Anything less than 18 precision is 0, so there is a high probability of an error.\n            throw new Error(\"Too little precision\");\n        }\n        if (DecUtils.tenExponentNs[n.toString()]) {\n            return DecUtils.tenExponentNs[n.toString()];\n        }\n        const dec = new decimal_1.Dec(10).pow(new int_1.Int(n));\n        DecUtils.tenExponentNs[n.toString()] = dec;\n        return dec;\n    }\n    static getTenExponentNInPrecisionRange(n) {\n        if (n > decimal_1.Dec.precision) {\n            throw new Error(\"Too much precision\");\n        }\n        return DecUtils.getTenExponentN(n);\n    }\n    /**\n     * @deprecated Use`getTenExponentNInPrecisionRange`\n     */\n    static getPrecisionDec(precision) {\n        return DecUtils.getTenExponentNInPrecisionRange(precision);\n    }\n}\nexports.DecUtils = DecUtils;\nDecUtils.tenExponentNs = {};\n//# sourceMappingURL=dec-utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC91bml0L2J1aWxkL2RlYy11dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsa0JBQWtCLG1CQUFPLENBQUMsMkVBQVc7QUFDckMsY0FBYyxtQkFBTyxDQUFDLG1FQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L3VuaXQvYnVpbGQvZGVjLXV0aWxzLmpzPzA0NGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlY1V0aWxzID0gdm9pZCAwO1xuY29uc3QgZGVjaW1hbF8xID0gcmVxdWlyZShcIi4vZGVjaW1hbFwiKTtcbmNvbnN0IGludF8xID0gcmVxdWlyZShcIi4vaW50XCIpO1xuY2xhc3MgRGVjVXRpbHMge1xuICAgIHN0YXRpYyB0cmltKGRlYykge1xuICAgICAgICBsZXQgZGVjU3RyID0gdHlwZW9mIGRlYyA9PT0gXCJzdHJpbmdcIiA/IGRlYyA6IGRlYy50b1N0cmluZygpO1xuICAgICAgICBpZiAoZGVjU3RyLmluZGV4T2YoXCIuXCIpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlY1N0cjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gZGVjU3RyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoZGVjU3RyW2ldID09PSBcIjBcIikge1xuICAgICAgICAgICAgICAgIGRlY1N0ciA9IGRlY1N0ci5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWNTdHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKGRlY1N0cltkZWNTdHIubGVuZ3RoIC0gMV0gPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgZGVjU3RyID0gZGVjU3RyLnNsaWNlKDAsIGRlY1N0ci5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVjU3RyO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VGVuRXhwb25lbnROKG4pIHtcbiAgICAgICAgaWYgKG4gPCAtZGVjaW1hbF8xLkRlYy5wcmVjaXNpb24pIHtcbiAgICAgICAgICAgIC8vIERlYyBjYW4gb25seSBoYW5kbGUgdXAgdG8gcHJlY2lzaW9uIDE4LlxuICAgICAgICAgICAgLy8gQW55dGhpbmcgbGVzcyB0aGFuIDE4IHByZWNpc2lvbiBpcyAwLCBzbyB0aGVyZSBpcyBhIGhpZ2ggcHJvYmFiaWxpdHkgb2YgYW4gZXJyb3IuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb28gbGl0dGxlIHByZWNpc2lvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoRGVjVXRpbHMudGVuRXhwb25lbnROc1tuLnRvU3RyaW5nKCldKSB7XG4gICAgICAgICAgICByZXR1cm4gRGVjVXRpbHMudGVuRXhwb25lbnROc1tuLnRvU3RyaW5nKCldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlYyA9IG5ldyBkZWNpbWFsXzEuRGVjKDEwKS5wb3cobmV3IGludF8xLkludChuKSk7XG4gICAgICAgIERlY1V0aWxzLnRlbkV4cG9uZW50TnNbbi50b1N0cmluZygpXSA9IGRlYztcbiAgICAgICAgcmV0dXJuIGRlYztcbiAgICB9XG4gICAgc3RhdGljIGdldFRlbkV4cG9uZW50TkluUHJlY2lzaW9uUmFuZ2Uobikge1xuICAgICAgICBpZiAobiA+IGRlY2ltYWxfMS5EZWMucHJlY2lzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb28gbXVjaCBwcmVjaXNpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY1V0aWxzLmdldFRlbkV4cG9uZW50TihuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlYGdldFRlbkV4cG9uZW50TkluUHJlY2lzaW9uUmFuZ2VgXG4gICAgICovXG4gICAgc3RhdGljIGdldFByZWNpc2lvbkRlYyhwcmVjaXNpb24pIHtcbiAgICAgICAgcmV0dXJuIERlY1V0aWxzLmdldFRlbkV4cG9uZW50TkluUHJlY2lzaW9uUmFuZ2UocHJlY2lzaW9uKTtcbiAgICB9XG59XG5leHBvcnRzLkRlY1V0aWxzID0gRGVjVXRpbHM7XG5EZWNVdGlscy50ZW5FeHBvbmVudE5zID0ge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWMtdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/unit/build/dec-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/unit/build/decimal.js":
/*!**********************************************************!*\
  !*** ./node_modules/@keplr-wallet/unit/build/decimal.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Dec = void 0;\nconst big_integer_1 = __importDefault(__webpack_require__(/*! big-integer */ \"(ssr)/./node_modules/big-integer/BigInteger.js\"));\nconst int_1 = __webpack_require__(/*! ./int */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/int.js\");\nconst etc_1 = __webpack_require__(/*! ./etc */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/etc.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/utils.js\");\nclass Dec {\n    static calcPrecisionMultiplier(prec) {\n        if (prec < 0) {\n            throw new Error(\"Invalid prec\");\n        }\n        if (prec > Dec.precision) {\n            throw new Error(\"Too much precision\");\n        }\n        const key = prec.toString();\n        const cached = Dec.precisionMultipliers.get(key);\n        if (cached) {\n            return cached;\n        }\n        const zerosToAdd = Dec.precision - prec;\n        const multiplier = (0, big_integer_1.default)(10).pow(zerosToAdd);\n        Dec.precisionMultipliers.set(key, multiplier);\n        return multiplier;\n    }\n    static reduceDecimalsFromString(str) {\n        const decimalPointIndex = str.indexOf(\".\");\n        if (decimalPointIndex < 0) {\n            return {\n                res: str,\n                isDownToZero: false,\n            };\n        }\n        const exceededDecimals = str.length - 1 - decimalPointIndex - Dec.precision;\n        if (exceededDecimals <= 0) {\n            return {\n                res: str,\n                isDownToZero: false,\n            };\n        }\n        const res = str.slice(0, str.length - exceededDecimals);\n        return {\n            res,\n            isDownToZero: /^[0.]*$/.test(res),\n        };\n    }\n    /**\n     * Create a new Dec from integer with decimal place at prec\n     * @param int - Parse a number | bigInteger | string into a Dec.\n     * If int is string and contains dot(.), prec is ignored and automatically calculated.\n     * @param prec - Precision\n     */\n    constructor(int, prec = 0) {\n        if (typeof int === \"number\") {\n            int = int.toString();\n        }\n        if (typeof int === \"string\") {\n            if (int.length === 0) {\n                throw new Error(\"empty string\");\n            }\n            if (!(0, etc_1.isValidDecimalString)(int)) {\n                if ((0, etc_1.isExponentDecString)(int)) {\n                    int = (0, etc_1.exponentDecStringToDecString)(int);\n                }\n                else {\n                    throw new Error(`invalid decimal: ${int}`);\n                }\n            }\n            // Even if an input with more than 18 decimals, it does not throw an error and ignores the rest.\n            const reduced = Dec.reduceDecimalsFromString(int);\n            if (reduced.isDownToZero) {\n                // However, as a result, if the input becomes 0, a problem may occur in mul or quo. In this case, print a warning.\n                console.log(`WARNING: Got ${int}. Dec can only handle up to 18 decimals. However, since the decimal point of the input exceeds 18 digits, the remainder is discarded. As a result, input becomes 0.`);\n            }\n            int = reduced.res;\n            if (int.indexOf(\".\") >= 0) {\n                prec = int.length - int.indexOf(\".\") - 1;\n                int = int.replace(\".\", \"\");\n            }\n            this.int = (0, big_integer_1.default)(int);\n        }\n        else if (int instanceof int_1.Int) {\n            this.int = (0, big_integer_1.default)(int.toString());\n        }\n        else if (int instanceof int_1.Uint) {\n            this.int = (0, big_integer_1.default)(int.toString());\n        }\n        else if (typeof int === \"bigint\") {\n            this.int = (0, big_integer_1.default)(int);\n        }\n        else {\n            this.int = (0, big_integer_1.default)(int);\n        }\n        this.int = this.int.multiply(Dec.calcPrecisionMultiplier(prec));\n        this.checkBitLen();\n    }\n    checkBitLen() {\n        if (this.int.abs().gt(Dec.maxDec)) {\n            throw new Error(`Integer out of range ${this.int.toString()}`);\n        }\n    }\n    isZero() {\n        return this.int.eq((0, big_integer_1.default)(0));\n    }\n    isNegative() {\n        return this.int.isNegative();\n    }\n    isPositive() {\n        return this.int.isPositive();\n    }\n    equals(d2) {\n        return this.int.eq(d2.int);\n    }\n    /**\n     * Alias for the greater method.\n     */\n    gt(d2) {\n        return this.int.gt(d2.int);\n    }\n    /**\n     * Alias for the greaterOrEquals method.\n     */\n    gte(d2) {\n        return this.int.geq(d2.int);\n    }\n    /**\n     * Alias for the lesser method.\n     */\n    lt(d2) {\n        return this.int.lt(d2.int);\n    }\n    /**\n     * Alias for the lesserOrEquals method.\n     */\n    lte(d2) {\n        return this.int.leq(d2.int);\n    }\n    /**\n     * reverse the decimal sign.\n     */\n    neg() {\n        return new Dec(this.int.negate(), Dec.precision);\n    }\n    /**\n     * Returns the absolute value of a decimals.\n     */\n    abs() {\n        return new Dec(this.int.abs(), Dec.precision);\n    }\n    add(d2) {\n        return new Dec(this.int.add(d2.int), Dec.precision);\n    }\n    sub(d2) {\n        return new Dec(this.int.subtract(d2.int), Dec.precision);\n    }\n    pow(n) {\n        if (n.isZero()) {\n            return new Dec(1);\n        }\n        if (n.isNegative()) {\n            return new Dec(1).quo(this.pow(n.abs()));\n        }\n        let base = new Dec(this.int, Dec.precision);\n        let tmp = new Dec(1);\n        for (let i = n; i.gt(new int_1.Int(1)); i = i.div(new int_1.Int(2))) {\n            if (!i.mod(new int_1.Int(2)).isZero()) {\n                tmp = tmp.mul(base);\n            }\n            base = base.mul(base);\n        }\n        return base.mul(tmp);\n    }\n    approxSqrt() {\n        return this.approxRoot(2);\n    }\n    approxRoot(root, maxIters = 300) {\n        if (this.isNegative()) {\n            return this.neg().approxRoot(root).neg();\n        }\n        if (root === 1 || this.isZero() || this.equals(Dec.one)) {\n            return this;\n        }\n        if (root === 0) {\n            return Dec.one;\n        }\n        let [guess, delta] = [Dec.one, Dec.one];\n        for (let i = 0; delta.abs().gt(Dec.smallestDec) && i < maxIters; i++) {\n            let prev = guess.pow(new int_1.Int(root - 1));\n            if (prev.isZero()) {\n                prev = Dec.smallestDec;\n            }\n            delta = this.quo(prev);\n            delta = delta.sub(guess);\n            delta = delta.quoTruncate(new Dec(root));\n            guess = guess.add(delta);\n        }\n        return guess;\n    }\n    mul(d2) {\n        return new Dec(this.mulRaw(d2).chopPrecisionAndRound(), Dec.precision);\n    }\n    mulTruncate(d2) {\n        return new Dec(this.mulRaw(d2).chopPrecisionAndTruncate(), Dec.precision);\n    }\n    mulRoundUp(d2) {\n        return new Dec(this.mulRaw(d2).chopPrecisionAndRoundUp(), Dec.precision);\n    }\n    mulRaw(d2) {\n        return new Dec(this.int.multiply(d2.int), Dec.precision);\n    }\n    quo(d2) {\n        return new Dec(this.quoRaw(d2).chopPrecisionAndRound(), Dec.precision);\n    }\n    quoTruncate(d2) {\n        return new Dec(this.quoRaw(d2).chopPrecisionAndTruncate(), Dec.precision);\n    }\n    quoRoundUp(d2) {\n        return new Dec(this.quoRaw(d2).chopPrecisionAndRoundUp(), Dec.precision);\n    }\n    quoRaw(d2) {\n        const precision = Dec.calcPrecisionMultiplier(0);\n        // multiply precision twice\n        const mul = this.int.multiply(precision).multiply(precision);\n        return new Dec(mul.divide(d2.int), Dec.precision);\n    }\n    isInteger() {\n        const precision = Dec.calcPrecisionMultiplier(0);\n        return this.int.remainder(precision).equals((0, big_integer_1.default)(0));\n    }\n    /**\n     * Remove a Precision amount of rightmost digits and perform bankers rounding\n     * on the remainder (gaussian rounding) on the digits which have been removed.\n     */\n    chopPrecisionAndRound() {\n        // Remove the negative and add it back when returning\n        if (this.isNegative()) {\n            const absoulteDec = this.abs();\n            const choped = absoulteDec.chopPrecisionAndRound();\n            return choped.negate();\n        }\n        const precision = Dec.calcPrecisionMultiplier(0);\n        const fivePrecision = precision.divide((0, big_integer_1.default)(2));\n        // Get the truncated quotient and remainder\n        const { quotient, remainder } = this.int.divmod(precision);\n        // If remainder is zero\n        if (remainder.equals((0, big_integer_1.default)(0))) {\n            return quotient;\n        }\n        if (remainder.lt(fivePrecision)) {\n            return quotient;\n        }\n        else if (remainder.gt(fivePrecision)) {\n            return quotient.add((0, big_integer_1.default)(1));\n        }\n        else {\n            // always round to an even number\n            if (quotient.divide((0, big_integer_1.default)(2)).equals((0, big_integer_1.default)(0))) {\n                return quotient;\n            }\n            else {\n                return quotient.add((0, big_integer_1.default)(1));\n            }\n        }\n    }\n    chopPrecisionAndRoundUp() {\n        // Remove the negative and add it back when returning\n        if (this.isNegative()) {\n            const absoulteDec = this.abs();\n            // truncate since d is negative...\n            const choped = absoulteDec.chopPrecisionAndTruncate();\n            return choped.negate();\n        }\n        const precision = Dec.calcPrecisionMultiplier(0);\n        // Get the truncated quotient and remainder\n        const { quotient, remainder } = this.int.divmod(precision);\n        // If remainder is zero\n        if (remainder.equals((0, big_integer_1.default)(0))) {\n            return quotient;\n        }\n        return quotient.add((0, big_integer_1.default)(1));\n    }\n    /**\n     * Similar to chopPrecisionAndRound, but always rounds down\n     */\n    chopPrecisionAndTruncate() {\n        const precision = Dec.calcPrecisionMultiplier(0);\n        return this.int.divide(precision);\n    }\n    toString(prec = Dec.precision, locale = false) {\n        const precision = Dec.calcPrecisionMultiplier(0);\n        const int = this.int.abs();\n        const { quotient: integer, remainder: fraction } = int.divmod(precision);\n        let fractionStr = fraction.toString(10);\n        for (let i = 0, l = fractionStr.length; i < Dec.precision - l; i++) {\n            fractionStr = \"0\" + fractionStr;\n        }\n        fractionStr = fractionStr.substring(0, prec);\n        const isNegative = this.isNegative() &&\n            !(integer.eq((0, big_integer_1.default)(0)) && fractionStr.length === 0);\n        const integerStr = locale\n            ? (0, utils_1.integerStringToUSLocaleString)(integer.toString())\n            : integer.toString();\n        return `${isNegative ? \"-\" : \"\"}${integerStr}${fractionStr.length > 0 ? \".\" + fractionStr : \"\"}`;\n    }\n    round() {\n        return new int_1.Int(this.chopPrecisionAndRound());\n    }\n    roundUp() {\n        return new int_1.Int(this.chopPrecisionAndRoundUp());\n    }\n    truncate() {\n        return new int_1.Int(this.chopPrecisionAndTruncate());\n    }\n    roundDec() {\n        return new Dec(this.chopPrecisionAndRound(), 0);\n    }\n    roundUpDec() {\n        return new Dec(this.chopPrecisionAndRoundUp(), 0);\n    }\n    truncateDec() {\n        return new Dec(this.chopPrecisionAndTruncate(), 0);\n    }\n}\nexports.Dec = Dec;\nDec.precision = 18;\n// Bytes required to represent the above precision is 18.\n// Ceiling[Log2[999 999 999 999 999 999]]\nDec.decimalPrecisionBits = 60;\n// Max bit length for `Dec` is 256 + 60(decimalPrecisionBits)\n// The int in the `Dec` is handled as integer assuming that it has 18 precision.\n// (2 ** (256 + 60) - 1)\nDec.maxDec = (0, big_integer_1.default)(\"133499189745056880149688856635597007162669032647290798121690100488888732861290034376435130433535\");\nDec.precisionMultipliers = new Map();\nDec.zero = new Dec(0);\n/** Smallest `Dec` with current precision. */\nDec.smallestDec = new Dec(\"1\", Dec.precision);\nDec.one = new Dec(1);\nint_1.Int.prototype.toDec = function () {\n    return new Dec(this);\n};\nint_1.Uint.prototype.toDec = function () {\n    return new Dec(this);\n};\n//# sourceMappingURL=decimal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC91bml0L2J1aWxkL2RlY2ltYWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxXQUFXO0FBQ1gsc0NBQXNDLG1CQUFPLENBQUMsbUVBQWE7QUFDM0QsY0FBYyxtQkFBTyxDQUFDLG1FQUFPO0FBQzdCLGNBQWMsbUJBQU8sQ0FBQyxtRUFBTztBQUM3QixnQkFBZ0IsbUJBQU8sQ0FBQyx1RUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxJQUFJO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxJQUFJO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG9CQUFvQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaURBQWlEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUNBQXlDO0FBQ3pEO0FBQ0EsZ0RBQWdELHVCQUF1QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQixFQUFFLFdBQVcsRUFBRSxnREFBZ0Q7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC91bml0L2J1aWxkL2RlY2ltYWwuanM/MjhmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVjID0gdm9pZCAwO1xuY29uc3QgYmlnX2ludGVnZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYmlnLWludGVnZXJcIikpO1xuY29uc3QgaW50XzEgPSByZXF1aXJlKFwiLi9pbnRcIik7XG5jb25zdCBldGNfMSA9IHJlcXVpcmUoXCIuL2V0Y1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNsYXNzIERlYyB7XG4gICAgc3RhdGljIGNhbGNQcmVjaXNpb25NdWx0aXBsaWVyKHByZWMpIHtcbiAgICAgICAgaWYgKHByZWMgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByZWNcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWMgPiBEZWMucHJlY2lzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb28gbXVjaCBwcmVjaXNpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gcHJlYy50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBjYWNoZWQgPSBEZWMucHJlY2lzaW9uTXVsdGlwbGllcnMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgemVyb3NUb0FkZCA9IERlYy5wcmVjaXNpb24gLSBwcmVjO1xuICAgICAgICBjb25zdCBtdWx0aXBsaWVyID0gKDAsIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCkoMTApLnBvdyh6ZXJvc1RvQWRkKTtcbiAgICAgICAgRGVjLnByZWNpc2lvbk11bHRpcGxpZXJzLnNldChrZXksIG11bHRpcGxpZXIpO1xuICAgICAgICByZXR1cm4gbXVsdGlwbGllcjtcbiAgICB9XG4gICAgc3RhdGljIHJlZHVjZURlY2ltYWxzRnJvbVN0cmluZyhzdHIpIHtcbiAgICAgICAgY29uc3QgZGVjaW1hbFBvaW50SW5kZXggPSBzdHIuaW5kZXhPZihcIi5cIik7XG4gICAgICAgIGlmIChkZWNpbWFsUG9pbnRJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVzOiBzdHIsXG4gICAgICAgICAgICAgICAgaXNEb3duVG9aZXJvOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhjZWVkZWREZWNpbWFscyA9IHN0ci5sZW5ndGggLSAxIC0gZGVjaW1hbFBvaW50SW5kZXggLSBEZWMucHJlY2lzaW9uO1xuICAgICAgICBpZiAoZXhjZWVkZWREZWNpbWFscyA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlczogc3RyLFxuICAgICAgICAgICAgICAgIGlzRG93blRvWmVybzogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IHN0ci5zbGljZSgwLCBzdHIubGVuZ3RoIC0gZXhjZWVkZWREZWNpbWFscyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXMsXG4gICAgICAgICAgICBpc0Rvd25Ub1plcm86IC9eWzAuXSokLy50ZXN0KHJlcyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBEZWMgZnJvbSBpbnRlZ2VyIHdpdGggZGVjaW1hbCBwbGFjZSBhdCBwcmVjXG4gICAgICogQHBhcmFtIGludCAtIFBhcnNlIGEgbnVtYmVyIHwgYmlnSW50ZWdlciB8IHN0cmluZyBpbnRvIGEgRGVjLlxuICAgICAqIElmIGludCBpcyBzdHJpbmcgYW5kIGNvbnRhaW5zIGRvdCguKSwgcHJlYyBpcyBpZ25vcmVkIGFuZCBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQuXG4gICAgICogQHBhcmFtIHByZWMgLSBQcmVjaXNpb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpbnQsIHByZWMgPSAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW50ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpbnQgPSBpbnQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGludCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGludC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eSBzdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISgwLCBldGNfMS5pc1ZhbGlkRGVjaW1hbFN0cmluZykoaW50KSkge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgZXRjXzEuaXNFeHBvbmVudERlY1N0cmluZykoaW50KSkge1xuICAgICAgICAgICAgICAgICAgICBpbnQgPSAoMCwgZXRjXzEuZXhwb25lbnREZWNTdHJpbmdUb0RlY1N0cmluZykoaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkZWNpbWFsOiAke2ludH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFdmVuIGlmIGFuIGlucHV0IHdpdGggbW9yZSB0aGFuIDE4IGRlY2ltYWxzLCBpdCBkb2VzIG5vdCB0aHJvdyBhbiBlcnJvciBhbmQgaWdub3JlcyB0aGUgcmVzdC5cbiAgICAgICAgICAgIGNvbnN0IHJlZHVjZWQgPSBEZWMucmVkdWNlRGVjaW1hbHNGcm9tU3RyaW5nKGludCk7XG4gICAgICAgICAgICBpZiAocmVkdWNlZC5pc0Rvd25Ub1plcm8pIHtcbiAgICAgICAgICAgICAgICAvLyBIb3dldmVyLCBhcyBhIHJlc3VsdCwgaWYgdGhlIGlucHV0IGJlY29tZXMgMCwgYSBwcm9ibGVtIG1heSBvY2N1ciBpbiBtdWwgb3IgcXVvLiBJbiB0aGlzIGNhc2UsIHByaW50IGEgd2FybmluZy5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgV0FSTklORzogR290ICR7aW50fS4gRGVjIGNhbiBvbmx5IGhhbmRsZSB1cCB0byAxOCBkZWNpbWFscy4gSG93ZXZlciwgc2luY2UgdGhlIGRlY2ltYWwgcG9pbnQgb2YgdGhlIGlucHV0IGV4Y2VlZHMgMTggZGlnaXRzLCB0aGUgcmVtYWluZGVyIGlzIGRpc2NhcmRlZC4gQXMgYSByZXN1bHQsIGlucHV0IGJlY29tZXMgMC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGludCA9IHJlZHVjZWQucmVzO1xuICAgICAgICAgICAgaWYgKGludC5pbmRleE9mKFwiLlwiKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcHJlYyA9IGludC5sZW5ndGggLSBpbnQuaW5kZXhPZihcIi5cIikgLSAxO1xuICAgICAgICAgICAgICAgIGludCA9IGludC5yZXBsYWNlKFwiLlwiLCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW50ID0gKDAsIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCkoaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnQgaW5zdGFuY2VvZiBpbnRfMS5JbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ID0gKDAsIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCkoaW50LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGludCBpbnN0YW5jZW9mIGludF8xLlVpbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ID0gKDAsIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCkoaW50LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbnQgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ID0gKDAsIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCkoaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW50ID0gKDAsIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCkoaW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludCA9IHRoaXMuaW50Lm11bHRpcGx5KERlYy5jYWxjUHJlY2lzaW9uTXVsdGlwbGllcihwcmVjKSk7XG4gICAgICAgIHRoaXMuY2hlY2tCaXRMZW4oKTtcbiAgICB9XG4gICAgY2hlY2tCaXRMZW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmludC5hYnMoKS5ndChEZWMubWF4RGVjKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlZ2VyIG91dCBvZiByYW5nZSAke3RoaXMuaW50LnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNaZXJvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQuZXEoKDAsIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCkoMCkpO1xuICAgIH1cbiAgICBpc05lZ2F0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQuaXNOZWdhdGl2ZSgpO1xuICAgIH1cbiAgICBpc1Bvc2l0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQuaXNQb3NpdGl2ZSgpO1xuICAgIH1cbiAgICBlcXVhbHMoZDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50LmVxKGQyLmludCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB0aGUgZ3JlYXRlciBtZXRob2QuXG4gICAgICovXG4gICAgZ3QoZDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50Lmd0KGQyLmludCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB0aGUgZ3JlYXRlck9yRXF1YWxzIG1ldGhvZC5cbiAgICAgKi9cbiAgICBndGUoZDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50LmdlcShkMi5pbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3IgdGhlIGxlc3NlciBtZXRob2QuXG4gICAgICovXG4gICAgbHQoZDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50Lmx0KGQyLmludCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB0aGUgbGVzc2VyT3JFcXVhbHMgbWV0aG9kLlxuICAgICAqL1xuICAgIGx0ZShkMikge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQubGVxKGQyLmludCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJldmVyc2UgdGhlIGRlY2ltYWwgc2lnbi5cbiAgICAgKi9cbiAgICBuZWcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjKHRoaXMuaW50Lm5lZ2F0ZSgpLCBEZWMucHJlY2lzaW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgYSBkZWNpbWFscy5cbiAgICAgKi9cbiAgICBhYnMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjKHRoaXMuaW50LmFicygpLCBEZWMucHJlY2lzaW9uKTtcbiAgICB9XG4gICAgYWRkKGQyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjKHRoaXMuaW50LmFkZChkMi5pbnQpLCBEZWMucHJlY2lzaW9uKTtcbiAgICB9XG4gICAgc3ViKGQyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjKHRoaXMuaW50LnN1YnRyYWN0KGQyLmludCksIERlYy5wcmVjaXNpb24pO1xuICAgIH1cbiAgICBwb3cobikge1xuICAgICAgICBpZiAobi5pc1plcm8oKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWMoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4uaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlYygxKS5xdW8odGhpcy5wb3cobi5hYnMoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBiYXNlID0gbmV3IERlYyh0aGlzLmludCwgRGVjLnByZWNpc2lvbik7XG4gICAgICAgIGxldCB0bXAgPSBuZXcgRGVjKDEpO1xuICAgICAgICBmb3IgKGxldCBpID0gbjsgaS5ndChuZXcgaW50XzEuSW50KDEpKTsgaSA9IGkuZGl2KG5ldyBpbnRfMS5JbnQoMikpKSB7XG4gICAgICAgICAgICBpZiAoIWkubW9kKG5ldyBpbnRfMS5JbnQoMikpLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgdG1wID0gdG1wLm11bChiYXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhc2UgPSBiYXNlLm11bChiYXNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZS5tdWwodG1wKTtcbiAgICB9XG4gICAgYXBwcm94U3FydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwcm94Um9vdCgyKTtcbiAgICB9XG4gICAgYXBwcm94Um9vdChyb290LCBtYXhJdGVycyA9IDMwMCkge1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmFwcHJveFJvb3Qocm9vdCkubmVnKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvb3QgPT09IDEgfHwgdGhpcy5pc1plcm8oKSB8fCB0aGlzLmVxdWFscyhEZWMub25lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvb3QgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBEZWMub25lO1xuICAgICAgICB9XG4gICAgICAgIGxldCBbZ3Vlc3MsIGRlbHRhXSA9IFtEZWMub25lLCBEZWMub25lXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGRlbHRhLmFicygpLmd0KERlYy5zbWFsbGVzdERlYykgJiYgaSA8IG1heEl0ZXJzOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gZ3Vlc3MucG93KG5ldyBpbnRfMS5JbnQocm9vdCAtIDEpKTtcbiAgICAgICAgICAgIGlmIChwcmV2LmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgcHJldiA9IERlYy5zbWFsbGVzdERlYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbHRhID0gdGhpcy5xdW8ocHJldik7XG4gICAgICAgICAgICBkZWx0YSA9IGRlbHRhLnN1YihndWVzcyk7XG4gICAgICAgICAgICBkZWx0YSA9IGRlbHRhLnF1b1RydW5jYXRlKG5ldyBEZWMocm9vdCkpO1xuICAgICAgICAgICAgZ3Vlc3MgPSBndWVzcy5hZGQoZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBndWVzcztcbiAgICB9XG4gICAgbXVsKGQyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjKHRoaXMubXVsUmF3KGQyKS5jaG9wUHJlY2lzaW9uQW5kUm91bmQoKSwgRGVjLnByZWNpc2lvbik7XG4gICAgfVxuICAgIG11bFRydW5jYXRlKGQyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjKHRoaXMubXVsUmF3KGQyKS5jaG9wUHJlY2lzaW9uQW5kVHJ1bmNhdGUoKSwgRGVjLnByZWNpc2lvbik7XG4gICAgfVxuICAgIG11bFJvdW5kVXAoZDIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWModGhpcy5tdWxSYXcoZDIpLmNob3BQcmVjaXNpb25BbmRSb3VuZFVwKCksIERlYy5wcmVjaXNpb24pO1xuICAgIH1cbiAgICBtdWxSYXcoZDIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWModGhpcy5pbnQubXVsdGlwbHkoZDIuaW50KSwgRGVjLnByZWNpc2lvbik7XG4gICAgfVxuICAgIHF1byhkMikge1xuICAgICAgICByZXR1cm4gbmV3IERlYyh0aGlzLnF1b1JhdyhkMikuY2hvcFByZWNpc2lvbkFuZFJvdW5kKCksIERlYy5wcmVjaXNpb24pO1xuICAgIH1cbiAgICBxdW9UcnVuY2F0ZShkMikge1xuICAgICAgICByZXR1cm4gbmV3IERlYyh0aGlzLnF1b1JhdyhkMikuY2hvcFByZWNpc2lvbkFuZFRydW5jYXRlKCksIERlYy5wcmVjaXNpb24pO1xuICAgIH1cbiAgICBxdW9Sb3VuZFVwKGQyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjKHRoaXMucXVvUmF3KGQyKS5jaG9wUHJlY2lzaW9uQW5kUm91bmRVcCgpLCBEZWMucHJlY2lzaW9uKTtcbiAgICB9XG4gICAgcXVvUmF3KGQyKSB7XG4gICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IERlYy5jYWxjUHJlY2lzaW9uTXVsdGlwbGllcigwKTtcbiAgICAgICAgLy8gbXVsdGlwbHkgcHJlY2lzaW9uIHR3aWNlXG4gICAgICAgIGNvbnN0IG11bCA9IHRoaXMuaW50Lm11bHRpcGx5KHByZWNpc2lvbikubXVsdGlwbHkocHJlY2lzaW9uKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWMobXVsLmRpdmlkZShkMi5pbnQpLCBEZWMucHJlY2lzaW9uKTtcbiAgICB9XG4gICAgaXNJbnRlZ2VyKCkge1xuICAgICAgICBjb25zdCBwcmVjaXNpb24gPSBEZWMuY2FsY1ByZWNpc2lvbk11bHRpcGxpZXIoMCk7XG4gICAgICAgIHJldHVybiB0aGlzLmludC5yZW1haW5kZXIocHJlY2lzaW9uKS5lcXVhbHMoKDAsIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCkoMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBQcmVjaXNpb24gYW1vdW50IG9mIHJpZ2h0bW9zdCBkaWdpdHMgYW5kIHBlcmZvcm0gYmFua2VycyByb3VuZGluZ1xuICAgICAqIG9uIHRoZSByZW1haW5kZXIgKGdhdXNzaWFuIHJvdW5kaW5nKSBvbiB0aGUgZGlnaXRzIHdoaWNoIGhhdmUgYmVlbiByZW1vdmVkLlxuICAgICAqL1xuICAgIGNob3BQcmVjaXNpb25BbmRSb3VuZCgpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBuZWdhdGl2ZSBhbmQgYWRkIGl0IGJhY2sgd2hlbiByZXR1cm5pbmdcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBhYnNvdWx0ZURlYyA9IHRoaXMuYWJzKCk7XG4gICAgICAgICAgICBjb25zdCBjaG9wZWQgPSBhYnNvdWx0ZURlYy5jaG9wUHJlY2lzaW9uQW5kUm91bmQoKTtcbiAgICAgICAgICAgIHJldHVybiBjaG9wZWQubmVnYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gRGVjLmNhbGNQcmVjaXNpb25NdWx0aXBsaWVyKDApO1xuICAgICAgICBjb25zdCBmaXZlUHJlY2lzaW9uID0gcHJlY2lzaW9uLmRpdmlkZSgoMCwgYmlnX2ludGVnZXJfMS5kZWZhdWx0KSgyKSk7XG4gICAgICAgIC8vIEdldCB0aGUgdHJ1bmNhdGVkIHF1b3RpZW50IGFuZCByZW1haW5kZXJcbiAgICAgICAgY29uc3QgeyBxdW90aWVudCwgcmVtYWluZGVyIH0gPSB0aGlzLmludC5kaXZtb2QocHJlY2lzaW9uKTtcbiAgICAgICAgLy8gSWYgcmVtYWluZGVyIGlzIHplcm9cbiAgICAgICAgaWYgKHJlbWFpbmRlci5lcXVhbHMoKDAsIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCkoMCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gcXVvdGllbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbWFpbmRlci5sdChmaXZlUHJlY2lzaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHF1b3RpZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlbWFpbmRlci5ndChmaXZlUHJlY2lzaW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHF1b3RpZW50LmFkZCgoMCwgYmlnX2ludGVnZXJfMS5kZWZhdWx0KSgxKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhbHdheXMgcm91bmQgdG8gYW4gZXZlbiBudW1iZXJcbiAgICAgICAgICAgIGlmIChxdW90aWVudC5kaXZpZGUoKDAsIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCkoMikpLmVxdWFscygoMCwgYmlnX2ludGVnZXJfMS5kZWZhdWx0KSgwKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVvdGllbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVvdGllbnQuYWRkKCgwLCBiaWdfaW50ZWdlcl8xLmRlZmF1bHQpKDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjaG9wUHJlY2lzaW9uQW5kUm91bmRVcCgpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBuZWdhdGl2ZSBhbmQgYWRkIGl0IGJhY2sgd2hlbiByZXR1cm5pbmdcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICBjb25zdCBhYnNvdWx0ZURlYyA9IHRoaXMuYWJzKCk7XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSBzaW5jZSBkIGlzIG5lZ2F0aXZlLi4uXG4gICAgICAgICAgICBjb25zdCBjaG9wZWQgPSBhYnNvdWx0ZURlYy5jaG9wUHJlY2lzaW9uQW5kVHJ1bmNhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiBjaG9wZWQubmVnYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gRGVjLmNhbGNQcmVjaXNpb25NdWx0aXBsaWVyKDApO1xuICAgICAgICAvLyBHZXQgdGhlIHRydW5jYXRlZCBxdW90aWVudCBhbmQgcmVtYWluZGVyXG4gICAgICAgIGNvbnN0IHsgcXVvdGllbnQsIHJlbWFpbmRlciB9ID0gdGhpcy5pbnQuZGl2bW9kKHByZWNpc2lvbik7XG4gICAgICAgIC8vIElmIHJlbWFpbmRlciBpcyB6ZXJvXG4gICAgICAgIGlmIChyZW1haW5kZXIuZXF1YWxzKCgwLCBiaWdfaW50ZWdlcl8xLmRlZmF1bHQpKDApKSkge1xuICAgICAgICAgICAgcmV0dXJuIHF1b3RpZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxdW90aWVudC5hZGQoKDAsIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCkoMSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1pbGFyIHRvIGNob3BQcmVjaXNpb25BbmRSb3VuZCwgYnV0IGFsd2F5cyByb3VuZHMgZG93blxuICAgICAqL1xuICAgIGNob3BQcmVjaXNpb25BbmRUcnVuY2F0ZSgpIHtcbiAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gRGVjLmNhbGNQcmVjaXNpb25NdWx0aXBsaWVyKDApO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQuZGl2aWRlKHByZWNpc2lvbik7XG4gICAgfVxuICAgIHRvU3RyaW5nKHByZWMgPSBEZWMucHJlY2lzaW9uLCBsb2NhbGUgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBwcmVjaXNpb24gPSBEZWMuY2FsY1ByZWNpc2lvbk11bHRpcGxpZXIoMCk7XG4gICAgICAgIGNvbnN0IGludCA9IHRoaXMuaW50LmFicygpO1xuICAgICAgICBjb25zdCB7IHF1b3RpZW50OiBpbnRlZ2VyLCByZW1haW5kZXI6IGZyYWN0aW9uIH0gPSBpbnQuZGl2bW9kKHByZWNpc2lvbik7XG4gICAgICAgIGxldCBmcmFjdGlvblN0ciA9IGZyYWN0aW9uLnRvU3RyaW5nKDEwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBmcmFjdGlvblN0ci5sZW5ndGg7IGkgPCBEZWMucHJlY2lzaW9uIC0gbDsgaSsrKSB7XG4gICAgICAgICAgICBmcmFjdGlvblN0ciA9IFwiMFwiICsgZnJhY3Rpb25TdHI7XG4gICAgICAgIH1cbiAgICAgICAgZnJhY3Rpb25TdHIgPSBmcmFjdGlvblN0ci5zdWJzdHJpbmcoMCwgcHJlYyk7XG4gICAgICAgIGNvbnN0IGlzTmVnYXRpdmUgPSB0aGlzLmlzTmVnYXRpdmUoKSAmJlxuICAgICAgICAgICAgIShpbnRlZ2VyLmVxKCgwLCBiaWdfaW50ZWdlcl8xLmRlZmF1bHQpKDApKSAmJiBmcmFjdGlvblN0ci5sZW5ndGggPT09IDApO1xuICAgICAgICBjb25zdCBpbnRlZ2VyU3RyID0gbG9jYWxlXG4gICAgICAgICAgICA/ICgwLCB1dGlsc18xLmludGVnZXJTdHJpbmdUb1VTTG9jYWxlU3RyaW5nKShpbnRlZ2VyLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICA6IGludGVnZXIudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIGAke2lzTmVnYXRpdmUgPyBcIi1cIiA6IFwiXCJ9JHtpbnRlZ2VyU3RyfSR7ZnJhY3Rpb25TdHIubGVuZ3RoID4gMCA/IFwiLlwiICsgZnJhY3Rpb25TdHIgOiBcIlwifWA7XG4gICAgfVxuICAgIHJvdW5kKCkge1xuICAgICAgICByZXR1cm4gbmV3IGludF8xLkludCh0aGlzLmNob3BQcmVjaXNpb25BbmRSb3VuZCgpKTtcbiAgICB9XG4gICAgcm91bmRVcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBpbnRfMS5JbnQodGhpcy5jaG9wUHJlY2lzaW9uQW5kUm91bmRVcCgpKTtcbiAgICB9XG4gICAgdHJ1bmNhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgaW50XzEuSW50KHRoaXMuY2hvcFByZWNpc2lvbkFuZFRydW5jYXRlKCkpO1xuICAgIH1cbiAgICByb3VuZERlYygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWModGhpcy5jaG9wUHJlY2lzaW9uQW5kUm91bmQoKSwgMCk7XG4gICAgfVxuICAgIHJvdW5kVXBEZWMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjKHRoaXMuY2hvcFByZWNpc2lvbkFuZFJvdW5kVXAoKSwgMCk7XG4gICAgfVxuICAgIHRydW5jYXRlRGVjKCkge1xuICAgICAgICByZXR1cm4gbmV3IERlYyh0aGlzLmNob3BQcmVjaXNpb25BbmRUcnVuY2F0ZSgpLCAwKTtcbiAgICB9XG59XG5leHBvcnRzLkRlYyA9IERlYztcbkRlYy5wcmVjaXNpb24gPSAxODtcbi8vIEJ5dGVzIHJlcXVpcmVkIHRvIHJlcHJlc2VudCB0aGUgYWJvdmUgcHJlY2lzaW9uIGlzIDE4LlxuLy8gQ2VpbGluZ1tMb2cyWzk5OSA5OTkgOTk5IDk5OSA5OTkgOTk5XV1cbkRlYy5kZWNpbWFsUHJlY2lzaW9uQml0cyA9IDYwO1xuLy8gTWF4IGJpdCBsZW5ndGggZm9yIGBEZWNgIGlzIDI1NiArIDYwKGRlY2ltYWxQcmVjaXNpb25CaXRzKVxuLy8gVGhlIGludCBpbiB0aGUgYERlY2AgaXMgaGFuZGxlZCBhcyBpbnRlZ2VyIGFzc3VtaW5nIHRoYXQgaXQgaGFzIDE4IHByZWNpc2lvbi5cbi8vICgyICoqICgyNTYgKyA2MCkgLSAxKVxuRGVjLm1heERlYyA9ICgwLCBiaWdfaW50ZWdlcl8xLmRlZmF1bHQpKFwiMTMzNDk5MTg5NzQ1MDU2ODgwMTQ5Njg4ODU2NjM1NTk3MDA3MTYyNjY5MDMyNjQ3MjkwNzk4MTIxNjkwMTAwNDg4ODg4NzMyODYxMjkwMDM0Mzc2NDM1MTMwNDMzNTM1XCIpO1xuRGVjLnByZWNpc2lvbk11bHRpcGxpZXJzID0gbmV3IE1hcCgpO1xuRGVjLnplcm8gPSBuZXcgRGVjKDApO1xuLyoqIFNtYWxsZXN0IGBEZWNgIHdpdGggY3VycmVudCBwcmVjaXNpb24uICovXG5EZWMuc21hbGxlc3REZWMgPSBuZXcgRGVjKFwiMVwiLCBEZWMucHJlY2lzaW9uKTtcbkRlYy5vbmUgPSBuZXcgRGVjKDEpO1xuaW50XzEuSW50LnByb3RvdHlwZS50b0RlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IERlYyh0aGlzKTtcbn07XG5pbnRfMS5VaW50LnByb3RvdHlwZS50b0RlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IERlYyh0aGlzKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWNpbWFsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/unit/build/decimal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/unit/build/etc.js":
/*!******************************************************!*\
  !*** ./node_modules/@keplr-wallet/unit/build/etc.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.exponentDecStringToDecString = exports.isExponentDecString = exports.isValidDecimalString = exports.isValidIntegerString = void 0;\nconst regexIntString = /^-?\\d+$/;\nconst regexDecString = /^-?\\d+.?\\d*$/;\nconst regexExponentDecString = /^(-?)([\\d.]+)e([-+])([\\d]+)$/;\nfunction isValidIntegerString(str) {\n    return regexIntString.test(str);\n}\nexports.isValidIntegerString = isValidIntegerString;\nfunction isValidDecimalString(str) {\n    return regexDecString.test(str);\n}\nexports.isValidDecimalString = isValidDecimalString;\nfunction isExponentDecString(str) {\n    return regexExponentDecString.test(str);\n}\nexports.isExponentDecString = isExponentDecString;\nfunction makeZerosStr(len) {\n    let r = \"\";\n    for (let i = 0; i < len; i++) {\n        r += \"0\";\n    }\n    return r;\n}\nfunction removeHeadZeros(str) {\n    while (str.length > 0 && str[0] === \"0\") {\n        str = str.slice(1);\n    }\n    if (str.length === 0 || str[0] === \".\") {\n        return \"0\" + str;\n    }\n    return str;\n}\nfunction exponentDecStringToDecString(str) {\n    const split = str.split(regexExponentDecString);\n    if (split.length !== 6) {\n        return str;\n    }\n    const isNeg = split[1] === \"-\";\n    let numStr = split[2];\n    const numStrFractionIndex = numStr.indexOf(\".\");\n    const exponentStr = split[4];\n    let exponent = parseInt(exponentStr) * (split[3] === \"-\" ? -1 : 1);\n    if (numStrFractionIndex >= 0) {\n        const fractionLen = numStr.length - numStrFractionIndex - 1;\n        exponent = exponent - fractionLen;\n        numStr = removeHeadZeros(numStr.replace(\".\", \"\"));\n    }\n    const prefix = isNeg ? \"-\" : \"\";\n    if (exponent < 0) {\n        if (numStr.length > -exponent) {\n            const fractionPosition = numStr.length + exponent;\n            return (prefix +\n                (numStr.slice(0, fractionPosition) +\n                    \".\" +\n                    numStr.slice(fractionPosition)));\n        }\n        return prefix + \"0.\" + makeZerosStr(-(numStr.length + exponent)) + numStr;\n    }\n    else {\n        return prefix + numStr + makeZerosStr(exponent);\n    }\n}\nexports.exponentDecStringToDecString = exponentDecStringToDecString;\n//# sourceMappingURL=etc.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC91bml0L2J1aWxkL2V0Yy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQ0FBb0MsR0FBRywyQkFBMkIsR0FBRyw0QkFBNEIsR0FBRyw0QkFBNEI7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC91bml0L2J1aWxkL2V0Yy5qcz85Njc3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHBvbmVudERlY1N0cmluZ1RvRGVjU3RyaW5nID0gZXhwb3J0cy5pc0V4cG9uZW50RGVjU3RyaW5nID0gZXhwb3J0cy5pc1ZhbGlkRGVjaW1hbFN0cmluZyA9IGV4cG9ydHMuaXNWYWxpZEludGVnZXJTdHJpbmcgPSB2b2lkIDA7XG5jb25zdCByZWdleEludFN0cmluZyA9IC9eLT9cXGQrJC87XG5jb25zdCByZWdleERlY1N0cmluZyA9IC9eLT9cXGQrLj9cXGQqJC87XG5jb25zdCByZWdleEV4cG9uZW50RGVjU3RyaW5nID0gL14oLT8pKFtcXGQuXSspZShbLStdKShbXFxkXSspJC87XG5mdW5jdGlvbiBpc1ZhbGlkSW50ZWdlclN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gcmVnZXhJbnRTdHJpbmcudGVzdChzdHIpO1xufVxuZXhwb3J0cy5pc1ZhbGlkSW50ZWdlclN0cmluZyA9IGlzVmFsaWRJbnRlZ2VyU3RyaW5nO1xuZnVuY3Rpb24gaXNWYWxpZERlY2ltYWxTdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIHJlZ2V4RGVjU3RyaW5nLnRlc3Qoc3RyKTtcbn1cbmV4cG9ydHMuaXNWYWxpZERlY2ltYWxTdHJpbmcgPSBpc1ZhbGlkRGVjaW1hbFN0cmluZztcbmZ1bmN0aW9uIGlzRXhwb25lbnREZWNTdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuIHJlZ2V4RXhwb25lbnREZWNTdHJpbmcudGVzdChzdHIpO1xufVxuZXhwb3J0cy5pc0V4cG9uZW50RGVjU3RyaW5nID0gaXNFeHBvbmVudERlY1N0cmluZztcbmZ1bmN0aW9uIG1ha2VaZXJvc1N0cihsZW4pIHtcbiAgICBsZXQgciA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByICs9IFwiMFwiO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIHJlbW92ZUhlYWRaZXJvcyhzdHIpIHtcbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA+IDAgJiYgc3RyWzBdID09PSBcIjBcIikge1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG4gICAgfVxuICAgIGlmIChzdHIubGVuZ3RoID09PSAwIHx8IHN0clswXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiMFwiICsgc3RyO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gZXhwb25lbnREZWNTdHJpbmdUb0RlY1N0cmluZyhzdHIpIHtcbiAgICBjb25zdCBzcGxpdCA9IHN0ci5zcGxpdChyZWdleEV4cG9uZW50RGVjU3RyaW5nKTtcbiAgICBpZiAoc3BsaXQubGVuZ3RoICE9PSA2KSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIGNvbnN0IGlzTmVnID0gc3BsaXRbMV0gPT09IFwiLVwiO1xuICAgIGxldCBudW1TdHIgPSBzcGxpdFsyXTtcbiAgICBjb25zdCBudW1TdHJGcmFjdGlvbkluZGV4ID0gbnVtU3RyLmluZGV4T2YoXCIuXCIpO1xuICAgIGNvbnN0IGV4cG9uZW50U3RyID0gc3BsaXRbNF07XG4gICAgbGV0IGV4cG9uZW50ID0gcGFyc2VJbnQoZXhwb25lbnRTdHIpICogKHNwbGl0WzNdID09PSBcIi1cIiA/IC0xIDogMSk7XG4gICAgaWYgKG51bVN0ckZyYWN0aW9uSW5kZXggPj0gMCkge1xuICAgICAgICBjb25zdCBmcmFjdGlvbkxlbiA9IG51bVN0ci5sZW5ndGggLSBudW1TdHJGcmFjdGlvbkluZGV4IC0gMTtcbiAgICAgICAgZXhwb25lbnQgPSBleHBvbmVudCAtIGZyYWN0aW9uTGVuO1xuICAgICAgICBudW1TdHIgPSByZW1vdmVIZWFkWmVyb3MobnVtU3RyLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgICB9XG4gICAgY29uc3QgcHJlZml4ID0gaXNOZWcgPyBcIi1cIiA6IFwiXCI7XG4gICAgaWYgKGV4cG9uZW50IDwgMCkge1xuICAgICAgICBpZiAobnVtU3RyLmxlbmd0aCA+IC1leHBvbmVudCkge1xuICAgICAgICAgICAgY29uc3QgZnJhY3Rpb25Qb3NpdGlvbiA9IG51bVN0ci5sZW5ndGggKyBleHBvbmVudDtcbiAgICAgICAgICAgIHJldHVybiAocHJlZml4ICtcbiAgICAgICAgICAgICAgICAobnVtU3RyLnNsaWNlKDAsIGZyYWN0aW9uUG9zaXRpb24pICtcbiAgICAgICAgICAgICAgICAgICAgXCIuXCIgK1xuICAgICAgICAgICAgICAgICAgICBudW1TdHIuc2xpY2UoZnJhY3Rpb25Qb3NpdGlvbikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJlZml4ICsgXCIwLlwiICsgbWFrZVplcm9zU3RyKC0obnVtU3RyLmxlbmd0aCArIGV4cG9uZW50KSkgKyBudW1TdHI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgbnVtU3RyICsgbWFrZVplcm9zU3RyKGV4cG9uZW50KTtcbiAgICB9XG59XG5leHBvcnRzLmV4cG9uZW50RGVjU3RyaW5nVG9EZWNTdHJpbmcgPSBleHBvbmVudERlY1N0cmluZ1RvRGVjU3RyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXRjLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/unit/build/etc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/unit/build/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@keplr-wallet/unit/build/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./int-pretty */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/int-pretty.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coin-pretty */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/coin-pretty.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coin */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/coin.js\"), exports);\n__exportStar(__webpack_require__(/*! ./int */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/int.js\"), exports);\n__exportStar(__webpack_require__(/*! ./decimal */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/decimal.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coin-utils */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/coin-utils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./dec-utils */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/dec-utils.js\"), exports);\n__exportStar(__webpack_require__(/*! ./price-pretty */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/price-pretty.js\"), exports);\n__exportStar(__webpack_require__(/*! ./rate-pretty */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/rate-pretty.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC91bml0L2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxpRkFBYztBQUNuQyxhQUFhLG1CQUFPLENBQUMsbUZBQWU7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLHFFQUFRO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyxtRUFBTztBQUM1QixhQUFhLG1CQUFPLENBQUMsMkVBQVc7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLGlGQUFjO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQywrRUFBYTtBQUNsQyxhQUFhLG1CQUFPLENBQUMscUZBQWdCO0FBQ3JDLGFBQWEsbUJBQU8sQ0FBQyxtRkFBZTtBQUNwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvdW5pdC9idWlsZC9pbmRleC5qcz80MDBkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaW50LXByZXR0eVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbi1wcmV0dHlcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2ludFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZGVjaW1hbFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbi11dGlsc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZGVjLXV0aWxzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcmljZS1wcmV0dHlcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3JhdGUtcHJldHR5XCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/unit/build/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/unit/build/int-pretty.js":
/*!*************************************************************!*\
  !*** ./node_modules/@keplr-wallet/unit/build/int-pretty.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IntPretty = void 0;\nconst int_1 = __webpack_require__(/*! ./int */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/int.js\");\nconst decimal_1 = __webpack_require__(/*! ./decimal */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/decimal.js\");\nconst dec_utils_1 = __webpack_require__(/*! ./dec-utils */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/dec-utils.js\");\nconst coin_utils_1 = __webpack_require__(/*! ./coin-utils */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/coin-utils.js\");\nclass IntPretty {\n    constructor(num) {\n        this.floatingDecimalPointRight = 0;\n        this._options = {\n            maxDecimals: 0,\n            trim: false,\n            shrink: false,\n            ready: true,\n            locale: true,\n            inequalitySymbol: false,\n            inequalitySymbolSeparator: \" \",\n        };\n        if (typeof num === \"object\" && \"toDec\" in num) {\n            num = num.toDec();\n        }\n        else if (!(num instanceof decimal_1.Dec)) {\n            num = new decimal_1.Dec(num);\n        }\n        if (num.isZero()) {\n            this.dec = num;\n            return;\n        }\n        let dec = num;\n        let decPrecision = 0;\n        for (let i = 0; i < 18; i++) {\n            if (!dec.truncate().equals(new int_1.Int(0)) &&\n                dec.equals(new decimal_1.Dec(dec.truncate()))) {\n                break;\n            }\n            dec = dec.mul(new decimal_1.Dec(10));\n            decPrecision++;\n        }\n        this.dec = num;\n        this._options.maxDecimals = decPrecision;\n    }\n    get options() {\n        return this._options;\n    }\n    moveDecimalPointLeft(delta) {\n        const pretty = this.clone();\n        pretty.floatingDecimalPointRight += -delta;\n        return pretty;\n    }\n    moveDecimalPointRight(delta) {\n        const pretty = this.clone();\n        pretty.floatingDecimalPointRight += delta;\n        return pretty;\n    }\n    /**\n     * @deprecated Use`moveDecimalPointLeft`\n     */\n    increasePrecision(delta) {\n        return this.moveDecimalPointLeft(delta);\n    }\n    /**\n     * @deprecated Use`moveDecimalPointRight`\n     */\n    decreasePrecision(delta) {\n        return this.moveDecimalPointRight(delta);\n    }\n    maxDecimals(max) {\n        const pretty = this.clone();\n        pretty._options.maxDecimals = max;\n        return pretty;\n    }\n    inequalitySymbol(bool) {\n        const pretty = this.clone();\n        pretty._options.inequalitySymbol = bool;\n        return pretty;\n    }\n    inequalitySymbolSeparator(str) {\n        const pretty = this.clone();\n        pretty._options.inequalitySymbolSeparator = str;\n        return pretty;\n    }\n    trim(bool) {\n        const pretty = this.clone();\n        pretty._options.trim = bool;\n        return pretty;\n    }\n    shrink(bool) {\n        const pretty = this.clone();\n        pretty._options.shrink = bool;\n        return pretty;\n    }\n    locale(locale) {\n        const pretty = this.clone();\n        pretty._options.locale = locale;\n        return pretty;\n    }\n    /**\n     * Ready indicates the actual value is ready to show the users.\n     * Even if the ready option is false, it expects that the value can be shown to users (probably as 0).\n     * The method that returns prettied value may return `undefined` or `null` if the value is not ready.\n     * But, alternatively, it can return the 0 value that can be shown the users anyway, but indicates that the value is not ready.\n     * @param bool\n     */\n    ready(bool) {\n        const pretty = this.clone();\n        pretty._options.ready = bool;\n        return pretty;\n    }\n    get isReady() {\n        return this._options.ready;\n    }\n    add(target) {\n        if (!(target instanceof decimal_1.Dec)) {\n            target = target.toDec();\n        }\n        const pretty = new IntPretty(this.toDec().add(target));\n        pretty._options = Object.assign({}, this._options);\n        return pretty;\n    }\n    sub(target) {\n        if (!(target instanceof decimal_1.Dec)) {\n            target = target.toDec();\n        }\n        const pretty = new IntPretty(this.toDec().sub(target));\n        pretty._options = Object.assign({}, this._options);\n        return pretty;\n    }\n    mul(target) {\n        if (!(target instanceof decimal_1.Dec)) {\n            target = target.toDec();\n        }\n        const pretty = new IntPretty(this.toDec().mul(target));\n        pretty._options = Object.assign({}, this._options);\n        return pretty;\n    }\n    quo(target) {\n        if (!(target instanceof decimal_1.Dec)) {\n            target = target.toDec();\n        }\n        const pretty = new IntPretty(this.toDec().quo(target));\n        pretty._options = Object.assign({}, this._options);\n        return pretty;\n    }\n    toDec() {\n        if (this.floatingDecimalPointRight === 0) {\n            return this.dec;\n        }\n        else if (this.floatingDecimalPointRight > 0) {\n            return this.dec.mulTruncate(dec_utils_1.DecUtils.getTenExponentN(this.floatingDecimalPointRight));\n        }\n        else {\n            // Since a decimal in Dec cannot exceed 18, it cannot be computed at once.\n            let i = -this.floatingDecimalPointRight;\n            let dec = this.dec;\n            while (i > 0) {\n                if (i >= decimal_1.Dec.precision) {\n                    dec = dec.mulTruncate(dec_utils_1.DecUtils.getTenExponentN(-decimal_1.Dec.precision));\n                    i -= decimal_1.Dec.precision;\n                }\n                else {\n                    dec = dec.mulTruncate(dec_utils_1.DecUtils.getTenExponentN(-(i % decimal_1.Dec.precision)));\n                    break;\n                }\n            }\n            return dec;\n        }\n    }\n    toString() {\n        return this.toStringWithSymbols(\"\", \"\");\n    }\n    toStringWithSymbols(prefix, suffix) {\n        const dec = this.toDec();\n        if (this._options.inequalitySymbol &&\n            !dec.isZero() &&\n            dec.abs().lt(dec_utils_1.DecUtils.getTenExponentN(-this._options.maxDecimals))) {\n            const isNeg = dec.isNegative();\n            return `${isNeg ? \">\" : \"<\"}${this._options.inequalitySymbolSeparator}${isNeg ? \"-\" : \"\"}${prefix}${dec_utils_1.DecUtils.getTenExponentN(-this._options.maxDecimals).toString(this._options.maxDecimals, this._options.locale)}${suffix}`;\n        }\n        let result;\n        if (!this._options.shrink) {\n            result = dec.toString(this._options.maxDecimals, this._options.locale);\n        }\n        else {\n            result = coin_utils_1.CoinUtils.shrinkDecimals(dec, 0, this._options.maxDecimals, this._options.locale);\n        }\n        if (this._options.trim) {\n            result = dec_utils_1.DecUtils.trim(result);\n        }\n        const isNeg = result.charAt(0) === \"-\";\n        if (isNeg) {\n            result = result.slice(1);\n        }\n        return `${isNeg ? \"-\" : \"\"}${prefix}${result}${suffix}`;\n    }\n    clone() {\n        const pretty = new IntPretty(this.dec);\n        pretty.dec = this.dec;\n        pretty.floatingDecimalPointRight = this.floatingDecimalPointRight;\n        pretty._options = Object.assign({}, this._options);\n        return pretty;\n    }\n}\nexports.IntPretty = IntPretty;\n//# sourceMappingURL=int-pretty.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC91bml0L2J1aWxkL2ludC1wcmV0dHkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLGNBQWMsbUJBQU8sQ0FBQyxtRUFBTztBQUM3QixrQkFBa0IsbUJBQU8sQ0FBQywyRUFBVztBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQywrRUFBYTtBQUN6QyxxQkFBcUIsbUJBQU8sQ0FBQyxpRkFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQixFQUFFLHdDQUF3QyxFQUFFLGlCQUFpQixFQUFFLE9BQU8sRUFBRSwySEFBMkgsRUFBRSxPQUFPO0FBQ3BQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUIsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L3VuaXQvYnVpbGQvaW50LXByZXR0eS5qcz9hNmM5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnRQcmV0dHkgPSB2b2lkIDA7XG5jb25zdCBpbnRfMSA9IHJlcXVpcmUoXCIuL2ludFwiKTtcbmNvbnN0IGRlY2ltYWxfMSA9IHJlcXVpcmUoXCIuL2RlY2ltYWxcIik7XG5jb25zdCBkZWNfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2RlYy11dGlsc1wiKTtcbmNvbnN0IGNvaW5fdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2NvaW4tdXRpbHNcIik7XG5jbGFzcyBJbnRQcmV0dHkge1xuICAgIGNvbnN0cnVjdG9yKG51bSkge1xuICAgICAgICB0aGlzLmZsb2F0aW5nRGVjaW1hbFBvaW50UmlnaHQgPSAwO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0ge1xuICAgICAgICAgICAgbWF4RGVjaW1hbHM6IDAsXG4gICAgICAgICAgICB0cmltOiBmYWxzZSxcbiAgICAgICAgICAgIHNocmluazogZmFsc2UsXG4gICAgICAgICAgICByZWFkeTogdHJ1ZSxcbiAgICAgICAgICAgIGxvY2FsZTogdHJ1ZSxcbiAgICAgICAgICAgIGluZXF1YWxpdHlTeW1ib2w6IGZhbHNlLFxuICAgICAgICAgICAgaW5lcXVhbGl0eVN5bWJvbFNlcGFyYXRvcjogXCIgXCIsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgbnVtID09PSBcIm9iamVjdFwiICYmIFwidG9EZWNcIiBpbiBudW0pIHtcbiAgICAgICAgICAgIG51bSA9IG51bS50b0RlYygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEobnVtIGluc3RhbmNlb2YgZGVjaW1hbF8xLkRlYykpIHtcbiAgICAgICAgICAgIG51bSA9IG5ldyBkZWNpbWFsXzEuRGVjKG51bSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bS5pc1plcm8oKSkge1xuICAgICAgICAgICAgdGhpcy5kZWMgPSBudW07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlYyA9IG51bTtcbiAgICAgICAgbGV0IGRlY1ByZWNpc2lvbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFkZWMudHJ1bmNhdGUoKS5lcXVhbHMobmV3IGludF8xLkludCgwKSkgJiZcbiAgICAgICAgICAgICAgICBkZWMuZXF1YWxzKG5ldyBkZWNpbWFsXzEuRGVjKGRlYy50cnVuY2F0ZSgpKSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlYyA9IGRlYy5tdWwobmV3IGRlY2ltYWxfMS5EZWMoMTApKTtcbiAgICAgICAgICAgIGRlY1ByZWNpc2lvbisrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVjID0gbnVtO1xuICAgICAgICB0aGlzLl9vcHRpb25zLm1heERlY2ltYWxzID0gZGVjUHJlY2lzaW9uO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gICAgfVxuICAgIG1vdmVEZWNpbWFsUG9pbnRMZWZ0KGRlbHRhKSB7XG4gICAgICAgIGNvbnN0IHByZXR0eSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcHJldHR5LmZsb2F0aW5nRGVjaW1hbFBvaW50UmlnaHQgKz0gLWRlbHRhO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICBtb3ZlRGVjaW1hbFBvaW50UmlnaHQoZGVsdGEpIHtcbiAgICAgICAgY29uc3QgcHJldHR5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwcmV0dHkuZmxvYXRpbmdEZWNpbWFsUG9pbnRSaWdodCArPSBkZWx0YTtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlYG1vdmVEZWNpbWFsUG9pbnRMZWZ0YFxuICAgICAqL1xuICAgIGluY3JlYXNlUHJlY2lzaW9uKGRlbHRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdmVEZWNpbWFsUG9pbnRMZWZ0KGRlbHRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlYG1vdmVEZWNpbWFsUG9pbnRSaWdodGBcbiAgICAgKi9cbiAgICBkZWNyZWFzZVByZWNpc2lvbihkZWx0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3ZlRGVjaW1hbFBvaW50UmlnaHQoZGVsdGEpO1xuICAgIH1cbiAgICBtYXhEZWNpbWFscyhtYXgpIHtcbiAgICAgICAgY29uc3QgcHJldHR5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwcmV0dHkuX29wdGlvbnMubWF4RGVjaW1hbHMgPSBtYXg7XG4gICAgICAgIHJldHVybiBwcmV0dHk7XG4gICAgfVxuICAgIGluZXF1YWxpdHlTeW1ib2woYm9vbCkge1xuICAgICAgICBjb25zdCBwcmV0dHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHByZXR0eS5fb3B0aW9ucy5pbmVxdWFsaXR5U3ltYm9sID0gYm9vbDtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgaW5lcXVhbGl0eVN5bWJvbFNlcGFyYXRvcihzdHIpIHtcbiAgICAgICAgY29uc3QgcHJldHR5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwcmV0dHkuX29wdGlvbnMuaW5lcXVhbGl0eVN5bWJvbFNlcGFyYXRvciA9IHN0cjtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgdHJpbShib29sKSB7XG4gICAgICAgIGNvbnN0IHByZXR0eSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcHJldHR5Ll9vcHRpb25zLnRyaW0gPSBib29sO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICBzaHJpbmsoYm9vbCkge1xuICAgICAgICBjb25zdCBwcmV0dHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHByZXR0eS5fb3B0aW9ucy5zaHJpbmsgPSBib29sO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICBsb2NhbGUobG9jYWxlKSB7XG4gICAgICAgIGNvbnN0IHByZXR0eSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcHJldHR5Ll9vcHRpb25zLmxvY2FsZSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHkgaW5kaWNhdGVzIHRoZSBhY3R1YWwgdmFsdWUgaXMgcmVhZHkgdG8gc2hvdyB0aGUgdXNlcnMuXG4gICAgICogRXZlbiBpZiB0aGUgcmVhZHkgb3B0aW9uIGlzIGZhbHNlLCBpdCBleHBlY3RzIHRoYXQgdGhlIHZhbHVlIGNhbiBiZSBzaG93biB0byB1c2VycyAocHJvYmFibHkgYXMgMCkuXG4gICAgICogVGhlIG1ldGhvZCB0aGF0IHJldHVybnMgcHJldHRpZWQgdmFsdWUgbWF5IHJldHVybiBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaWYgdGhlIHZhbHVlIGlzIG5vdCByZWFkeS5cbiAgICAgKiBCdXQsIGFsdGVybmF0aXZlbHksIGl0IGNhbiByZXR1cm4gdGhlIDAgdmFsdWUgdGhhdCBjYW4gYmUgc2hvd24gdGhlIHVzZXJzIGFueXdheSwgYnV0IGluZGljYXRlcyB0aGF0IHRoZSB2YWx1ZSBpcyBub3QgcmVhZHkuXG4gICAgICogQHBhcmFtIGJvb2xcbiAgICAgKi9cbiAgICByZWFkeShib29sKSB7XG4gICAgICAgIGNvbnN0IHByZXR0eSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcHJldHR5Ll9vcHRpb25zLnJlYWR5ID0gYm9vbDtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgZ2V0IGlzUmVhZHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLnJlYWR5O1xuICAgIH1cbiAgICBhZGQodGFyZ2V0KSB7XG4gICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGRlY2ltYWxfMS5EZWMpKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQudG9EZWMoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV0dHkgPSBuZXcgSW50UHJldHR5KHRoaXMudG9EZWMoKS5hZGQodGFyZ2V0KSk7XG4gICAgICAgIHByZXR0eS5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX29wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICBzdWIodGFyZ2V0KSB7XG4gICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGRlY2ltYWxfMS5EZWMpKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQudG9EZWMoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV0dHkgPSBuZXcgSW50UHJldHR5KHRoaXMudG9EZWMoKS5zdWIodGFyZ2V0KSk7XG4gICAgICAgIHByZXR0eS5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX29wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICBtdWwodGFyZ2V0KSB7XG4gICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGRlY2ltYWxfMS5EZWMpKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQudG9EZWMoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV0dHkgPSBuZXcgSW50UHJldHR5KHRoaXMudG9EZWMoKS5tdWwodGFyZ2V0KSk7XG4gICAgICAgIHByZXR0eS5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX29wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICBxdW8odGFyZ2V0KSB7XG4gICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGRlY2ltYWxfMS5EZWMpKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQudG9EZWMoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV0dHkgPSBuZXcgSW50UHJldHR5KHRoaXMudG9EZWMoKS5xdW8odGFyZ2V0KSk7XG4gICAgICAgIHByZXR0eS5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX29wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICB0b0RlYygpIHtcbiAgICAgICAgaWYgKHRoaXMuZmxvYXRpbmdEZWNpbWFsUG9pbnRSaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZmxvYXRpbmdEZWNpbWFsUG9pbnRSaWdodCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlYy5tdWxUcnVuY2F0ZShkZWNfdXRpbHNfMS5EZWNVdGlscy5nZXRUZW5FeHBvbmVudE4odGhpcy5mbG9hdGluZ0RlY2ltYWxQb2ludFJpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTaW5jZSBhIGRlY2ltYWwgaW4gRGVjIGNhbm5vdCBleGNlZWQgMTgsIGl0IGNhbm5vdCBiZSBjb21wdXRlZCBhdCBvbmNlLlxuICAgICAgICAgICAgbGV0IGkgPSAtdGhpcy5mbG9hdGluZ0RlY2ltYWxQb2ludFJpZ2h0O1xuICAgICAgICAgICAgbGV0IGRlYyA9IHRoaXMuZGVjO1xuICAgICAgICAgICAgd2hpbGUgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gZGVjaW1hbF8xLkRlYy5wcmVjaXNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjID0gZGVjLm11bFRydW5jYXRlKGRlY191dGlsc18xLkRlY1V0aWxzLmdldFRlbkV4cG9uZW50TigtZGVjaW1hbF8xLkRlYy5wcmVjaXNpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgaSAtPSBkZWNpbWFsXzEuRGVjLnByZWNpc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYyA9IGRlYy5tdWxUcnVuY2F0ZShkZWNfdXRpbHNfMS5EZWNVdGlscy5nZXRUZW5FeHBvbmVudE4oLShpICUgZGVjaW1hbF8xLkRlYy5wcmVjaXNpb24pKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nV2l0aFN5bWJvbHMoXCJcIiwgXCJcIik7XG4gICAgfVxuICAgIHRvU3RyaW5nV2l0aFN5bWJvbHMocHJlZml4LCBzdWZmaXgpIHtcbiAgICAgICAgY29uc3QgZGVjID0gdGhpcy50b0RlYygpO1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5pbmVxdWFsaXR5U3ltYm9sICYmXG4gICAgICAgICAgICAhZGVjLmlzWmVybygpICYmXG4gICAgICAgICAgICBkZWMuYWJzKCkubHQoZGVjX3V0aWxzXzEuRGVjVXRpbHMuZ2V0VGVuRXhwb25lbnROKC10aGlzLl9vcHRpb25zLm1heERlY2ltYWxzKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzTmVnID0gZGVjLmlzTmVnYXRpdmUoKTtcbiAgICAgICAgICAgIHJldHVybiBgJHtpc05lZyA/IFwiPlwiIDogXCI8XCJ9JHt0aGlzLl9vcHRpb25zLmluZXF1YWxpdHlTeW1ib2xTZXBhcmF0b3J9JHtpc05lZyA/IFwiLVwiIDogXCJcIn0ke3ByZWZpeH0ke2RlY191dGlsc18xLkRlY1V0aWxzLmdldFRlbkV4cG9uZW50TigtdGhpcy5fb3B0aW9ucy5tYXhEZWNpbWFscykudG9TdHJpbmcodGhpcy5fb3B0aW9ucy5tYXhEZWNpbWFscywgdGhpcy5fb3B0aW9ucy5sb2NhbGUpfSR7c3VmZml4fWA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLnNocmluaykge1xuICAgICAgICAgICAgcmVzdWx0ID0gZGVjLnRvU3RyaW5nKHRoaXMuX29wdGlvbnMubWF4RGVjaW1hbHMsIHRoaXMuX29wdGlvbnMubG9jYWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvaW5fdXRpbHNfMS5Db2luVXRpbHMuc2hyaW5rRGVjaW1hbHMoZGVjLCAwLCB0aGlzLl9vcHRpb25zLm1heERlY2ltYWxzLCB0aGlzLl9vcHRpb25zLmxvY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMudHJpbSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZGVjX3V0aWxzXzEuRGVjVXRpbHMudHJpbShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzTmVnID0gcmVzdWx0LmNoYXJBdCgwKSA9PT0gXCItXCI7XG4gICAgICAgIGlmIChpc05lZykge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtpc05lZyA/IFwiLVwiIDogXCJcIn0ke3ByZWZpeH0ke3Jlc3VsdH0ke3N1ZmZpeH1gO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgcHJldHR5ID0gbmV3IEludFByZXR0eSh0aGlzLmRlYyk7XG4gICAgICAgIHByZXR0eS5kZWMgPSB0aGlzLmRlYztcbiAgICAgICAgcHJldHR5LmZsb2F0aW5nRGVjaW1hbFBvaW50UmlnaHQgPSB0aGlzLmZsb2F0aW5nRGVjaW1hbFBvaW50UmlnaHQ7XG4gICAgICAgIHByZXR0eS5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX29wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbn1cbmV4cG9ydHMuSW50UHJldHR5ID0gSW50UHJldHR5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50LXByZXR0eS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/unit/build/int-pretty.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/unit/build/int.js":
/*!******************************************************!*\
  !*** ./node_modules/@keplr-wallet/unit/build/int.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Uint = exports.Int = void 0;\nconst big_integer_1 = __importDefault(__webpack_require__(/*! big-integer */ \"(ssr)/./node_modules/big-integer/BigInteger.js\"));\nconst etc_1 = __webpack_require__(/*! ./etc */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/etc.js\");\nclass Int {\n    /**\n     * @param int - Parse a number | bigInteger | string into a bigInt.\n     */\n    constructor(int) {\n        if (typeof int === \"number\") {\n            int = int.toString();\n        }\n        if (typeof int === \"string\") {\n            if (!(0, etc_1.isValidIntegerString)(int)) {\n                if ((0, etc_1.isExponentDecString)(int)) {\n                    int = (0, etc_1.exponentDecStringToDecString)(int);\n                }\n                else {\n                    throw new Error(`invalid integer: ${int}`);\n                }\n            }\n            this.int = (0, big_integer_1.default)(int);\n        }\n        else if (typeof int === \"bigint\") {\n            this.int = (0, big_integer_1.default)(int);\n        }\n        else {\n            this.int = (0, big_integer_1.default)(int);\n        }\n        this.checkBitLen();\n    }\n    checkBitLen() {\n        if (this.int.abs().gt(Int.maxInt)) {\n            throw new Error(`Integer out of range ${this.int.toString()}`);\n        }\n    }\n    toString() {\n        return this.int.toString(10);\n    }\n    isNegative() {\n        return this.int.isNegative();\n    }\n    isPositive() {\n        return this.int.isPositive();\n    }\n    isZero() {\n        return this.int.eq((0, big_integer_1.default)(0));\n    }\n    equals(i) {\n        return this.int.equals(i.int);\n    }\n    gt(i) {\n        return this.int.gt(i.int);\n    }\n    gte(i) {\n        return this.int.greaterOrEquals(i.int);\n    }\n    lt(i) {\n        return this.int.lt(i.int);\n    }\n    lte(i) {\n        return this.int.lesserOrEquals(i.int);\n    }\n    abs() {\n        return new Int(this.int.abs());\n    }\n    absUInt() {\n        return new Uint(this.int.abs());\n    }\n    add(i) {\n        return new Int(this.int.add(i.int));\n    }\n    sub(i) {\n        return new Int(this.int.subtract(i.int));\n    }\n    mul(i) {\n        return new Int(this.int.multiply(i.int));\n    }\n    div(i) {\n        return new Int(this.int.divide(i.int));\n    }\n    mod(i) {\n        return new Int(this.int.mod(i.int));\n    }\n    neg() {\n        return new Int(this.int.negate());\n    }\n    pow(i) {\n        return new Int(this.int.pow(i.toBigNumber()));\n    }\n    toBigNumber() {\n        return this.int;\n    }\n}\nexports.Int = Int;\n// (2 ** 256) - 1\nInt.maxInt = (0, big_integer_1.default)(\"115792089237316195423570985008687907853269984665640564039457584007913129639935\");\nclass Uint {\n    /**\n     * @param uint - Parse a number | bigInteger | string into a bigUint.\n     */\n    constructor(uint) {\n        if (typeof uint === \"number\") {\n            uint = uint.toString();\n        }\n        if (typeof uint === \"string\") {\n            if (!(0, etc_1.isValidIntegerString)(uint)) {\n                if ((0, etc_1.isExponentDecString)(uint)) {\n                    uint = (0, etc_1.exponentDecStringToDecString)(uint);\n                }\n                else {\n                    throw new Error(`invalid integer: ${uint}`);\n                }\n            }\n            this.uint = (0, big_integer_1.default)(uint);\n        }\n        else if (typeof uint === \"bigint\") {\n            this.uint = (0, big_integer_1.default)(uint);\n        }\n        else {\n            this.uint = (0, big_integer_1.default)(uint);\n        }\n        if (this.uint.isNegative()) {\n            throw new TypeError(\"Uint should not be negative\");\n        }\n        this.checkBitLen();\n    }\n    checkBitLen() {\n        if (this.uint.abs().bitLength().gt(256)) {\n            throw new Error(`Integer out of range ${this.uint.toString()}`);\n        }\n    }\n    toString() {\n        return this.uint.toString(10);\n    }\n    isZero() {\n        return this.uint.eq((0, big_integer_1.default)(0));\n    }\n    equals(i) {\n        return this.uint.equals(i.uint);\n    }\n    gt(i) {\n        return this.uint.gt(i.uint);\n    }\n    gte(i) {\n        return this.uint.greaterOrEquals(i.uint);\n    }\n    lt(i) {\n        return this.uint.lt(i.uint);\n    }\n    lte(i) {\n        return this.uint.lesserOrEquals(i.uint);\n    }\n    add(i) {\n        return new Uint(this.uint.add(i.uint));\n    }\n    sub(i) {\n        return new Uint(this.uint.subtract(i.uint));\n    }\n    mul(i) {\n        return new Uint(this.uint.multiply(i.uint));\n    }\n    div(i) {\n        return new Uint(this.uint.divide(i.uint));\n    }\n    mod(i) {\n        return new Uint(this.uint.mod(i.uint));\n    }\n    pow(i) {\n        return new Uint(this.uint.pow(i.toBigNumber()));\n    }\n    toBigNumber() {\n        return this.uint;\n    }\n}\nexports.Uint = Uint;\n//# sourceMappingURL=int.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC91bml0L2J1aWxkL2ludC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVksR0FBRyxXQUFXO0FBQzFCLHNDQUFzQyxtQkFBTyxDQUFDLG1FQUFhO0FBQzNELGNBQWMsbUJBQU8sQ0FBQyxtRUFBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELElBQUk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxvQkFBb0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELEtBQUs7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxxQkFBcUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZXhhbXBsZS1hdnMtdWkvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC91bml0L2J1aWxkL2ludC5qcz9hMDMwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VaW50ID0gZXhwb3J0cy5JbnQgPSB2b2lkIDA7XG5jb25zdCBiaWdfaW50ZWdlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJiaWctaW50ZWdlclwiKSk7XG5jb25zdCBldGNfMSA9IHJlcXVpcmUoXCIuL2V0Y1wiKTtcbmNsYXNzIEludCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGludCAtIFBhcnNlIGEgbnVtYmVyIHwgYmlnSW50ZWdlciB8IHN0cmluZyBpbnRvIGEgYmlnSW50LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGludCkge1xuICAgICAgICBpZiAodHlwZW9mIGludCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaW50ID0gaW50LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBpbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICghKDAsIGV0Y18xLmlzVmFsaWRJbnRlZ2VyU3RyaW5nKShpbnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBldGNfMS5pc0V4cG9uZW50RGVjU3RyaW5nKShpbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGludCA9ICgwLCBldGNfMS5leHBvbmVudERlY1N0cmluZ1RvRGVjU3RyaW5nKShpbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGludGVnZXI6ICR7aW50fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW50ID0gKDAsIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCkoaW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaW50ID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICB0aGlzLmludCA9ICgwLCBiaWdfaW50ZWdlcl8xLmRlZmF1bHQpKGludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmludCA9ICgwLCBiaWdfaW50ZWdlcl8xLmRlZmF1bHQpKGludCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0JpdExlbigpO1xuICAgIH1cbiAgICBjaGVja0JpdExlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50LmFicygpLmd0KEludC5tYXhJbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVnZXIgb3V0IG9mIHJhbmdlICR7dGhpcy5pbnQudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50LnRvU3RyaW5nKDEwKTtcbiAgICB9XG4gICAgaXNOZWdhdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50LmlzTmVnYXRpdmUoKTtcbiAgICB9XG4gICAgaXNQb3NpdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50LmlzUG9zaXRpdmUoKTtcbiAgICB9XG4gICAgaXNaZXJvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQuZXEoKDAsIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCkoMCkpO1xuICAgIH1cbiAgICBlcXVhbHMoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQuZXF1YWxzKGkuaW50KTtcbiAgICB9XG4gICAgZ3QoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQuZ3QoaS5pbnQpO1xuICAgIH1cbiAgICBndGUoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQuZ3JlYXRlck9yRXF1YWxzKGkuaW50KTtcbiAgICB9XG4gICAgbHQoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQubHQoaS5pbnQpO1xuICAgIH1cbiAgICBsdGUoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnQubGVzc2VyT3JFcXVhbHMoaS5pbnQpO1xuICAgIH1cbiAgICBhYnMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50KHRoaXMuaW50LmFicygpKTtcbiAgICB9XG4gICAgYWJzVUludCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50KHRoaXMuaW50LmFicygpKTtcbiAgICB9XG4gICAgYWRkKGkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQodGhpcy5pbnQuYWRkKGkuaW50KSk7XG4gICAgfVxuICAgIHN1YihpKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50KHRoaXMuaW50LnN1YnRyYWN0KGkuaW50KSk7XG4gICAgfVxuICAgIG11bChpKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50KHRoaXMuaW50Lm11bHRpcGx5KGkuaW50KSk7XG4gICAgfVxuICAgIGRpdihpKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50KHRoaXMuaW50LmRpdmlkZShpLmludCkpO1xuICAgIH1cbiAgICBtb2QoaSkge1xuICAgICAgICByZXR1cm4gbmV3IEludCh0aGlzLmludC5tb2QoaS5pbnQpKTtcbiAgICB9XG4gICAgbmVnKCkge1xuICAgICAgICByZXR1cm4gbmV3IEludCh0aGlzLmludC5uZWdhdGUoKSk7XG4gICAgfVxuICAgIHBvdyhpKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW50KHRoaXMuaW50LnBvdyhpLnRvQmlnTnVtYmVyKCkpKTtcbiAgICB9XG4gICAgdG9CaWdOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludDtcbiAgICB9XG59XG5leHBvcnRzLkludCA9IEludDtcbi8vICgyICoqIDI1NikgLSAxXG5JbnQubWF4SW50ID0gKDAsIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCkoXCIxMTU3OTIwODkyMzczMTYxOTU0MjM1NzA5ODUwMDg2ODc5MDc4NTMyNjk5ODQ2NjU2NDA1NjQwMzk0NTc1ODQwMDc5MTMxMjk2Mzk5MzVcIik7XG5jbGFzcyBVaW50IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdWludCAtIFBhcnNlIGEgbnVtYmVyIHwgYmlnSW50ZWdlciB8IHN0cmluZyBpbnRvIGEgYmlnVWludC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1aW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdWludCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdWludCA9IHVpbnQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHVpbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICghKDAsIGV0Y18xLmlzVmFsaWRJbnRlZ2VyU3RyaW5nKSh1aW50KSkge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgZXRjXzEuaXNFeHBvbmVudERlY1N0cmluZykodWludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdWludCA9ICgwLCBldGNfMS5leHBvbmVudERlY1N0cmluZ1RvRGVjU3RyaW5nKSh1aW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnRlZ2VyOiAke3VpbnR9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51aW50ID0gKDAsIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCkodWludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHVpbnQgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHRoaXMudWludCA9ICgwLCBiaWdfaW50ZWdlcl8xLmRlZmF1bHQpKHVpbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51aW50ID0gKDAsIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCkodWludCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudWludC5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVaW50IHNob3VsZCBub3QgYmUgbmVnYXRpdmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0JpdExlbigpO1xuICAgIH1cbiAgICBjaGVja0JpdExlbigpIHtcbiAgICAgICAgaWYgKHRoaXMudWludC5hYnMoKS5iaXRMZW5ndGgoKS5ndCgyNTYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVnZXIgb3V0IG9mIHJhbmdlICR7dGhpcy51aW50LnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVpbnQudG9TdHJpbmcoMTApO1xuICAgIH1cbiAgICBpc1plcm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVpbnQuZXEoKDAsIGJpZ19pbnRlZ2VyXzEuZGVmYXVsdCkoMCkpO1xuICAgIH1cbiAgICBlcXVhbHMoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy51aW50LmVxdWFscyhpLnVpbnQpO1xuICAgIH1cbiAgICBndChpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVpbnQuZ3QoaS51aW50KTtcbiAgICB9XG4gICAgZ3RlKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudWludC5ncmVhdGVyT3JFcXVhbHMoaS51aW50KTtcbiAgICB9XG4gICAgbHQoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy51aW50Lmx0KGkudWludCk7XG4gICAgfVxuICAgIGx0ZShpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVpbnQubGVzc2VyT3JFcXVhbHMoaS51aW50KTtcbiAgICB9XG4gICAgYWRkKGkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50KHRoaXMudWludC5hZGQoaS51aW50KSk7XG4gICAgfVxuICAgIHN1YihpKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludCh0aGlzLnVpbnQuc3VidHJhY3QoaS51aW50KSk7XG4gICAgfVxuICAgIG11bChpKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludCh0aGlzLnVpbnQubXVsdGlwbHkoaS51aW50KSk7XG4gICAgfVxuICAgIGRpdihpKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludCh0aGlzLnVpbnQuZGl2aWRlKGkudWludCkpO1xuICAgIH1cbiAgICBtb2QoaSkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQodGhpcy51aW50Lm1vZChpLnVpbnQpKTtcbiAgICB9XG4gICAgcG93KGkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50KHRoaXMudWludC5wb3coaS50b0JpZ051bWJlcigpKSk7XG4gICAgfVxuICAgIHRvQmlnTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51aW50O1xuICAgIH1cbn1cbmV4cG9ydHMuVWludCA9IFVpbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/unit/build/int.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/unit/build/price-pretty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@keplr-wallet/unit/build/price-pretty.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PricePretty = void 0;\nconst int_pretty_1 = __webpack_require__(/*! ./int-pretty */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/int-pretty.js\");\nconst dec_utils_1 = __webpack_require__(/*! ./dec-utils */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/dec-utils.js\");\nclass PricePretty {\n    constructor(_fiatCurrency, amount) {\n        this._fiatCurrency = _fiatCurrency;\n        this._options = {\n            separator: \"\",\n            upperCase: false,\n            lowerCase: false,\n            locale: \"en-US\",\n        };\n        this.intPretty = new int_pretty_1.IntPretty(amount)\n            .maxDecimals(_fiatCurrency.maxDecimals)\n            .shrink(true)\n            .trim(true)\n            .locale(false)\n            .inequalitySymbol(true);\n        this._options.locale = _fiatCurrency.locale;\n    }\n    get options() {\n        return Object.assign(Object.assign({}, this.intPretty.options), this._options);\n    }\n    get symbol() {\n        return this._fiatCurrency.symbol;\n    }\n    get fiatCurrency() {\n        return this._fiatCurrency;\n    }\n    separator(str) {\n        const pretty = this.clone();\n        pretty._options.separator = str;\n        return pretty;\n    }\n    upperCase(bool) {\n        const pretty = this.clone();\n        pretty._options.upperCase = bool;\n        pretty._options.lowerCase = !bool;\n        return pretty;\n    }\n    lowerCase(bool) {\n        const pretty = this.clone();\n        pretty._options.lowerCase = bool;\n        pretty._options.upperCase = !bool;\n        return pretty;\n    }\n    moveDecimalPointLeft(delta) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.moveDecimalPointLeft(delta);\n        return pretty;\n    }\n    moveDecimalPointRight(delta) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.moveDecimalPointRight(delta);\n        return pretty;\n    }\n    /**\n     * @deprecated Use`moveDecimalPointLeft`\n     */\n    increasePrecision(delta) {\n        return this.moveDecimalPointLeft(delta);\n    }\n    /**\n     * @deprecated Use`moveDecimalPointRight`\n     */\n    decreasePrecision(delta) {\n        return this.moveDecimalPointRight(delta);\n    }\n    maxDecimals(max) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.maxDecimals(max);\n        return pretty;\n    }\n    inequalitySymbol(bool) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.inequalitySymbol(bool);\n        return pretty;\n    }\n    inequalitySymbolSeparator(str) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.inequalitySymbolSeparator(str);\n        return pretty;\n    }\n    trim(bool) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.trim(bool);\n        return pretty;\n    }\n    shrink(bool) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.shrink(bool);\n        return pretty;\n    }\n    locale(locale) {\n        const pretty = this.clone();\n        pretty._options.locale = locale;\n        return pretty;\n    }\n    /**\n     * Ready indicates the actual value is ready to show the users.\n     * Even if the ready option is false, it expects that the value can be shown to users (probably as 0).\n     * The method that returns prettied value may return `undefined` or `null` if the value is not ready.\n     * But, alternatively, it can return the 0 value that can be shown the users anyway, but indicates that the value is not ready.\n     * @param bool\n     */\n    ready(bool) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.ready(bool);\n        return pretty;\n    }\n    get isReady() {\n        return this.intPretty.isReady;\n    }\n    add(target) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.add(target);\n        return pretty;\n    }\n    sub(target) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.sub(target);\n        return pretty;\n    }\n    mul(target) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.mul(target);\n        return pretty;\n    }\n    quo(target) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.quo(target);\n        return pretty;\n    }\n    toDec() {\n        return this.intPretty.toDec();\n    }\n    toString() {\n        let symbol = this.symbol;\n        if (this._options.upperCase) {\n            symbol = symbol.toUpperCase();\n        }\n        if (this._options.lowerCase) {\n            symbol = symbol.toLowerCase();\n        }\n        const dec = this.toDec();\n        const options = this.options;\n        if (options.inequalitySymbol &&\n            !dec.isZero() &&\n            dec.abs().lt(dec_utils_1.DecUtils.getTenExponentN(-options.maxDecimals))) {\n            return this.intPretty.toStringWithSymbols(`${symbol}${this._options.separator}`, \"\");\n        }\n        let localeString = parseFloat(this.intPretty.toString()).toLocaleString(options.locale, {\n            maximumFractionDigits: options.maxDecimals,\n        });\n        const isNeg = localeString.charAt(0) === \"-\";\n        if (isNeg) {\n            localeString = localeString.slice(1);\n        }\n        return `${isNeg ? \"-\" : \"\"}${symbol}${this._options.separator}${localeString}`;\n    }\n    clone() {\n        const pretty = new PricePretty(this._fiatCurrency, 0);\n        pretty._options = Object.assign({}, this._options);\n        pretty.intPretty = this.intPretty.clone();\n        return pretty;\n    }\n}\nexports.PricePretty = PricePretty;\n//# sourceMappingURL=price-pretty.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC91bml0L2J1aWxkL3ByaWNlLXByZXR0eS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIscUJBQXFCLG1CQUFPLENBQUMsaUZBQWM7QUFDM0Msb0JBQW9CLG1CQUFPLENBQUMsK0VBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU8sRUFBRSx3QkFBd0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQixFQUFFLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL2V4YW1wbGUtYXZzLXVpLy4vbm9kZV9tb2R1bGVzL0BrZXBsci13YWxsZXQvdW5pdC9idWlsZC9wcmljZS1wcmV0dHkuanM/MGNjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJpY2VQcmV0dHkgPSB2b2lkIDA7XG5jb25zdCBpbnRfcHJldHR5XzEgPSByZXF1aXJlKFwiLi9pbnQtcHJldHR5XCIpO1xuY29uc3QgZGVjX3V0aWxzXzEgPSByZXF1aXJlKFwiLi9kZWMtdXRpbHNcIik7XG5jbGFzcyBQcmljZVByZXR0eSB7XG4gICAgY29uc3RydWN0b3IoX2ZpYXRDdXJyZW5jeSwgYW1vdW50KSB7XG4gICAgICAgIHRoaXMuX2ZpYXRDdXJyZW5jeSA9IF9maWF0Q3VycmVuY3k7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSB7XG4gICAgICAgICAgICBzZXBhcmF0b3I6IFwiXCIsXG4gICAgICAgICAgICB1cHBlckNhc2U6IGZhbHNlLFxuICAgICAgICAgICAgbG93ZXJDYXNlOiBmYWxzZSxcbiAgICAgICAgICAgIGxvY2FsZTogXCJlbi1VU1wiLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmludFByZXR0eSA9IG5ldyBpbnRfcHJldHR5XzEuSW50UHJldHR5KGFtb3VudClcbiAgICAgICAgICAgIC5tYXhEZWNpbWFscyhfZmlhdEN1cnJlbmN5Lm1heERlY2ltYWxzKVxuICAgICAgICAgICAgLnNocmluayh0cnVlKVxuICAgICAgICAgICAgLnRyaW0odHJ1ZSlcbiAgICAgICAgICAgIC5sb2NhbGUoZmFsc2UpXG4gICAgICAgICAgICAuaW5lcXVhbGl0eVN5bWJvbCh0cnVlKTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5sb2NhbGUgPSBfZmlhdEN1cnJlbmN5LmxvY2FsZTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaW50UHJldHR5Lm9wdGlvbnMpLCB0aGlzLl9vcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0IHN5bWJvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpYXRDdXJyZW5jeS5zeW1ib2w7XG4gICAgfVxuICAgIGdldCBmaWF0Q3VycmVuY3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWF0Q3VycmVuY3k7XG4gICAgfVxuICAgIHNlcGFyYXRvcihzdHIpIHtcbiAgICAgICAgY29uc3QgcHJldHR5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwcmV0dHkuX29wdGlvbnMuc2VwYXJhdG9yID0gc3RyO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICB1cHBlckNhc2UoYm9vbCkge1xuICAgICAgICBjb25zdCBwcmV0dHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHByZXR0eS5fb3B0aW9ucy51cHBlckNhc2UgPSBib29sO1xuICAgICAgICBwcmV0dHkuX29wdGlvbnMubG93ZXJDYXNlID0gIWJvb2w7XG4gICAgICAgIHJldHVybiBwcmV0dHk7XG4gICAgfVxuICAgIGxvd2VyQ2FzZShib29sKSB7XG4gICAgICAgIGNvbnN0IHByZXR0eSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcHJldHR5Ll9vcHRpb25zLmxvd2VyQ2FzZSA9IGJvb2w7XG4gICAgICAgIHByZXR0eS5fb3B0aW9ucy51cHBlckNhc2UgPSAhYm9vbDtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgbW92ZURlY2ltYWxQb2ludExlZnQoZGVsdGEpIHtcbiAgICAgICAgY29uc3QgcHJldHR5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwcmV0dHkuaW50UHJldHR5ID0gcHJldHR5LmludFByZXR0eS5tb3ZlRGVjaW1hbFBvaW50TGVmdChkZWx0YSk7XG4gICAgICAgIHJldHVybiBwcmV0dHk7XG4gICAgfVxuICAgIG1vdmVEZWNpbWFsUG9pbnRSaWdodChkZWx0YSkge1xuICAgICAgICBjb25zdCBwcmV0dHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHByZXR0eS5pbnRQcmV0dHkgPSBwcmV0dHkuaW50UHJldHR5Lm1vdmVEZWNpbWFsUG9pbnRSaWdodChkZWx0YSk7XG4gICAgICAgIHJldHVybiBwcmV0dHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZWBtb3ZlRGVjaW1hbFBvaW50TGVmdGBcbiAgICAgKi9cbiAgICBpbmNyZWFzZVByZWNpc2lvbihkZWx0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3ZlRGVjaW1hbFBvaW50TGVmdChkZWx0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZWBtb3ZlRGVjaW1hbFBvaW50UmlnaHRgXG4gICAgICovXG4gICAgZGVjcmVhc2VQcmVjaXNpb24oZGVsdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW92ZURlY2ltYWxQb2ludFJpZ2h0KGRlbHRhKTtcbiAgICB9XG4gICAgbWF4RGVjaW1hbHMobWF4KSB7XG4gICAgICAgIGNvbnN0IHByZXR0eSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcHJldHR5LmludFByZXR0eSA9IHByZXR0eS5pbnRQcmV0dHkubWF4RGVjaW1hbHMobWF4KTtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgaW5lcXVhbGl0eVN5bWJvbChib29sKSB7XG4gICAgICAgIGNvbnN0IHByZXR0eSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcHJldHR5LmludFByZXR0eSA9IHByZXR0eS5pbnRQcmV0dHkuaW5lcXVhbGl0eVN5bWJvbChib29sKTtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgaW5lcXVhbGl0eVN5bWJvbFNlcGFyYXRvcihzdHIpIHtcbiAgICAgICAgY29uc3QgcHJldHR5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwcmV0dHkuaW50UHJldHR5ID0gcHJldHR5LmludFByZXR0eS5pbmVxdWFsaXR5U3ltYm9sU2VwYXJhdG9yKHN0cik7XG4gICAgICAgIHJldHVybiBwcmV0dHk7XG4gICAgfVxuICAgIHRyaW0oYm9vbCkge1xuICAgICAgICBjb25zdCBwcmV0dHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHByZXR0eS5pbnRQcmV0dHkgPSBwcmV0dHkuaW50UHJldHR5LnRyaW0oYm9vbCk7XG4gICAgICAgIHJldHVybiBwcmV0dHk7XG4gICAgfVxuICAgIHNocmluayhib29sKSB7XG4gICAgICAgIGNvbnN0IHByZXR0eSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcHJldHR5LmludFByZXR0eSA9IHByZXR0eS5pbnRQcmV0dHkuc2hyaW5rKGJvb2wpO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICBsb2NhbGUobG9jYWxlKSB7XG4gICAgICAgIGNvbnN0IHByZXR0eSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcHJldHR5Ll9vcHRpb25zLmxvY2FsZSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHkgaW5kaWNhdGVzIHRoZSBhY3R1YWwgdmFsdWUgaXMgcmVhZHkgdG8gc2hvdyB0aGUgdXNlcnMuXG4gICAgICogRXZlbiBpZiB0aGUgcmVhZHkgb3B0aW9uIGlzIGZhbHNlLCBpdCBleHBlY3RzIHRoYXQgdGhlIHZhbHVlIGNhbiBiZSBzaG93biB0byB1c2VycyAocHJvYmFibHkgYXMgMCkuXG4gICAgICogVGhlIG1ldGhvZCB0aGF0IHJldHVybnMgcHJldHRpZWQgdmFsdWUgbWF5IHJldHVybiBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaWYgdGhlIHZhbHVlIGlzIG5vdCByZWFkeS5cbiAgICAgKiBCdXQsIGFsdGVybmF0aXZlbHksIGl0IGNhbiByZXR1cm4gdGhlIDAgdmFsdWUgdGhhdCBjYW4gYmUgc2hvd24gdGhlIHVzZXJzIGFueXdheSwgYnV0IGluZGljYXRlcyB0aGF0IHRoZSB2YWx1ZSBpcyBub3QgcmVhZHkuXG4gICAgICogQHBhcmFtIGJvb2xcbiAgICAgKi9cbiAgICByZWFkeShib29sKSB7XG4gICAgICAgIGNvbnN0IHByZXR0eSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcHJldHR5LmludFByZXR0eSA9IHByZXR0eS5pbnRQcmV0dHkucmVhZHkoYm9vbCk7XG4gICAgICAgIHJldHVybiBwcmV0dHk7XG4gICAgfVxuICAgIGdldCBpc1JlYWR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRQcmV0dHkuaXNSZWFkeTtcbiAgICB9XG4gICAgYWRkKHRhcmdldCkge1xuICAgICAgICBjb25zdCBwcmV0dHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHByZXR0eS5pbnRQcmV0dHkgPSBwcmV0dHkuaW50UHJldHR5LmFkZCh0YXJnZXQpO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICBzdWIodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHByZXR0eSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcHJldHR5LmludFByZXR0eSA9IHByZXR0eS5pbnRQcmV0dHkuc3ViKHRhcmdldCk7XG4gICAgICAgIHJldHVybiBwcmV0dHk7XG4gICAgfVxuICAgIG11bCh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgcHJldHR5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwcmV0dHkuaW50UHJldHR5ID0gcHJldHR5LmludFByZXR0eS5tdWwodGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgcXVvKHRhcmdldCkge1xuICAgICAgICBjb25zdCBwcmV0dHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHByZXR0eS5pbnRQcmV0dHkgPSBwcmV0dHkuaW50UHJldHR5LnF1byh0YXJnZXQpO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICB0b0RlYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50UHJldHR5LnRvRGVjKCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgc3ltYm9sID0gdGhpcy5zeW1ib2w7XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnVwcGVyQ2FzZSkge1xuICAgICAgICAgICAgc3ltYm9sID0gc3ltYm9sLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMubG93ZXJDYXNlKSB7XG4gICAgICAgICAgICBzeW1ib2wgPSBzeW1ib2wudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWMgPSB0aGlzLnRvRGVjKCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRpb25zLmluZXF1YWxpdHlTeW1ib2wgJiZcbiAgICAgICAgICAgICFkZWMuaXNaZXJvKCkgJiZcbiAgICAgICAgICAgIGRlYy5hYnMoKS5sdChkZWNfdXRpbHNfMS5EZWNVdGlscy5nZXRUZW5FeHBvbmVudE4oLW9wdGlvbnMubWF4RGVjaW1hbHMpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50UHJldHR5LnRvU3RyaW5nV2l0aFN5bWJvbHMoYCR7c3ltYm9sfSR7dGhpcy5fb3B0aW9ucy5zZXBhcmF0b3J9YCwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxvY2FsZVN0cmluZyA9IHBhcnNlRmxvYXQodGhpcy5pbnRQcmV0dHkudG9TdHJpbmcoKSkudG9Mb2NhbGVTdHJpbmcob3B0aW9ucy5sb2NhbGUsIHtcbiAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogb3B0aW9ucy5tYXhEZWNpbWFscyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGlzTmVnID0gbG9jYWxlU3RyaW5nLmNoYXJBdCgwKSA9PT0gXCItXCI7XG4gICAgICAgIGlmIChpc05lZykge1xuICAgICAgICAgICAgbG9jYWxlU3RyaW5nID0gbG9jYWxlU3RyaW5nLnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtpc05lZyA/IFwiLVwiIDogXCJcIn0ke3N5bWJvbH0ke3RoaXMuX29wdGlvbnMuc2VwYXJhdG9yfSR7bG9jYWxlU3RyaW5nfWA7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBwcmV0dHkgPSBuZXcgUHJpY2VQcmV0dHkodGhpcy5fZmlhdEN1cnJlbmN5LCAwKTtcbiAgICAgICAgcHJldHR5Ll9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fb3B0aW9ucyk7XG4gICAgICAgIHByZXR0eS5pbnRQcmV0dHkgPSB0aGlzLmludFByZXR0eS5jbG9uZSgpO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbn1cbmV4cG9ydHMuUHJpY2VQcmV0dHkgPSBQcmljZVByZXR0eTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByaWNlLXByZXR0eS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/unit/build/price-pretty.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/unit/build/rate-pretty.js":
/*!**************************************************************!*\
  !*** ./node_modules/@keplr-wallet/unit/build/rate-pretty.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RatePretty = void 0;\nconst int_pretty_1 = __webpack_require__(/*! ./int-pretty */ \"(ssr)/./node_modules/@keplr-wallet/unit/build/int-pretty.js\");\n/**\n * RatePretty treats `Dec` in rate form for easy calculation, and displays it as a percentage to the user by using toString().\n * By default, if the value is less than maxDeciamls, it is displayed using an inequality sign (Ex. < 0.001%)\n */\nclass RatePretty {\n    constructor(amount) {\n        this._options = {\n            separator: \"\",\n            symbol: \"%\",\n        };\n        this.intPretty = new int_pretty_1.IntPretty(amount);\n        this.intPretty = this.intPretty\n            .maxDecimals(3)\n            .shrink(false)\n            .trim(true)\n            .locale(true)\n            .inequalitySymbol(true);\n    }\n    get options() {\n        return Object.assign(Object.assign({}, this.intPretty.options), this._options);\n    }\n    separator(str) {\n        const pretty = this.clone();\n        pretty._options.separator = str;\n        return pretty;\n    }\n    symbol(str) {\n        const pretty = this.clone();\n        pretty._options.symbol = str;\n        return pretty;\n    }\n    moveDecimalPointLeft(delta) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.moveDecimalPointLeft(delta);\n        return pretty;\n    }\n    moveDecimalPointRight(delta) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.moveDecimalPointRight(delta);\n        return pretty;\n    }\n    maxDecimals(max) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.maxDecimals(max);\n        return pretty;\n    }\n    inequalitySymbol(bool) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.inequalitySymbol(bool);\n        return pretty;\n    }\n    inequalitySymbolSeparator(str) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.inequalitySymbolSeparator(str);\n        return pretty;\n    }\n    trim(bool) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.trim(bool);\n        return pretty;\n    }\n    shrink(bool) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.shrink(bool);\n        return pretty;\n    }\n    locale(locale) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.locale(locale);\n        return pretty;\n    }\n    /**\n     * Ready indicates the actual value is ready to show the users.\n     * Even if the ready option is false, it expects that the value can be shown to users (probably as 0).\n     * The method that returns prettied value may return `undefined` or `null` if the value is not ready.\n     * But, alternatively, it can return the 0 value that can be shown the users anyway, but indicates that the value is not ready.\n     * @param bool\n     */\n    ready(bool) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.ready(bool);\n        return pretty;\n    }\n    get isReady() {\n        return this.intPretty.isReady;\n    }\n    add(target) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.add(target);\n        return pretty;\n    }\n    sub(target) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.sub(target);\n        return pretty;\n    }\n    mul(target) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.mul(target);\n        return pretty;\n    }\n    quo(target) {\n        const pretty = this.clone();\n        pretty.intPretty = pretty.intPretty.quo(target);\n        return pretty;\n    }\n    toDec() {\n        return this.intPretty.toDec();\n    }\n    toString() {\n        return this.intPretty\n            .moveDecimalPointRight(2)\n            .toStringWithSymbols(\"\", `${this._options.separator}${this._options.symbol}`);\n    }\n    clone() {\n        const pretty = new RatePretty(0);\n        pretty._options = Object.assign({}, this._options);\n        pretty.intPretty = this.intPretty.clone();\n        return pretty;\n    }\n}\nexports.RatePretty = RatePretty;\n//# sourceMappingURL=rate-pretty.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC91bml0L2J1aWxkL3JhdGUtcHJldHR5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixxQkFBcUIsbUJBQU8sQ0FBQyxpRkFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHdCQUF3QixFQUFFLHFCQUFxQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L3VuaXQvYnVpbGQvcmF0ZS1wcmV0dHkuanM/NjFhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmF0ZVByZXR0eSA9IHZvaWQgMDtcbmNvbnN0IGludF9wcmV0dHlfMSA9IHJlcXVpcmUoXCIuL2ludC1wcmV0dHlcIik7XG4vKipcbiAqIFJhdGVQcmV0dHkgdHJlYXRzIGBEZWNgIGluIHJhdGUgZm9ybSBmb3IgZWFzeSBjYWxjdWxhdGlvbiwgYW5kIGRpc3BsYXlzIGl0IGFzIGEgcGVyY2VudGFnZSB0byB0aGUgdXNlciBieSB1c2luZyB0b1N0cmluZygpLlxuICogQnkgZGVmYXVsdCwgaWYgdGhlIHZhbHVlIGlzIGxlc3MgdGhhbiBtYXhEZWNpYW1scywgaXQgaXMgZGlzcGxheWVkIHVzaW5nIGFuIGluZXF1YWxpdHkgc2lnbiAoRXguIDwgMC4wMDElKVxuICovXG5jbGFzcyBSYXRlUHJldHR5IHtcbiAgICBjb25zdHJ1Y3RvcihhbW91bnQpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHNlcGFyYXRvcjogXCJcIixcbiAgICAgICAgICAgIHN5bWJvbDogXCIlXCIsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW50UHJldHR5ID0gbmV3IGludF9wcmV0dHlfMS5JbnRQcmV0dHkoYW1vdW50KTtcbiAgICAgICAgdGhpcy5pbnRQcmV0dHkgPSB0aGlzLmludFByZXR0eVxuICAgICAgICAgICAgLm1heERlY2ltYWxzKDMpXG4gICAgICAgICAgICAuc2hyaW5rKGZhbHNlKVxuICAgICAgICAgICAgLnRyaW0odHJ1ZSlcbiAgICAgICAgICAgIC5sb2NhbGUodHJ1ZSlcbiAgICAgICAgICAgIC5pbmVxdWFsaXR5U3ltYm9sKHRydWUpO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5pbnRQcmV0dHkub3B0aW9ucyksIHRoaXMuX29wdGlvbnMpO1xuICAgIH1cbiAgICBzZXBhcmF0b3Ioc3RyKSB7XG4gICAgICAgIGNvbnN0IHByZXR0eSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcHJldHR5Ll9vcHRpb25zLnNlcGFyYXRvciA9IHN0cjtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgc3ltYm9sKHN0cikge1xuICAgICAgICBjb25zdCBwcmV0dHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHByZXR0eS5fb3B0aW9ucy5zeW1ib2wgPSBzdHI7XG4gICAgICAgIHJldHVybiBwcmV0dHk7XG4gICAgfVxuICAgIG1vdmVEZWNpbWFsUG9pbnRMZWZ0KGRlbHRhKSB7XG4gICAgICAgIGNvbnN0IHByZXR0eSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcHJldHR5LmludFByZXR0eSA9IHByZXR0eS5pbnRQcmV0dHkubW92ZURlY2ltYWxQb2ludExlZnQoZGVsdGEpO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICBtb3ZlRGVjaW1hbFBvaW50UmlnaHQoZGVsdGEpIHtcbiAgICAgICAgY29uc3QgcHJldHR5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwcmV0dHkuaW50UHJldHR5ID0gcHJldHR5LmludFByZXR0eS5tb3ZlRGVjaW1hbFBvaW50UmlnaHQoZGVsdGEpO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICBtYXhEZWNpbWFscyhtYXgpIHtcbiAgICAgICAgY29uc3QgcHJldHR5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwcmV0dHkuaW50UHJldHR5ID0gcHJldHR5LmludFByZXR0eS5tYXhEZWNpbWFscyhtYXgpO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICBpbmVxdWFsaXR5U3ltYm9sKGJvb2wpIHtcbiAgICAgICAgY29uc3QgcHJldHR5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwcmV0dHkuaW50UHJldHR5ID0gcHJldHR5LmludFByZXR0eS5pbmVxdWFsaXR5U3ltYm9sKGJvb2wpO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICBpbmVxdWFsaXR5U3ltYm9sU2VwYXJhdG9yKHN0cikge1xuICAgICAgICBjb25zdCBwcmV0dHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHByZXR0eS5pbnRQcmV0dHkgPSBwcmV0dHkuaW50UHJldHR5LmluZXF1YWxpdHlTeW1ib2xTZXBhcmF0b3Ioc3RyKTtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgdHJpbShib29sKSB7XG4gICAgICAgIGNvbnN0IHByZXR0eSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcHJldHR5LmludFByZXR0eSA9IHByZXR0eS5pbnRQcmV0dHkudHJpbShib29sKTtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgc2hyaW5rKGJvb2wpIHtcbiAgICAgICAgY29uc3QgcHJldHR5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwcmV0dHkuaW50UHJldHR5ID0gcHJldHR5LmludFByZXR0eS5zaHJpbmsoYm9vbCk7XG4gICAgICAgIHJldHVybiBwcmV0dHk7XG4gICAgfVxuICAgIGxvY2FsZShsb2NhbGUpIHtcbiAgICAgICAgY29uc3QgcHJldHR5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwcmV0dHkuaW50UHJldHR5ID0gcHJldHR5LmludFByZXR0eS5sb2NhbGUobG9jYWxlKTtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHkgaW5kaWNhdGVzIHRoZSBhY3R1YWwgdmFsdWUgaXMgcmVhZHkgdG8gc2hvdyB0aGUgdXNlcnMuXG4gICAgICogRXZlbiBpZiB0aGUgcmVhZHkgb3B0aW9uIGlzIGZhbHNlLCBpdCBleHBlY3RzIHRoYXQgdGhlIHZhbHVlIGNhbiBiZSBzaG93biB0byB1c2VycyAocHJvYmFibHkgYXMgMCkuXG4gICAgICogVGhlIG1ldGhvZCB0aGF0IHJldHVybnMgcHJldHRpZWQgdmFsdWUgbWF5IHJldHVybiBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaWYgdGhlIHZhbHVlIGlzIG5vdCByZWFkeS5cbiAgICAgKiBCdXQsIGFsdGVybmF0aXZlbHksIGl0IGNhbiByZXR1cm4gdGhlIDAgdmFsdWUgdGhhdCBjYW4gYmUgc2hvd24gdGhlIHVzZXJzIGFueXdheSwgYnV0IGluZGljYXRlcyB0aGF0IHRoZSB2YWx1ZSBpcyBub3QgcmVhZHkuXG4gICAgICogQHBhcmFtIGJvb2xcbiAgICAgKi9cbiAgICByZWFkeShib29sKSB7XG4gICAgICAgIGNvbnN0IHByZXR0eSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcHJldHR5LmludFByZXR0eSA9IHByZXR0eS5pbnRQcmV0dHkucmVhZHkoYm9vbCk7XG4gICAgICAgIHJldHVybiBwcmV0dHk7XG4gICAgfVxuICAgIGdldCBpc1JlYWR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRQcmV0dHkuaXNSZWFkeTtcbiAgICB9XG4gICAgYWRkKHRhcmdldCkge1xuICAgICAgICBjb25zdCBwcmV0dHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHByZXR0eS5pbnRQcmV0dHkgPSBwcmV0dHkuaW50UHJldHR5LmFkZCh0YXJnZXQpO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICBzdWIodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHByZXR0eSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcHJldHR5LmludFByZXR0eSA9IHByZXR0eS5pbnRQcmV0dHkuc3ViKHRhcmdldCk7XG4gICAgICAgIHJldHVybiBwcmV0dHk7XG4gICAgfVxuICAgIG11bCh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgcHJldHR5ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICBwcmV0dHkuaW50UHJldHR5ID0gcHJldHR5LmludFByZXR0eS5tdWwodGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIHByZXR0eTtcbiAgICB9XG4gICAgcXVvKHRhcmdldCkge1xuICAgICAgICBjb25zdCBwcmV0dHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHByZXR0eS5pbnRQcmV0dHkgPSBwcmV0dHkuaW50UHJldHR5LnF1byh0YXJnZXQpO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbiAgICB0b0RlYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50UHJldHR5LnRvRGVjKCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRQcmV0dHlcbiAgICAgICAgICAgIC5tb3ZlRGVjaW1hbFBvaW50UmlnaHQoMilcbiAgICAgICAgICAgIC50b1N0cmluZ1dpdGhTeW1ib2xzKFwiXCIsIGAke3RoaXMuX29wdGlvbnMuc2VwYXJhdG9yfSR7dGhpcy5fb3B0aW9ucy5zeW1ib2x9YCk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBwcmV0dHkgPSBuZXcgUmF0ZVByZXR0eSgwKTtcbiAgICAgICAgcHJldHR5Ll9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fb3B0aW9ucyk7XG4gICAgICAgIHByZXR0eS5pbnRQcmV0dHkgPSB0aGlzLmludFByZXR0eS5jbG9uZSgpO1xuICAgICAgICByZXR1cm4gcHJldHR5O1xuICAgIH1cbn1cbmV4cG9ydHMuUmF0ZVByZXR0eSA9IFJhdGVQcmV0dHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYXRlLXByZXR0eS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/unit/build/rate-pretty.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@keplr-wallet/unit/build/utils.js":
/*!********************************************************!*\
  !*** ./node_modules/@keplr-wallet/unit/build/utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.integerStringToUSLocaleString = void 0;\n/**\n * Change the non-locale integer string to locale string.\n * Only support en-US format.\n * This method uses the BigInt if the environment supports the BigInt.\n * @param numberStr\n */\nfunction integerStringToUSLocaleString(numberStr) {\n    if (numberStr.indexOf(\".\") >= 0) {\n        throw new Error(`${numberStr} is not integer`);\n    }\n    if (typeof BigInt !== \"undefined\") {\n        return BigInt(numberStr).toLocaleString(\"en-US\");\n    }\n    const integer = numberStr;\n    const chunks = [];\n    for (let i = integer.length; i > 0; i -= 3) {\n        chunks.push(integer.slice(Math.max(0, i - 3), i));\n    }\n    return chunks.reverse().join(\",\");\n}\nexports.integerStringToUSLocaleString = integerStringToUSLocaleString;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGtlcGxyLXdhbGxldC91bml0L2J1aWxkL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9leGFtcGxlLWF2cy11aS8uL25vZGVfbW9kdWxlcy9Aa2VwbHItd2FsbGV0L3VuaXQvYnVpbGQvdXRpbHMuanM/N2UwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW50ZWdlclN0cmluZ1RvVVNMb2NhbGVTdHJpbmcgPSB2b2lkIDA7XG4vKipcbiAqIENoYW5nZSB0aGUgbm9uLWxvY2FsZSBpbnRlZ2VyIHN0cmluZyB0byBsb2NhbGUgc3RyaW5nLlxuICogT25seSBzdXBwb3J0IGVuLVVTIGZvcm1hdC5cbiAqIFRoaXMgbWV0aG9kIHVzZXMgdGhlIEJpZ0ludCBpZiB0aGUgZW52aXJvbm1lbnQgc3VwcG9ydHMgdGhlIEJpZ0ludC5cbiAqIEBwYXJhbSBudW1iZXJTdHJcbiAqL1xuZnVuY3Rpb24gaW50ZWdlclN0cmluZ1RvVVNMb2NhbGVTdHJpbmcobnVtYmVyU3RyKSB7XG4gICAgaWYgKG51bWJlclN0ci5pbmRleE9mKFwiLlwiKSA+PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtudW1iZXJTdHJ9IGlzIG5vdCBpbnRlZ2VyYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgQmlnSW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQobnVtYmVyU3RyKS50b0xvY2FsZVN0cmluZyhcImVuLVVTXCIpO1xuICAgIH1cbiAgICBjb25zdCBpbnRlZ2VyID0gbnVtYmVyU3RyO1xuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBpbnRlZ2VyLmxlbmd0aDsgaSA+IDA7IGkgLT0gMykge1xuICAgICAgICBjaHVua3MucHVzaChpbnRlZ2VyLnNsaWNlKE1hdGgubWF4KDAsIGkgLSAzKSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gY2h1bmtzLnJldmVyc2UoKS5qb2luKFwiLFwiKTtcbn1cbmV4cG9ydHMuaW50ZWdlclN0cmluZ1RvVVNMb2NhbGVTdHJpbmcgPSBpbnRlZ2VyU3RyaW5nVG9VU0xvY2FsZVN0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@keplr-wallet/unit/build/utils.js\n");

/***/ })

};
;